"""LibCST visitor for discovering protocol functions."""

import libcst as cst

from praxis.backend.utils.plr_static_analysis.models import (
  ProtocolFunctionInfo,
  ProtocolParameterInfo,
)
from praxis.backend.utils.plr_static_analysis.visitors.base import BasePLRVisitor
from praxis.common.type_inspection import is_pylabrobot_resource


class ProtocolFunctionVisitor(BasePLRVisitor):
  """Visitor to find and extract metadata from @protocol_function decorated functions."""

  # Decorator names that indicate a protocol function
  PROTOCOL_DECORATOR_NAMES = {"protocol_function"}

  def __init__(self, module_name: str, file_path: str) -> None:
    """Initialize the visitor.

    Args:
      module_name: The module name (e.g., 'protocols.my_protocol')
      file_path: Absolute path to the source file
    """
    super().__init__(module_name, file_path)
    self.definitions: list[ProtocolFunctionInfo] = []

  def visit_FunctionDef(self, node: cst.FunctionDef) -> bool:
    """Visit a function definition to check for protocol decorators."""
    if not self._has_protocol_decorator(node):
      return False

    self._process_protocol_function(node)
    # We don't need to traverse into the function body for discovery purposes,
    # unless we want to do nested protocol discovery (which we don't for now).
    # However, if we add requirements extraction here later, we might return True.
    return False

  def _has_protocol_decorator(self, node: cst.FunctionDef) -> bool:
    """Check if the function has a @protocol_function decorator."""
    for decorator in node.decorators:
      # Handle @protocol_function
      if isinstance(decorator.decorator, cst.Name):
        if decorator.decorator.value in self.PROTOCOL_DECORATOR_NAMES:
          return True
      # Handle @protocol_function(...)
      elif isinstance(decorator.decorator, cst.Call):
        func = decorator.decorator.func
        if isinstance(func, cst.Name):
          if func.value in self.PROTOCOL_DECORATOR_NAMES:
            return True
        elif isinstance(func, cst.Attribute):
          if func.attr.value in self.PROTOCOL_DECORATOR_NAMES:
            return True
      # Handle @module.protocol_function (attribute without call)
      elif isinstance(decorator.decorator, cst.Attribute):
        if decorator.decorator.attr.value in self.PROTOCOL_DECORATOR_NAMES:
          return True

    return False

  def _process_protocol_function(self, node: cst.FunctionDef) -> None:
    """Extract metadata from a protocol function node."""
    function_name = node.name.value
    docstring = self._get_docstring(node.body) or "Inferred from code."
    
    params_info: list[ProtocolParameterInfo] = []
    
    # Process parameters
    # node.params.params contains positional/keyword args
    # defaults are stored in node.params.params[-N:].default if they exist, 
    # but LibCST structures defaults directly on the Param node.
    
    for param in node.params.params:
      param_name = param.name.value
      
      # Extract type hint
      type_hint = "Any"
      if param.annotation:
        type_hint = self._type_annotation_to_string(param.annotation.annotation)
        
      # Extract default value
      default_value = None
      is_optional = False
      if param.default:
        is_optional = True
        # CST to source string for default value
        default_value = cst.Module([]).code_for_node(param.default)

      is_asset = is_pylabrobot_resource(type_hint)
      
      fqn = f"{self.module_path}.{function_name}.{param_name}"
      
      info = ProtocolParameterInfo(
        name=param_name,
        type_hint=type_hint,
        default_value=default_value,
        is_optional=is_optional,
        is_asset=is_asset,
        fqn=fqn,
      )
      
      if is_asset:
        info.asset_type = type_hint
        
      params_info.append(info)

    # Construct raw dicts for backward compatibility with DiscoveryService
    # This matches the structure created by the AST-based ProtocolVisitor
    uuid_placeholder = "00000000-0000-0000-0000-000000000000" # Real UUIDs generated by service
    
    raw_assets = []
    raw_parameters = []
    
    for p in params_info:
      if p.is_asset:
        raw_assets.append({
          "accession_id": uuid_placeholder, # Service will replace this
          "name": p.name,
          "fqn": p.fqn,
          "type_hint_str": p.type_hint,
          "actual_type_str": p.type_hint,
          "optional": p.is_optional,
          "default_value_repr": p.default_value,
        })
      else:
        raw_parameters.append({
          "name": p.name,
          "fqn": p.fqn,
          "type_hint": p.type_hint,
          "optional": p.is_optional,
          "default_value_repr": p.default_value,
        })

    definition = ProtocolFunctionInfo(
      name=function_name,
      fqn=f"{self.module_path}.{function_name}",
      module_name=self.module_path,
      source_file_path=self.file_path,
      docstring=docstring,
      parameters=params_info,
      raw_assets=raw_assets,
      raw_parameters=raw_parameters,
    )
    
    self.definitions.append(definition)

  def _type_annotation_to_string(self, node: cst.BaseExpression) -> str:
    """Convert a type annotation node to a string representation."""
    return cst.Module([]).code_for_node(node)
