D100 Missing docstring in public module
--> __version__.py:1:1

INP001 File `alembic/env.py` is part of an implicit namespace package. Add an `__init__.py`.
--> alembic/env.py:1:1

D100 Missing docstring in public module
--> alembic/env.py:1:1

ERA001 Found commented-out code
  --> alembic/env.py:70:7
   |
68 |       # --- MODIFICATION FOR PRAXIS ---
69 |       compare_type=True,  # For detecting column type changes
70 |       # include_schemas=True, # If you use multiple schemas
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
71 |       # --- END MODIFICATION ---
72 |     )
   |
help: Remove commented-out code

INP001 File `alembic/versions/3a1fe0851e06_make_resourceorm_resource_definition_.py` is part of an implicit namespace package. Add an `__init__.py`.
--> alembic/versions/3a1fe0851e06_make_resourceorm_resource_definition_.py:1:1

D400 First line should end with a period
 --> alembic/versions/3a1fe0851e06_make_resourceorm_resource_definition_.py:1:1
  |
1 | / """Make ResourceOrm.resource_definition_accession_id nullable
2 | |
3 | | Revision ID: 3a1fe0851e06
4 | | Revises:
5 | | Create Date: 2025-11-10 18:42:40.749914
6 | |
7 | | """
  | |___^
8 |
9 |   from collections.abc import Sequence
  |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
 --> alembic/versions/3a1fe0851e06_make_resourceorm_resource_definition_.py:1:1
  |
1 | / """Make ResourceOrm.resource_definition_accession_id nullable
2 | |
3 | | Revision ID: 3a1fe0851e06
4 | | Revises:
5 | | Create Date: 2025-11-10 18:42:40.749914
6 | |
7 | | """
  | |___^
8 |
9 |   from collections.abc import Sequence
  |
help: Add closing punctuation

INP001 File `alembic_old/env.py` is part of an implicit namespace package. Add an `__init__.py`.
--> alembic_old/env.py:1:1

D100 Missing docstring in public module
--> alembic_old/env.py:1:1

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
 --> alembic_old/env.py:2:3
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^
3 | from logging.config import fileConfig
  |

TD003 Missing issue link for this TODO
 --> alembic_old/env.py:2:3
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^
3 | from logging.config import fileConfig
  |

FIX002 Line contains TODO, consider resolving the issue
 --> alembic_old/env.py:2:3
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^
3 | from logging.config import fileConfig
  |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
  --> alembic_old/env.py:20:3
   |
18 |   fileConfig(config.config_file_name)
19 |
20 | # TODO: add your model's MetaData object here
   |   ^^^^
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

TD003 Missing issue link for this TODO
  --> alembic_old/env.py:20:3
   |
18 |   fileConfig(config.config_file_name)
19 |
20 | # TODO: add your model's MetaData object here
   |   ^^^^
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

FIX002 Line contains TODO, consider resolving the issue
  --> alembic_old/env.py:20:3
   |
18 |   fileConfig(config.config_file_name)
19 |
20 | # TODO: add your model's MetaData object here
   |   ^^^^
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

ERA001 Found commented-out code
  --> alembic_old/env.py:22:1
   |
20 | # TODO: add your model's MetaData object here
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 | # target_metadata = mymodel.Base.metadata
24 | # --- MODIFICATION FOR PRAXIS ---
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> alembic_old/env.py:23:1
   |
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
23 | # target_metadata = mymodel.Base.metadata
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 | # --- MODIFICATION FOR PRAXIS ---
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> alembic_old/env.py:31:1
   |
29 | # other values from the config, defined by the needs of env.py,
30 | # can be acquired:
31 | # my_important_option = config.get_main_option("my_important_option")
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 | # ... etc.
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> alembic_old/env.py:89:7
   |
87 |       # --- MODIFICATION FOR PRAXIS ---
88 |       compare_type=True,  # For detecting column type changes
89 |       # include_schemas=True, # If you use multiple schemas
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
90 |       # --- END MODIFICATION ---
91 |     )
   |
help: Remove commented-out code

D100 Missing docstring in public module
--> dependency_analysis.py:1:1

ANN201 Missing return type annotation for public function `get_module_name`
  --> dependency_analysis.py:23:5
   |
23 | def get_module_name(filepath):
   |     ^^^^^^^^^^^^^^^
24 |   """Converts a file path to a module name."""
25 |   return os.path.splitext(filepath.replace("/", "."))[0]
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `filepath`
  --> dependency_analysis.py:23:21
   |
23 | def get_module_name(filepath):
   |                     ^^^^^^^^
24 |   """Converts a file path to a module name."""
25 |   return os.path.splitext(filepath.replace("/", "."))[0]
   |

D401 First line of docstring should be in imperative mood: "Converts a file path to a module name."
  --> dependency_analysis.py:24:3
   |
23 | def get_module_name(filepath):
24 |   """Converts a file path to a module name."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |   return os.path.splitext(filepath.replace("/", "."))[0]
   |

PTH122 `os.path.splitext()` should be replaced by `Path.suffix`, `Path.stem`, and `Path.parent`
  --> dependency_analysis.py:25:10
   |
23 | def get_module_name(filepath):
24 |   """Converts a file path to a module name."""
25 |   return os.path.splitext(filepath.replace("/", "."))[0]
   |          ^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `get_filepath_from_module`
  --> dependency_analysis.py:28:5
   |
28 | def get_filepath_from_module(module_name):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
29 |   """Converts a module name back to a file path."""
30 |   return module_name.replace(".", "/") + ".py"
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `module_name`
  --> dependency_analysis.py:28:30
   |
28 | def get_filepath_from_module(module_name):
   |                              ^^^^^^^^^^^
29 |   """Converts a module name back to a file path."""
30 |   return module_name.replace(".", "/") + ".py"
   |

D401 First line of docstring should be in imperative mood: "Converts a module name back to a file path."
  --> dependency_analysis.py:29:3
   |
28 | def get_filepath_from_module(module_name):
29 |   """Converts a module name back to a file path."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |   return module_name.replace(".", "/") + ".py"
   |

ANN201 Missing return type annotation for public function `analyze_dependencies`
  --> dependency_analysis.py:36:5
   |
36 | def analyze_dependencies(files):
   |     ^^^^^^^^^^^^^^^^^^^^
37 |   """Analyzes the import statements in a list of Python files to build a dependency graph.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `files`
  --> dependency_analysis.py:36:26
   |
36 | def analyze_dependencies(files):
   |                          ^^^^^
37 |   """Analyzes the import statements in a list of Python files to build a dependency graph.
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> dependency_analysis.py:48:10
   |
46 |   dependency_graph = defaultdict(set)
47 |   for filepath in files:
48 |     with open(filepath) as f:
   |          ^^^^
49 |       content = f.read()
50 |       tree = ast.parse(content)
   |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> dependency_analysis.py:66:17
   |
64 |             and get_module_name(
65 |               os.path.normpath(
66 |                 os.path.join(os.path.dirname(filepath), node.module.replace(".", "/")),
   |                 ^^^^^^^^^^^^
67 |               )
68 |               + ".py",
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> dependency_analysis.py:66:30
   |
64 |             and get_module_name(
65 |               os.path.normpath(
66 |                 os.path.join(os.path.dirname(filepath), node.module.replace(".", "/")),
   |                              ^^^^^^^^^^^^^^^
67 |               )
68 |               + ".py",
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> dependency_analysis.py:74:17
   |
72 |             imported_module_path = (
73 |               os.path.normpath(
74 |                 os.path.join(os.path.dirname(filepath), node.module.replace(".", "/")),
   |                 ^^^^^^^^^^^^
75 |               )
76 |               + ".py"
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> dependency_analysis.py:74:30
   |
72 |             imported_module_path = (
73 |               os.path.normpath(
74 |                 os.path.join(os.path.dirname(filepath), node.module.replace(".", "/")),
   |                              ^^^^^^^^^^^^^^^
75 |               )
76 |               + ".py"
   |
help: Replace with `Path(...).parent`

C901 `find_circular_dependencies` is too complex (18 > 10)
  --> dependency_analysis.py:83:5
   |
83 | def find_circular_dependencies(graph):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |   """Finds circular dependencies in a graph using Depth First Search.
   |

PLR0912 Too many branches (13 > 12)
  --> dependency_analysis.py:83:5
   |
83 | def find_circular_dependencies(graph):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |   """Finds circular dependencies in a graph using Depth First Search.
   |

ANN201 Missing return type annotation for public function `find_circular_dependencies`
  --> dependency_analysis.py:83:5
   |
83 | def find_circular_dependencies(graph):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |   """Finds circular dependencies in a graph using Depth First Search.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `graph`
  --> dependency_analysis.py:83:32
   |
83 | def find_circular_dependencies(graph):
   |                                ^^^^^
84 |   """Finds circular dependencies in a graph using Depth First Search.
   |

D401 First line of docstring should be in imperative mood: "Finds circular dependencies in a graph using Depth First Search."
  --> dependency_analysis.py:84:3
   |
83 |   def find_circular_dependencies(graph):
84 | /   """Finds circular dependencies in a graph using Depth First Search.
85 | |
86 | |   Args:
87 | |       graph: A dictionary representing the dependency graph.
88 | |
89 | |   Returns:
90 | |       A list of tuples, where each tuple represents a circular dependency.
91 | |
92 | |   """
   | |_____^
93 |     path = set()
94 |     visited = set()
   |

ANN202 Missing return type annotation for private function `dfs`
  --> dependency_analysis.py:97:7
   |
95 |   cycles = []
96 |
97 |   def dfs(node):
   |       ^^^
98 |     path.add(node)
99 |     visited.add(node)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `node`
  --> dependency_analysis.py:97:11
   |
95 |   cycles = []
96 |
97 |   def dfs(node):
   |           ^^^^
98 |     path.add(node)
99 |     visited.add(node)
   |

RUF005 Consider `[*list(path)[cycle_start_index:], neighbor]` instead of concatenation
   --> dependency_analysis.py:104:29
    |
102 |         # Found a cycle
103 |         cycle_start_index = list(path).index(neighbor)
104 |         cycles.append(tuple(list(path)[cycle_start_index:] + [neighbor]))
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |       if neighbor not in visited:
106 |         dfs(neighbor)
    |
help: Replace with `[*list(path)[cycle_start_index:], neighbor]`

RUF005 Consider `[*path[path.index(current):], current]` instead of concatenation
   --> dependency_analysis.py:145:22
    |
143 |       if current in path:
144 |         # Cycle detected
145 |         cycle_path = path[path.index(current) :] + [current]
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
146 |         # Normalize cycle to avoid duplicates (e.g., A->B->A vs B->A->B)
147 |         sorted_cycle = tuple(sorted(list(set(cycle_path))))
    |
help: Replace with `[*path[path.index(current):], current]`

C414 Unnecessary `list()` call within `sorted()`
   --> dependency_analysis.py:147:30
    |
145 |         cycle_path = path[path.index(current) :] + [current]
146 |         # Normalize cycle to avoid duplicates (e.g., A->B->A vs B->A->B)
147 |         sorted_cycle = tuple(sorted(list(set(cycle_path))))
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |         if sorted_cycle not in [tuple(sorted(list(set(c)))) for c in final_cycles]:
149 |           final_cycles.append(cycle_path)
    |
help: Remove the inner `list()` call

C414 Unnecessary `list()` call within `sorted()`
   --> dependency_analysis.py:148:39
    |
146 |         # Normalize cycle to avoid duplicates (e.g., A->B->A vs B->A->B)
147 |         sorted_cycle = tuple(sorted(list(set(cycle_path))))
148 |         if sorted_cycle not in [tuple(sorted(list(set(c)))) for c in final_cycles]:
    |                                       ^^^^^^^^^^^^^^^^^^^^
149 |           final_cycles.append(cycle_path)
150 |         continue
    |
help: Remove the inner `list()` call

PERF401 Use `list.extend` to create a transformed list
   --> dependency_analysis.py:153:9
    |
151 |       path.append(current)
152 |       for neighbor in graph.get(current, []):
153 |         stack.append((neighbor, list(path)))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |
155 |   return final_cycles
    |
help: Replace for loop with list.extend

ANN201 Missing return type annotation for public function `detect_cycle_util`
   --> dependency_analysis.py:158:5
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |     ^^^^^^^^^^^^^^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |
help: Add return type annotation: `bool`

D103 Missing docstring in public function
   --> dependency_analysis.py:158:5
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |     ^^^^^^^^^^^^^^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

ANN001 Missing type annotation for function argument `node`
   --> dependency_analysis.py:158:23
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |                       ^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

ANN001 Missing type annotation for function argument `graph`
   --> dependency_analysis.py:158:29
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |                             ^^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

ANN001 Missing type annotation for function argument `visiting`
   --> dependency_analysis.py:158:36
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |                                    ^^^^^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

ANN001 Missing type annotation for function argument `visited`
   --> dependency_analysis.py:158:46
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |                                              ^^^^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

ANN001 Missing type annotation for function argument `path`
   --> dependency_analysis.py:158:55
    |
158 | def detect_cycle_util(node, graph, visiting, visited, path):
    |                                                       ^^^^
159 |   visiting.add(node)
160 |   path.append(node)
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> dependency_analysis.py:166:5
    |
164 |         path.append(neighbour)
165 |         return True
166 | /     if neighbour not in visited:
167 | |       if detect_cycle_util(neighbour, graph, visiting, visited, path):
    | |______________________________________________________________________^
168 |           return True
    |
help: Combine `if` statements using `and`

ANN201 Missing return type annotation for public function `analyze_global_state`
   --> dependency_analysis.py:176:5
    |
176 | def analyze_global_state(files):
    |     ^^^^^^^^^^^^^^^^^^^^
177 |   """Analyzes files for potential global state.
178 |   Looks for module-level variable assignments that are not constants.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `files`
   --> dependency_analysis.py:176:26
    |
176 | def analyze_global_state(files):
    |                          ^^^^^
177 |   """Analyzes files for potential global state.
178 |   Looks for module-level variable assignments that are not constants.
    |

D205 1 blank line required between summary line and description
   --> dependency_analysis.py:177:3
    |
176 |   def analyze_global_state(files):
177 | /   """Analyzes files for potential global state.
178 | |   Looks for module-level variable assignments that are not constants.
179 | |   This is a heuristic and may not be 100% accurate.
180 | |
181 | |   Args:
182 | |       files: A list of file paths to analyze.
183 | |
184 | |   Returns:
185 | |       A dictionary where keys are filepaths and values are lists of global variable names.
186 | |
187 | |   """
    | |_____^
188 |     global_state = defaultdict(list)
189 |     for filepath in files:
    |
help: Insert single blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> dependency_analysis.py:190:10
    |
188 |   global_state = defaultdict(list)
189 |   for filepath in files:
190 |     with open(filepath) as f:
    |          ^^^^
191 |       content = f.read()
192 |       tree = ast.parse(content)
    |
help: Replace with `Path.open()`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> dependency_analysis.py:197:13
    |
195 |           if isinstance(node, ast.Assign):
196 |             for target in node.targets:
197 | /             if isinstance(target, ast.Name):
198 | |               # A simple heuristic: if it's all caps, it's probably a constant.
199 | |               if not target.id.isupper():
    | |_________________________________________^
200 |                   global_state[filepath].append(target.id)
201 |           # Also consider annotated assignments
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> dependency_analysis.py:202:9
    |
200 |                   global_state[filepath].append(target.id)
201 |           # Also consider annotated assignments
202 | /         elif isinstance(node, ast.AnnAssign):
203 | |           if isinstance(node.target, ast.Name):
204 | |             if not node.target.id.isupper():
    | |____________________________________________^
205 |                 global_state[filepath].append(node.target.id)
206 |     return global_state
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> dependency_analysis.py:203:11
    |
201 |           # Also consider annotated assignments
202 |           elif isinstance(node, ast.AnnAssign):
203 | /           if isinstance(node.target, ast.Name):
204 | |             if not node.target.id.isupper():
    | |____________________________________________^
205 |                 global_state[filepath].append(node.target.id)
206 |     return global_state
    |
help: Combine `if` statements using `and`

T201 `print` found
   --> dependency_analysis.py:210:3
    |
209 | if __name__ == "__main__":
210 |   print("--- Phase 0: Dependency Analysis ---")
    |   ^^^^^
211 |
212 |   # 1. Analyze dependencies
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:214:3
    |
212 |   # 1. Analyze dependencies
213 |   dependency_graph = analyze_dependencies(CORE_MODULES)
214 |   print("\n--- Dependency Graph ---")
    |   ^^^^^
215 |   for module, dependencies in sorted(dependency_graph.items()):
216 |     if dependencies:
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:217:7
    |
215 |   for module, dependencies in sorted(dependency_graph.items()):
216 |     if dependencies:
217 |       print(f"{module}:")
    |       ^^^^^
218 |       for dep in sorted(list(dependencies)):
219 |         print(f"  -> {dep}")
    |
help: Remove `print`

C414 Unnecessary `list()` call within `sorted()`
   --> dependency_analysis.py:218:18
    |
216 |     if dependencies:
217 |       print(f"{module}:")
218 |       for dep in sorted(list(dependencies)):
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |         print(f"  -> {dep}")
    |
help: Remove the inner `list()` call

T201 `print` found
   --> dependency_analysis.py:219:9
    |
217 |       print(f"{module}:")
218 |       for dep in sorted(list(dependencies)):
219 |         print(f"  -> {dep}")
    |         ^^^^^
220 |
221 |   # 2. Find circular dependencies
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:223:3
    |
221 |   # 2. Find circular dependencies
222 |   circular_dependencies = find_circular_dependencies(dependency_graph)
223 |   print("\n--- Circular Dependencies ---")
    |   ^^^^^
224 |   if circular_dependencies:
225 |     for i, cycle in enumerate(circular_dependencies, 1):
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:226:7
    |
224 |   if circular_dependencies:
225 |     for i, cycle in enumerate(circular_dependencies, 1):
226 |       print(f"Cycle {i}: {' -> '.join(cycle)}")
    |       ^^^^^
227 |   else:
228 |     print("No circular dependencies found.")
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:228:5
    |
226 |       print(f"Cycle {i}: {' -> '.join(cycle)}")
227 |   else:
228 |     print("No circular dependencies found.")
    |     ^^^^^
229 |
230 |   # 3. Analyze global state
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:232:3
    |
230 |   # 3. Analyze global state
231 |   global_state = analyze_global_state(CORE_MODULES)
232 |   print("\n--- Global State Analysis (Heuristic) ---")
    |   ^^^^^
233 |   if global_state:
234 |     for module, variables in sorted(global_state.items()):
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:236:9
    |
234 |     for module, variables in sorted(global_state.items()):
235 |       if variables:
236 |         print(f"{module}:")
    |         ^^^^^
237 |         for var in variables:
238 |           print(f"  - {var}")
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:238:11
    |
236 |         print(f"{module}:")
237 |         for var in variables:
238 |           print(f"  - {var}")
    |           ^^^^^
239 |   else:
240 |     print("No potential global state found.")
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:240:5
    |
238 |           print(f"  - {var}")
239 |   else:
240 |     print("No potential global state found.")
    |     ^^^^^
241 |
242 |   # 4. Assess container.py
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:243:3
    |
242 |   # 4. Assess container.py
243 |   print("\n--- container.py Assessment ---")
    |   ^^^^^
244 |   if "praxis/backend/core/container.py" in CORE_MODULES:
245 |     with open("praxis/backend/core/container.py") as f:
    |
help: Remove `print`

PTH123 `open()` should be replaced by `Path.open()`
   --> dependency_analysis.py:245:10
    |
243 |   print("\n--- container.py Assessment ---")
244 |   if "praxis/backend/core/container.py" in CORE_MODULES:
245 |     with open("praxis/backend/core/container.py") as f:
    |          ^^^^
246 |       print(f.read())
247 |   else:
    |
help: Replace with `Path.open()`

T201 `print` found
   --> dependency_analysis.py:246:7
    |
244 |   if "praxis/backend/core/container.py" in CORE_MODULES:
245 |     with open("praxis/backend/core/container.py") as f:
246 |       print(f.read())
    |       ^^^^^
247 |   else:
248 |     print("container.py not in the list of core modules.")
    |
help: Remove `print`

T201 `print` found
   --> dependency_analysis.py:248:5
    |
246 |       print(f.read())
247 |   else:
248 |     print("container.py not in the list of core modules.")
    |     ^^^^^
    |
help: Remove `print`

INP001 File `docs/conf.py` is part of an implicit namespace package. Add an `__init__.py`.
--> docs/conf.py:1:1

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> docs/conf.py:11:20
   |
10 | # Add the project root to the Python path
11 | sys.path.insert(0, os.path.abspath(".."))
   |                    ^^^^^^^^^^^^^^^
12 |
13 | # -- Project information -----------------------------------------------------
   |
help: Replace with `Path(...).resolve()`

A001 Variable `copyright` is shadowing a Python builtin
  --> docs/conf.py:15:1
   |
13 | # -- Project information -----------------------------------------------------
14 | project = "PyLabPraxis"
15 | copyright = "2025, Marielle Russo"
   | ^^^^^^^^^
16 | author = "Marielle Russo"
17 | release = "0.0.1"
   |

TC001 Move application import `praxis.backend.services.praxis_orm_service.PraxisDBService` into a type-checking block
  --> main.py:25:56
   |
23 | from praxis.backend.services.discovery_service import DiscoveryService
24 | from praxis.backend.services.machine_type_definition import MachineTypeDefinitionService
25 | from praxis.backend.services.praxis_orm_service import PraxisDBService
   |                                                        ^^^^^^^^^^^^^^^
26 | from praxis.backend.services.resource_type_definition import ResourceTypeDefinitionService
27 | from praxis.backend.utils.db import (
   |
help: Move into type-checking block

PLR0915 Too many statements (66 > 50)
  --> main.py:49:11
   |
48 | @asynccontextmanager
49 | async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
   |           ^^^^^^^^
50 |   """Manage application startup and shutdown events.
   |

ERA001 Found commented-out code
  --> main.py:84:5
   |
82 |     logger.info("Praxis database schema initialization complete.")
83 |
84 |     # logger.info("Initializing PraxisDBService...")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |     # assert KEYCLOAK_DSN_FROM_CONFIG, "Keycloak DSN must be configured in praxis.ini"
86 |     # db_service_instance = await PraxisDBService.initialize(
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> main.py:86:5
   |
84 |     # logger.info("Initializing PraxisDBService...")
85 |     # assert KEYCLOAK_DSN_FROM_CONFIG, "Keycloak DSN must be configured in praxis.ini"
86 |     # db_service_instance = await PraxisDBService.initialize(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |     #   keycloak_dsn=KEYCLOAK_DSN_FROM_CONFIG,
88 |     # )
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> main.py:87:5
   |
85 |     # assert KEYCLOAK_DSN_FROM_CONFIG, "Keycloak DSN must be configured in praxis.ini"
86 |     # db_service_instance = await PraxisDBService.initialize(
87 |     #   keycloak_dsn=KEYCLOAK_DSN_FROM_CONFIG,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |     # )
89 |     # logger.info("PraxisDBService initialized successfully.")
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> main.py:88:5
   |
86 |     # db_service_instance = await PraxisDBService.initialize(
87 |     #   keycloak_dsn=KEYCLOAK_DSN_FROM_CONFIG,
88 |     # )
   |     ^^^
89 |     # logger.info("PraxisDBService initialized successfully.")
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> main.py:89:5
   |
87 |     #   keycloak_dsn=KEYCLOAK_DSN_FROM_CONFIG,
88 |     # )
89 |     # logger.info("PraxisDBService initialized successfully.")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
90 |
91 |     # Initialize AssetManager and WorkcellRuntime
   |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
  --> main.py:93:5
   |
91 |     # Initialize AssetManager and WorkcellRuntime
92 |     logger.info("Initializing AssetManager and WorkcellRuntime...")
93 |     from praxis.backend.core.filesystem import FileSystem
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |     from praxis.backend.core.workcell import Workcell
95 |     from praxis.backend.services.deck import DeckService
   |

PLC0415 `import` should be at the top-level of a file
  --> main.py:94:5
   |
92 |     logger.info("Initializing AssetManager and WorkcellRuntime...")
93 |     from praxis.backend.core.filesystem import FileSystem
94 |     from praxis.backend.core.workcell import Workcell
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
95 |     from praxis.backend.services.deck import DeckService
96 |     from praxis.backend.services.machine import MachineService
   |

PLC0415 `import` should be at the top-level of a file
  --> main.py:95:5
   |
93 |     from praxis.backend.core.filesystem import FileSystem
94 |     from praxis.backend.core.workcell import Workcell
95 |     from praxis.backend.services.deck import DeckService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
96 |     from praxis.backend.services.machine import MachineService
97 |     from praxis.backend.services.resource import ResourceService
   |

PLC0415 `import` should be at the top-level of a file
  --> main.py:96:5
   |
94 |     from praxis.backend.core.workcell import Workcell
95 |     from praxis.backend.services.deck import DeckService
96 |     from praxis.backend.services.machine import MachineService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |     from praxis.backend.services.resource import ResourceService
98 |     from praxis.backend.services.workcell import WorkcellService
   |

PLC0415 `import` should be at the top-level of a file
  --> main.py:97:5
   |
95 |     from praxis.backend.services.deck import DeckService
96 |     from praxis.backend.services.machine import MachineService
97 |     from praxis.backend.services.resource import ResourceService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
98 |     from praxis.backend.services.workcell import WorkcellService
   |

PLC0415 `import` should be at the top-level of a file
   --> main.py:98:5
    |
 96 |     from praxis.backend.services.machine import MachineService
 97 |     from praxis.backend.services.resource import ResourceService
 98 |     from praxis.backend.services.workcell import WorkcellService
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 99 |
100 |     workcell = Workcell(
    |

ERA001 Found commented-out code
   --> main.py:147:7
    |
146 |       # Run initial discovery and synchronization
147 |       # logger.info("Running initial discovery and synchronization...")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |       # await discovery_service.discover_and_sync_all_definitions(
149 |       #   protocol_search_paths=praxis_config.all_protocol_source_paths,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> main.py:149:7
    |
147 |       # logger.info("Running initial discovery and synchronization...")
148 |       # await discovery_service.discover_and_sync_all_definitions(
149 |       #   protocol_search_paths=praxis_config.all_protocol_source_paths,
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
150 |       # )
151 |       # logger.info("Initial discovery and synchronization complete.")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> main.py:150:7
    |
148 |       # await discovery_service.discover_and_sync_all_definitions(
149 |       #   protocol_search_paths=praxis_config.all_protocol_source_paths,
150 |       # )
    |       ^^^
151 |       # logger.info("Initial discovery and synchronization complete.")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> main.py:151:7
    |
149 |       #   protocol_search_paths=praxis_config.all_protocol_source_paths,
150 |       # )
151 |       # logger.info("Initial discovery and synchronization complete.")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
152 |
153 |       # Instantiate and initialize the Orchestrator with its dependencies
    |
help: Remove commented-out code

TRY401 Redundant exception object included in `logging.exception` call
   --> main.py:180:66
    |
179 |   except Exception as e:
180 |     logger.exception("Error during application startup: %s", str(e))
    |                                                                  ^
181 |     # In a production scenario, you might want to exit or handle this more gracefully
182 |     raise
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> main.py:199:69
    |
197 |       logger.info("Application shutdown complete.")
198 |     except Exception as e:
199 |       logger.exception("Error during application shutdown: %s", str(e))
    |                                                                     ^
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> main.py:215:33
    |
213 |   allow_origins=[
214 |     "http://localhost:5173",
215 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^
216 |   ],
217 |   allow_credentials=True,
    |

TD003 Missing issue link for this TODO
   --> main.py:215:33
    |
213 |   allow_origins=[
214 |     "http://localhost:5173",
215 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^
216 |   ],
217 |   allow_credentials=True,
    |

FIX002 Line contains TODO, consider resolving the issue
   --> main.py:215:33
    |
213 |   allow_origins=[
214 |     "http://localhost:5173",
215 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^
216 |   ],
217 |   allow_credentials=True,
    |

ANN001 Missing type annotation for function argument `call_next`
   --> main.py:239:42
    |
238 | @app.middleware("http")
239 | async def log_requests(request: Request, call_next) -> Response:
    |                                          ^^^^^^^^^
240 |   """Middleware to log incoming requests and their response status codes."""
241 |   logger.info("Request: %s %s", request.method, request.url.path)
    |

ANN201 Missing return type annotation for public function `root_redirect`
   --> main.py:253:11
    |
252 | @app.get("/", include_in_schema=False)
253 | async def root_redirect():
    |           ^^^^^^^^^^^^^
254 |   """Redirects the root URL to the static index page."""
255 |   return RedirectResponse(url="/docs")
    |
help: Add return type annotation

BLE001 Do not catch blind exception: `Exception`
  --> praxis/backend/api/discovery.py:35:10
   |
33 |       content={"message": "Discovery and synchronization initiated successfully."},
34 |     )
35 |   except Exception as e:
   |          ^^^^^^^^^
36 |     return JSONResponse(
37 |       status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
   |

FAST001 FastAPI route with redundant `response_model` argument
  --> praxis/backend/api/machines.py:67:3
   |
65 | @router.patch(
66 |   "/{accession}/status",
67 |   response_model=MachineResponse,
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |   tags=["Machines"],
69 | )
   |
help: Remove argument

INP001 File `praxis/backend/api/utils/crud_router_factory.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/api/utils/crud_router_factory.py:1:1

FAST002 FastAPI dependency without `Annotated`
  --> praxis/backend/api/utils/crud_router_factory.py:44:5
   |
42 |   async def create(
43 |     request: Request,
44 |     db: AsyncSession = Depends(get_db),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |   ) -> ModelType:
46 |     obj_in_data = await request.json()
   |
help: Replace with `typing.Annotated`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
  --> praxis/backend/api/utils/crud_router_factory.py:44:24
   |
42 |   async def create(
43 |     request: Request,
44 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^
45 |   ) -> ModelType:
46 |     obj_in_data = await request.json()
   |

D100 Missing docstring in public module
--> praxis/backend/celery_app.py:1:1

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/configure.py:183:5
    |
181 |     """Return the protocol output directory path."""
182 |     path = self._output_directories_section.get("protocol_output", "./protocol_output")
183 |     os.makedirs(path, exist_ok=True)  # Ensure the directory exists
    |     ^^^^^^^^^^^
184 |     return path
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> praxis/backend/configure.py:207:20
    |
205 |     Ensures the directory exists.
206 |     """
207 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                    ^^^^^^^^^^^^
208 |     path = self._protocol_directories_section.get("default_directory", default_path)
209 |     os.makedirs(
    |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> praxis/backend/configure.py:207:33
    |
205 |     Ensures the directory exists.
206 |     """
207 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                                 ^^^^^^^^^^^^^^^
208 |     path = self._protocol_directories_section.get("default_directory", default_path)
209 |     os.makedirs(
    |
help: Replace with `Path(...).parent`

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/configure.py:209:5
    |
207 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
208 |     path = self._protocol_directories_section.get("default_directory", default_path)
209 |     os.makedirs(
    |     ^^^^^^^^^^^
210 |       path,
211 |       exist_ok=True,
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:242:19
    |
241 |     # Add default protocol directory
242 |     all_paths.add(os.path.abspath(self.default_protocol_dir))
    |                   ^^^^^^^^^^^^^^^
243 |
244 |     # Add additional directories
    |
help: Replace with `Path(...).resolve()`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:246:21
    |
244 |     # Add additional directories
245 |     for d in self.additional_directories:
246 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^
247 |
248 |     # Add protocol discovery directories
    |
help: Replace with `Path(...).resolve()`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:250:21
    |
248 |     # Add protocol discovery directories
249 |     for d in self.protocol_discovery_dirs:
250 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^
251 |
252 |     return sorted(all_paths)
    |
help: Replace with `Path(...).resolve()`

PTH123 `open()` should be replaced by `Path.open()`
   --> praxis/backend/configure.py:293:10
    |
291 |     self._config_parser.set("keycloak", "client_secret", client_secret)
292 |
293 |     with open(self._config_file_path, "w") as f:
    |          ^^^^
294 |       self._config_parser.write(f)
    |
help: Replace with `Path.open()`

ARG002 Unused method argument: `redis_url`
  --> praxis/backend/core/asset_lock_manager.py:14:22
   |
12 |   """A simple in-memory asset lock manager."""
13 |
14 |   def __init__(self, redis_url: str | None = None) -> None:
   |                      ^^^^^^^^^
15 |     """Initialize the AssetLockManager."""
16 |     self._locks: dict[str, AcquireAssetLock] = {}
   |

ARG002 Unused method argument: `reservation_id`
  --> praxis/backend/core/asset_lock_manager.py:35:5
   |
33 |     asset_type: str,
34 |     asset_name: str,
35 |     reservation_id: uuid.UUID,
   |     ^^^^^^^^^^^^^^
36 |     protocol_run_id: uuid.UUID | None = None,
37 |   ) -> bool:
   |

ARG002 Unused method argument: `protocol_run_id`
  --> praxis/backend/core/asset_lock_manager.py:36:5
   |
34 |     asset_name: str,
35 |     reservation_id: uuid.UUID,
36 |     protocol_run_id: uuid.UUID | None = None,
   |     ^^^^^^^^^^^^^^^
37 |   ) -> bool:
38 |     """Release a lock on an asset."""
   |

SLF001 Private member accessed: `_handle_location_constraints`
   --> praxis/backend/core/asset_manager/resource_manager.py:229:15
    |
227 |       target_position_name,
228 |       final_status_details,
229 |     ) = await cast("LocationHandlerMixin", self)._handle_location_constraints(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
230 |       is_acquiring_a_deck_resource,
231 |       resource_data.location_constraints,
    |

D100 Missing docstring in public module
--> praxis/backend/core/celery_base.py:1:1

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:13:3
   |
11 |   class PraxisTask(Task):
12 |
13 | /   """A custom Celery Task class for Praxis that integrates with the dependency injection container.
14 | |   """
   | |_____^
15 |
16 |     @property
   |
help: Reformat to one line

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:18:5
   |
16 |     @property
17 |     def container(self) -> Container:
18 | /     """Returns the dependency injection container.
19 | |     """
   | |_______^
20 |       # The container is attached to the app instance.
21 |       return self.app.container
   |
help: Reformat to one line

ANN204 Missing return type annotation for special method `__call__`
  --> praxis/backend/core/celery_base.py:23:7
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |       ^^^^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/celery_base.py:23:22
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |                      ^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/celery_base.py:23:29
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |                             ^^^^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:24:5
   |
23 |     def __call__(self, *args, **kwargs):
24 | /     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 | |     """
   | |_______^
26 |       with self.container.db_session.override(self.container.db_session_factory()):
27 |         return super().__call__(*args, **kwargs)
   |
help: Reformat to one line

D401 First line of docstring should be in imperative mood: "Overrides the default `__call__` method to provide a DI container scope for each task execution."
  --> praxis/backend/core/celery_base.py:24:5
   |
23 |     def __call__(self, *args, **kwargs):
24 | /     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 | |     """
   | |_______^
26 |       with self.container.db_session.override(self.container.db_session_factory()):
27 |         return super().__call__(*args, **kwargs)
   |

E501 Line too long (103 > 100)
  --> praxis/backend/core/celery_base.py:24:101
   |
23 |   def __call__(self, *args, **kwargs):
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
   |                                                                                                     ^^^
25 |     """
26 |     with self.container.db_session.override(self.container.db_session_factory()):
   |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/celery_tasks.py:120:9
    |
118 |       if not protocol_run_orm:
119 |         msg = f"Protocol run {protocol_run_id} not found."
120 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^
121 |
122 |       await protocol_run_service.update_run_status(
    |

TID252 Prefer absolute imports over relative imports from parent modules
  --> praxis/backend/core/container.py:26:1
   |
24 | from praxis.backend.services.workcell import WorkcellService
25 |
26 | from ..utils.filesystem import RealFileSystem
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 | from .asset_lock_manager import AssetLockManager
28 | from .asset_manager import AssetManager
   |
help: Replace relative imports from parent modules with absolute imports

ERA001 Found commented-out code
   --> praxis/backend/core/container.py:122:3
    |
121 |   # Singleton provider: one instance for the entire app lifecycle.
122 |   # discovery_service = providers.Singleton(DiscoveryService)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |
124 |   # Factory provider: a new instance is created on each injection.
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/core/container.py:126:3
    |
124 |   # Factory provider: a new instance is created on each injection.
125 |   # e.g. for a service that holds request-specific state.
126 |   # transient_service = providers.Factory(MyTransientService)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |   # --- Database ---
    |
help: Remove commented-out code

PIE794 Class field `asset_manager` is defined multiple times
   --> praxis/backend/core/container.py:215:3
    |
213 |     )
214 |
215 | /   asset_manager: providers.Factory[IAssetManager] = providers.Factory(
216 | |     AssetManager,
217 | |     db_session=db_session,
218 | |     workcell_runtime=workcell_runtime,
219 | |     deck_service=deck_service,
220 | |     machine_service=machine_service,
221 | |     resource_service=resource_service,
222 | |     resource_type_definition_service=resource_type_definition_service,
223 | |     asset_lock_manager=asset_lock_manager,
224 | |   )
    | |___^
225 |
226 |     orchestrator: providers.Factory[IOrchestrator] = providers.Factory(
    |
help: Remove duplicate field definition for `asset_manager`

D104 Missing docstring in public package
--> praxis/backend/core/decorators/__init__.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/definition_builder.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/models.py:1:1

TC003 Move standard library import `uuid` into a type-checking block
 --> praxis/backend/core/decorators/models.py:2:8
  |
1 | import contextvars
2 | import uuid
  |        ^^^^
3 | from collections.abc import Callable
4 | from dataclasses import dataclass
  |
help: Move into type-checking block

D101 Missing docstring in public class
  --> praxis/backend/core/decorators/models.py:25:7
   |
24 | @dataclass
25 | class CreateProtocolDefinitionData:
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |   func: Callable
27 |   name: str | None
   |

D100 Missing docstring in public module
--> praxis/backend/core/decorators/parameter_processor.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/protocol_decorator.py:1:1

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/core/decorators/protocol_decorator.py:96:5
   |
94 |       parent_function_call_log_accession_id=parent_log_id,
95 |     )
96 |     return call_log_entry_orm.accession_id
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |   except Exception:  # pylint: disable=broad-except
98 |     logger.exception(
   |

C901 `protocol_function` is too complex (17 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

PLR0913 Too many arguments in function definition (13 > 8)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

PLR0915 Too many statements (65 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

C901 `decorator` is too complex (16 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:197:7
    |
195 |   actual_tags = tags or []
196 |
197 |   def decorator(func: Callable) -> Callable:
    |       ^^^^^^^^^
198 |     protocol_definition, found_state_param_details = _create_protocol_definition(
199 |       CreateProtocolDefinitionData(
    |

PLR0915 Too many statements (61 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:197:7
    |
195 |   actual_tags = tags or []
196 |
197 |   def decorator(func: Callable) -> Callable:
    |       ^^^^^^^^^
198 |     protocol_definition, found_state_param_details = _create_protocol_definition(
199 |       CreateProtocolDefinitionData(
    |

SLF001 Private member accessed: `_protocol_definition`
   --> praxis/backend/core/decorators/protocol_decorator.py:216:5
    |
214 |       ),
215 |     )
216 |     cast("Any", func)._protocol_definition = protocol_definition
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

ERA001 Found commented-out code
   --> praxis/backend/core/decorators/protocol_decorator.py:219:5
    |
218 |     # TODO: The protocol registration should be handled by a discovery service.
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |
221 |     # Create the runtime info object and attach it to the function.
    |
help: Remove commented-out code

SLF001 Private member accessed: `_protocol_runtime_info`
   --> praxis/backend/core/decorators/protocol_decorator.py:228:5
    |
226 |       found_state_param_details=found_state_param_details,
227 |     )
228 |     cast("Any", func)._protocol_runtime_info = protocol_runtime_info
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |
230 |     @functools.wraps(func)
    |

C901 `wrapper` is too complex (15 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

PLR0912 Too many branches (17 > 12)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

PLR0915 Too many statements (56 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:30
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                              ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:45
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                             ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:53
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                                     ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

SLF001 Private member accessed: `_protocol_runtime_info`
   --> praxis/backend/core/decorators/protocol_decorator.py:233:22
    |
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |       protocol_unique_key = (
235 |         f"{current_meta.pydantic_definition.name}_v{current_meta.pydantic_definition.version}"
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/core/filesystem.py:20:5
   |
18 |     errors: str | None = None,
19 |     newline: str | None = None,
20 |     closefd: bool = True,
   |     ^^^^^^^
21 |     opener: Any | None = None,
22 |   ) -> IO[Any]: ...
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/core/filesystem.py:20:5
   |
18 |     errors: str | None = None,
19 |     newline: str | None = None,
20 |     closefd: bool = True,
   |     ^^^^^^^
21 |     opener: Any | None = None,
22 |   ) -> IO[Any]: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `opener`
  --> praxis/backend/core/filesystem.py:21:13
   |
19 |     newline: str | None = None,
20 |     closefd: bool = True,
21 |     opener: Any | None = None,
   |             ^^^^^^^^^^
22 |   ) -> IO[Any]: ...
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> praxis/backend/core/filesystem.py:26:12
   |
24 |   def open(self, *args: Any, **kwargs: Any) -> IO[Any]:
25 |     """Open a file and return a file object."""
26 |     return open(*args, **kwargs)
   |            ^^^^
27 |
28 |   def exists(self, path: str | bytes | int) -> bool:
   |
help: Replace with `Path.open()`

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/core/filesystem.py:46:66
   |
44 |     Path(path).mkdir(mode=mode)
45 |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
   |                                                                  ^^^^^^^^
47 |     """Create a directory named path with numeric mode mode."""
48 |     Path(path).mkdir(mode=mode, parents=True, exist_ok=exist_ok)
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/core/filesystem.py:46:66
   |
44 |     Path(path).mkdir(mode=mode)
45 |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
   |                                                                  ^^^^^^^^
47 |     """Create a directory named path with numeric mode mode."""
48 |     Path(path).mkdir(mode=mode, parents=True, exist_ok=exist_ok)
   |

PERF203 `try`-`except` within a loop incurs performance overhead
  --> praxis/backend/core/orchestrator/asset_acquisition.py:64:7
   |
62 |             live_obj,
63 |           )
64 | /       except AssetAcquisitionError as e:
65 | |         if asset_req_model.optional:
66 | |           logger.warning(
67 | |             "ORCH-ACQUIRE: Optional asset '%s' could not be acquired: %s. Proceeding as it's optional.",
68 | |             asset_req_model.name,
69 | |             e,
70 | |           )
71 | |           final_args[asset_req_model.name] = None
72 | |         else:
73 | |           error_msg = (
74 | |             f"Failed to acquire mandatory asset '{asset_req_model.name}' for "
75 | |             f"protocol '{protocol_pydantic_def.name}': {e}"
76 | |           )
77 | |           logger.exception(error_msg)
78 | |           raise ValueError(error_msg) from e
   | |____________________________________________^
79 |         except Exception as e_general:
80 |           error_msg = (
   |

E501 Line too long (104 > 100)
  --> praxis/backend/core/orchestrator/asset_acquisition.py:67:101
   |
65 |         if asset_req_model.optional:
66 |           logger.warning(
67 |             "ORCH-ACQUIRE: Optional asset '%s' could not be acquired: %s. Proceeding as it's optional.",
   |                                                                                                     ^^^^
68 |             asset_req_model.name,
69 |             e,
   |

E501 Line too long (103 > 100)
   --> praxis/backend/core/orchestrator/asset_acquisition.py:154:101
    |
152 |       elif deck_param_name in final_args:
153 |         logger.warning(
154 |           "Deck parameter '%s' was already processed (e.g., as an asset). Review protocol definition.",
    |                                                                                                     ^^^
155 |           deck_param_name,
156 |         )
    |

TRY003 Avoid specifying long messages outside the exception class
  --> praxis/backend/core/orchestrator/error_handling.py:38:13
   |
36 |     """Validate the PraxisState object."""
37 |     if praxis_state is None:
38 |       raise ValueError("PraxisState is None")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |
40 |   async def _handle_protocol_execution_error(
   |

EM101 Exception must not use a string literal, assign to variable first
  --> praxis/backend/core/orchestrator/error_handling.py:38:24
   |
36 |     """Validate the PraxisState object."""
37 |     if praxis_state is None:
38 |       raise ValueError("PraxisState is None")
   |                        ^^^^^^^^^^^^^^^^^^^^^
39 |
40 |   async def _handle_protocol_execution_error(
   |
help: Assign to variable; remove string literal

LOG014 `exc_info=` outside exception handlers
  --> praxis/backend/core/orchestrator/error_handling.py:54:7
   |
52 |       protocol_def_name,
53 |       e,
54 |       exc_info=True,
   |       ^^^^^^^^^^^^^
55 |     )
56 |     error_info = {
   |
help: Remove `exc_info=`

E501 Line too long (112 > 100)
  --> praxis/backend/core/orchestrator/error_handling.py:89:101
   |
87 |     if isinstance(e, PyLabRobotVolumeError):
88 |       logger.info(
89 |         "Specific PyLabRobot error 'VolumeError' detected for run %s. Setting status to REQUIRES_INTERVENTION.",
   |                                                                                                     ^^^^^^^^^^^^
90 |         run_accession_id,
91 |       )
   |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/orchestrator/error_handling.py:174:9
    |
172 |               asset_orm_accession_id,
173 |             )
174 | /         except Exception as release_err:  # pylint: disable=broad-except
175 | |           logger.error(
176 | |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
177 | |             asset_info.get("name_in_protocol", "UnknownAsset"),
178 | |             asset_info.get("orm_accession_id"),
179 | |             release_err,
180 | |             exc_info=True,
181 | |           )
    | |___________^
182 |
183 |       await db_session.merge(protocol_run_orm)
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/error_handling.py:175:18
    |
173 |           )
174 |         except Exception as release_err:  # pylint: disable=broad-except
175 |           logger.error(
    |                  ^^^^^
176 |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
177 |             asset_info.get("name_in_protocol", "UnknownAsset"),
    |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:40:56
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                        ^^^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:40:63
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                               ^^^^^^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_get_protocol_definition_orm_from_db`
  --> praxis/backend/core/orchestrator/execution.py:40:76
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                                            ^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:41:42
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                          ^^^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:41:49
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                                 ^^^^^^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_prepare_protocol_code`
  --> praxis/backend/core/orchestrator/execution.py:41:62
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                                              ^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:42:43
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                           ^^^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:42:50
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                                  ^^^^^^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_initialize_run_context`
  --> praxis/backend/core/orchestrator/execution.py:42:63
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                                               ^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:43:38
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                      ^^^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:43:45
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                             ^^^^^^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_prepare_arguments`
  --> praxis/backend/core/orchestrator/execution.py:43:58
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                                          ^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:44:42
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                          ^^^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:44:49
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                                 ^^^^^^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_finalize_protocol_run`
  --> praxis/backend/core/orchestrator/execution.py:44:62
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                                              ^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:45:52
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                    ^^^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:45:59
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                           ^^^^^^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_handle_protocol_execution_error`
  --> praxis/backend/core/orchestrator/execution.py:45:72
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                                        ^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

SLF001 Private member accessed: `_load_callable_from_fqn`
   --> praxis/backend/core/orchestrator/execution.py:143:32
    |
141 |     deck_construction_func = None
142 |     if protocol_pydantic_def.deck_construction_function_fqn:
143 |       deck_construction_func = self.protocol_code_manager._load_callable_from_fqn(
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
144 |         protocol_pydantic_def.deck_construction_function_fqn,
145 |       )
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/execution.py:293:18
    |
291 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
292 |         except Exception as db_final_err:  # pylint: disable=broad-except
293 |           logger.error(
    |                  ^^^^^
294 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
295 |             run_accession_id,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/execution.py:424:18
    |
422 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
423 |         except Exception as db_final_err:
424 |           logger.error(
    |                  ^^^^^
425 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
426 |             run_accession_id,
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/orchestrator/protocol_preparation.py:190:36
    |
188 |     # Expects _acquire_assets and _handle_deck_preconfiguration from AssetAcquisitionMixin
189 |     if hasattr(self, "_acquire_assets"):
190 |       await self._acquire_assets(  # type: ignore
    |                                    ^^^^^^^^^^^^^^
191 |         protocol_pydantic_def,
192 |         protocol_run_accession_id,
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/orchestrator/protocol_preparation.py:198:50
    |
197 |     if hasattr(self, "_handle_deck_preconfiguration"):
198 |       await self._handle_deck_preconfiguration(  # type: ignore
    |                                                  ^^^^^^^^^^^^^^
199 |         db_session,
200 |         protocol_pydantic_def,
    |

ANN201 Missing return type annotation for public function `temporary_sys_path`
  --> praxis/backend/core/protocol_code_manager.py:32:5
   |
31 | @contextlib.contextmanager
32 | def temporary_sys_path(path_to_add: str | None):
   |     ^^^^^^^^^^^^^^^^^^
33 |   """Add a path to sys.path temporarily.
   |
help: Add return type annotation

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/core/protocol_code_manager.py:101:5
    |
 99 |     command: list[str],
100 |     cwd: str,
101 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^
102 |     timeout: int = 300,
103 |   ) -> str:
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/core/protocol_code_manager.py:101:5
    |
 99 |     command: list[str],
100 |     cwd: str,
101 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^
102 |     timeout: int = 300,
103 |   ) -> str:
    |

UP031 Use format specifiers instead of percent format
   --> praxis/backend/core/protocol_code_manager.py:147:9
    |
145 |     except subprocess.TimeoutExpired as e:
146 |       error_message = (
147 |         "CODE-GIT: Command '%s' timed out after %d seconds in %s.\nStderr: %s\nStdout: %s"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |       ) % (
149 |         " ".join(e.cmd),
    |
help: Replace with format specifiers

UP031 Use format specifiers instead of percent format
   --> praxis/backend/core/protocol_code_manager.py:173:9
    |
171 |       )
172 |       error_message = (
173 |         "CODE-GIT: Command '%s' failed with exit code %d in %s.\nStderr: %s\nStdout: %s"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |       ) % (
175 |         " ".join(e.cmd),
    |
help: Replace with format specifiers

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> praxis/backend/core/protocol_code_manager.py:209:8
    |
207 |     """
208 |     is_git_repo = False
209 |     if os.path.exists(checkout_path):
    |        ^^^^^^^^^^^^^^
210 |       try:
211 |         result = await self._run_git_command(
    |
help: Replace with `Path(...).exists()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> praxis/backend/core/protocol_code_manager.py:263:10
    |
261 |       )
262 |     else:
263 |       if os.path.exists(checkout_path):
    |          ^^^^^^^^^^^^^^
264 |         if os.listdir(checkout_path):
265 |           msg = (
    |
help: Replace with `Path(...).exists()`

PTH208 Use `pathlib.Path.iterdir()` instead.
   --> praxis/backend/core/protocol_code_manager.py:264:12
    |
262 |     else:
263 |       if os.path.exists(checkout_path):
264 |         if os.listdir(checkout_path):
    |            ^^^^^^^^^^
265 |           msg = (
266 |             f"Path '{checkout_path}' for repo '{repo_name_for_logging}' exists, "
    |

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/core/protocol_code_manager.py:284:11
    |
282 |         )
283 |         try:
284 |           os.makedirs(checkout_path, exist_ok=True)
    |           ^^^^^^^^^^^
285 |         except OSError as e:
286 |           msg = f"Failed to create directory '{checkout_path}': {e}"
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
   --> praxis/backend/core/protocol_code_manager.py:481:14
    |
479 |     elif protocol_def_orm.file_system_source_accession_id and protocol_def_orm.file_system_source:
480 |       fs_source = protocol_def_orm.file_system_source
481 |       if not os.path.isdir(fs_source.base_path):
    |              ^^^^^^^^^^^^^
482 |         msg = f"Invalid base path '{fs_source.base_path}' for FS source '{fs_source.name}'."
483 |         raise ValueError(
    |
help: Replace with `Path(...).is_dir()`

TRY300 Consider moving this statement to an `else` block
   --> praxis/backend/core/protocol_code_manager.py:513:7
    |
511 |         )
512 |
513 |       return func_wrapper, pydantic_def
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
514 |
515 |     except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/protocol_code_manager.py:516:14
    |
515 |     except Exception as e:
516 |       logger.error(
    |              ^^^^^
517 |         "Failed to load protocol function '%s' from module '%s': %s",
518 |         protocol_def_orm.function_name,
    |

INP001 File `praxis/backend/core/protocols/asset_lock_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/asset_lock_manager.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/protocols/asset_lock_manager.py:1:1

INP001 File `praxis/backend/core/protocols/asset_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/asset_manager.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:19:13
   |
17 |   """A protocol for an asset manager."""
18 |
19 |   async def apply_deck(
   |             ^^^^^^^^^^
20 |     self,
21 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:25:13
   |
23 |   ) -> Deck: ...
24 |
25 |   async def acquire_machine(
   |             ^^^^^^^^^^^^^^^
26 |     self,
27 |     protocol_run_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:32:13
   |
30 |   ) -> tuple[Any, uuid.UUID, str]: ...
31 |
32 |   async def acquire_resource(
   |             ^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_data: AcquireAsset,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:37:13
   |
35 |   ) -> tuple[Any, uuid.UUID, str]: ...
36 |
37 |   async def acquire_asset(
   |             ^^^^^^^^^^^^^
38 |     self,
39 |     protocol_run_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:43:13
   |
41 |   ) -> tuple[Any, uuid.UUID, str]: ...
42 |
43 |   async def release_machine(
   |             ^^^^^^^^^^^^^^^
44 |     self,
45 |     machine_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:50:13
   |
48 |   ) -> None: ...
49 |
50 |   async def release_resource(
   |             ^^^^^^^^^^^^^^^^
51 |     self,
52 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:60:13
   |
58 |   ) -> None: ...
59 |
60 |   async def lock_asset(
   |             ^^^^^^^^^^
61 |     self,
62 |     asset_type: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:68:13
   |
66 |   ) -> bool: ...
67 |
68 |   async def unlock_asset(
   |             ^^^^^^^^^^^^
69 |     self,
70 |     asset_type: str,
   |

INP001 File `praxis/backend/core/protocols/filesystem.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/filesystem.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/protocols/filesystem.py:1:1

INP001 File `praxis/backend/core/protocols/orchestrator.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/orchestrator.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/orchestrator.py:13:13
   |
11 |   """A protocol for an orchestrator."""
12 |
13 |   async def execute_protocol(
   |             ^^^^^^^^^^^^^^^^
14 |     self,
15 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/orchestrator.py:23:13
   |
21 |   ) -> ProtocolRunOrm: ...
22 |
23 |   async def execute_existing_protocol_run(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 |     self,
25 |     protocol_run_orm: ProtocolRunOrm,
   |

INP001 File `praxis/backend/core/protocols/protocol_code_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/protocol_code_manager.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_code_manager.py:17:13
   |
15 |   """A protocol for a protocol code manager."""
16 |
17 |   async def prepare_protocol_code(
   |             ^^^^^^^^^^^^^^^^^^^^^
18 |     self,
19 |     protocol_def_orm: FunctionProtocolDefinitionOrm,
   |

INP001 File `praxis/backend/core/protocols/protocol_execution_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/protocol_execution_service.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:14:13
   |
12 |   """A protocol for a protocol execution service."""
13 |
14 |   async def execute_protocol_immediately(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |     self,
16 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:24:13
   |
22 |   ) -> ProtocolRunOrm: ...
23 |
24 |   async def schedule_protocol_execution(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     self,
26 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:34:13
   |
32 |   ) -> ProtocolRunOrm: ...
33 |
34 |   async def get_protocol_run_status(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
35 |     self,
36 |     protocol_run_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:39:13
   |
37 |   ) -> dict[str, Any] | None: ...
38 |
39 |   async def cancel_protocol_run(self, protocol_run_id: uuid.UUID) -> bool: ...
   |             ^^^^^^^^^^^^^^^^^^^
   |

INP001 File `praxis/backend/core/protocols/scheduler.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/scheduler.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:14:13
   |
12 |   """A protocol for a protocol scheduler."""
13 |
14 |   async def schedule_protocol_execution(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |     self,
16 |     protocol_run_orm: ProtocolRunOrm,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:21:13
   |
19 |   ) -> bool: ...
20 |
21 |   async def cancel_scheduled_run(self, protocol_run_id: uuid.UUID) -> bool: ...
   |             ^^^^^^^^^^^^^^^^^^^^
22 |
23 |   async def get_schedule_status(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:23:13
   |
21 |   async def cancel_scheduled_run(self, protocol_run_id: uuid.UUID) -> bool: ...
22 |
23 |   async def get_schedule_status(
   |             ^^^^^^^^^^^^^^^^^^^
24 |     self,
25 |     protocol_run_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:28:13
   |
26 |   ) -> dict[str, Any] | None: ...
27 |
28 |   async def list_active_schedules(self) -> list[dict[str, Any]]: ...
   |             ^^^^^^^^^^^^^^^^^^^^^
   |

INP001 File `praxis/backend/core/protocols/workcell.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/workcell.py:1:1

INP001 File `praxis/backend/core/protocols/workcell_runtime.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/workcell_runtime.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:19:13
   |
17 |   """A protocol for a workcell runtime."""
18 |
19 |   async def start_workcell_state_sync(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |
21 |   async def stop_workcell_state_sync(self) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:21:13
   |
19 |   async def start_workcell_state_sync(self) -> None: ...
20 |
21 |   async def stop_workcell_state_sync(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 |   def get_main_workcell(self) -> IWorkcell: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:23:7
   |
21 |   async def stop_workcell_state_sync(self) -> None: ...
22 |
23 |   def get_main_workcell(self) -> IWorkcell: ...
   |       ^^^^^^^^^^^^^^^^^
24 |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:25:7
   |
23 |   def get_main_workcell(self) -> IWorkcell: ...
24 |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
   |       ^^^^^^^^^^^^^^^^^^
26 |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:27:7
   |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
26 |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
   |       ^^^^^^^^^^^^^^^^^^^^
28 |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:29:13
   |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
28 |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
   |             ^^^^^^^^^^^^^^^^^^
30 |
31 |   async def create_or_get_resource(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:31:13
   |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
30 |
31 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
32 |     self,
33 |     resource_orm: ResourceOrm,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:37:7
   |
35 |   ) -> Resource: ...
36 |
37 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine: ...
   |       ^^^^^^^^^^^^^^^^^^
38 |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:39:7
   |
37 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine: ...
38 |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:41:7
   |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
40 |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |
43 |   def get_active_resource(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:43:7
   |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
42 |
43 |   def get_active_resource(
   |       ^^^^^^^^^^^^^^^^^^^
44 |     self,
45 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:48:7
   |
46 |   ) -> Resource: ...
47 |
48 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:50:7
   |
48 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID: ...
49 |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
   |       ^^^^^^^^^^^^^^^
51 |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:52:13
   |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
51 |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
   |             ^^^^^^^^^^^^^^^^
53 |
54 |   async def assign_resource_to_deck(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:54:13
   |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
53 |
54 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
55 |     self,
56 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:62:13
   |
60 |   ) -> None: ...
61 |
62 |   async def clear_deck_position(
   |             ^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:69:13
   |
67 |   ) -> None: ...
68 |
69 |   async def execute_machine_action(
   |             ^^^^^^^^^^^^^^^^^^^^^^
70 |     self,
71 |     machine_orm_accession_id: uuid.UUID,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_machine_action`
  --> praxis/backend/core/protocols/workcell_runtime.py:74:8
   |
72 |     action_name: str,
73 |     params: dict[str, Any] | None = None,
74 |   ) -> Any: ...
   |        ^^^
75 |
76 |   async def shutdown_all_machines(self) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:76:13
   |
74 |   ) -> Any: ...
75 |
76 |   async def shutdown_all_machines(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^
77 |
78 |   async def get_deck_state_representation(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:78:13
   |
76 |   async def shutdown_all_machines(self) -> None: ...
77 |
78 |   async def get_deck_state_representation(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
79 |     self,
80 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:83:13
   |
81 |   ) -> dict[str, Any]: ...
82 |
83 |   async def get_last_initialized_deck_object(self) -> Deck | None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |
85 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:85:13
   |
83 |   async def get_last_initialized_deck_object(self) -> Deck | None: ...
84 |
85 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None: ...
   |             ^^^^^^^^^^^^^^
   |

E501 Line too long (109 > 100)
   --> praxis/backend/core/scheduler.py:165:101
    |
164 |         if self._asset_reservations[asset_key]:
165 |           error_msg = f"Asset {asset_key} is already reserved by runs: {self._asset_reservations[asset_key]}"
    |                                                                                                     ^^^^^^^^^
166 |           logger.warning(error_msg)
167 |           await self._release_reservations(reserved_assets, protocol_run_id)
    |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/scheduler.py:168:11
    |
166 |           logger.warning(error_msg)
167 |           await self._release_reservations(reserved_assets, protocol_run_id)
168 |           raise AssetAcquisitionError(error_msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |
170 |         self._asset_reservations[asset_key].add(protocol_run_id)
    |

TRY300 Consider moving this statement to an `else` block
   --> praxis/backend/core/scheduler.py:185:7
    |
183 |         protocol_run_id,
184 |       )
185 |       return True
    |       ^^^^^^^^^^^
186 |
187 |     except AssetAcquisitionError:
    |

TRY003 Avoid specifying long messages outside the exception class
   --> praxis/backend/core/scheduler.py:195:13
    |
193 |       )
194 |       await self._release_reservations(reserved_assets, protocol_run_id)
195 |       raise AssetAcquisitionError(f"Unexpected error during asset reservation: {e!s}") from e
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 |
197 |   async def _release_reservations(
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> praxis/backend/core/scheduler.py:195:35
    |
193 |       )
194 |       await self._release_reservations(reserved_assets, protocol_run_id)
195 |       raise AssetAcquisitionError(f"Unexpected error during asset reservation: {e!s}") from e
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 |
197 |   async def _release_reservations(
    |
help: Assign to variable; remove f-string literal

TRY400 Use `logging.exception` instead of `logging.error`
   --> praxis/backend/core/scheduler.py:249:11
    |
247 |             await self.reserve_assets(requirements, protocol_run_orm.accession_id)
248 |           except AssetAcquisitionError as e:
249 | /           logger.error(
250 | |             "Failed to reserve assets for run %s: %s",
251 | |             protocol_run_orm.accession_id,
252 | |             e,
253 | |           )
    | |___________^
254 |             await self.protocol_run_service.update(
255 |               db=db_session,
    |
help: Replace with `exception`

TRY003 Avoid specifying long messages outside the exception class
   --> praxis/backend/core/scheduler.py:311:13
    |
309 |       if isinstance(e, (AssetAcquisitionError, OrchestratorError)):
310 |         raise
311 |       raise OrchestratorError(f"Failed to schedule protocol execution: {e!s}") from e
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
312 |
313 |   async def _queue_execution_task(
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> praxis/backend/core/scheduler.py:311:31
    |
309 |       if isinstance(e, (AssetAcquisitionError, OrchestratorError)):
310 |         raise
311 |       raise OrchestratorError(f"Failed to schedule protocol execution: {e!s}") from e
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
312 |
313 |   async def _queue_execution_task(
    |
help: Assign to variable; remove f-string literal

D104 Missing docstring in public package
--> praxis/backend/core/workcell_runtime/__init__.py:1:1

TC003 Move standard library import `asyncio` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:3:8
  |
1 | """Core WorkcellRuntime class definition."""
2 |
3 | import asyncio
  |        ^^^^^^^
4 | import uuid
5 | from typing import TYPE_CHECKING
  |
help: Move into type-checking block

TC003 Move standard library import `uuid` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:4:8
  |
3 | import asyncio
4 | import uuid
  |        ^^^^
5 | from typing import TYPE_CHECKING
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.machines.Machine` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:7:33
  |
5 | from typing import TYPE_CHECKING
6 |
7 | from pylabrobot.machines import Machine
  |                                 ^^^^^^^
8 | from pylabrobot.resources import Deck, Resource
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.resources.Deck` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:8:34
  |
7 | from pylabrobot.machines import Machine
8 | from pylabrobot.resources import Deck, Resource
  |                                  ^^^^
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.resources.Resource` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:8:40
  |
7 | from pylabrobot.machines import Machine
8 | from pylabrobot.resources import Deck, Resource
  |                                        ^^^^^^^^
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:34:5
   |
32 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID:
33 |     """Retrieve the ORM ID of an active PyLabRobot Deck instance."""
34 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
35 |     for orm_accession_id, active_deck in self._active_decks.items():
36 |       if active_deck is deck:
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:43:5
   |
41 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck:
42 |     """Retrieve an active PyLabRobot Deck instance by its ORM ID."""
43 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
44 |     deck = self._active_decks.get(deck_orm_accession_id)
45 |     if deck is None:
   |
help: Consider using a different variable name

C901 `assign_resource_to_deck` is too complex (17 > 10)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLR0912 Too many branches (20 > 12)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLR0915 Too many statements (65 > 50)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:70:5
   |
68 |   ) -> None:  # ruff: noqa: C901, PLR0912, PLR0915
69 |     """Assign a live Resource to a specific location or position on a deck."""
70 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
71 |     if location is None and position_accession_id is None:
72 |       msg = (
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:211:5
    |
209 |   ) -> None:
210 |     """Clear a resource from a specific position on a live deck."""
211 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
212 |     deck = self.get_active_deck(deck_orm_accession_id)
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:260:5
    |
258 |   ) -> dict[str, Any]:
259 |     """Construct a dictionary representing the state of a specific deck."""
260 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
261 |     async with self.db_session_factory() as db_session:
262 |       deck_orm = await self.deck_svc.get(db=db_session, accession_id=deck_orm_accession_id)
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:349:5
    |
347 |   async def get_last_initialized_deck_object(self) -> Deck | None:
348 |     """Return the Deck most recently initialized by this runtime instance."""
349 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
350 |     if self._last_initialized_deck_object:
351 |       return self._last_initialized_deck_object
    |
help: Consider using a different variable name

C901 `_get_calculated_location` is too complex (12 > 10)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:358:13
    |
356 |     suffix=" - Ensure the deck type definition exists in the database.",
357 |   )
358 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
359 |     self,
360 |     target_deck: Deck,
    |

PLR0912 Too many branches (15 > 12)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:358:13
    |
356 |     suffix=" - Ensure the deck type definition exists in the database.",
357 |   )
358 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
359 |     self,
360 |     target_deck: Deck,
    |

PLR0915 Too many statements (55 > 50)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:358:13
    |
356 |     suffix=" - Ensure the deck type definition exists in the database.",
357 |   )
358 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
359 |     self,
360 |     target_deck: Deck,
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:366:5
    |
364 |   ) -> Coordinate:  # ruff: noqa: C901, PLR0912, PLR0915
365 |     """Calculate the PyLabRobot Coordinate for a given position_accession_id."""
366 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
367 |     if positioning_config is None:
368 |       logger.info(
    |
help: Consider using a different variable name

TRY003 Avoid specifying long messages outside the exception class
   --> praxis/backend/core/workcell_runtime/deck_manager.py:379:19
    |
377 |           )
378 |           if not deck_type_definition:
379 |             raise WorkcellRuntimeError(f"Deck type definition with ID {deck_type_id} not found.")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
380 |           all_deck_position_definitions = deck_type_definition.positions
381 |           found_position_def = next(
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> praxis/backend/core/workcell_runtime/deck_manager.py:379:40
    |
377 |           )
378 |           if not deck_type_definition:
379 |             raise WorkcellRuntimeError(f"Deck type definition with ID {deck_type_id} not found.")
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
380 |           all_deck_position_definitions = deck_type_definition.positions
381 |           found_position_def = next(
    |
help: Assign to variable; remove f-string literal

C901 `initialize_machine` is too complex (21 > 10)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLR0912 Too many branches (24 > 12)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLR0915 Too many statements (87 > 50)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/machine_manager.py:39:5
   |
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
39 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
40 |
41 |     if not hasattr(machine_orm, "id") or machine_orm.accession_id is None:
   |
help: Consider using a different variable name

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:137:11
    |
135 |             f"instance. Type is {type(machine_instance).__name__}."
136 |           )
137 |           raise TypeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^
138 |
139 |         if (
    |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:160:11
    |
158 |             "and awaitable."
159 |           )
160 |           raise WorkcellRuntimeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |       except Exception as e:  # pylint: disable=broad-except
162 |         error_message = f"Failed to instantiate or setup machine \
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/workcell_runtime/machine_manager.py:213:74
    |
212 |     if hasattr(machine_instance, "deck") and isinstance(machine_instance.deck, Deck):
213 |       machine_deck: Deck = cast("LiquidHandler", machine_instance).deck  # type: ignore
    |                                                                          ^^^^^^^^^^^^^^
214 |       if not isinstance(machine_deck, Deck):
215 |         msg = (
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:263:5
    |
261 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine:
262 |     """Retrieve an active PyLabRobot machine instance by its ORM ID."""
263 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
264 |     machine = self._active_machines.get(machine_orm_accession_id)
265 |     if machine is None:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:280:5
    |
278 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID:
279 |     """Retrieve the ORM ID of an active PyLabRobot machine instance."""
280 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
281 |     for orm_accession_id, active_machine in self._active_machines.items():
282 |       if active_machine is machine:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:295:5
    |
293 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None:
294 |     """Shut down and removes a live PyLabRobot machine instance."""
295 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
296 |     machine_instance = self._active_machines.pop(machine_orm_accession_id, None)
297 |     try:
    |
help: Consider using a different variable name

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:318:11
    |
316 |             f"{machine_orm_accession_id} that is callable and awaitable."
317 |           )
318 |           raise WorkcellRuntimeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
319 |         async with self.db_session_factory() as db_session:
320 |           await self.machine_svc.update_machine_status(
    |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:341:9
    |
339 |           "unexpectedly offline."
340 |         )
341 |         raise WorkcellRuntimeError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
342 |
343 |     except Exception as e:  # pylint: disable=broad-except
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_machine_action`
   --> praxis/backend/core/workcell_runtime/machine_manager.py:373:8
    |
371 |     action_name: str,
372 |     params: dict[str, Any] | None = None,
373 |   ) -> Any:  # ruff: noqa: ANN401
    |        ^^^
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |

ERA001 Found commented-out code
   --> praxis/backend/core/workcell_runtime/machine_manager.py:375:5
    |
373 |   ) -> Any:  # ruff: noqa: ANN401
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
376 |     machine = self.get_active_machine(machine_orm_accession_id)
377 |     logger.info(
    |
help: Remove commented-out code

E501 Line too long (124 > 100)
   --> praxis/backend/core/workcell_runtime/machine_manager.py:375:101
    |
373 |   ) -> Any:  # ruff: noqa: ANN401
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
376 |     machine = self.get_active_machine(machine_orm_accession_id)
377 |     logger.info(
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:410:5
    |
408 |   async def shutdown_all_machines(self) -> None:
409 |     """Shut down all currently active PyLabRobot machine instances."""
410 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
411 |     logger.info("WorkcellRuntime: Shutting down all active machines...")
412 |     for machine_accession_id in list(self._active_machines.keys()):  # ruff: noqa: PERF203
    |
help: Consider using a different variable name

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/workcell_runtime/machine_manager.py:419:7
    |
417 |           )
418 |           await self.shutdown_machine(machine_accession_id)
419 | /       except WorkcellRuntimeError:
420 | |         logger.exception(
421 | |           "WorkcellRuntime: Error shutting down machine ID %s",
422 | |           machine_accession_id,
423 | |         )
424 | |         continue
    | |________________^
425 |       logger.info("WorkcellRuntime: All active machines processed for shutdown.")
    |

C901 `create_or_get_resource` is too complex (12 > 10)
  --> praxis/backend/core/workcell_runtime/resource_manager.py:32:13
   |
30 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
31 |   )
32 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_orm: ResourceOrm,
   |

PLR0912 Too many branches (13 > 12)
  --> praxis/backend/core/workcell_runtime/resource_manager.py:32:13
   |
30 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
31 |   )
32 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_orm: ResourceOrm,
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/resource_manager.py:38:5
   |
36 |   ) -> Resource:  # ruff: noqa: C901, PLR0912
37 |     """Create or retrieve a live PyLabRobot resource object."""
38 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
39 |     if not hasattr(resource_orm, "id") or resource_orm.accession_id is None:
40 |       msg = "Invalid resource_orm object passed to create_or_get_resource (no id)."
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:163:5
    |
161 |   ) -> Resource:
162 |     """Retrieve an active PyLabRobot resource object by its ORM ID."""
163 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
164 |     resource = self._active_resources.get(resource_orm_accession_id)
165 |     if resource is None:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:181:5
    |
179 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID:
180 |     """Retrieve the ORM ID of an active PyLabRobot resource object."""
181 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
182 |     for orm_accession_id, active_resource in self._active_resources.items():
183 |       if active_resource is resource:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:194:5
    |
192 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None:
193 |     """Clear a resource from the workcell runtime."""
194 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
195 |     if resource_orm_accession_id in self._active_resources:
196 |       del self._active_resources[resource_orm_accession_id]
    |
help: Consider using a different variable name

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/workcell_runtime/state_sync.py:107:7
    |
105 |             )
106 |
107 | /       except asyncio.CancelledError:
108 | |         logger.info("Workcell state sync loop cancelled.")
109 | |         break
    | |_____________^
110 |         except Exception:  # pylint: disable=broad-except
111 |           logger.exception(
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> praxis/backend/models/orm/deck.py:77:20
   |
76 |   __tablename__ = "decks"
77 |   __table_args__ = {"extend_existing": True}
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
78 |   __mapper_args__: ClassVar[dict] = {
79 |     "polymorphic_identity": "DECK",  # Uppercase to match AssetType.DECK
   |

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:126:3
    |
124 |   # resource_child_list: Mapped[list["ResourceOrm"]] = relationship(
125 |   #   "ResourceOrm",
126 |   #   back_populates="resource_definition",
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |   #   cascade="all, delete-orphan",
128 |   #   default_factory=list,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:127:3
    |
125 |   #   "ResourceOrm",
126 |   #   back_populates="resource_definition",
127 |   #   cascade="all, delete-orphan",
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |   #   default_factory=list,
129 |   # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:128:3
    |
126 |   #   back_populates="resource_definition",
127 |   #   cascade="all, delete-orphan",
128 |   #   default_factory=list,
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^
129 |   # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:129:3
    |
127 |   #   cascade="all, delete-orphan",
128 |   #   default_factory=list,
129 |   # )
    |   ^^^
130 |
131 |   resource_definition_accession_id: Mapped[uuid.UUID | None] = mapped_column(
    |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> praxis/backend/models/orm/protocol.py:65:20
   |
64 |   __tablename__ = "protocol_source_repositories"
65 |   __table_args__ = {"extend_existing": True}
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
66 |
67 |   name: Mapped[str] = mapped_column(
   |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/orm/protocol.py:398:22
    |
396 |     comment="JSONB representation of any constraints on the parameter, such as allowed values or \
397 |       ranges.",
398 |     default=None,  # TODO(mar): consider using a more structured type for constraints # noqa: TD003
    |                      ^^^^
399 |   )
400 |   ui_hint_json: Mapped[dict | None] = mapped_column(
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/orm/protocol.py:495:22
    |
493 |     comment="JSONB representation of any constraints on the asset requirement, such as allowed \
494 |       values or ranges.",
495 |     default=None,  # TODO(mar): consider using a more structured type for constraints # noqa: TD003
    |                      ^^^^
496 |   )
497 |   location_constraints_json: Mapped[dict | None] = mapped_column(
    |

E501 Line too long (101 > 100)
   --> praxis/backend/models/orm/schedule.py:444:101
    |
442 |     nullable=False,
443 |     default=ScheduleHistoryEventTriggerEnum.SYSTEM,
444 |     comment="Identifier for the entity that triggered this event, e.g., 'user', 'system', 'celery'.",
    |                                                                                                     ^
445 |     kw_only=True,
446 |   )
    |

ERA001 Found commented-out code
   --> praxis/backend/models/orm/schedule.py:496:1
    |
494 |   CreateMaterializedView("scheduler_metrics_mv", metrics_query),
495 | )
496 | # event.listen(Base.metadata, "before_drop", DropMaterializedView("scheduler_metrics_mv"))
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> praxis/backend/models/orm/schedule.py:515:20
    |
513 |   avg_execution_time_ms: Mapped[float] = mapped_column(Float, init=False)
514 |
515 |   __table_args__ = {"extend_existing": True}
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
    |

E501 Line too long (106 > 100)
  --> praxis/backend/models/pydantic_internals/filters.py:38:101
   |
36 |     description="Filter by associated protocol run ID.",
37 |   )
38 |   machine_accession_id: UUID7 | None = Field(default=None, description="Filter by associated machine ID.")
   |                                                                                                     ^^^^^^
39 |   resource_accession_id: UUID7 | None = Field(default=None, description="Filter by associated resource ID.")
40 |   parent_accession_id: UUID7 | None = Field(default=None, description="Filter by parent asset ID.")
   |

E501 Line too long (108 > 100)
  --> praxis/backend/models/pydantic_internals/filters.py:39:101
   |
37 |   )
38 |   machine_accession_id: UUID7 | None = Field(default=None, description="Filter by associated machine ID.")
39 |   resource_accession_id: UUID7 | None = Field(default=None, description="Filter by associated resource ID.")
   |                                                                                                     ^^^^^^^^
40 |   parent_accession_id: UUID7 | None = Field(default=None, description="Filter by parent asset ID.")
   |

D101 Missing docstring in public class
  --> praxis/backend/models/pydantic_internals/outputs.py:73:7
   |
73 | class FunctionDataOutputCreate(FunctionDataOutputBase):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^
74 |   name: str = "default_name"
75 |   """Model for creating function data outputs."""
   |

ANN201 Missing return type annotation for public function `validate_data_content`
   --> praxis/backend/models/pydantic_internals/outputs.py:125:7
    |
124 |   @model_validator(mode="after")
125 |   def validate_data_content(self):
    |       ^^^^^^^^^^^^^^^^^^^^^
126 |     """Ensure at least one data field is provided."""
127 |     data_fields = [
    |
help: Add return type annotation

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/models/pydantic_internals/outputs.py:284:8
    |
282 |     None,
283 |     description="Updated metadata",
284 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/models/pydantic_internals/outputs.py:284:8
    |
282 |     None,
283 |     description="Updated metadata",
284 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/pydantic_internals/outputs.py:284:8
    |
282 |     None,
283 |     description="Updated metadata",
284 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:371:34
    |
369 |   export_format: str = Field(..., description="Export format (csv, json, xlsx, etc.)")
370 |
371 |   include_metadata: bool = Field(True, description="Whether to include metadata")
    |                                  ^^^^
372 |
373 |   include_spatial_info: bool = Field(
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:374:5
    |
373 |   include_spatial_info: bool = Field(
374 |     True,
    |     ^^^^
375 |     description="Whether to include spatial information",
376 |   )
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:379:5
    |
378 |   flatten_structure: bool = Field(
379 |     False,
    |     ^^^^^
380 |     description="Whether to flatten hierarchical data",
381 |   )
    |

PYI063 Use PEP 570 syntax for positional-only parameters
  --> praxis/backend/models/pydantic_internals/pydantic_base.py:44:29
   |
42 |   )
43 |
44 |   def model_post_init(self, __context: Any) -> None:  # noqa: ANN401
   |                             ^^^^^^^^^
45 |     """Set the updated_at field to the current time after model initialization."""
46 |     self.updated_at = datetime.datetime.now(tz=datetime.timezone.utc)
   |
help: Add `/` to function signature

RUF022 `__all__` is not sorted
  --> praxis/backend/services/__init__.py:30:11
   |
28 |   from praxis.backend.services.workcell import workcell_service
29 |
30 |   __all__ = [
   |  ___________^
31 | |   # Deck
32 | |   "deck_service",
33 | |   # Deck Type Definition
34 | |   "DeckTypeDefinitionService",
35 | |   "DiscoveryService",
36 | |   # Function Output Data
37 | |   "FunctionDataOutputCRUDService",
38 | |   # Machine
39 | |   "machine_service",
40 | |   # Plate Viz
41 | |   "read_plate_data_visualization",
42 | |   # Praxis ORM Service
43 | |   "PraxisDBService",
44 | |   # Protocol Output Data
45 | |   "read_protocol_run_data_summary",
46 | |   # Protocols
47 | |   "protocol_run_service",
48 | |   # Resource
49 | |   "resource_service",
50 | |   # Resource Definition
51 | |   "ResourceTypeDefinitionService",
52 | |   # Workcell
53 | |   "workcell_service",
54 | | ]
   | |_^
   |
help: Apply an isort-style sorting to `__all__`

ANN204 Missing return type annotation for special method `__init__`
  --> praxis/backend/services/discovery_service.py:39:9
   |
37 |     """AST visitor to find protocol functions."""
38 |
39 |     def __init__(self, module_name: str, file_path: str):
   |         ^^^^^^^^
40 |         self.module_name = module_name
41 |         self.file_path = file_path
   |
help: Add return type annotation: `None`

D107 Missing docstring in `__init__`
  --> praxis/backend/services/discovery_service.py:39:9
   |
37 |     """AST visitor to find protocol functions."""
38 |
39 |     def __init__(self, module_name: str, file_path: str):
   |         ^^^^^^^^
40 |         self.module_name = module_name
41 |         self.file_path = file_path
   |

ANN201 Missing return type annotation for public function `visit_FunctionDef`
  --> praxis/backend/services/discovery_service.py:44:9
   |
42 |         self.definitions = []
43 |
44 |     def visit_FunctionDef(self, node: ast.FunctionDef):  # pylint: disable=invalid-name
   |         ^^^^^^^^^^^^^^^^^
45 |         """Visit a function definition."""
46 |         params_list = []
   |
help: Add return type annotation: `None`

B905 `zip()` without an explicit `strict=` parameter
  --> praxis/backend/services/discovery_service.py:55:29
   |
53 |         ]
54 |
55 |         for arg, default in zip(node.args.args, defaults):
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |             annotation = ast.unparse(arg.annotation) if arg.annotation else "Any"
   |
help: Add explicit value for parameter `strict=`

PTH123 `open()` should be replaced by `Path.open()`
   --> praxis/backend/services/discovery_service.py:152:30
    |
150 |                         )
151 |
152 |                         with open(module_file_path, encoding="utf-8") as f:
    |                              ^^^^
153 |                             source = f.read()
154 |                             try:
    |
help: Replace with `Path.open()`

G004 Logging statement uses f-string
   --> praxis/backend/services/discovery_service.py:163:37
    |
161 |                             except SyntaxError as e:
162 |                                 logger.warning(
163 |                                     f"Could not parse {module_file_path}: {e}",
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
164 |                                 )
165 |         return extracted_definitions
    |
help: Convert to lazy `%` formatting

ARG002 Unused method argument: `source_repository_accession_id`
   --> praxis/backend/services/discovery_service.py:170:9
    |
168 |         self,
169 |         search_paths: str | list[str],
170 |         source_repository_accession_id: uuid.UUID | None = None,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
171 |         commit_hash: str | None = None,
172 |         file_system_source_accession_id: uuid.UUID | None = None,
    |

ARG002 Unused method argument: `commit_hash`
   --> praxis/backend/services/discovery_service.py:171:9
    |
169 |         search_paths: str | list[str],
170 |         source_repository_accession_id: uuid.UUID | None = None,
171 |         commit_hash: str | None = None,
    |         ^^^^^^^^^^^
172 |         file_system_source_accession_id: uuid.UUID | None = None,
173 |     ) -> list[Any]:
    |

ARG002 Unused method argument: `file_system_source_accession_id`
   --> praxis/backend/services/discovery_service.py:172:9
    |
170 |         source_repository_accession_id: uuid.UUID | None = None,
171 |         commit_hash: str | None = None,
172 |         file_system_source_accession_id: uuid.UUID | None = None,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
173 |     ) -> list[Any]:
174 |         """Discover protocol functions and upsert them to the DB."""
    |

E501 Line too long (105 > 100)
   --> praxis/backend/services/discovery_service.py:177:101
    |
175 |         if not self.protocol_definition_service:
176 |             logger.error(
177 |                 "DiscoveryService: Protocol definition service not provided. Cannot upsert definitions.",
    |                                                                                                     ^^^^^
178 |             )
179 |             return []
    |

E501 Line too long (104 > 100)
   --> praxis/backend/services/discovery_service.py:201:101
    |
199 |         if self.db_session_factory is None:
200 |             logger.error(
201 |                 "DiscoveryService: No DB session factory provided. Cannot upsert protocol definitions.",
    |                                                                                                     ^^^^
202 |             )
203 |             return []
    |

E501 Line too long (101 > 100)
   --> praxis/backend/services/discovery_service.py:241:101
    |
239 |                     )
240 |         num_successful_upserts = len(
241 |             [d for d in upserted_definitions_orm if hasattr(d, "id") and d.accession_id is not None],
    |                                                                                                     ^
242 |         )
243 |         logger.info(
    |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/entity_linking.py:46:3
   |
44 | ) -> "ResourceDefinitionOrm":
45 |   """Retrieve a resource definition."""
46 |   from praxis.backend.models import ResourceDefinitionOrm
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |
48 |   result = await db.execute(
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/entity_linking.py:73:3
   |
71 |   ) -> Optional["ResourceOrm"]:
72 |     """Create or link ResourceOrm counterpart for a MachineOrm."""
73 | /   from praxis.backend.models import (
74 | |     ResourceOrm,
75 | |     ResourceStatusEnum,
76 | |   )  # Runtime import
   | |___^
77 |
78 |     log_prefix = f"Machine (ID: {machine_orm.accession_id}, Name: '{machine_orm.name}'):"
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/entity_linking.py:194:3
    |
192 | ) -> Optional["MachineOrm"]:
193 |   """Create or link a MachineOrm counterpart for a ResourceOrm."""
194 |   from praxis.backend.models import MachineOrm, MachineStatusEnum
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
195 |
196 |   log_prefix = f"Resource (ID: {resource_orm.accession_id}, Name: '{resource_orm.name}'):"
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:321:1
    |
321 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:349:1
    |
349 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:377:1
    |
377 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/outputs.py:61:5
   |
59 |   ) -> FunctionDataOutputOrm:
60 |     """Create a new function data output record."""
61 |     from praxis.backend.models.enums.outputs import DataOutputTypeEnum
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 |
63 |     data_type_enum = DataOutputTypeEnum(obj_in.data_type)
   |

C901 `read_plate_dimensions` is too complex (15 > 10)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PLR0911 Too many return statements (10 > 6)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PLR0912 Too many branches (14 > 12)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PERF203 `try`-`except` within a loop incurs performance overhead
  --> praxis/backend/services/plate_parsing.py:65:11
   |
63 |               max_row = max(max_row, row_idx)
64 |               max_col = max(max_col, col_idx)
65 | /           except ValueError:
66 | |             continue
   | |____________________^
67 |
68 |           if max_row > 0 or max_col > 0:
   |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> praxis/backend/services/plate_parsing.py:103:40
    |
102 |   """
103 |   if not well_name or len(well_name) < 2:
    |                                        ^
104 |     msg = f"Invalid well name: {well_name}"
105 |     raise ValueError(msg)
    |

PYI059 `Generic[]` should always be the last base class
  --> praxis/backend/services/plr_type_base.py:17:34
   |
17 |   class DiscoverableTypeServiceBase(
   |  __________________________________^
18 | |   Generic[ModelType, CreateSchemaType, UpdateSchemaType],
19 | |   ABC,
20 | | ):
   | |_^
21 |
22 |     """An abstract base class for services that handle discoverable pylabrobot type definitions."""
   |
help: Move `Generic[]` to the end

C901 `initialize` is too complex (11 > 10)
  --> praxis/backend/services/praxis_orm_service.py:67:13
   |
66 |   @classmethod
67 |   async def initialize(
   |             ^^^^^^^^^^
68 |     cls,
69 |     keycloak_dsn: str | None = None,
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:297:7
    |
295 |     logger.info("Executing raw SQL statement.")
296 |     async with self.get_praxis_session() as session:
297 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
298 |
299 |       await session.execute(text(sql_statement), params)
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:321:7
    |
319 |     logger.info("Fetching all rows from raw SQL query.")
320 |     async with self.get_praxis_session() as session:
321 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
322 |
323 |       result = await session.execute(text(sql_query), params)
    |

SLF001 Private member accessed: `_mapping`
   --> praxis/backend/services/praxis_orm_service.py:324:20
    |
323 |       result = await session.execute(text(sql_query), params)
324 |       rows = [dict(row._mapping) for row in result]
    |                    ^^^^^^^^^^^^
325 |       logger.debug("Fetched %d rows.", len(rows))
326 |       return rows
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:347:7
    |
345 |     logger.info("Fetching one row from raw SQL query.")
346 |     async with self.get_praxis_session() as session:
347 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
348 |
349 |       result = await session.execute(text(sql_query), params)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `fetch_val_sql`
   --> praxis/backend/services/praxis_orm_service.py:357:80
    |
355 |       return None
356 |
357 |   async def fetch_val_sql(self, sql_query: str, params: dict | None = None) -> Any:
    |                                                                                ^^^
358 |     """Fetch a single scalar value from a raw SQL query on the Praxis database.
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:372:7
    |
370 |     logger.info("Fetching scalar value from raw SQL query.")
371 |     async with self.get_praxis_session() as session:
372 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
373 |
374 |       result = await session.execute(text(sql_query), params)
    |

N806 Variable `PROJECT_ROOT` in function should be lowercase
   --> praxis/backend/services/praxis_orm_service.py:410:3
    |
408 |   """
409 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
410 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
    |   ^^^^^^^^^^^^
411 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |

N806 Variable `CONFIG_FILE_PATH` in function should be lowercase
   --> praxis/backend/services/praxis_orm_service.py:411:3
    |
409 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
410 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
411 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |   ^^^^^^^^^^^^^^^^
412 |
413 |   if not CONFIG_FILE_PATH.exists():
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/services/praxis_orm_service.py:436:74
    |
434 |       logger.info("Successfully retrieved Keycloak DSN from config.")
435 |     except Exception as e:
436 |       logger.exception("Error reading Keycloak DSN from praxis.ini: %s", e)
    |                                                                          ^
437 |       return None
438 |     else:
    |

C901 `update_run_status` is too complex (11 > 10)
   --> praxis/backend/services/protocols.py:189:13
    |
188 |   @handle_db_transaction
189 |   async def update_run_status(
    |             ^^^^^^^^^^^^^^^^^
190 |     self,
191 |     db: AsyncSession,
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/protocols.py:222:11
    |
220 |         try:
221 |           # Import here to avoid circular dependency
222 |           from praxis.backend.api.global_dependencies import get_scheduler
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |
224 |           scheduler = None
    |

TRY400 Use `logging.exception` instead of `logging.error`
   --> praxis/backend/services/protocols.py:253:11
    |
251 |         except (AssetAcquisitionError, OrchestratorError) as e:
252 |           # Log error
253 |           logger.error("Core exception caught in service: %s", e)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
254 |
255 |           # Update to FAILED
    |
help: Replace with `exception`

TC002 Move third-party import `sqlalchemy.orm.attributes.InstrumentedAttribute` into a type-checking block
  --> praxis/backend/services/scheduler.py:20:39
   |
18 | from sqlalchemy.ext.asyncio import AsyncSession
19 | from sqlalchemy.orm import selectinload
20 | from sqlalchemy.orm.attributes import InstrumentedAttribute
   |                                       ^^^^^^^^^^^^^^^^^^^^^
21 |
22 | from praxis.backend.models.enums import (
   |
help: Move into type-checking block

F811 Redefinition of unused `ScheduleStatusEnum` from line 26
  --> praxis/backend/services/scheduler.py:33:3
   |
31 |   ScheduleEntryOrm,
32 |   ScheduleHistoryOrm,
33 |   ScheduleStatusEnum,
   |   ^^^^^^^^^^^^^^^^^^ `ScheduleStatusEnum` redefined here
34 | )
35 | from praxis.backend.models.pydantic_internals.filters import SearchFilters
   |
  ::: praxis/backend/services/scheduler.py:26:3
   |
24 |   ScheduleHistoryEventEnum,
25 |   ScheduleHistoryEventTriggerEnum,
26 |   ScheduleStatusEnum,
   |   ------------------ previous definition of `ScheduleStatusEnum` here
27 | )
28 | from praxis.backend.models.orm.schedule import (
   |
help: Remove definition: `ScheduleStatusEnum`

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/scheduler.py:82:5
   |
81 |     # Fetch the protocol run
82 |     from praxis.backend.models.orm.protocol import ProtocolRunOrm
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |
84 |     protocol_run_result = await db.execute(
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/scheduler.py:111:5
    |
110 |     # Create a new ScheduleEntryOrm
111 |     from datetime import datetime, timezone
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |
113 |     schedule_entry = self.model(
    |

PLR0913 Too many arguments in function definition (11 > 8)
   --> praxis/backend/services/scheduler.py:284:11
    |
283 | @handle_db_transaction
284 | async def create_asset_reservation(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^
285 |   db: AsyncSession,
286 |   schedule_entry_accession_id: uuid.UUID,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/services/scheduler.py:352:3
    |
350 |   asset_name: str | None = None,
351 |   status_filter: list[AssetReservationStatusEnum] | None = None,
352 |   active_only: bool = False,
    |   ^^^^^^^^^^^
353 | ) -> list[AssetReservationOrm]:
354 |   """List asset reservations with optional filters."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/services/scheduler.py:352:3
    |
350 |   asset_name: str | None = None,
351 |   status_filter: list[AssetReservationStatusEnum] | None = None,
352 |   active_only: bool = False,
    |   ^^^^^^^^^^^
353 | ) -> list[AssetReservationOrm]:
354 |   """List asset reservations with optional filters."""
    |

PLR0913 Too many arguments in function definition (12 > 8)
   --> praxis/backend/services/scheduler.py:462:11
    |
461 | @handle_db_transaction
462 | async def log_schedule_event(
    |           ^^^^^^^^^^^^^^^^^^
463 |   db: AsyncSession,
464 |   schedule_entry_accession_id: uuid.UUID,
    |

A004 Import `ConnectionError` is shadowing a Python builtin
  --> praxis/backend/services/state.py:9:30
   |
 8 | import redis
 9 | from redis.exceptions import ConnectionError
   |                              ^^^^^^^^^^^^^^^
10 |
11 | from praxis.backend.configure import PraxisConfiguration
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/utils/crud_base.py:98:5
    |
 96 |     # Convert enum string values back to enum members for SQLAlchemy
 97 |     # This is necessary because jsonable_encoder converts enums to strings
 98 |     import enum
    |     ^^^^^^^^^^^
 99 |
100 |     for attr_name, column in inspect(self.model).columns.items():
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/utils/crud_base.py:129:5
    |
128 |     # Convert enum string values back to enum members for SQLAlchemy
129 |     import enum
    |     ^^^^^^^^^^^
130 |
131 |     for attr_name, column in inspect(self.model).columns.items():
    |

TC002 Move third-party import `sqlalchemy.engine.CursorResult` into a type-checking block
  --> praxis/backend/services/well_outputs.py:13:31
   |
12 | from sqlalchemy import delete, select
13 | from sqlalchemy.engine import CursorResult
   |                               ^^^^^^^^^^^^
14 | from sqlalchemy.ext.asyncio import AsyncSession
15 | from sqlalchemy.orm import joinedload
   |
help: Move into type-checking block

F403 `from .db import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:1:1
  |
1 | from .db import *
  | ^^^^^^^^^^^^^^^^^
2 | from .errors import *
3 | from .logging import *
  |

D104 Missing docstring in public package
--> praxis/backend/utils/__init__.py:1:1

F403 `from .errors import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:2:1
  |
1 | from .db import *
2 | from .errors import *
  | ^^^^^^^^^^^^^^^^^^^^^
3 | from .logging import *
4 | from .notify import *
  |

F403 `from .logging import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:3:1
  |
1 | from .db import *
2 | from .errors import *
3 | from .logging import *
  | ^^^^^^^^^^^^^^^^^^^^^^
4 | from .notify import *
5 | from .redis_lock import *
  |

F403 `from .notify import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:4:1
  |
2 | from .errors import *
3 | from .logging import *
4 | from .notify import *
  | ^^^^^^^^^^^^^^^^^^^^^
5 | from .redis_lock import *
6 | from .sanitation import *
  |

F403 `from .redis_lock import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:5:1
  |
3 | from .logging import *
4 | from .notify import *
5 | from .redis_lock import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
6 | from .sanitation import *
7 | from .uuid import uuid4, uuid7
  |

F403 `from .sanitation import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:6:1
  |
4 | from .notify import *
5 | from .redis_lock import *
6 | from .sanitation import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
7 | from .uuid import uuid4, uuid7
  |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/db.py:52:12
   |
50 |         "password",
51 |         fallback="password",
52 |       )  # TODO(mar): Use a secure method for production # noqa: TD003
   |            ^^^^
53 |       praxis_db_host = config_parser.get("database", "host", fallback="localhost")
54 |       praxis_db_port = config_parser.get("database", "port", fallback="5432")
   |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/db.py:61:12
   |
59 |         "POSTGRES_PASSWORD",
60 |         praxis_db_password,
61 |       )  # TODO(mar): Use a secure method for production # noqa: TD003
   |            ^^^^
62 |       praxis_db_host = os.getenv("POSTGRES_HOST", praxis_db_host)
63 |       praxis_db_port = os.getenv("POSTGRES_PORT", praxis_db_port)
   |

ANN001 Missing type annotation for function argument `engine`
   --> praxis/backend/utils/db.py:201:33
    |
201 | async def init_praxis_db_schema(engine=None) -> None:
    |                                 ^^^^^^
202 |   """Initialize the Praxis database schema.
    |

D401 First line of docstring should be in imperative mood: "Decorator to manage database transactions in service layer methods."
  --> praxis/backend/utils/db_decorator.py:13:3
   |
12 |   def handle_db_transaction(func: F) -> F:
13 | /   """Decorator to manage database transactions in service layer methods.
14 | |
15 | |   This decorator wraps an async function that takes a SQLAlchemy `AsyncSession`
16 | |   as its first argument. It ensures that the session is properly committed
17 | |   on success and rolled back on any exception.
18 | |
19 | |   Args:
20 | |       func (Callable): The async function to be decorated.
21 | |
22 | |   Returns:
23 | |       Callable: The wrapped async function with transaction management logic.
24 | |
25 | |   Raises:
26 | |       Exception: Re-raises any exception that occurs within the decorated function
27 | |       after rolling back the transaction.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
  --> praxis/backend/utils/db_decorator.py:32:28
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                            ^^^
33 |     """Wrap the function with transaction handling.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> praxis/backend/utils/db_decorator.py:32:43
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                           ^^^
33 |     """Wrap the function with transaction handling.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
  --> praxis/backend/utils/db_decorator.py:32:51
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                                   ^^^
33 |     """Wrap the function with transaction handling.
   |

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/db_decorator.py:62:7
   |
60 |       result = await func(*args, **kwargs)
61 |       await db.commit()
62 |       return result
   |       ^^^^^^^^^^^^^
63 |     except Exception:
64 |       await db.rollback()
   |

ANN001 Missing type annotation for function argument `message`
   --> praxis/backend/utils/errors.py:220:5
    |
218 |   def __init__(
219 |     self,
220 |     message="Too little liquid for transfer.",
    |     ^^^^^^^
221 |     details=None,
222 |     original_plr_exception: Exception | None = None,
    |

ANN001 Missing type annotation for function argument `details`
   --> praxis/backend/utils/errors.py:221:5
    |
219 |     self,
220 |     message="Too little liquid for transfer.",
221 |     details=None,
    |     ^^^^^^^
222 |     original_plr_exception: Exception | None = None,
223 |   ) -> None:
    |

ANN001 Missing type annotation for function argument `message`
   --> praxis/backend/utils/errors.py:243:5
    |
241 |   def __init__(
242 |     self,
243 |     message="A PyLabRobot operation failed.",
    |     ^^^^^^^
244 |     original_plr_exception: Exception | None = None,
245 |   ) -> None:
    |

D100 Missing docstring in public module
--> praxis/backend/utils/filesystem.py:1:1

PTH123 `open()` should be replaced by `Path.open()`
  --> praxis/backend/utils/filesystem.py:10:12
   |
 8 |   def open(self, file: str, mode: str = "r", encoding: str | None = None) -> IO[Any]:
 9 |     """Open a file and return a file object."""
10 |     return open(file, mode, encoding=encoding)
   |            ^^^^
   |
help: Replace with `Path.open()`

ANN201 Missing return type annotation for public function `get_logger`
  --> praxis/backend/utils/logging.py:10:5
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |     ^^^^^^^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `name`
  --> praxis/backend/utils/logging.py:10:16
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

TD003 Missing issue link for this TODO
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/logging.py:25:3
   |
23 |   exception: Exception,
24 |   exception_type: type[Exception],
25 |   raises: bool,
   |   ^^^^^^
26 |   raises_exception: type[Exception],
27 |   prefix: str,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
  --> praxis/backend/utils/logging.py:29:12
   |
27 |   prefix: str,
28 |   suffix: str,
29 |   return_: Any,
   |            ^^^
30 | ) -> Any:
31 |   """Process the exception to generate a custom error message."""
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_process_exception`
  --> praxis/backend/utils/logging.py:30:6
   |
28 |   suffix: str,
29 |   return_: Any,
30 | ) -> Any:
   |      ^^^
31 |   """Process the exception to generate a custom error message."""
32 |   error_message = f"{prefix}{exception.__class__.__name__}: \
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/logging.py:54:3
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/logging.py:54:3
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
  --> praxis/backend/utils/logging.py:58:12
   |
56 |   prefix: str = "",
57 |   suffix: str = "",
58 |   return_: Any = None,
   |            ^^^
59 | ) -> Callable:
60 |   """Log specified exceptions in a function and optionally re-raise them.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
  --> praxis/backend/utils/logging.py:94:30
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                              ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> praxis/backend/utils/logging.py:94:45
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                             ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
  --> praxis/backend/utils/logging.py:94:53
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                                     ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/logging.py:117:3
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/logging.py:117:3
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
   --> praxis/backend/utils/logging.py:121:12
    |
119 |   prefix: str = "",
120 |   suffix: str = "",
121 |   return_: Any = None,
    |            ^^^
122 | ) -> Callable:
123 |   """Log specified exceptions in a function and optionally re-raise them.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> praxis/backend/utils/logging.py:157:24
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                        ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> praxis/backend/utils/logging.py:157:39
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                       ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
   --> praxis/backend/utils/logging.py:157:47
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                               ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN001 Missing type annotation for function argument `smtp_server`
  --> praxis/backend/utils/notify.py:41:22
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                      ^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_port`
  --> praxis/backend/utils/notify.py:41:35
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                   ^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_username`
  --> praxis/backend/utils/notify.py:41:46
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                              ^^^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_password`
  --> praxis/backend/utils/notify.py:41:61
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                                             ^^^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> praxis/backend/utils/notify.py:74:5
   |
72 |           server.login(self.smtp_username, self.smtp_password)
73 |           server.send_message(message)
74 | /     except Exception:  # noqa: BLE001
75 | |       pass
   | |__________^
76 |
77 |     def send_text(
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `module`
  --> praxis/backend/utils/plr_inspection.py:38:11
   |
37 | def get_module_classes(
38 |   module: Any,
   |           ^^^
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:40:3
   |
38 |   module: Any,
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |   ^^^^^^^^^^^^^
41 | ) -> dict[str, type[Any]]:
42 |   """Get all classes from a module that are subclasses of parent_class.
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:40:3
   |
38 |   module: Any,
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |   ^^^^^^^^^^^^^
41 | ) -> dict[str, type[Any]]:
42 |   """Get all classes from a module that are subclasses of parent_class.
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:82:3
   |
80 | def get_constructor_params_with_defaults(
81 |   klass: type[Any],
82 |   required_only: bool = False,
   |   ^^^^^^^^^^^^^
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:82:3
   |
80 | def get_constructor_params_with_defaults(
81 |   klass: type[Any],
82 |   required_only: bool = False,
   |   ^^^^^^^^^^^^^
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:105:87
    |
103 |       params[name] = param.default
104 |   except Exception as e:
105 |     logger.exception("Error inspecting constructor for %s: %s", get_class_fqn(klass), e)
    |                                                                                       ^
106 |   return params
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:142:3
    |
140 |   module_name: str,
141 |   parent_class: type[Any] | None,
142 |   concrete_only: bool,
    |   ^^^^^^^^^^^^^
143 |   visited_modules: set[str],
144 | ) -> dict[str, type[Any]]:
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:188:69
    |
186 |     logger.warning("Could not import module %s: %s", module_name, e)
187 |   except Exception as e:
188 |     logger.exception("Error processing module %s: %s", module_name, e)
    |                                                                     ^
189 |   return found_classes
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:195:3
    |
193 |   base_module_names: str | list[str] = "pylabrobot",
194 |   parent_class: type[Any] | None = None,
195 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
196 | ) -> dict[str, type[Any]]:
197 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:195:3
    |
193 |   base_module_names: str | list[str] = "pylabrobot",
194 |   parent_class: type[Any] | None = None,
195 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
196 | ) -> dict[str, type[Any]]:
197 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:224:3
    |
223 | def get_resource_classes(
224 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:224:3
    |
223 | def get_resource_classes(
224 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:227:28
    |
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
227 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
228 |     base_module_names=[
229 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:238:3
    |
237 | def get_machine_classes(
238 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:238:3
    |
237 | def get_machine_classes(
238 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:241:28
    |
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
241 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
242 |     base_module_names="pylabrobot.machines",
243 |     parent_class=Machine,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:248:22
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:248:22
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:250:33
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |                                 ^^^^^^^^^^^^^^
251 |     base_module_names=[
252 |       "pylabrobot.resources",
    |

PERF403 Use a dictionary comprehension instead of a for-loop
   --> praxis/backend/utils/plr_inspection.py:281:11
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |
help: Replace for loop with dict comprehension

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:281:54
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |                                                      ^^^^^^^^^^^^^^
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/utils/plr_inspection.py:282:5
    |
280 |           if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |             discovered_deck_classes[fqn] = deck_class  # type: ignore
282 | /     except ImportError:
283 | |       logger.warning("Package %s not found during deck discovery.", package_name)
    | |_________________________________________________________________________________^
284 |       except Exception as e:
285 |         logger.exception("Error discovering deck classes in package %s: %s", package_name, e)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:285:90
    |
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
284 |     except Exception as e:
285 |       logger.exception("Error discovering deck classes in package %s: %s", package_name, e)
    |                                                                                          ^
286 |   return discovered_deck_classes
    |

C901 `_get_accepted_categories_for_resource_holder` is too complex (11 > 10)
   --> praxis/backend/utils/plr_inspection.py:289:5
    |
289 | def _get_accepted_categories_for_resource_holder(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
290 |   holder: ResourceHolder,
291 |   parent_carrier: Carrier | None = None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:327:3
    |
326 | def get_resource_holder_classes(
327 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
328 | ) -> dict[str, type[ResourceHolder]]:
329 |   """Return all resource holder and specific carrier classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:327:3
    |
326 | def get_resource_holder_classes(
327 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
328 | ) -> dict[str, type[ResourceHolder]]:
329 |   """Return all resource holder and specific carrier classes.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:333:28
    |
331 |   Includes holders and specific carriers from PyLabRobot modules.
332 |   """
333 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
334 |     base_module_names=[
335 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:344:3
    |
343 | def get_carrier_classes(
344 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
345 | ) -> dict[str, type[Carrier]]:
346 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:344:3
    |
343 | def get_carrier_classes(
344 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
345 | ) -> dict[str, type[Carrier]]:
346 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:350:28
    |
348 |   Includes all carrier types from PyLabRobot modules.
349 |   """
350 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
351 |     base_module_names=[
352 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:361:3
    |
360 | def get_plate_carrier_classes(
361 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:361:3
    |
360 | def get_plate_carrier_classes(
361 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:364:28
    |
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
364 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
365 |     base_module_names=[
366 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:375:3
    |
374 | def get_tip_carrier_classes(
375 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:375:3
    |
374 | def get_tip_carrier_classes(
375 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:378:28
    |
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
378 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
379 |     base_module_names=[
380 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:389:3
    |
388 | def get_trough_carrier_classes(
389 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:389:3
    |
388 | def get_trough_carrier_classes(
389 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:392:28
    |
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
392 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
393 |     base_module_names=[
394 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:403:3
    |
402 | def get_all_carrier_classes(
403 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
404 | ) -> dict[str, type[Carrier]]:
405 |   """Return all carrier classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:403:3
    |
402 | def get_all_carrier_classes(
403 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
404 | ) -> dict[str, type[Carrier]]:
405 |   """Return all carrier classes.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:417:36
    |
416 |   """
417 |   all_carriers = get_all_classes(  # type: ignore
    |                                    ^^^^^^^^^^^^^^
418 |     base_module_names=[
419 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:433:3
    |
432 | def get_all_deck_and_carrier_classes(
433 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
434 | ) -> dict[str, type[Deck | Carrier]]:
435 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:433:3
    |
432 | def get_all_deck_and_carrier_classes(
433 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
434 | ) -> dict[str, type[Deck | Carrier]]:
435 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:442:3
    |
441 | def get_all_resource_classes(
442 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:442:3
    |
441 | def get_all_resource_classes(
442 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

E501 Line too long (102 > 100)
   --> praxis/backend/utils/plr_inspection.py:444:101
    |
442 |   concrete_only: bool = True,
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |                                                                                                     ^^
445 |   all_resources = get_resource_classes(concrete_only=concrete_only)
446 |   all_holders = get_resource_holder_classes(concrete_only=concrete_only)
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:451:3
    |
450 | def get_all_machine_and_deck_classes(
451 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
452 | ) -> dict[str, type[Machine | Deck]]:
453 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:451:3
    |
450 | def get_all_machine_and_deck_classes(
451 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
452 | ) -> dict[str, type[Machine | Deck]]:
453 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:462:3
    |
460 |   base_module_names: str | list[str] = "pylabrobot",
461 |   parent_class: type[Any] | None = None,
462 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
463 | ) -> dict[str, type[Any]]:
464 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:462:3
    |
460 |   base_module_names: str | list[str] = "pylabrobot",
461 |   parent_class: type[Any] | None = None,
462 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
463 | ) -> dict[str, type[Any]]:
464 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:505:3
    |
504 | def get_all_resource_and_machine_classes(
505 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
506 | ) -> dict[str, type[Any]]:
507 |   """Return all resources and machine classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:505:3
    |
504 | def get_all_resource_and_machine_classes(
505 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
506 | ) -> dict[str, type[Any]]:
507 |   """Return all resources and machine classes.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:517:3
    |
516 | def get_deck_and_carrier_classes(
517 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
518 | ) -> dict[str, type[Any]]:
519 |   """Return all deck and carrier classes with enhanced inspection.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:517:3
    |
516 | def get_deck_and_carrier_classes(
517 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
518 | ) -> dict[str, type[Any]]:
519 |   """Return all deck and carrier classes with enhanced inspection.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:539:3
    |
538 | def get_all_resource_and_machine_classes_enhanced(
539 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
540 | ) -> dict[str, type[Any]]:
541 |   """Return all resources and machine classes with enhanced inspection.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:539:3
    |
538 | def get_all_resource_and_machine_classes_enhanced(
539 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
540 | ) -> dict[str, type[Any]]:
541 |   """Return all resources and machine classes with enhanced inspection.
    |

D100 Missing docstring in public module
--> praxis/backend/utils/redis_lock.py:1:1

ANN201 Missing return type annotation for public function `acquire_lock`
  --> praxis/backend/utils/redis_lock.py:9:5
   |
 8 | @contextlib.contextmanager
 9 | def acquire_lock(
   |     ^^^^^^^^^^^^
10 |   redis_client: redis.Redis,
11 |   resource_name: str,
   |
help: Add return type annotation

TRY203 Remove exception handler; error is immediately re-raised
  --> praxis/backend/utils/redis_lock.py:45:3
   |
43 |       # Timeout
44 |       yield False
45 | /   except Exception:
46 | |     raise
   | |_________^
47 |     finally:
48 |       # Only release the lock if it was acquired and the identifier matches
   |

TRY203 Remove exception handler; error is immediately re-raised
  --> praxis/backend/utils/redis_lock.py:53:7
   |
51 |         try:
52 |           redis_client.delete(lock_name)
53 | /       except Exception:
54 | |         raise
   | |_____________^
   |

ERA001 Found commented-out code
  --> praxis/backend/utils/run_control.py:19:3
   |
17 |   # Assuming settings.redis_host and settings.redis_port are available
18 |   # If settings.redis_url is directly available, that would be preferred:
19 |   # redis_url = settings.redis_url
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 |   redis_url = f"redis://{SETTINGS.redis_host}:{SETTINGS.redis_port}/0"
21 |   return redis.Redis.from_url(redis_url, decode_responses=True)
   |
help: Remove commented-out code

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/run_control.py:51:5
   |
49 |     key = _get_command_key(run_accession_id)
50 |     await r.set(key, command, ex=ttl_seconds)
51 |     return True
   |     ^^^^^^^^^^^
52 |   except RedisError:
53 |     # In a real application, use a proper logger
   |

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/run_control.py:89:5
   |
87 |     key = _get_command_key(run_accession_id)
88 |     deleted_count = await r.delete(key)
89 |     return deleted_count > 0
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
90 |   except RedisError:
91 |     return False
   |

D100 Missing docstring in public module
--> praxis/backend/utils/sanitation.py:1:1

D103 Missing docstring in public function
  --> praxis/backend/utils/sanitation.py:10:11
   |
10 | async def well_to_int(well: Well, plate: Plate) -> int:
   |           ^^^^^^^^^^^
11 |   column, row = await parse_well_name(well)
12 |   return int((column * plate.num_items_y) + row)
   |

ANN201 Missing return type annotation for public function `liquid_handler_setup_check`
  --> praxis/backend/utils/sanitation.py:15:5
   |
15 | def liquid_handler_setup_check(func):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
  --> praxis/backend/utils/sanitation.py:15:32
   |
15 | def liquid_handler_setup_check(func):
   |                                ^^^^
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |

D205 1 blank line required between summary line and description
  --> praxis/backend/utils/sanitation.py:16:3
   |
15 |   def liquid_handler_setup_check(func):
16 | /   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 | |   function.
18 | |
19 | |   Args:
20 | |     func: The function to be decorated.
21 | |
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | |
26 | |   Returns:
27 | |     The decorated function.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "A decorator function that checks if a liquid handler is set up before executing the decorated"
  --> praxis/backend/utils/sanitation.py:16:3
   |
15 |   def liquid_handler_setup_check(func):
16 | /   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 | |   function.
18 | |
19 | |   Args:
20 | |     func: The function to be decorated.
21 | |
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | |
26 | |   Returns:
27 | |     The decorated function.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |

ANN202 Missing return type annotation for private function `wrapper`
  --> praxis/backend/utils/sanitation.py:32:13
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |             ^^^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> praxis/backend/utils/sanitation.py:32:21
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                     ^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/utils/sanitation.py:32:28
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                            ^^^^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |

D417 Missing argument description in the docstring for `coerce_to_list`: `target_length`
  --> praxis/backend/utils/sanitation.py:45:11
   |
45 | async def coerce_to_list(items: list | tuple, target_length: int | None) -> list:
   |           ^^^^^^^^^^^^^^
46 |   """Coerces the given items into a list.
   |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/sanitation.py:109:48
    |
109 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^
110 |   """Check the types of items in a list against a given list of types.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/sanitation.py:109:48
    |
109 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^
110 |   """Check the types of items in a list against a given list of types.
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:129:7
    |
127 |     if not isinstance(item, item_type):
128 |       msg = f"Expected {item_type} but got {type(item)}"
129 |       raise ValueError(msg)
    |       ^^^^^^^^^^^^^^^^^^^^^
    |

D417 Missing argument descriptions in the docstring for `check_list_length`: `coerce_length`, `target_length`
   --> praxis/backend/utils/sanitation.py:132:11
    |
132 | async def check_list_length(
    |           ^^^^^^^^^^^^^^^^^
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/sanitation.py:134:3
    |
132 | async def check_list_length(
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^
135 |   target_length: int | None = None,
136 | ) -> list[list[Any]]:
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/sanitation.py:134:3
    |
132 | async def check_list_length(
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^
135 |   target_length: int | None = None,
136 | ) -> list[list[Any]]:
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:155:7
    |
153 |   if not isinstance(items[0], list) and len(items) != target_length:
154 |     if len(items) == 1 and coerce_length:
155 |       assert target_length is not None, "Expected target length to be provided"
    |       ^^^^^^
156 |       return items * target_length
157 |     msg = f"Expected list of length {length} but got list of length {len(items)}"
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:165:7
    |
163 |     if not isinstance(item, list):
164 |       msg = f"Expected list but got {type(item)}"
165 |       raise ValueError(msg)
    |       ^^^^^^^^^^^^^^^^^^^^^
166 |     if len(item) != target_length:
167 |       if len(item) == 1 and coerce_length:
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:168:9
    |
166 |     if len(item) != target_length:
167 |       if len(item) == 1 and coerce_length:
168 |         assert target_length is not None, "Expected target length to be provided"  # mypy assert
    |         ^^^^^^
169 |         new_items.append(item * target_length)
170 |       else:
    |

D417 Missing argument description in the docstring for `parse_well_name`: `well`
   --> praxis/backend/utils/sanitation.py:180:11
    |
180 | async def parse_well_name(well: Well) -> tuple:
    |           ^^^^^^^^^^^^^^^
181 |   """Parse the name of a well into a tuple of the row and column.
    |

D417 Missing argument descriptions in the docstring for `parse_well_str_accession_id`: `plate`, `well`
   --> praxis/backend/utils/sanitation.py:196:11
    |
196 | async def parse_well_str_accession_id(well: str, plate: Plate) -> list[Well]:
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 |   """Parse the name of a well into a tuple of the row and column.
    |

C901 `tip_mapping` is too complex (12 > 10)
   --> praxis/backend/utils/sanitation.py:209:11
    |
209 | async def tip_mapping(
    |           ^^^^^^^^^^^
210 |   tips: TipRack | list[TipSpot],
211 |   sources: list[Well],
    |

D417 Missing argument descriptions in the docstring for `tip_mapping`: `map_tips`, `source_plate`, `target_plate`
   --> praxis/backend/utils/sanitation.py:209:11
    |
209 | async def tip_mapping(
    |           ^^^^^^^^^^^
210 |   tips: TipRack | list[TipSpot],
211 |   sources: list[Well],
    |

ARG001 Unused function argument: `target_plate`
   --> praxis/backend/utils/sanitation.py:213:3
    |
211 |   sources: list[Well],
212 |   source_plate: Plate,
213 |   target_plate: Plate | None = None,
    |   ^^^^^^^^^^^^
214 |   targets: list[Well] | None = None,
215 |   map_tips: Literal["source", "target"] | None = None,
    |

D205 1 blank line required between summary line and description
   --> praxis/backend/utils/sanitation.py:217:3
    |
215 |     map_tips: Literal["source", "target"] | None = None,
216 |   ) -> list[TipSpot]:
217 | /   """Check if tips can be mapped between either source or destination containers based on if they
218 | |   are wells, and that the number of tips is sufficient for the number of sources and targets.
219 | |
220 | |   Args:
221 | |     tips (TipRack | list[TipSpot]): The list of tips to be mapped.
222 | |     sources (list[Well]): The list of source containers.
223 | |     targets (list[Well]): The list of destination containers.
224 | |
225 | |   Raises:
226 | |     ValueError: If the tips cannot be mapped between either the source and target containers.
227 | |     NotImplementedError: If multiple tip racks are used to map between source or target containers.
228 | |     ValueError: If the tip rack does not have a tip at the specified location.
229 | |     ValueError: If the type of the tip is not a list of Tip objects or a single TipRack.
230 | |     ValueError: If the value of map_tips is not "source" or "target".
231 | |     ValueError: If the number of tips is insufficient for the number of sources or targets.
232 | |
233 | |   Returns:
234 | |     tips: The list of tips, either from the input or from mapping between source, target, and
235 | |     tip rack.
236 | |
237 | |   """
    | |_____^
238 |     if isinstance(tips, list):
239 |       if all(isinstance(tip, TipSpot) for tip in tips):
    |
help: Insert single blank line

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:258:3
    |
256 |     targets = sources
257 |   map_onto = sources if map_tips == "source" else targets
258 |   assert map_onto is not None, "Expected map_onto to be provided"  # mypy assert
    |   ^^^^^^
259 |   if isinstance(tips, TipRack):
260 |     tip_number = tips.num_items
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:263:5
    |
261 |     else:
262 |       msg = "Invalid type for tip. Must be a list of TipSpot objects or single TipRack."
263 | /     raise ValueError(
264 | |       msg,
265 | |     )
    | |_____^
266 |     if tip_number < len(map_onto):
267 |       msg = "Insufficient number of tips for the number of sources or targets."
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:280:7
    |
278 |       )
279 |     for well in map_onto:
280 |       assert isinstance(well, Well), "Expected Well object"  # mypy compatible assert
    |       ^^^^^^
281 |       well_number = await well_to_int(well, source_plate)
282 |       if not tips[well_number][0].has_tip():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `key`
   --> praxis/backend/utils/sanitation.py:289:43
    |
289 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                           ^^^
290 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 |     the key matches the given key and the value matches the given value.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> praxis/backend/utils/sanitation.py:289:55
    |
289 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                                       ^^^
290 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 |     the key matches the given key and the value matches the given value.
    |

D205 1 blank line required between summary line and description
   --> praxis/backend/utils/sanitation.py:290:3
    |
289 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
290 | /   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 | |     the key matches the given key and the value matches the given value.
292 | |
293 | |   Args:
294 | |     nested_dict (dict): The nested dictionary to be sliced.
295 | |     key (Any): The key to be matched.
296 | |     value (Any): The value to be matched.
297 | |
298 | |   Returns:
299 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
300 | |
301 | |   """
    | |_____^
302 |     new_dict = {}
303 |     for k, v in nested_dict.items():
    |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "Returns a new dictionary containing only the key-value pairs from the nested dictionary where \"
   --> praxis/backend/utils/sanitation.py:290:3
    |
289 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
290 | /   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 | |     the key matches the given key and the value matches the given value.
292 | |
293 | |   Args:
294 | |     nested_dict (dict): The nested dictionary to be sliced.
295 | |     key (Any): The key to be matched.
296 | |     value (Any): The value to be matched.
297 | |
298 | |   Returns:
299 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
300 | |
301 | |   """
    | |_____^
302 |     new_dict = {}
303 |     for k, v in nested_dict.items():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
  --> praxis/backend/utils/type_inspection.py:10:30
   |
10 | def fqn_from_hint(type_hint: Any) -> str:
   |                              ^^^
11 |   """Get the fully qualified name of a type hint.
   |

SIM108 Use ternary operator `actual_type = resource_types[0] if resource_types else non_none_args[0]` instead of `if`-`else`-block
  --> praxis/backend/utils/type_inspection.py:32:7
   |
30 |         # This is a heuristic. A more robust solution might require more context.
31 |         resource_types = [t for t in non_none_args if is_pylabrobot_resource(t)]
32 | /       if resource_types:
33 | |         actual_type = resource_types[0]
34 | |       else:
35 | |         actual_type = non_none_args[0]  # Fallback to the first type
   | |______________________________________^
36 |       else:  # Only NoneType in Union
37 |         return "None"
   |
help: Replace `if`-`else`-block with `actual_type = resource_types[0] if resource_types else non_none_args[0]`

D104 Missing docstring in public package
--> praxis/common/__init__.py:1:1

PLR0911 Too many return statements (8 > 6)
  --> praxis/common/type_inspection.py:15:5
   |
15 | def serialize_type_hint(type_hint: Any) -> str:
   |     ^^^^^^^^^^^^^^^^^^^
16 |     """Serialize a type hint to a string representation."""
17 |     if type_hint == inspect.Parameter.empty:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
  --> praxis/common/type_inspection.py:15:36
   |
15 | def serialize_type_hint(type_hint: Any) -> str:
   |                                    ^^^
16 |     """Serialize a type hint to a string representation."""
17 |     if type_hint == inspect.Parameter.empty:
   |

INP001 File `scripts/create_test_tables.py` is part of an implicit namespace package. Add an `__init__.py`.
--> scripts/create_test_tables.py:1:1

ANN201 Missing return type annotation for public function `create_tables`
  --> scripts/create_test_tables.py:15:11
   |
15 | async def create_tables():
   |           ^^^^^^^^^^^^^
16 |   """Create all database tables."""
17 |   database_url = "postgresql+asyncpg://test_user:test_password@localhost:5433/test_db"
   |
help: Add return type annotation: `None`

T201 `print` found
  --> scripts/create_test_tables.py:27:3
   |
26 |   await engine.dispose()
27 |   print("\n All tables created successfully!")
   |   ^^^^^
   |
help: Remove `print`

Found 565 errors (20 fixed, 545 remaining).
No fixes available (55 hidden fixes can be enabled with the `--unsafe-fixes` option).
