__version__.py:1:1: D100 Missing docstring in public module
alembic/env.py:1:1: INP001 File `alembic/env.py` is part of an implicit namespace package. Add an `__init__.py`.
alembic/env.py:1:1: D100 Missing docstring in public module
alembic/env.py:2:3: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^ TD002
3 | from logging.config import fileConfig
  |

alembic/env.py:2:3: TD003 Missing issue link on the line following this TODO
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^ TD003
3 | from logging.config import fileConfig
  |

alembic/env.py:2:3: FIX002 Line contains TODO, consider resolving the issue
  |
1 | # alembic/env.py
2 | # TODO: Remove this import if not needed
  |   ^^^^ FIX002
3 | from logging.config import fileConfig
  |

alembic/env.py:20:3: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
18 |     fileConfig(config.config_file_name)
19 | 
20 | # TODO: add your model's MetaData object here
   |   ^^^^ TD002
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

alembic/env.py:20:3: TD003 Missing issue link on the line following this TODO
   |
18 |     fileConfig(config.config_file_name)
19 | 
20 | # TODO: add your model's MetaData object here
   |   ^^^^ TD003
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

alembic/env.py:20:3: FIX002 Line contains TODO, consider resolving the issue
   |
18 |     fileConfig(config.config_file_name)
19 | 
20 | # TODO: add your model's MetaData object here
   |   ^^^^ FIX002
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   |

alembic/env.py:22:1: ERA001 Found commented-out code
   |
20 | # TODO: add your model's MetaData object here
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
23 | # target_metadata = mymodel.Base.metadata
24 | # --- MODIFICATION FOR PRAXIS ---
   |
   = help: Remove commented-out code

alembic/env.py:23:1: ERA001 Found commented-out code
   |
21 | # for 'autogenerate' support
22 | # from myapp import mymodel
23 | # target_metadata = mymodel.Base.metadata
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
24 | # --- MODIFICATION FOR PRAXIS ---
   |
   = help: Remove commented-out code

alembic/env.py:31:1: ERA001 Found commented-out code
   |
29 | # other values from the config, defined by the needs of env.py,
30 | # can be acquired:
31 | # my_important_option = config.get_main_option("my_important_option")
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
32 | # ... etc.
   |
   = help: Remove commented-out code

alembic/env.py:89:13: ERA001 Found commented-out code
   |
87 |             # --- MODIFICATION FOR PRAXIS ---
88 |             compare_type=True, # For detecting column type changes
89 |             # include_schemas=True, # If you use multiple schemas
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
90 |             # --- END MODIFICATION ---
91 |         )
   |
   = help: Remove commented-out code

docs/conf.py:1:1: INP001 File `docs/conf.py` is part of an implicit namespace package. Add an `__init__.py`.
docs/conf.py:11:20: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   |
10 | # Add the project root to the Python path
11 | sys.path.insert(0, os.path.abspath(".."))
   |                    ^^^^^^^^^^^^^^^ PTH100
12 | 
13 | # -- Project information -----------------------------------------------------
   |

docs/conf.py:15:1: A001 Variable `copyright` is shadowing a Python builtin
   |
13 | # -- Project information -----------------------------------------------------
14 | project = "PyLabPraxis"
15 | copyright = "2025, Marielle Russo"
   | ^^^^^^^^^ A001
16 | author = "Marielle Russo"
17 | release = "0.0.1"
   |

main.py:76:5: S101 Use of `assert` detected
   |
75 |     logger.info("Initializing PraxisDBService...")
76 |     assert KEYCLOAK_DSN_FROM_CONFIG, "Keycloak DSN must be configured in praxis.ini"
   |     ^^^^^^ S101
77 |     db_service_instance = await PraxisDBService.initialize(
78 |       keycloak_dsn=KEYCLOAK_DSN_FROM_CONFIG,
   |

main.py:118:66: TRY401 Redundant exception object included in `logging.exception` call
    |
117 |   except Exception as e:
118 |     logger.exception("Error during application startup: %s", str(e))
    |                                                                  ^ TRY401
119 |     # In a production scenario, you might want to exit or handle this more gracefully
120 |     raise
    |

main.py:137:69: TRY401 Redundant exception object included in `logging.exception` call
    |
135 |       logger.info("Application shutdown complete.")
136 |     except Exception as e:
137 |       logger.exception("Error during application shutdown: %s", str(e))
    |                                                                     ^ TRY401
    |

main.py:153:33: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
151 |   allow_origins=[
152 |     "http://localhost:5173",
153 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^ TD002
154 |   ],
155 |   allow_credentials=True,
    |

main.py:153:33: TD003 Missing issue link on the line following this TODO
    |
151 |   allow_origins=[
152 |     "http://localhost:5173",
153 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^ TD003
154 |   ],
155 |   allow_credentials=True,
    |

main.py:153:33: FIX002 Line contains TODO, consider resolving the issue
    |
151 |   allow_origins=[
152 |     "http://localhost:5173",
153 |     "http://localhost:4200",  # TODO: ensure this is the correct URL for your frontend
    |                                 ^^^^ FIX002
154 |   ],
155 |   allow_credentials=True,
    |

main.py:173:42: ANN001 Missing type annotation for function argument `call_next`
    |
172 | @app.middleware("http")
173 | async def log_requests(request: Request, call_next) -> Response:
    |                                          ^^^^^^^^^ ANN001
174 |   """Middleware to log incoming requests and their response status codes."""
175 |   logger.info("Request: %s %s", request.method, request.url.path)
    |

main.py:187:11: ANN201 Missing return type annotation for public function `root_redirect`
    |
186 | @app.get("/", include_in_schema=False)
187 | async def root_redirect():
    |           ^^^^^^^^^^^^^ ANN201
188 |   """Redirects the root URL to the static index page."""
189 |   return RedirectResponse(url="/docs")
    |
    = help: Add return type annotation

praxis/backend/__init__.py:2:15: F401 `.configure` imported but unused; consider removing, adding to `__all__`, or using a redundant alias
  |
1 | """Praxis Backend Package."""
2 | from . import configure
  |               ^^^^^^^^^ F401
  |
  = help: Use an explicit re-export: `configure as configure`

praxis/backend/api/decks.py:209:1: SyntaxError: Expected an indented block after function definition
    |
209 | @log_deck_api_errors(
    | ^
210 |   exception_type=HTTPException,
211 |   raises=True,
    |

praxis/backend/api/dependencies.py:1:1: D100 Missing docstring in public module
praxis/backend/api/function_data_outputs.py:1:1: ERA001 Found commented-out code
  |
1 | # filepath: praxis/backend/api/function_data_outputs.py
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
2 | #
3 | # This file contains the FastAPI router for all function data output endpoints,
  |
  = help: Remove commented-out code

praxis/backend/api/function_data_outputs.py:1:1: D100 Missing docstring in public module
praxis/backend/api/function_data_outputs.py:59:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
57 | async def create_function_data_output(
58 |     data_output: FunctionDataOutputCreate,
59 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^ B008
60 | ) -> FunctionDataOutputResponse:
61 |     """Create a new function data output."""
   |

praxis/backend/api/function_data_outputs.py:79:42: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
77 | )
78 | async def list_function_data_outputs(
79 |     filters: FunctionDataOutputFilters = Depends(),
   |                                          ^^^^^^^^^ B008
80 |     db: AsyncSession = Depends(get_db),
81 | ) -> list[FunctionDataOutputResponse]:
   |

praxis/backend/api/function_data_outputs.py:80:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
78 | async def list_function_data_outputs(
79 |     filters: FunctionDataOutputFilters = Depends(),
80 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^ B008
81 | ) -> list[FunctionDataOutputResponse]:
82 |     """Get function data outputs with optional filtering."""
   |

praxis/backend/api/function_data_outputs.py:107:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
105 | async def read_function_data_output(
106 |     output_id: UUID,
107 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
108 | ) -> FunctionDataOutputResponse:
109 |     """Get a specific function data output by ID."""
    |

praxis/backend/api/function_data_outputs.py:132:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
130 |     output_id: UUID,
131 |     data_output: FunctionDataOutputUpdate,
132 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
133 | ) -> FunctionDataOutputResponse:
134 |     """Update a function data output."""
    |

praxis/backend/api/function_data_outputs.py:156:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
154 | async def delete_function_data_output(
155 |     output_id: UUID,
156 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
157 | ) -> None:
158 |     """Delete a function data output."""
    |

praxis/backend/api/function_data_outputs.py:181:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
179 | async def create_well_data_output(
180 |     well_data_output: WellDataOutputCreate,
181 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
182 | ) -> WellDataOutputResponse:
183 |     """Create a new well data output."""
    |

praxis/backend/api/function_data_outputs.py:199:38: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
197 | )
198 | async def read_well_data_outputs(
199 |     filters: WellDataOutputFilters = Depends(),
    |                                      ^^^^^^^^^ B008
200 |     db: AsyncSession = Depends(get_db),
201 | ) -> list[WellDataOutputResponse]:
    |

praxis/backend/api/function_data_outputs.py:200:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
198 | async def read_well_data_outputs(
199 |     filters: WellDataOutputFilters = Depends(),
200 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
201 | ) -> list[WellDataOutputResponse]:
202 |     """Get well data outputs with optional filtering."""
    |

praxis/backend/api/function_data_outputs.py:229:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
227 | async def read_well_data_output(
228 |     output_id: UUID,
229 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
230 | ) -> WellDataOutputResponse:
231 |     """Get a specific well data output by ID."""
    |

praxis/backend/api/function_data_outputs.py:254:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
252 |     output_id: UUID,
253 |     well_data_output: WellDataOutputUpdate,
254 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
255 | ) -> WellDataOutputResponse:
256 |     """Update a well data output."""
    |

praxis/backend/api/function_data_outputs.py:278:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
276 | async def delete_well_data_output(
277 |     output_id: UUID,
278 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
279 | ) -> None:
280 |     """Delete a well data output."""
    |

praxis/backend/api/function_data_outputs.py:302:44: B008 Do not perform function call `Query` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
300 | async def read_plate_visualization_data(
301 |     plate_resource_id: UUID,
302 |     data_type: DataOutputTypeEnum | None = Query(None),
    |                                            ^^^^^^^^^^^ B008
303 |     function_call_id: UUID | None = Query(None),
304 |     protocol_run_id: UUID | None = Query(None),
    |

praxis/backend/api/function_data_outputs.py:303:37: B008 Do not perform function call `Query` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
301 |     plate_resource_id: UUID,
302 |     data_type: DataOutputTypeEnum | None = Query(None),
303 |     function_call_id: UUID | None = Query(None),
    |                                     ^^^^^^^^^^^ B008
304 |     protocol_run_id: UUID | None = Query(None),
305 |     db: AsyncSession = Depends(get_db),
    |

praxis/backend/api/function_data_outputs.py:304:36: B008 Do not perform function call `Query` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
302 |     data_type: DataOutputTypeEnum | None = Query(None),
303 |     function_call_id: UUID | None = Query(None),
304 |     protocol_run_id: UUID | None = Query(None),
    |                                    ^^^^^^^^^^^ B008
305 |     db: AsyncSession = Depends(get_db),
306 | ) -> PlateDataVisualization:
    |

praxis/backend/api/function_data_outputs.py:305:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
303 |     function_call_id: UUID | None = Query(None),
304 |     protocol_run_id: UUID | None = Query(None),
305 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
306 | ) -> PlateDataVisualization:
307 |     """Get plate visualization data for a specific plate resource."""
    |

praxis/backend/api/global_dependencies.py:21:9: ANN204 Missing return type annotation for special method `__init__`
   |
19 |     """A class to hold global dependencies."""
20 | 
21 |     def __init__(self):
   |         ^^^^^^^^ ANN204
22 |         self.scheduler: ProtocolScheduler | None = None
23 |         self.asset_lock_manager: AssetLockManager | None = None
   |
   = help: Add return type annotation: `None`

praxis/backend/api/global_dependencies.py:21:9: D107 Missing docstring in `__init__`
   |
19 |     """A class to hold global dependencies."""
20 | 
21 |     def __init__(self):
   |         ^^^^^^^^ D107
22 |         self.scheduler: ProtocolScheduler | None = None
23 |         self.asset_lock_manager: AssetLockManager | None = None
   |

praxis/backend/api/global_dependencies.py:25:15: ANN201 Missing return type annotation for public function `initialize`
   |
23 |         self.asset_lock_manager: AssetLockManager | None = None
24 | 
25 |     async def initialize(
   |               ^^^^^^^^^^ ANN201
26 |         self,
27 |         db_session_factory,
   |
   = help: Add return type annotation: `None`

praxis/backend/api/global_dependencies.py:27:9: ANN001 Missing type annotation for function argument `db_session_factory`
   |
25 |     async def initialize(
26 |         self,
27 |         db_session_factory,
   |         ^^^^^^^^^^^^^^^^^^ ANN001
28 |         config: PraxisConfiguration = PraxisConfiguration(),
29 |     ):
   |

praxis/backend/api/global_dependencies.py:28:39: B008 Do not perform function call `PraxisConfiguration` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
26 |         self,
27 |         db_session_factory,
28 |         config: PraxisConfiguration = PraxisConfiguration(),
   |                                       ^^^^^^^^^^^^^^^^^^^^^ B008
29 |     ):
30 |         """Initialize global scheduler components."""
   |

praxis/backend/api/global_dependencies.py:49:15: TRY003 Avoid specifying long messages outside the exception class
   |
47 |     """Get the global scheduler instance."""
48 |     if dependencies.scheduler is None:
49 |         raise RuntimeError("Scheduler not initialized")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
50 |     return dependencies.scheduler
   |

praxis/backend/api/global_dependencies.py:49:28: EM101 Exception must not use a string literal, assign to variable first
   |
47 |     """Get the global scheduler instance."""
48 |     if dependencies.scheduler is None:
49 |         raise RuntimeError("Scheduler not initialized")
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
50 |     return dependencies.scheduler
   |
   = help: Assign to variable; remove string literal

praxis/backend/api/global_dependencies.py:56:15: TRY003 Avoid specifying long messages outside the exception class
   |
54 |     """Get the global asset manager instance."""
55 |     if dependencies.asset_lock_manager is None:
56 |         raise RuntimeError("Asset manager not initialized")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
57 |     return dependencies.asset_lock_manager
   |

praxis/backend/api/global_dependencies.py:56:28: EM101 Exception must not use a string literal, assign to variable first
   |
54 |     """Get the global asset manager instance."""
55 |     if dependencies.asset_lock_manager is None:
56 |         raise RuntimeError("Asset manager not initialized")
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
57 |     return dependencies.asset_lock_manager
   |
   = help: Assign to variable; remove string literal

praxis/backend/api/machines.py:61:11: ANN201 Missing return type annotation for public function `create_machine`
   |
59 |   tags=["Machines"],
60 | )
61 | async def create_machine(machine: MachineCreate, db: AsyncSession = Depends(get_db)):
   |           ^^^^^^^^^^^^^^ ANN201
62 |   """Create a new machine."""
63 |   try:
   |
   = help: Add return type annotation

praxis/backend/api/machines.py:61:69: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
59 |   tags=["Machines"],
60 | )
61 | async def create_machine(machine: MachineCreate, db: AsyncSession = Depends(get_db)):
   |                                                                     ^^^^^^^^^^^^^^^ B008
62 |   """Create a new machine."""
63 |   try:
   |

praxis/backend/api/machines.py:65:5: TRY300 Consider moving this statement to an `else` block
   |
63 |   try:
64 |     created_machine = await machine_service.create(db=db, obj_in=machine)
65 |     return created_machine
   |     ^^^^^^^^^^^^^^^^^^^^^^ TRY300
66 |   except ValueError as e:
67 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |

praxis/backend/api/machines.py:65:12: RET504 Unnecessary assignment to `created_machine` before `return` statement
   |
63 |   try:
64 |     created_machine = await machine_service.create(db=db, obj_in=machine)
65 |     return created_machine
   |            ^^^^^^^^^^^^^^^ RET504
66 |   except ValueError as e:
67 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |
   = help: Remove unnecessary assignment

praxis/backend/api/machines.py:67:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
65 |     return created_machine
66 |   except ValueError as e:
67 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
   |

praxis/backend/api/machines.py:81:11: ANN201 Missing return type annotation for public function `get_machine`
   |
79 |   tags=["Machines"],
80 | )
81 | async def get_machine(accession: str, db: AsyncSession = Depends(get_db)):
   |           ^^^^^^^^^^^ ANN201
82 |   """Retrieve a machine by accession ID or name."""
83 |   machine_id = await machine_accession_resolver(db=db, accession=accession)
   |
   = help: Add return type annotation

praxis/backend/api/machines.py:81:58: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
79 |   tags=["Machines"],
80 | )
81 | async def get_machine(accession: str, db: AsyncSession = Depends(get_db)):
   |                                                          ^^^^^^^^^^^^^^^ B008
82 |   """Retrieve a machine by accession ID or name."""
83 |   machine_id = await machine_accession_resolver(db=db, accession=accession)
   |

praxis/backend/api/machines.py:102:11: ANN201 Missing return type annotation for public function `list_machines`
    |
100 |   tags=["Machines"],
101 | )
102 | async def list_machines(
    |           ^^^^^^^^^^^^^ ANN201
103 |   db: AsyncSession = Depends(get_db),
104 |   filters: SearchFilters = Depends(),
    |
    = help: Add return type annotation

praxis/backend/api/machines.py:103:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
101 | )
102 | async def list_machines(
103 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
104 |   filters: SearchFilters = Depends(),
105 |   status: MachineStatusEnum | None = None,
    |

praxis/backend/api/machines.py:104:28: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
102 | async def list_machines(
103 |   db: AsyncSession = Depends(get_db),
104 |   filters: SearchFilters = Depends(),
    |                            ^^^^^^^^^ B008
105 |   status: MachineStatusEnum | None = None,
106 |   pylabrobot_class_filter: str | None = None,
    |

praxis/backend/api/machines.py:130:11: ANN201 Missing return type annotation for public function `update_machine`
    |
128 |   tags=["Machines"],
129 | )
130 | async def update_machine(
    |           ^^^^^^^^^^^^^^ ANN201
131 |   accession: str,
132 |   machine_update: MachineUpdate,
    |
    = help: Add return type annotation

praxis/backend/api/machines.py:133:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
131 |   accession: str,
132 |   machine_update: MachineUpdate,
133 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
134 | ):
135 |   """Update an existing machine."""
    |

praxis/backend/api/machines.py:145:5: TRY300 Consider moving this statement to an `else` block
    |
143 |       db=db, db_obj=db_obj, obj_in=machine_update,
144 |     )
145 |     return updated_machine
    |     ^^^^^^^^^^^^^^^^^^^^^^ TRY300
146 |   except ValueError as e:
147 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/machines.py:145:12: RET504 Unnecessary assignment to `updated_machine` before `return` statement
    |
143 |       db=db, db_obj=db_obj, obj_in=machine_update,
144 |     )
145 |     return updated_machine
    |            ^^^^^^^^^^^^^^^ RET504
146 |   except ValueError as e:
147 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |
    = help: Remove unnecessary assignment

praxis/backend/api/machines.py:147:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
145 |     return updated_machine
146 |   except ValueError as e:
147 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/machines.py:161:11: ANN201 Missing return type annotation for public function `update_machine_status`
    |
159 |   tags=["Machines"],
160 | )
161 | async def update_machine_status(
    |           ^^^^^^^^^^^^^^^^^^^^^ ANN201
162 |   accession: str,
163 |   new_status: MachineStatusEnum,
    |
    = help: Add return type annotation

praxis/backend/api/machines.py:166:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
164 |   status_details: str | None = None,
165 |   current_protocol_run_accession_id: UUID | None = None,
166 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
167 | ):
168 |   """Update the status of a machine."""
    |

praxis/backend/api/machines.py:181:5: TRY300 Consider moving this statement to an `else` block
    |
179 |     if not updated_machine:
180 |       raise HTTPException(status_code=404, detail=f"Machine '{accession}' not found.")
181 |     return updated_machine
    |     ^^^^^^^^^^^^^^^^^^^^^^ TRY300
182 |   except ValueError as e:
183 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/machines.py:183:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
181 |     return updated_machine
182 |   except ValueError as e:
183 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/machines.py:197:11: ANN201 Missing return type annotation for public function `delete_machine`
    |
195 |   tags=["Machines"],
196 | )
197 | async def delete_machine(accession: str, db: AsyncSession = Depends(get_db)):
    |           ^^^^^^^^^^^^^^ ANN201
198 |   """Delete a machine."""
199 |   machine_id = await machine_accession_resolver(db=db, accession=accession)
    |
    = help: Add return type annotation: `None`

praxis/backend/api/machines.py:197:61: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
195 |   tags=["Machines"],
196 | )
197 | async def delete_machine(accession: str, db: AsyncSession = Depends(get_db)):
    |                                                             ^^^^^^^^^^^^^^^ B008
198 |   """Delete a machine."""
199 |   machine_id = await machine_accession_resolver(db=db, accession=accession)
    |

praxis/backend/api/protocols.py:71:11: ANN201 Missing return type annotation for public function `list_protocol_definitions`
   |
69 |   tags=["Protocol Definitions"],
70 | )
71 | async def list_protocol_definitions(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
72 |   filters: ProtocolDefinitionFilters = Depends(),
73 |   db: AsyncSession = Depends(get_db),
   |
   = help: Add return type annotation

praxis/backend/api/protocols.py:72:40: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
70 | )
71 | async def list_protocol_definitions(
72 |   filters: ProtocolDefinitionFilters = Depends(),
   |                                        ^^^^^^^^^ B008
73 |   db: AsyncSession = Depends(get_db),
74 | ):
   |

praxis/backend/api/protocols.py:73:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
71 | async def list_protocol_definitions(
72 |   filters: ProtocolDefinitionFilters = Depends(),
73 |   db: AsyncSession = Depends(get_db),
   |                      ^^^^^^^^^^^^^^^ B008
74 | ):
75 |   """List all available protocol definitions."""
   |

praxis/backend/api/protocols.py:98:11: ANN201 Missing return type annotation for public function `get_protocol_definition`
    |
 96 |   tags=["Protocol Definitions"],
 97 | )
 98 | async def get_protocol_definition(accession: str, db: AsyncSession = Depends(get_db)):
    |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 99 |   """Retrieve a protocol definition by accession ID or name."""
100 |   definition_id = await protocol_definition_accession_resolver(
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:98:70: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
 96 |   tags=["Protocol Definitions"],
 97 | )
 98 | async def get_protocol_definition(accession: str, db: AsyncSession = Depends(get_db)):
    |                                                                      ^^^^^^^^^^^^^^^ B008
 99 |   """Retrieve a protocol definition by accession ID or name."""
100 |   definition_id = await protocol_definition_accession_resolver(
    |

praxis/backend/api/protocols.py:123:11: ANN201 Missing return type annotation for public function `get_protocol_definition_details`
    |
121 |   tags=["Protocol Definitions"],
122 | )
123 | async def get_protocol_definition_details(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
124 |   name: str,
125 |   db: AsyncSession = Depends(get_db),
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:125:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
123 | async def get_protocol_definition_details(
124 |   name: str,
125 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
126 |   version: str | None = None,
127 |   source_name: str | None = None,
    |

praxis/backend/api/protocols.py:154:11: ANN201 Missing return type annotation for public function `create_protocol_run`
    |
152 |   tags=["Protocol Runs"],
153 | )
154 | async def create_protocol_run(
    |           ^^^^^^^^^^^^^^^^^^^ ANN201
155 |   protocol_start: ProtocolStartRequest, db: AsyncSession = Depends(get_db),
156 | ):
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:155:60: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
153 | )
154 | async def create_protocol_run(
155 |   protocol_start: ProtocolStartRequest, db: AsyncSession = Depends(get_db),
    |                                                            ^^^^^^^^^^^^^^^ B008
156 | ):
157 |   """Create a new protocol run."""
    |

praxis/backend/api/protocols.py:170:5: TRY300 Consider moving this statement to an `else` block
    |
168 |       obj_in=protocol_start,
169 |     )
170 |     return created_run
    |     ^^^^^^^^^^^^^^^^^^ TRY300
171 |   except ValueError as e:
172 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/protocols.py:170:12: RET504 Unnecessary assignment to `created_run` before `return` statement
    |
168 |       obj_in=protocol_start,
169 |     )
170 |     return created_run
    |            ^^^^^^^^^^^ RET504
171 |   except ValueError as e:
172 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |
    = help: Remove unnecessary assignment

praxis/backend/api/protocols.py:172:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
170 |     return created_run
171 |   except ValueError as e:
172 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/protocols.py:186:11: ANN201 Missing return type annotation for public function `list_protocol_runs`
    |
184 |   tags=["Protocol Runs"],
185 | )
186 | async def list_protocol_runs(
    |           ^^^^^^^^^^^^^^^^^^ ANN201
187 |   db: AsyncSession = Depends(get_db),
188 |   filters: SearchFilters = Depends(),
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:187:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
185 | )
186 | async def list_protocol_runs(
187 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
188 |   filters: SearchFilters = Depends(),
189 |   protocol_definition_accession_id: UUID | None = None,
    |

praxis/backend/api/protocols.py:188:12: F821 Undefined name `SearchFilters`
    |
186 | async def list_protocol_runs(
187 |   db: AsyncSession = Depends(get_db),
188 |   filters: SearchFilters = Depends(),
    |            ^^^^^^^^^^^^^ F821
189 |   protocol_definition_accession_id: UUID | None = None,
190 |   protocol_name: str | None = None,
    |

praxis/backend/api/protocols.py:188:28: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
186 | async def list_protocol_runs(
187 |   db: AsyncSession = Depends(get_db),
188 |   filters: SearchFilters = Depends(),
    |                            ^^^^^^^^^ B008
189 |   protocol_definition_accession_id: UUID | None = None,
190 |   protocol_name: str | None = None,
    |

praxis/backend/api/protocols.py:214:11: ANN201 Missing return type annotation for public function `get_protocol_run`
    |
212 |   tags=["Protocol Runs"],
213 | )
214 | async def get_protocol_run(accession: str, db: AsyncSession = Depends(get_db)):
    |           ^^^^^^^^^^^^^^^^ ANN201
215 |   """Retrieve a protocol run by accession ID or name."""
216 |   run_id = await protocol_run_accession_resolver(db=db, accession=accession)
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:214:63: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
212 |   tags=["Protocol Runs"],
213 | )
214 | async def get_protocol_run(accession: str, db: AsyncSession = Depends(get_db)):
    |                                                               ^^^^^^^^^^^^^^^ B008
215 |   """Retrieve a protocol run by accession ID or name."""
216 |   run_id = await protocol_run_accession_resolver(db=db, accession=accession)
    |

praxis/backend/api/protocols.py:235:11: ANN201 Missing return type annotation for public function `update_protocol_run_status`
    |
233 |   tags=["Protocol Runs"],
234 | )
235 | async def update_protocol_run_status(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
236 |   accession: str,
237 |   new_status: ProtocolRunStatusEnum,
    |
    = help: Add return type annotation

praxis/backend/api/protocols.py:240:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
238 |   output_data_json: str | None = None,
239 |   final_state_json: str | None = None,
240 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
241 | ):
242 |   """Update the status of a protocol run."""
    |

praxis/backend/api/protocols.py:257:5: TRY300 Consider moving this statement to an `else` block
    |
255 |         status_code=404, detail=f"Protocol run '{accession}' not found.",
256 |       )
257 |     return updated_run
    |     ^^^^^^^^^^^^^^^^^^ TRY300
258 |   except ValueError as e:
259 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/protocols.py:259:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
257 |     return updated_run
258 |   except ValueError as e:
259 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/resources.py:64:11: ANN201 Missing return type annotation for public function `create_resource_definition_endpoint`
   |
62 |     tags=["Resource Definitions"],
63 | )
64 | async def create_resource_definition_endpoint(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
65 |     definition: ResourceDefinitionCreate,
66 |     db: AsyncSession = Depends(get_db),
   |
   = help: Add return type annotation

praxis/backend/api/resources.py:66:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
64 | async def create_resource_definition_endpoint(
65 |     definition: ResourceDefinitionCreate,
66 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^ B008
67 | ):
68 |     """Create a new resource definition in the catalog."""
   |

praxis/backend/api/resources.py:74:9: TRY300 Consider moving this statement to an `else` block
   |
72 |             obj_in=definition,
73 |         )
74 |         return created_def
   |         ^^^^^^^^^^^^^^^^^^ TRY300
75 |     except ValueError as e:
76 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |

praxis/backend/api/resources.py:74:16: RET504 Unnecessary assignment to `created_def` before `return` statement
   |
72 |             obj_in=definition,
73 |         )
74 |         return created_def
   |                ^^^^^^^^^^^ RET504
75 |     except ValueError as e:
76 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |
   = help: Remove unnecessary assignment

praxis/backend/api/resources.py:76:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
74 |         return created_def
75 |     except ValueError as e:
76 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
   |

praxis/backend/api/resources.py:90:11: ANN201 Missing return type annotation for public function `read_resource_definition_endpoint`
   |
88 |     tags=["Resource Definitions"],
89 | )
90 | async def read_resource_definition_endpoint(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
91 |     name: str,
92 |     db: AsyncSession = Depends(get_db),
   |
   = help: Add return type annotation

praxis/backend/api/resources.py:92:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
90 | async def read_resource_definition_endpoint(
91 |     name: str,
92 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^ B008
93 | ):
94 |     """Retrieve a resource definition by name."""
   |

praxis/backend/api/resources.py:112:11: ANN201 Missing return type annotation for public function `read_resource_definitions_endpoint`
    |
110 |     tags=["Resource Definitions"],
111 | )
112 | async def read_resource_definitions_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
113 |     db: AsyncSession = Depends(get_db),
114 |     limit: int = 100,
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:113:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
111 | )
112 | async def read_resource_definitions_endpoint(
113 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
114 |     limit: int = 100,
115 |     offset: int = 0,
    |

praxis/backend/api/resources.py:135:11: ANN201 Missing return type annotation for public function `update_resource_definition_endpoint`
    |
133 |     tags=["Resource Definitions"],
134 | )
135 | async def update_resource_definition_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
136 |     name: str,
137 |     definition_update: ResourceDefinitionUpdate,
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:138:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
136 |     name: str,
137 |     definition_update: ResourceDefinitionUpdate,
138 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
139 | ):
140 |     """Update an existing resource definition."""
    |

praxis/backend/api/resources.py:153:9: TRY300 Consider moving this statement to an `else` block
    |
151 |             obj_in=definition_update,
152 |         )
153 |         return updated_def
    |         ^^^^^^^^^^^^^^^^^^ TRY300
154 |     except ValueError as e:
155 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/resources.py:153:16: RET504 Unnecessary assignment to `updated_def` before `return` statement
    |
151 |             obj_in=definition_update,
152 |         )
153 |         return updated_def
    |                ^^^^^^^^^^^ RET504
154 |     except ValueError as e:
155 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |
    = help: Remove unnecessary assignment

praxis/backend/api/resources.py:155:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
153 |         return updated_def
154 |     except ValueError as e:
155 |         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/resources.py:169:11: ANN201 Missing return type annotation for public function `delete_resource_definition_endpoint`
    |
167 |     tags=["Resource Definitions"],
168 | )
169 | async def delete_resource_definition_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
170 |     name: str,
171 |     db: AsyncSession = Depends(get_db),
    |
    = help: Add return type annotation: `None`

praxis/backend/api/resources.py:171:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
169 | async def delete_resource_definition_endpoint(
170 |     name: str,
171 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
172 | ):
173 |     """Delete a resource definition."""
    |

praxis/backend/api/resources.py:203:11: ANN201 Missing return type annotation for public function `create_resource_endpoint`
    |
201 |     tags=["Resources"],
202 | )
203 | async def create_resource_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
204 |     request: ResourceCreate,
205 |     db: AsyncSession = Depends(get_db),
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:205:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
203 | async def create_resource_endpoint(
204 |     request: ResourceCreate,
205 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
206 | ):
207 |     """Create a new resource."""
    |

praxis/backend/api/resources.py:216:17: TRY301 Abstract `raise` to an inner function
    |
214 |               )
215 |               if not definition_orm:
216 |                   raise HTTPException(
    |  _________________^
217 | |                     status_code=404,
218 | |                     detail=f"Resource definition with FQN '{request.fqn}' not found.",
219 | |                 )
    | |_________________^ TRY301
220 |               request.resource_definition_accession_id = definition_orm.accession_id
221 |           resource_orm = await resource_service.create(
    |

praxis/backend/api/resources.py:226:12: BLE001 Do not catch blind exception: `Exception`
    |
224 |         )
225 |         return ResourceResponse.model_validate(resource_orm)
226 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
227 |         raise HTTPException(status_code=500, detail=f"Failed to create resource: {e!s}")
    |

praxis/backend/api/resources.py:227:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
225 |         return ResourceResponse.model_validate(resource_orm)
226 |     except Exception as e:
227 |         raise HTTPException(status_code=500, detail=f"Failed to create resource: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/resources.py:241:11: ANN201 Missing return type annotation for public function `read_resources_endpoint`
    |
239 |     tags=["Resources"],
240 | )
241 | async def read_resources_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
242 |     db: AsyncSession = Depends(get_db),
243 |     filters: SearchFilters = Depends(),
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:242:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
240 | )
241 | async def read_resources_endpoint(
242 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
243 |     filters: SearchFilters = Depends(),
244 | ):
    |

praxis/backend/api/resources.py:243:30: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
241 | async def read_resources_endpoint(
242 |     db: AsyncSession = Depends(get_db),
243 |     filters: SearchFilters = Depends(),
    |                              ^^^^^^^^^ B008
244 | ):
245 |     """List all resources."""
    |

praxis/backend/api/resources.py:261:11: ANN201 Missing return type annotation for public function `read_resource_endpoint`
    |
259 |     tags=["Resources"],
260 | )
261 | async def read_resource_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^ ANN201
262 |     accession: str | UUID,
263 |     db: AsyncSession = Depends(get_db),
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:263:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
261 | async def read_resource_endpoint(
262 |     accession: str | UUID,
263 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
264 | ):
265 |     """Retrieve a resource."""
    |

praxis/backend/api/resources.py:270:13: TRY301 Abstract `raise` to an inner function
    |
268 |         resource = await resource_service.get(db, id=accession_id)
269 |         if not resource:
270 |             raise HTTPException(status_code=404, detail="Resource not found")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
271 |         return ResourceResponse.model_validate(resource)
272 |     except Exception as e:
    |

praxis/backend/api/resources.py:272:12: BLE001 Do not catch blind exception: `Exception`
    |
270 |             raise HTTPException(status_code=404, detail="Resource not found")
271 |         return ResourceResponse.model_validate(resource)
272 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
273 |         raise HTTPException(status_code=500, detail=f"Failed to get resource: {e!s}")
    |

praxis/backend/api/resources.py:273:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
271 |         return ResourceResponse.model_validate(resource)
272 |     except Exception as e:
273 |         raise HTTPException(status_code=500, detail=f"Failed to get resource: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/resources.py:287:11: ANN201 Missing return type annotation for public function `update_resource_endpoint`
    |
285 |     tags=["Resources"],
286 | )
287 | async def update_resource_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
288 |     accession: str | UUID,
289 |     request: ResourceUpdate,
    |
    = help: Add return type annotation

praxis/backend/api/resources.py:290:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
288 |     accession: str | UUID,
289 |     request: ResourceUpdate,
290 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
291 | ):
292 |     """Update an existing resource."""
    |

praxis/backend/api/resources.py:297:13: TRY301 Abstract `raise` to an inner function
    |
295 |         resource = await resource_service.get(db, id=accession_id)
296 |         if resource is None:
297 |             raise HTTPException(status_code=404, detail="Resource not found")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
298 |         updated_resource = await resource_service.update(
299 |             db=db,
    |

praxis/backend/api/resources.py:305:12: BLE001 Do not catch blind exception: `Exception`
    |
303 |         return ResourceResponse.model_validate(updated_resource)
304 | 
305 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
306 |         raise HTTPException(status_code=500, detail=f"Failed to update resource: {e!s}")
    |

praxis/backend/api/resources.py:306:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
305 |     except Exception as e:
306 |         raise HTTPException(status_code=500, detail=f"Failed to update resource: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/resources.py:320:11: ANN201 Missing return type annotation for public function `delete_resource_endpoint`
    |
318 |     tags=["Resources"],
319 | )
320 | async def delete_resource_endpoint(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
321 |     accession: str | UUID,
322 |     db: AsyncSession = Depends(get_db),
    |
    = help: Add return type annotation: `None`

praxis/backend/api/resources.py:322:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
320 | async def delete_resource_endpoint(
321 |     accession: str | UUID,
322 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
323 | ):
324 |     """Delete a resource by name or ID."""
    |

praxis/backend/api/resources.py:329:13: TRY301 Abstract `raise` to an inner function
    |
327 |         resource = await resource_service.get(db, id=accession_id)
328 |         if not resource:
329 |             raise HTTPException(status_code=404, detail="Resource not found")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
330 |         success = await resource_service.remove(db, id=resource.accession_id)
331 |         if not success:
    |

praxis/backend/api/resources.py:332:13: TRY301 Abstract `raise` to an inner function
    |
330 |         success = await resource_service.remove(db, id=resource.accession_id)
331 |         if not success:
332 |             raise HTTPException(status_code=404, detail="Resource not found")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
333 |         return
334 |     except Exception as e:
    |

praxis/backend/api/resources.py:333:9: TRY300 Consider moving this statement to an `else` block
    |
331 |         if not success:
332 |             raise HTTPException(status_code=404, detail="Resource not found")
333 |         return
    |         ^^^^^^ TRY300
334 |     except Exception as e:
335 |         raise HTTPException(status_code=500, detail=f"Failed to delete resource: {e!s}")
    |

praxis/backend/api/resources.py:334:12: BLE001 Do not catch blind exception: `Exception`
    |
332 |             raise HTTPException(status_code=404, detail="Resource not found")
333 |         return
334 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
335 |         raise HTTPException(status_code=500, detail=f"Failed to delete resource: {e!s}")
    |

praxis/backend/api/resources.py:335:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
333 |         return
334 |     except Exception as e:
335 |         raise HTTPException(status_code=500, detail=f"Failed to delete resource: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/scheduler_api.py:49:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
47 | async def schedule_protocol(
48 |     request: ScheduleProtocolRequest,
49 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^ B008
50 |     scheduler: ProtocolScheduler = Depends(get_scheduler),
51 | ) -> ScheduleEntryResponse:
   |

praxis/backend/api/scheduler_api.py:50:36: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
48 |     request: ScheduleProtocolRequest,
49 |     db: AsyncSession = Depends(get_db),
50 |     scheduler: ProtocolScheduler = Depends(get_scheduler),
   |                                    ^^^^^^^^^^^^^^^^^^^^^^ B008
51 | ) -> ScheduleEntryResponse:
52 |     """Schedule a protocol run for execution.
   |

praxis/backend/api/scheduler_api.py:109:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
107 | async def get_schedule_status(
108 |     schedule_id: uuid.UUID,
109 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
110 | ) -> ScheduleStatusResponse:
111 |     """Get the current status of a scheduled protocol run."""
    |

praxis/backend/api/scheduler_api.py:139:11: TD003 Missing issue link on the line following this TODO
    |
137 |     queue_position = None
138 |     if schedule_entry.status == ScheduleStatusEnum.QUEUED:
139 |         # TODO(marielle): Add scheduler service method or include in model to get queue position
    |           ^^^^ TD003
140 |         # queued_before = await scheduler_svc.get_queue_position(db, schedule_id)
141 |         # queue_position = queued_before + 1
    |

praxis/backend/api/scheduler_api.py:139:11: FIX002 Line contains TODO, consider resolving the issue
    |
137 |     queue_position = None
138 |     if schedule_entry.status == ScheduleStatusEnum.QUEUED:
139 |         # TODO(marielle): Add scheduler service method or include in model to get queue position
    |           ^^^^ FIX002
140 |         # queued_before = await scheduler_svc.get_queue_position(db, schedule_id)
141 |         # queue_position = queued_before + 1
    |

praxis/backend/api/scheduler_api.py:140:9: ERA001 Found commented-out code
    |
138 |     if schedule_entry.status == ScheduleStatusEnum.QUEUED:
139 |         # TODO(marielle): Add scheduler service method or include in model to get queue position
140 |         # queued_before = await scheduler_svc.get_queue_position(db, schedule_id)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
141 |         # queue_position = queued_before + 1
142 |         queue_position = None  # Placeholder until service method is implemented
    |
    = help: Remove commented-out code

praxis/backend/api/scheduler_api.py:141:9: ERA001 Found commented-out code
    |
139 |         # TODO(marielle): Add scheduler service method or include in model to get queue position
140 |         # queued_before = await scheduler_svc.get_queue_position(db, schedule_id)
141 |         # queue_position = queued_before + 1
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
142 |         queue_position = None  # Placeholder until service method is implemented
    |
    = help: Remove commented-out code

praxis/backend/api/scheduler_api.py:149:39: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
147 |         protocol_version=protocol_version,
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
    |                                       ^^^^ TD002
150 |         resource_availability=None,  # TODO: Get from asset manager
151 |     )
    |

praxis/backend/api/scheduler_api.py:149:39: TD003 Missing issue link on the line following this TODO
    |
147 |         protocol_version=protocol_version,
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
    |                                       ^^^^ TD003
150 |         resource_availability=None,  # TODO: Get from asset manager
151 |     )
    |

praxis/backend/api/scheduler_api.py:149:39: FIX002 Line contains TODO, consider resolving the issue
    |
147 |         protocol_version=protocol_version,
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
    |                                       ^^^^ FIX002
150 |         resource_availability=None,  # TODO: Get from asset manager
151 |     )
    |

praxis/backend/api/scheduler_api.py:150:40: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
150 |         resource_availability=None,  # TODO: Get from asset manager
    |                                        ^^^^ TD002
151 |     )
    |

praxis/backend/api/scheduler_api.py:150:40: TD003 Missing issue link on the line following this TODO
    |
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
150 |         resource_availability=None,  # TODO: Get from asset manager
    |                                        ^^^^ TD003
151 |     )
    |

praxis/backend/api/scheduler_api.py:150:40: FIX002 Line contains TODO, consider resolving the issue
    |
148 |         queue_position=queue_position,
149 |         estimated_start_time=None,  # TODO: Calculate based on queue
150 |         resource_availability=None,  # TODO: Get from asset manager
    |                                        ^^^^ FIX002
151 |     )
    |

praxis/backend/api/scheduler_api.py:159:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
157 |     schedule_id: uuid.UUID,
158 |     request: CancelScheduleRequest,
159 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
160 |     scheduler: ProtocolScheduler = Depends(get_scheduler),
161 | ) -> ScheduleEntryResponse:
    |

praxis/backend/api/scheduler_api.py:160:36: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
158 |     request: CancelScheduleRequest,
159 |     db: AsyncSession = Depends(get_db),
160 |     scheduler: ProtocolScheduler = Depends(get_scheduler),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^ B008
161 | ) -> ScheduleEntryResponse:
162 |     """Cancel a scheduled protocol run."""
    |

praxis/backend/api/scheduler_api.py:212:36: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
210 | @log_async_runtime_errors(logger, raises=True, raises_exception=PraxisAPIError)
211 | async def list_schedules(
212 |     filters: ScheduleListFilters = Depends(),
    |                                    ^^^^^^^^^ B008
213 |     db: AsyncSession = Depends(get_db),
214 | ) -> ScheduleListResponse:
    |

praxis/backend/api/scheduler_api.py:213:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
211 | async def list_schedules(
212 |     filters: ScheduleListFilters = Depends(),
213 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
214 | ) -> ScheduleListResponse:
215 |     """List scheduled protocol runs with optional filters."""
    |

praxis/backend/api/scheduler_api.py:255:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
253 |     schedule_id: uuid.UUID,
254 |     request: SchedulePriorityUpdateRequest,
255 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
256 | ) -> ScheduleEntryResponse:
257 |     """Update the priority of a scheduled protocol run."""
    |

praxis/backend/api/scheduler_api.py:287:39: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
285 |     asset_type: str,
286 |     asset_name: str,
287 |     asset_manager: AssetLockManager = Depends(get_asset_manager),
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ B008
288 | ) -> AssetAvailabilityResponse:
289 |     """Check if a specific asset is currently available."""
    |

praxis/backend/api/scheduler_api.py:308:41: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
306 |         is_available=is_available,
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
    |                                         ^^^^ TD002
309 |         alternative_assets=None,  # TODO: Find alternatives
310 |     )
    |

praxis/backend/api/scheduler_api.py:308:41: TD003 Missing issue link on the line following this TODO
    |
306 |         is_available=is_available,
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
    |                                         ^^^^ TD003
309 |         alternative_assets=None,  # TODO: Find alternatives
310 |     )
    |

praxis/backend/api/scheduler_api.py:308:41: FIX002 Line contains TODO, consider resolving the issue
    |
306 |         is_available=is_available,
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
    |                                         ^^^^ FIX002
309 |         alternative_assets=None,  # TODO: Find alternatives
310 |     )
    |

praxis/backend/api/scheduler_api.py:309:37: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
309 |         alternative_assets=None,  # TODO: Find alternatives
    |                                     ^^^^ TD002
310 |     )
    |

praxis/backend/api/scheduler_api.py:309:37: TD003 Missing issue link on the line following this TODO
    |
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
309 |         alternative_assets=None,  # TODO: Find alternatives
    |                                     ^^^^ TD003
310 |     )
    |

praxis/backend/api/scheduler_api.py:309:37: FIX002 Line contains TODO, consider resolving the issue
    |
307 |         current_reservation=current_reservation,
308 |         estimated_available_at=None,  # TODO: Calculate from reservation data
309 |         alternative_assets=None,  # TODO: Find alternatives
    |                                     ^^^^ FIX002
310 |     )
    |

praxis/backend/api/scheduler_api.py:319:39: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
317 | @log_async_runtime_errors(logger, raises=True, raises_exception=PraxisAPIError)
318 | async def get_system_status(
319 |     asset_manager: AssetLockManager = Depends(get_asset_manager),
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ B008
320 | ) -> SchedulerSystemStatusResponse:
321 |     """Get current scheduler system status and health metrics."""
    |

praxis/backend/api/scheduler_api.py:325:7: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
323 |     redis_status = await asset_manager.get_system_status()
324 | 
325 |     # TODO: Add scheduler service methods to get these statistics
    |       ^^^^ TD002
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |

praxis/backend/api/scheduler_api.py:325:7: TD003 Missing issue link on the line following this TODO
    |
323 |     redis_status = await asset_manager.get_system_status()
324 | 
325 |     # TODO: Add scheduler service methods to get these statistics
    |       ^^^^ TD003
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |

praxis/backend/api/scheduler_api.py:325:7: FIX002 Line contains TODO, consider resolving the issue
    |
323 |     redis_status = await asset_manager.get_system_status()
324 | 
325 |     # TODO: Add scheduler service methods to get these statistics
    |       ^^^^ FIX002
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |

praxis/backend/api/scheduler_api.py:327:25: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
325 |     # TODO: Add scheduler service methods to get these statistics
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |                         ^^^^ TD002
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:327:25: TD003 Missing issue link on the line following this TODO
    |
325 |     # TODO: Add scheduler service methods to get these statistics
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |                         ^^^^ TD003
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:327:25: FIX002 Line contains TODO, consider resolving the issue
    |
325 |     # TODO: Add scheduler service methods to get these statistics
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
    |                         ^^^^ FIX002
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:328:26: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
    |                          ^^^^ TD002
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:328:26: TD003 Missing issue link on the line following this TODO
    |
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
    |                          ^^^^ TD003
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:328:26: FIX002 Line contains TODO, consider resolving the issue
    |
326 |     # For now, returning placeholder values
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
    |                          ^^^^ FIX002
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:329:34: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |                                  ^^^^ TD002
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:329:34: TD003 Missing issue link on the line following this TODO
    |
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |                                  ^^^^ TD003
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:329:34: FIX002 Line contains TODO, consider resolving the issue
    |
327 |     total_queued = 0  # TODO: await scheduler_svc.get_queued_count(db)
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
    |                                  ^^^^ FIX002
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |

praxis/backend/api/scheduler_api.py:330:31: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |                               ^^^^ TD002
331 | 
332 |     return SchedulerSystemStatusResponse(
    |

praxis/backend/api/scheduler_api.py:330:31: TD003 Missing issue link on the line following this TODO
    |
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |                               ^^^^ TD003
331 | 
332 |     return SchedulerSystemStatusResponse(
    |

praxis/backend/api/scheduler_api.py:330:31: FIX002 Line contains TODO, consider resolving the issue
    |
328 |     total_running = 0  # TODO: await scheduler_svc.get_running_count(db)
329 |     total_completed_today = 0  # TODO: await scheduler_svc.get_completed_today_count(db)
330 |     total_failed_today = 0  # TODO: await scheduler_svc.get_failed_today_count(db)
    |                               ^^^^ FIX002
331 | 
332 |     return SchedulerSystemStatusResponse(
    |

praxis/backend/api/scheduler_api.py:339:34: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
337 |         active_resource_locks=redis_status.get("active_locks", 0),
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
    |                                  ^^^^ TD002
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |

praxis/backend/api/scheduler_api.py:339:34: TD003 Missing issue link on the line following this TODO
    |
337 |         active_resource_locks=redis_status.get("active_locks", 0),
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
    |                                  ^^^^ TD003
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |

praxis/backend/api/scheduler_api.py:339:34: FIX002 Line contains TODO, consider resolving the issue
    |
337 |         active_resource_locks=redis_status.get("active_locks", 0),
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
    |                                  ^^^^ FIX002
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |

praxis/backend/api/scheduler_api.py:340:35: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
    |                                   ^^^^ TD002
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |

praxis/backend/api/scheduler_api.py:340:35: TD003 Missing issue link on the line following this TODO
    |
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
    |                                   ^^^^ TD003
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |

praxis/backend/api/scheduler_api.py:340:35: FIX002 Line contains TODO, consider resolving the issue
    |
338 |         active_reservations=redis_status.get("active_reservations", 0),
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
    |                                   ^^^^ FIX002
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |

praxis/backend/api/scheduler_api.py:341:34: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |                                  ^^^^ TD002
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |

praxis/backend/api/scheduler_api.py:341:34: TD003 Missing issue link on the line following this TODO
    |
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |                                  ^^^^ TD003
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |

praxis/backend/api/scheduler_api.py:341:34: FIX002 Line contains TODO, consider resolving the issue
    |
339 |         available_machines=0,  # TODO: Query from machine service
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
    |                                  ^^^^ FIX002
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |

praxis/backend/api/scheduler_api.py:342:37: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |                                     ^^^^ TD002
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:342:37: TD003 Missing issue link on the line following this TODO
    |
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |                                     ^^^^ TD003
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:342:37: FIX002 Line contains TODO, consider resolving the issue
    |
340 |         available_resources=0,  # TODO: Query from resource service
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
    |                                     ^^^^ FIX002
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:343:35: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |                                   ^^^^ TD002
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:343:35: TD003 Missing issue link on the line following this TODO
    |
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |                                   ^^^^ TD003
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:343:35: FIX002 Line contains TODO, consider resolving the issue
    |
341 |         redis_connected=True,  # TODO: Get from Redis health check
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
    |                                   ^^^^ FIX002
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |

praxis/backend/api/scheduler_api.py:344:40: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |                                        ^^^^ TD002
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |

praxis/backend/api/scheduler_api.py:344:40: TD003 Missing issue link on the line following this TODO
    |
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |                                        ^^^^ TD003
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |

praxis/backend/api/scheduler_api.py:344:40: FIX002 Line contains TODO, consider resolving the issue
    |
342 |         celery_workers_active=0,  # TODO: Get from Celery inspection
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
    |                                        ^^^^ FIX002
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |

praxis/backend/api/scheduler_api.py:345:44: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |                                            ^^^^ TD002
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
    |

praxis/backend/api/scheduler_api.py:345:44: TD003 Missing issue link on the line following this TODO
    |
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |                                            ^^^^ TD003
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
    |

praxis/backend/api/scheduler_api.py:345:44: FIX002 Line contains TODO, consider resolving the issue
    |
343 |         database_healthy=True,  # TODO: Perform DB health check
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
    |                                            ^^^^ FIX002
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
    |

praxis/backend/api/scheduler_api.py:346:41: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |                                         ^^^^ TD002
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |

praxis/backend/api/scheduler_api.py:346:41: TD003 Missing issue link on the line following this TODO
    |
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |                                         ^^^^ TD003
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |

praxis/backend/api/scheduler_api.py:346:41: FIX002 Line contains TODO, consider resolving the issue
    |
344 |         average_queue_time_ms=None,  # TODO: Calculate from metrics
345 |         average_execution_time_ms=None,  # TODO: Calculate from metrics
346 |         system_load_percentage=None,  # TODO: Get system metrics
    |                                         ^^^^ FIX002
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |

praxis/backend/api/scheduler_api.py:348:30: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |                              ^^^^ TD002
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
350 |     )
    |

praxis/backend/api/scheduler_api.py:348:30: TD003 Missing issue link on the line following this TODO
    |
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |                              ^^^^ TD003
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
350 |     )
    |

praxis/backend/api/scheduler_api.py:348:30: FIX002 Line contains TODO, consider resolving the issue
    |
346 |         system_load_percentage=None,  # TODO: Get system metrics
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
    |                              ^^^^ FIX002
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
350 |     )
    |

praxis/backend/api/scheduler_api.py:349:41: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
    |                                         ^^^^ TD002
350 |     )
    |

praxis/backend/api/scheduler_api.py:349:41: TD003 Missing issue link on the line following this TODO
    |
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
    |                                         ^^^^ TD003
350 |     )
    |

praxis/backend/api/scheduler_api.py:349:41: FIX002 Line contains TODO, consider resolving the issue
    |
347 |         timestamp=datetime.now(timezone.utc),
348 |         uptime_seconds=0,  # TODO: Track uptime
349 |         last_cleanup_timestamp=None,  # TODO: Track cleanup times
    |                                         ^^^^ FIX002
350 |     )
    |

praxis/backend/api/scheduler_api.py:361:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
359 |     schedule_id: uuid.UUID,
360 |     limit: int = Query(100, ge=1, le=1000),
361 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
362 | ) -> list[ScheduleHistoryResponse]:
363 |     """Get the scheduling history for a specific schedule entry."""
    |

praxis/backend/api/scheduler_api.py:372:35: B008 Do not perform function call `Query` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
370 | @log_async_runtime_errors(logger, raises=True, raises_exception=PraxisAPIError)
371 | async def get_scheduler_metrics(
372 |     start_time: datetime | None = Query(None),
    |                                   ^^^^^^^^^^^ B008
373 |     end_time: datetime | None = Query(None),
374 |     db: AsyncSession = Depends(get_db),
    |

praxis/backend/api/scheduler_api.py:373:33: B008 Do not perform function call `Query` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
371 | async def get_scheduler_metrics(
372 |     start_time: datetime | None = Query(None),
373 |     end_time: datetime | None = Query(None),
    |                                 ^^^^^^^^^^^ B008
374 |     db: AsyncSession = Depends(get_db),
375 | ) -> SchedulerMetricsResponse:
    |

praxis/backend/api/scheduler_api.py:374:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
372 |     start_time: datetime | None = Query(None),
373 |     end_time: datetime | None = Query(None),
374 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
375 | ) -> SchedulerMetricsResponse:
376 |     """Get scheduler performance metrics for a time period."""
    |

praxis/backend/api/scheduler_api.py:394:48: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
392 |         protocols_cancelled=status_counts.get("CANCELLED", 0),
393 |         average_queue_time_seconds=(metrics.get("average_queue_time_ms", 0) or 0) / 1000.0,
394 |         average_execution_time_seconds=0.0,  # TODO: Calculate from protocol runs
    |                                                ^^^^ TD002
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
    |

praxis/backend/api/scheduler_api.py:394:48: TD003 Missing issue link on the line following this TODO
    |
392 |         protocols_cancelled=status_counts.get("CANCELLED", 0),
393 |         average_queue_time_seconds=(metrics.get("average_queue_time_ms", 0) or 0) / 1000.0,
394 |         average_execution_time_seconds=0.0,  # TODO: Calculate from protocol runs
    |                                                ^^^^ TD003
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
    |

praxis/backend/api/scheduler_api.py:394:48: FIX002 Line contains TODO, consider resolving the issue
    |
392 |         protocols_cancelled=status_counts.get("CANCELLED", 0),
393 |         average_queue_time_seconds=(metrics.get("average_queue_time_ms", 0) or 0) / 1000.0,
394 |         average_execution_time_seconds=0.0,  # TODO: Calculate from protocol runs
    |                                                ^^^^ FIX002
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
    |

praxis/backend/api/scheduler_api.py:397:41: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
    |                                         ^^^^ TD002
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |

praxis/backend/api/scheduler_api.py:397:41: TD003 Missing issue link on the line following this TODO
    |
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
    |                                         ^^^^ TD003
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |

praxis/backend/api/scheduler_api.py:397:41: FIX002 Line contains TODO, consider resolving the issue
    |
395 |         average_resource_reservation_time_ms=metrics.get("average_reservation_time_ms", 0)
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
    |                                         ^^^^ FIX002
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |

praxis/backend/api/scheduler_api.py:398:57: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
    |                                                         ^^^^ TD002
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
    |

praxis/backend/api/scheduler_api.py:398:57: TD003 Missing issue link on the line following this TODO
    |
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
    |                                                         ^^^^ TD003
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
    |

praxis/backend/api/scheduler_api.py:398:57: FIX002 Line contains TODO, consider resolving the issue
    |
396 |         or 0.0,
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
    |                                                         ^^^^ FIX002
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
    |

praxis/backend/api/scheduler_api.py:399:41: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |                                         ^^^^ TD002
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |

praxis/backend/api/scheduler_api.py:399:41: TD003 Missing issue link on the line following this TODO
    |
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |                                         ^^^^ TD003
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |

praxis/backend/api/scheduler_api.py:399:41: FIX002 Line contains TODO, consider resolving the issue
    |
397 |         peak_concurrent_protocols=0,  # TODO: Calculate from history
398 |         average_resource_utilization_percentage=0.0,  # TODO: Calculate
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
    |                                         ^^^^ FIX002
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |

praxis/backend/api/scheduler_api.py:401:34: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |                                  ^^^^ TD002
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:401:34: TD003 Missing issue link on the line following this TODO
    |
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |                                  ^^^^ TD003
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:401:34: FIX002 Line contains TODO, consider resolving the issue
    |
399 |         most_contested_resources=[],  # TODO: Calculate from reservation conflicts
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
    |                                  ^^^^ FIX002
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:402:30: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
    |                              ^^^^ TD002
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:402:30: TD003 Missing issue link on the line following this TODO
    |
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
    |                              ^^^^ TD003
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:402:30: FIX002 Line contains TODO, consider resolving the issue
    |
400 |         scheduling_errors=metrics.get("error_count", 0),
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
    |                              ^^^^ FIX002
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |

praxis/backend/api/scheduler_api.py:403:49: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                 ^^^^ TD002
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |

praxis/backend/api/scheduler_api.py:403:49: TD003 Missing issue link on the line following this TODO
    |
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                 ^^^^ TD003
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |

praxis/backend/api/scheduler_api.py:403:49: FIX002 Line contains TODO, consider resolving the issue
    |
401 |         resource_conflicts=0,  # TODO: Count reservation failures
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                 ^^^^ FIX002
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |

praxis/backend/api/scheduler_api.py:404:52: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                    ^^^^ TD002
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
406 |     )
    |

praxis/backend/api/scheduler_api.py:404:52: TD003 Missing issue link on the line following this TODO
    |
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                    ^^^^ TD003
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
406 |     )
    |

praxis/backend/api/scheduler_api.py:404:52: FIX002 Line contains TODO, consider resolving the issue
    |
402 |         timeout_errors=0,  # TODO: Count timeout events
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
    |                                                    ^^^^ FIX002
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
406 |     )
    |

praxis/backend/api/scheduler_api.py:405:44: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |                                            ^^^^ TD002
406 |     )
    |

praxis/backend/api/scheduler_api.py:405:44: TD003 Missing issue link on the line following this TODO
    |
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |                                            ^^^^ TD003
406 |     )
    |

praxis/backend/api/scheduler_api.py:405:44: FIX002 Line contains TODO, consider resolving the issue
    |
403 |         redis_availability_percentage=100.0,  # TODO: Calculate from monitoring
404 |         database_availability_percentage=100.0,  # TODO: Calculate from monitoring
405 |         celery_task_success_rate=100.0,  # TODO: Calculate from Celery metrics
    |                                            ^^^^ FIX002
406 |     )
    |

praxis/backend/api/scheduler_api.py:415:24: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
413 | @log_async_runtime_errors(logger, raises=True, raises_exception=PraxisAPIError)
414 | async def cleanup_expired_asset_locks(
415 |     db: AsyncSession = Depends(get_db),
    |                        ^^^^^^^^^^^^^^^ B008
416 |     asset_manager: AssetLockManager = Depends(get_asset_manager),
417 | ) -> dict[str, int]:
    |

praxis/backend/api/scheduler_api.py:416:39: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
414 | async def cleanup_expired_asset_locks(
415 |     db: AsyncSession = Depends(get_db),
416 |     asset_manager: AssetLockManager = Depends(get_asset_manager),
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ B008
417 | ) -> dict[str, int]:
418 |     """Clean up expired asset_locks and reservations."""
    |

praxis/backend/api/workcell_api.py:60:11: ANN201 Missing return type annotation for public function `create_workcell`
   |
58 |   tags=["Workcells"],
59 | )
60 | async def create_workcell(workcell: WorkcellCreate, db: AsyncSession = Depends(get_db)):
   |           ^^^^^^^^^^^^^^^ ANN201
61 |   """Create a new workcell."""
62 |   try:
   |
   = help: Add return type annotation

praxis/backend/api/workcell_api.py:60:72: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
58 |   tags=["Workcells"],
59 | )
60 | async def create_workcell(workcell: WorkcellCreate, db: AsyncSession = Depends(get_db)):
   |                                                                        ^^^^^^^^^^^^^^^ B008
61 |   """Create a new workcell."""
62 |   try:
   |

praxis/backend/api/workcell_api.py:64:5: TRY300 Consider moving this statement to an `else` block
   |
62 |   try:
63 |     created_workcell = await workcell_service.create(db=db, obj_in=workcell)
64 |     return created_workcell
   |     ^^^^^^^^^^^^^^^^^^^^^^^ TRY300
65 |   except ValueError as e:
66 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |

praxis/backend/api/workcell_api.py:64:12: RET504 Unnecessary assignment to `created_workcell` before `return` statement
   |
62 |   try:
63 |     created_workcell = await workcell_service.create(db=db, obj_in=workcell)
64 |     return created_workcell
   |            ^^^^^^^^^^^^^^^^ RET504
65 |   except ValueError as e:
66 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |
   = help: Remove unnecessary assignment

praxis/backend/api/workcell_api.py:66:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
64 |     return created_workcell
65 |   except ValueError as e:
66 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
   |

praxis/backend/api/workcell_api.py:80:11: ANN201 Missing return type annotation for public function `get_workcell`
   |
78 |   tags=["Workcells"],
79 | )
80 | async def get_workcell(accession: str, db: AsyncSession = Depends(get_db)):
   |           ^^^^^^^^^^^^ ANN201
81 |   """Retrieve a workcell by accession ID or name."""
82 |   workcell_id = await workcell_accession_resolver(db=db, accession=accession)
   |
   = help: Add return type annotation

praxis/backend/api/workcell_api.py:80:59: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
78 |   tags=["Workcells"],
79 | )
80 | async def get_workcell(accession: str, db: AsyncSession = Depends(get_db)):
   |                                                           ^^^^^^^^^^^^^^^ B008
81 |   """Retrieve a workcell by accession ID or name."""
82 |   workcell_id = await workcell_accession_resolver(db=db, accession=accession)
   |

praxis/backend/api/workcell_api.py:101:11: ANN201 Missing return type annotation for public function `list_workcells`
    |
 99 |   tags=["Workcells"],
100 | )
101 | async def list_workcells( # pylint: disable=too-many-arguments
    |           ^^^^^^^^^^^^^^ ANN201
102 |   db: AsyncSession = Depends(get_db), # pylint: disable=too-many-arguments
103 |   filters: SearchFilters = Depends(), # pylint: disable=too-many-arguments
    |
    = help: Add return type annotation

praxis/backend/api/workcell_api.py:102:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
100 | )
101 | async def list_workcells( # pylint: disable=too-many-arguments
102 |   db: AsyncSession = Depends(get_db), # pylint: disable=too-many-arguments
    |                      ^^^^^^^^^^^^^^^ B008
103 |   filters: SearchFilters = Depends(), # pylint: disable=too-many-arguments
104 | ):
    |

praxis/backend/api/workcell_api.py:103:28: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
101 | async def list_workcells( # pylint: disable=too-many-arguments
102 |   db: AsyncSession = Depends(get_db), # pylint: disable=too-many-arguments
103 |   filters: SearchFilters = Depends(), # pylint: disable=too-many-arguments
    |                            ^^^^^^^^^ B008
104 | ):
105 |   """List all workcells."""
    |

praxis/backend/api/workcell_api.py:120:11: ANN201 Missing return type annotation for public function `update_workcell`
    |
118 |   tags=["Workcells"],
119 | )
120 | async def update_workcell(
    |           ^^^^^^^^^^^^^^^ ANN201
121 |   accession: str,
122 |   workcell_update: WorkcellUpdate,
    |
    = help: Add return type annotation

praxis/backend/api/workcell_api.py:123:22: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
121 |   accession: str,
122 |   workcell_update: WorkcellUpdate,
123 |   db: AsyncSession = Depends(get_db),
    |                      ^^^^^^^^^^^^^^^ B008
124 | ):
125 |   """Update an existing workcell."""
    |

praxis/backend/api/workcell_api.py:135:5: TRY300 Consider moving this statement to an `else` block
    |
133 |       db=db, db_obj=db_obj, obj_in=workcell_update,
134 |     )
135 |     return updated_workcell
    |     ^^^^^^^^^^^^^^^^^^^^^^^ TRY300
136 |   except ValueError as e:
137 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |

praxis/backend/api/workcell_api.py:135:12: RET504 Unnecessary assignment to `updated_workcell` before `return` statement
    |
133 |       db=db, db_obj=db_obj, obj_in=workcell_update,
134 |     )
135 |     return updated_workcell
    |            ^^^^^^^^^^^^^^^^ RET504
136 |   except ValueError as e:
137 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |
    = help: Remove unnecessary assignment

praxis/backend/api/workcell_api.py:137:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
135 |     return updated_workcell
136 |   except ValueError as e:
137 |     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

praxis/backend/api/workcell_api.py:151:11: ANN201 Missing return type annotation for public function `delete_workcell`
    |
149 |   tags=["Workcells"],
150 | )
151 | async def delete_workcell(accession: str, db: AsyncSession = Depends(get_db)):
    |           ^^^^^^^^^^^^^^^ ANN201
152 |   """Delete a workcell."""
153 |   workcell_id = await workcell_accession_resolver(db=db, accession=accession)
    |
    = help: Add return type annotation: `None`

praxis/backend/api/workcell_api.py:151:62: B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    |
149 |   tags=["Workcells"],
150 | )
151 | async def delete_workcell(accession: str, db: AsyncSession = Depends(get_db)):
    |                                                              ^^^^^^^^^^^^^^^ B008
152 |   """Delete a workcell."""
153 |   workcell_id = await workcell_accession_resolver(db=db, accession=accession)
    |

praxis/backend/commons/__init__.py:1:1: D104 Missing docstring in public package
praxis/backend/commons/commons.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/dilution.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/dilution.py:16:11: C901 `dilution_checks` is too complex (12 > 10)
   |
16 | async def dilution_checks(
   |           ^^^^^^^^^^^^^^^ C901
17 |   n_dilutions: int,
18 |   source_plate: Plate,
   |

praxis/backend/commons/dilution.py:16:11: PLR0913 Too many arguments in function definition (10 > 5)
   |
16 | async def dilution_checks(
   |           ^^^^^^^^^^^^^^^ PLR0913
17 |   n_dilutions: int,
18 |   source_plate: Plate,
   |

praxis/backend/commons/dilution.py:16:11: ANN201 Missing return type annotation for public function `dilution_checks`
   |
16 | async def dilution_checks(
   |           ^^^^^^^^^^^^^^^ ANN201
17 |   n_dilutions: int,
18 |   source_plate: Plate,
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:16:11: D417 Missing argument description in the docstring for `dilution_checks`: `n_dilutions`
   |
16 | async def dilution_checks(
   |           ^^^^^^^^^^^^^^^ D417
17 |   n_dilutions: int,
18 |   source_plate: Plate,
   |

praxis/backend/commons/dilution.py:17:3: ARG001 Unused function argument: `n_dilutions`
   |
16 | async def dilution_checks(
17 |   n_dilutions: int,
   |   ^^^^^^^^^^^ ARG001
18 |   source_plate: Plate,
19 |   target_plate: Plate,
   |

praxis/backend/commons/dilution.py:28:3: D401 First line of docstring should be in imperative mood: "Checks for errors in the dilution series functions."
   |
26 |     dilution_axis: Literal["row", "column", "x", "y", 0, 1, "optimal"] | None = "optimal",
27 |   ):
28 |     """Checks for errors in the dilution series functions.
   |  ___^
29 | | 
30 | |   Args:
31 | |     liquid_handler: LiquidHandler object
32 | |     source_plate: Plate with the source wells
33 | |     target_plate: Plate with the target wells
34 | |     dilution_factor: Factor by which to dilute each time
35 | |     source_wells: Wells in the source plate to dilute
36 | |     target_wells: Wells in the target plate to dilute
37 | |     mix_cycles: Number of mixing cycles to perform
38 | |     tip_rack: TipRack object
39 | |     source_volumes: Volume in the source wells. If None, will transfer the total well volume \
40 | |       divided by the dilution factor.
41 | |     dilution_axis: Axis along which to dilute. Options are "row", "column", "x", "y", 0, 1.
42 | | 
43 | |   Raises:
44 | |     ExperimentError: If there are errors in the input parameters.
45 | | 
46 | |   """
   | |_____^ D401
47 |     if len(source_wells) != len(target_wells):
48 |       raise ValueError("Number of source wells does not match number of target wells")
   |

praxis/backend/commons/dilution.py:48:11: TRY003 Avoid specifying long messages outside the exception class
   |
46 |   """
47 |   if len(source_wells) != len(target_wells):
48 |     raise ValueError("Number of source wells does not match number of target wells")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
49 |   if not source_plate:
50 |     raise ValueError("No source plate specified")
   |

praxis/backend/commons/dilution.py:48:22: EM101 Exception must not use a string literal, assign to variable first
   |
46 |   """
47 |   if len(source_wells) != len(target_wells):
48 |     raise ValueError("Number of source wells does not match number of target wells")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
49 |   if not source_plate:
50 |     raise ValueError("No source plate specified")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:50:11: TRY003 Avoid specifying long messages outside the exception class
   |
48 |     raise ValueError("Number of source wells does not match number of target wells")
49 |   if not source_plate:
50 |     raise ValueError("No source plate specified")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
51 |   if not target_plate:
52 |     raise ValueError("No target plate specified")
   |

praxis/backend/commons/dilution.py:50:22: EM101 Exception must not use a string literal, assign to variable first
   |
48 |     raise ValueError("Number of source wells does not match number of target wells")
49 |   if not source_plate:
50 |     raise ValueError("No source plate specified")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
51 |   if not target_plate:
52 |     raise ValueError("No target plate specified")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:52:11: TRY003 Avoid specifying long messages outside the exception class
   |
50 |     raise ValueError("No source plate specified")
51 |   if not target_plate:
52 |     raise ValueError("No target plate specified")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
53 |   if not isinstance(dilution_factor, float):
54 |     raise ValueError("Dilution factor must be a float")
   |

praxis/backend/commons/dilution.py:52:22: EM101 Exception must not use a string literal, assign to variable first
   |
50 |     raise ValueError("No source plate specified")
51 |   if not target_plate:
52 |     raise ValueError("No target plate specified")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
53 |   if not isinstance(dilution_factor, float):
54 |     raise ValueError("Dilution factor must be a float")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:54:5: TRY004 Prefer `TypeError` exception for invalid type
   |
52 |     raise ValueError("No target plate specified")
53 |   if not isinstance(dilution_factor, float):
54 |     raise ValueError("Dilution factor must be a float")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |

praxis/backend/commons/dilution.py:54:11: TRY003 Avoid specifying long messages outside the exception class
   |
52 |     raise ValueError("No target plate specified")
53 |   if not isinstance(dilution_factor, float):
54 |     raise ValueError("Dilution factor must be a float")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |

praxis/backend/commons/dilution.py:54:22: EM101 Exception must not use a string literal, assign to variable first
   |
52 |     raise ValueError("No target plate specified")
53 |   if not isinstance(dilution_factor, float):
54 |     raise ValueError("Dilution factor must be a float")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:56:5: TRY004 Prefer `TypeError` exception for invalid type
   |
54 |     raise ValueError("Dilution factor must be a float")
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |

praxis/backend/commons/dilution.py:56:11: TRY003 Avoid specifying long messages outside the exception class
   |
54 |     raise ValueError("Dilution factor must be a float")
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |

praxis/backend/commons/dilution.py:56:22: EM101 Exception must not use a string literal, assign to variable first
   |
54 |     raise ValueError("Dilution factor must be a float")
55 |   if not isinstance(source_wells, list) or not isinstance(target_wells, list):
56 |     raise ValueError("Source and target wells must be lists")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:58:5: TRY004 Prefer `TypeError` exception for invalid type
   |
56 |     raise ValueError("Source and target wells must be lists")
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |

praxis/backend/commons/dilution.py:58:11: TRY003 Avoid specifying long messages outside the exception class
   |
56 |     raise ValueError("Source and target wells must be lists")
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |

praxis/backend/commons/dilution.py:58:22: EM101 Exception must not use a string literal, assign to variable first
   |
56 |     raise ValueError("Source and target wells must be lists")
57 |   if not isinstance(mix_cycles, int):
58 |     raise ValueError("Mix cycles must be an integer")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:60:5: TRY004 Prefer `TypeError` exception for invalid type
   |
58 |     raise ValueError("Mix cycles must be an integer")
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
   |

praxis/backend/commons/dilution.py:60:11: TRY003 Avoid specifying long messages outside the exception class
   |
58 |     raise ValueError("Mix cycles must be an integer")
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
   |

praxis/backend/commons/dilution.py:60:22: EM101 Exception must not use a string literal, assign to variable first
   |
58 |     raise ValueError("Mix cycles must be an integer")
59 |   if not isinstance(tip_rack, TipRack):
60 |     raise ValueError("Tip rack must be a TipRack object")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:62:12: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
60 |     raise ValueError("Tip rack must be a TipRack object")
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
63 |       raise ValueError("Source volumes must be a float or list of floats")
64 |     if isinstance(source_volumes, list) and len(source_volumes) != len(source_wells):
   |
   = help: Convert to `X | Y`

praxis/backend/commons/dilution.py:63:13: TRY003 Avoid specifying long messages outside the exception class
   |
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
63 |       raise ValueError("Source volumes must be a float or list of floats")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
64 |     if isinstance(source_volumes, list) and len(source_volumes) != len(source_wells):
65 |       raise ValueError("Number of source volumes does not match number of source wells")
   |

praxis/backend/commons/dilution.py:63:24: EM101 Exception must not use a string literal, assign to variable first
   |
61 |   if source_volumes:
62 |     if not isinstance(source_volumes, (float, list)):
63 |       raise ValueError("Source volumes must be a float or list of floats")
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
64 |     if isinstance(source_volumes, list) and len(source_volumes) != len(source_wells):
65 |       raise ValueError("Number of source volumes does not match number of source wells")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:65:13: TRY003 Avoid specifying long messages outside the exception class
   |
63 |       raise ValueError("Source volumes must be a float or list of floats")
64 |     if isinstance(source_volumes, list) and len(source_volumes) != len(source_wells):
65 |       raise ValueError("Number of source volumes does not match number of source wells")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
66 |   if dilution_axis not in ["row", "column", "x", "y", 0, 1, "optimal"]:
67 |     raise ValueError("Invalid dilution axis")
   |

praxis/backend/commons/dilution.py:65:24: EM101 Exception must not use a string literal, assign to variable first
   |
63 |       raise ValueError("Source volumes must be a float or list of floats")
64 |     if isinstance(source_volumes, list) and len(source_volumes) != len(source_wells):
65 |       raise ValueError("Number of source volumes does not match number of source wells")
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
66 |   if dilution_axis not in ["row", "column", "x", "y", 0, 1, "optimal"]:
67 |     raise ValueError("Invalid dilution axis")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:67:11: TRY003 Avoid specifying long messages outside the exception class
   |
65 |       raise ValueError("Number of source volumes does not match number of source wells")
66 |   if dilution_axis not in ["row", "column", "x", "y", 0, 1, "optimal"]:
67 |     raise ValueError("Invalid dilution axis")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
   |

praxis/backend/commons/dilution.py:67:22: EM101 Exception must not use a string literal, assign to variable first
   |
65 |       raise ValueError("Number of source volumes does not match number of source wells")
66 |   if dilution_axis not in ["row", "column", "x", "y", 0, 1, "optimal"]:
67 |     raise ValueError("Invalid dilution axis")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^ EM101
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:70:11: C901 `find_optimal_dilution_strategy` is too complex (15 > 10)
   |
70 | async def find_optimal_dilution_strategy(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
71 |   n_variables: int,  # TODO: implement replicate handling
72 |   n_dilutions: int,
   |

praxis/backend/commons/dilution.py:70:11: PLR0913 Too many arguments in function definition (8 > 5)
   |
70 | async def find_optimal_dilution_strategy(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
71 |   n_variables: int,  # TODO: implement replicate handling
72 |   n_dilutions: int,
   |

praxis/backend/commons/dilution.py:70:11: PLR0912 Too many branches (17 > 12)
   |
70 | async def find_optimal_dilution_strategy(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
71 |   n_variables: int,  # TODO: implement replicate handling
72 |   n_dilutions: int,
   |

praxis/backend/commons/dilution.py:70:11: D417 Missing argument description in the docstring for `find_optimal_dilution_strategy`: `undiluted_source`
   |
70 | async def find_optimal_dilution_strategy(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D417
71 |   n_variables: int,  # TODO: implement replicate handling
72 |   n_dilutions: int,
   |

praxis/backend/commons/dilution.py:71:24: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
70 | async def find_optimal_dilution_strategy(
71 |   n_variables: int,  # TODO: implement replicate handling
   |                        ^^^^ TD002
72 |   n_dilutions: int,
73 |   dilution_factors: float | list[float] | list[list[float]],
   |

praxis/backend/commons/dilution.py:71:24: TD003 Missing issue link on the line following this TODO
   |
70 | async def find_optimal_dilution_strategy(
71 |   n_variables: int,  # TODO: implement replicate handling
   |                        ^^^^ TD003
72 |   n_dilutions: int,
73 |   dilution_factors: float | list[float] | list[list[float]],
   |

praxis/backend/commons/dilution.py:71:24: FIX002 Line contains TODO, consider resolving the issue
   |
70 | async def find_optimal_dilution_strategy(
71 |   n_variables: int,  # TODO: implement replicate handling
   |                        ^^^^ FIX002
72 |   n_dilutions: int,
73 |   dilution_factors: float | list[float] | list[list[float]],
   |

praxis/backend/commons/dilution.py:74:3: ARG001 Unused function argument: `source_plate`
   |
72 |   n_dilutions: int,
73 |   dilution_factors: float | list[float] | list[list[float]],
74 |   source_plate: Plate,
   |   ^^^^^^^^^^^^ ARG001
75 |   target_plate: Plate,
76 |   variables_volumes: float | list[float],
   |

praxis/backend/commons/dilution.py:77:3: FBT001 Boolean-typed positional argument in function definition
   |
75 |   target_plate: Plate,
76 |   variables_volumes: float | list[float],
77 |   undiluted_source: bool = True,
   |   ^^^^^^^^^^^^^^^^ FBT001
78 |   variable_accession_ids: list[str] | None = None,
79 | ) -> dict[str, dict]:
   |

praxis/backend/commons/dilution.py:77:3: FBT002 Boolean default positional argument in function definition
   |
75 |   target_plate: Plate,
76 |   variables_volumes: float | list[float],
77 |   undiluted_source: bool = True,
   |   ^^^^^^^^^^^^^^^^ FBT002
78 |   variable_accession_ids: list[str] | None = None,
79 | ) -> dict[str, dict]:
   |

praxis/backend/commons/dilution.py:77:3: ARG001 Unused function argument: `undiluted_source`
   |
75 |   target_plate: Plate,
76 |   variables_volumes: float | list[float],
77 |   undiluted_source: bool = True,
   |   ^^^^^^^^^^^^^^^^ ARG001
78 |   variable_accession_ids: list[str] | None = None,
79 | ) -> dict[str, dict]:
   |

praxis/backend/commons/dilution.py:80:3: D205 1 blank line required between summary line and description
   |
78 |     variable_accession_ids: list[str] | None = None,
79 |   ) -> dict[str, dict]:
80 |     """Finds the optimal dilution strategy for a dilution series and prints the details for what wells
   |  ___^
81 | |   to use for each variable undiluted or initial dilution source.
82 | | 
83 | |   Args:
84 | |     n_variables: Number of variables to dilute
85 | |     n_dilutions: Number of dilutions to perform
86 | |     dilution_factors: Factor by which to dilute each time
87 | |     source_plate: Plate with the source wells
88 | |     target_plate: Plate with the target wells
89 | |     variables_volumes: Volume in the source wells. If None, will transfer the total well volume \
90 | |       divided by the dilution factor.
91 | |     variable_accession_ids: Names of the variables to dilute
92 | | 
93 | |   Returns:
94 | |     variable_details: Dictionary with the details of the dilution strategy for each variable
95 | | 
96 | |   """
   | |_____^ D205
97 |     if n_dilutions * n_variables > target_plate.num_items:
98 |       raise ValueError("Number of dilutions exceeds number of wells in plate")
   |
   = help: Insert single blank line

praxis/backend/commons/dilution.py:80:3: D401 First line of docstring should be in imperative mood: "Finds the optimal dilution strategy for a dilution series and prints the details for what wells"
   |
78 |     variable_accession_ids: list[str] | None = None,
79 |   ) -> dict[str, dict]:
80 |     """Finds the optimal dilution strategy for a dilution series and prints the details for what wells
   |  ___^
81 | |   to use for each variable undiluted or initial dilution source.
82 | | 
83 | |   Args:
84 | |     n_variables: Number of variables to dilute
85 | |     n_dilutions: Number of dilutions to perform
86 | |     dilution_factors: Factor by which to dilute each time
87 | |     source_plate: Plate with the source wells
88 | |     target_plate: Plate with the target wells
89 | |     variables_volumes: Volume in the source wells. If None, will transfer the total well volume \
90 | |       divided by the dilution factor.
91 | |     variable_accession_ids: Names of the variables to dilute
92 | | 
93 | |   Returns:
94 | |     variable_details: Dictionary with the details of the dilution strategy for each variable
95 | | 
96 | |   """
   | |_____^ D401
97 |     if n_dilutions * n_variables > target_plate.num_items:
98 |       raise ValueError("Number of dilutions exceeds number of wells in plate")
   |

praxis/backend/commons/dilution.py:98:11: TRY003 Avoid specifying long messages outside the exception class
    |
 96 |   """
 97 |   if n_dilutions * n_variables > target_plate.num_items:
 98 |     raise ValueError("Number of dilutions exceeds number of wells in plate")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
 99 |   dilution_factors, variables_volumes = await coerce_to_list(
100 |     [dilution_factors, variables_volumes],
    |

praxis/backend/commons/dilution.py:98:22: EM101 Exception must not use a string literal, assign to variable first
    |
 96 |   """
 97 |   if n_dilutions * n_variables > target_plate.num_items:
 98 |     raise ValueError("Number of dilutions exceeds number of wells in plate")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
 99 |   dilution_factors, variables_volumes = await coerce_to_list(
100 |     [dilution_factors, variables_volumes],
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:102:3: S101 Use of `assert` detected
    |
100 |     [dilution_factors, variables_volumes],
101 |   )
102 |   assert isinstance(dilution_factors, list) and isinstance(variables_volumes, list)
    |   ^^^^^^ S101
103 |   dilution_factors, variables_volumes = await check_list_length(
104 |     items=[dilution_factors, variables_volumes],
    |

praxis/backend/commons/dilution.py:102:3: PT018 Assertion should be broken down into multiple parts
    |
100 |     [dilution_factors, variables_volumes],
101 |   )
102 |   assert isinstance(dilution_factors, list) and isinstance(variables_volumes, list)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
103 |   dilution_factors, variables_volumes = await check_list_length(
104 |     items=[dilution_factors, variables_volumes],
    |
    = help: Break down assertion into multiple parts

praxis/backend/commons/dilution.py:111:9: PLW2901 `for` loop variable `dilution_factor` overwritten by assignment target
    |
109 |     if isinstance(dilution_factor, list):
110 |       if len(dilution_factor) == 1:
111 |         dilution_factor = dilution_factor * n_dilutions
    |         ^^^^^^^^^^^^^^^ PLW2901
112 |       if len(dilution_factor) != n_dilutions:
113 |         raise ValueError("Number of dilutions does not match with dilution factors")
    |

praxis/backend/commons/dilution.py:113:15: TRY003 Avoid specifying long messages outside the exception class
    |
111 |         dilution_factor = dilution_factor * n_dilutions
112 |       if len(dilution_factor) != n_dilutions:
113 |         raise ValueError("Number of dilutions does not match with dilution factors")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
114 |     else:
115 |       dilution_factor = [dilution_factor] * n_dilutions
    |

praxis/backend/commons/dilution.py:113:26: EM101 Exception must not use a string literal, assign to variable first
    |
111 |         dilution_factor = dilution_factor * n_dilutions
112 |       if len(dilution_factor) != n_dilutions:
113 |         raise ValueError("Number of dilutions does not match with dilution factors")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
114 |     else:
115 |       dilution_factor = [dilution_factor] * n_dilutions
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:115:7: PLW2901 `for` loop variable `dilution_factor` overwritten by assignment target
    |
113 |         raise ValueError("Number of dilutions does not match with dilution factors")
114 |     else:
115 |       dilution_factor = [dilution_factor] * n_dilutions
    |       ^^^^^^^^^^^^^^^ PLW2901
116 |   if (
117 |     n_variables <= target_plate.num_items_y and n_dilutions <= target_plate.num_items_x
    |

praxis/backend/commons/dilution.py:150:7: T201 `print` found
    |
148 |     for var in variable_details:
149 |       column, row = await parse_well_name(variable_details[var]["initial_well"])
150 |       print(f"Variable {var}: {chr(row + 65)}{column}")
    |       ^^^^^ T201
151 |   return variable_details
    |
    = help: Remove `print`

praxis/backend/commons/dilution.py:154:11: PLR0913 Too many arguments in function definition (9 > 5)
    |
154 | async def optimal_dilution_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
155 |   liquid_handler: LiquidHandler,
156 |   source_plate: Plate,
    |

praxis/backend/commons/dilution.py:154:11: ANN201 Missing return type annotation for public function `optimal_dilution_transfer`
    |
154 | async def optimal_dilution_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
155 |   liquid_handler: LiquidHandler,
156 |   source_plate: Plate,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:154:11: D103 Missing docstring in public function
    |
154 | async def optimal_dilution_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
155 |   liquid_handler: LiquidHandler,
156 |   source_plate: Plate,
    |

praxis/backend/commons/dilution.py:169:11: PLR0913 Too many arguments in function definition (14 > 5)
    |
168 | @liquid_handler_setup_check
169 | async def antigen_dilution_series(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
170 |   liquid_handler: LiquidHandler,
171 |   antigen_accession_ids: list[str],
    |

praxis/backend/commons/dilution.py:169:11: ANN201 Missing return type annotation for public function `antigen_dilution_series`
    |
168 | @liquid_handler_setup_check
169 | async def antigen_dilution_series(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
170 |   liquid_handler: LiquidHandler,
171 |   antigen_accession_ids: list[str],
    |
    = help: Add return type annotation

praxis/backend/commons/dilution.py:169:11: D103 Missing docstring in public function
    |
168 | @liquid_handler_setup_check
169 | async def antigen_dilution_series(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ D103
170 |   liquid_handler: LiquidHandler,
171 |   antigen_accession_ids: list[str],
    |

praxis/backend/commons/dilution.py:182:3: FBT001 Boolean-typed positional argument in function definition
    |
180 |   dilution_tips: TipRack,
181 |   dilution_axis: Literal["row", "column", "x", "y", 0, 1, "optimal"] | None = "optimal",
182 |   single_buffer: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
183 |   use_96: bool = True,
184 | ):
    |

praxis/backend/commons/dilution.py:182:3: FBT002 Boolean default positional argument in function definition
    |
180 |   dilution_tips: TipRack,
181 |   dilution_axis: Literal["row", "column", "x", "y", 0, 1, "optimal"] | None = "optimal",
182 |   single_buffer: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
183 |   use_96: bool = True,
184 | ):
    |

praxis/backend/commons/dilution.py:183:3: FBT001 Boolean-typed positional argument in function definition
    |
181 |   dilution_axis: Literal["row", "column", "x", "y", 0, 1, "optimal"] | None = "optimal",
182 |   single_buffer: bool = True,
183 |   use_96: bool = True,
    |   ^^^^^^ FBT001
184 | ):
185 |   antigen_volumes, dilution_factors = await coerce_to_list(
    |

praxis/backend/commons/dilution.py:183:3: FBT002 Boolean default positional argument in function definition
    |
181 |   dilution_axis: Literal["row", "column", "x", "y", 0, 1, "optimal"] | None = "optimal",
182 |   single_buffer: bool = True,
183 |   use_96: bool = True,
    |   ^^^^^^ FBT002
184 | ):
185 |   antigen_volumes, dilution_factors = await coerce_to_list(
    |

praxis/backend/commons/dilution.py:188:3: S101 Use of `assert` detected
    |
186 |     [antigen_volumes, dilution_factors],
187 |   )
188 |   assert isinstance(antigen_volumes, list) and isinstance(dilution_factors, list), (
    |   ^^^^^^ S101
189 |     "Antigen volumes and dilution factors must be lists"
190 |   )
    |

praxis/backend/commons/dilution.py:188:3: PT018 Assertion should be broken down into multiple parts
    |
186 |       [antigen_volumes, dilution_factors],
187 |     )
188 |     assert isinstance(antigen_volumes, list) and isinstance(dilution_factors, list), (
    |  ___^
189 | |     "Antigen volumes and dilution factors must be lists"
190 | |   )
    | |___^ PT018
191 |     antigen_volumes, dilution_factors = await check_list_length(
192 |       items=[antigen_volumes, dilution_factors],
    |
    = help: Break down assertion into multiple parts

praxis/backend/commons/dilution.py:208:31: EM101 Exception must not use a string literal, assign to variable first
    |
206 |     )
207 |   else:
208 |     raise NotImplementedError("Only optimal dilution strategy implemented currently")
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
209 |   print("Antigen dilution details:")
210 |   print(antigen_dilution_details)
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:209:3: T201 `print` found
    |
207 |   else:
208 |     raise NotImplementedError("Only optimal dilution strategy implemented currently")
209 |   print("Antigen dilution details:")
    |   ^^^^^ T201
210 |   print(antigen_dilution_details)
211 |   proceed = input("Proceed with dilution series? (y/n)")
    |
    = help: Remove `print`

praxis/backend/commons/dilution.py:210:3: T201 `print` found
    |
208 |     raise NotImplementedError("Only optimal dilution strategy implemented currently")
209 |   print("Antigen dilution details:")
210 |   print(antigen_dilution_details)
    |   ^^^^^ T201
211 |   proceed = input("Proceed with dilution series? (y/n)")
212 |   proceed = proceed.lower()
    |
    = help: Remove `print`

praxis/backend/commons/dilution.py:214:13: ANN202 Missing return type annotation for private function `check_input`
    |
212 |   proceed = proceed.lower()
213 | 
214 |   async def check_input(proceed: str):
    |             ^^^^^^^^^^^ ANN202
215 |     if proceed not in ["y", "n", "yes", "no", ""]:
216 |       proceed = input("Input invalid. Proceed with dilution series? (y/n)")
    |
    = help: Add return type annotation

praxis/backend/commons/dilution.py:225:11: TRY003 Avoid specifying long messages outside the exception class
    |
223 |   if proceed == "n":
224 |     return antigen_dilution_details
225 |     raise RuntimeError("Dilution series aborted")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
226 |   buffer_transfer_volumes = [
227 |     antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i]
    |

praxis/backend/commons/dilution.py:225:24: EM101 Exception must not use a string literal, assign to variable first
    |
223 |   if proceed == "n":
224 |     return antigen_dilution_details
225 |     raise RuntimeError("Dilution series aborted")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
226 |   buffer_transfer_volumes = [
227 |     antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i]
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:233:15: TRY003 Avoid specifying long messages outside the exception class
    |
231 |     if use_96:
232 |       if not single_buffer:
233 |         raise ValueError("Single buffer not specified but 96 transfer head specified")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
234 |       buffer_transfer_volume = buffer_transfer_volumes[0]
235 |       await transfer_buffer96(
    |

praxis/backend/commons/dilution.py:233:26: EM101 Exception must not use a string literal, assign to variable first
    |
231 |     if use_96:
232 |       if not single_buffer:
233 |         raise ValueError("Single buffer not specified but 96 transfer head specified")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
234 |       buffer_transfer_volume = buffer_transfer_volumes[0]
235 |       await transfer_buffer96(
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:245:33: EM101 Exception must not use a string literal, assign to variable first
    |
243 |       )
244 |     else:
245 |       raise NotImplementedError("8-well transfer head not implemented")
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
246 |     await serial_dilution(
247 |       liquid_handler=liquid_handler,
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:246:5: RET503 Missing explicit `return` at the end of function able to return non-`None` value
    |
244 |       else:
245 |         raise NotImplementedError("8-well transfer head not implemented")
246 |       await serial_dilution(
    |  _____^
247 | |       liquid_handler=liquid_handler,
248 | |       tips=dilution_tips,
249 | |       plate=dilution_plate,
250 | |       variable_dict=antigen_dilution_details,
251 | |       n_dilutions=n_dilutions,
252 | |       dilution_factors=dilution_factors,
253 | |       source_volumes=antigen_volumes,
254 | |       mix_cycles=mix_cycles,
255 | |     )
    | |_____^ RET503
256 |     elif len(set(buffer_transfer_volumes)) != 1 and use_96:
257 |       raise ValueError(
    |
    = help: Add explicit `return` statement

praxis/backend/commons/dilution.py:257:11: TRY003 Avoid specifying long messages outside the exception class
    |
255 |       )
256 |     elif len(set(buffer_transfer_volumes)) != 1 and use_96:
257 |       raise ValueError(
    |  ___________^
258 | |       "Buffer transfer volumes not equal but 96 transfer head was specified \
259 | |       for buffer transfer",
260 | |     )
    | |_____^ TRY003
261 |     else:
262 |       raise NotImplementedError(
    |

praxis/backend/commons/dilution.py:258:7: EM101 Exception must not use a string literal, assign to variable first
    |
256 |     elif len(set(buffer_transfer_volumes)) != 1 and use_96:
257 |       raise ValueError(
258 |         "Buffer transfer volumes not equal but 96 transfer head was specified \
    |  _______^
259 | |       for buffer transfer",
    | |__________________________^ EM101
260 |       )
261 |     else:
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:263:7: EM101 Exception must not use a string literal, assign to variable first
    |
261 |   else:
262 |     raise NotImplementedError(
263 |       "More complex dilution factors per variable not implemented",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
264 |     )
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:268:11: PLR0913 Too many arguments in function definition (7 > 5)
    |
267 | @liquid_handler_setup_check
268 | async def transfer_buffer96(
    |           ^^^^^^^^^^^^^^^^^ PLR0913
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
    |

praxis/backend/commons/dilution.py:268:11: ANN201 Missing return type annotation for public function `transfer_buffer96`
    |
267 | @liquid_handler_setup_check
268 | async def transfer_buffer96(
    |           ^^^^^^^^^^^^^^^^^ ANN201
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:268:11: D103 Missing docstring in public function
    |
267 | @liquid_handler_setup_check
268 | async def transfer_buffer96(
    |           ^^^^^^^^^^^^^^^^^ D103
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
    |

praxis/backend/commons/dilution.py:271:31: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
271 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ TD002
272 |   target_plate: Plate,
273 |   buffer_transfer_volume: float,
    |

praxis/backend/commons/dilution.py:271:31: TD003 Missing issue link on the line following this TODO
    |
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
271 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ TD003
272 |   target_plate: Plate,
273 |   buffer_transfer_volume: float,
    |

praxis/backend/commons/dilution.py:271:31: FIX002 Line contains TODO, consider resolving the issue
    |
269 |   liquid_handler: LiquidHandler,
270 |   tip_rack: TipRack,
271 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ FIX002
272 |   target_plate: Plate,
273 |   buffer_transfer_volume: float,
    |

praxis/backend/commons/dilution.py:275:3: FBT001 Boolean-typed positional argument in function definition
    |
273 |   buffer_transfer_volume: float,
274 |   buffer_total_volume: float,
275 |   return_tips: bool = False,
    |   ^^^^^^^^^^^ FBT001
276 | ):
277 |   if buffer_transfer_volume * 96 > buffer_total_volume:
    |

praxis/backend/commons/dilution.py:275:3: FBT002 Boolean default positional argument in function definition
    |
273 |   buffer_transfer_volume: float,
274 |   buffer_total_volume: float,
275 |   return_tips: bool = False,
    |   ^^^^^^^^^^^ FBT002
276 | ):
277 |   if buffer_transfer_volume * 96 > buffer_total_volume:
    |

praxis/backend/commons/dilution.py:278:11: TRY003 Avoid specifying long messages outside the exception class
    |
276 | ):
277 |   if buffer_transfer_volume * 96 > buffer_total_volume:
278 |     raise RuntimeError("Buffer volume insufficient")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
279 |   await liquid_handler.pick_up_tips96(tip_rack=tip_rack)
280 |   await liquid_handler.aspirate96(
    |

praxis/backend/commons/dilution.py:278:24: EM101 Exception must not use a string literal, assign to variable first
    |
276 | ):
277 |   if buffer_transfer_volume * 96 > buffer_total_volume:
278 |     raise RuntimeError("Buffer volume insufficient")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
279 |   await liquid_handler.pick_up_tips96(tip_rack=tip_rack)
280 |   await liquid_handler.aspirate96(
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:289:11: C901 `serial_dilution` is too complex (20 > 10)
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ C901
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:289:11: PLR0913 Too many arguments in function definition (8 > 5)
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ PLR0913
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:289:11: PLR0912 Too many branches (22 > 12)
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ PLR0912
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:289:11: PLR0915 Too many statements (71 > 50)
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ PLR0915
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:289:11: ANN201 Missing return type annotation for public function `serial_dilution`
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ ANN201
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:289:11: D417 Missing argument descriptions in the docstring for `serial_dilution`: `dilution_factors`, `mix_cycles`, `plate`, `tips`, `variable_dict`
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
    |           ^^^^^^^^^^^^^^^ D417
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
291 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:290:37: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
    |                                     ^^^^ TD002
291 |   tips: TipRack,
292 |   plate: Plate,
    |

praxis/backend/commons/dilution.py:290:37: TD003 Missing issue link on the line following this TODO
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
    |                                     ^^^^ TD003
291 |   tips: TipRack,
292 |   plate: Plate,
    |

praxis/backend/commons/dilution.py:290:37: FIX002 Line contains TODO, consider resolving the issue
    |
288 | @liquid_handler_setup_check
289 | async def serial_dilution(
290 |   liquid_handler: LiquidHandler,  # TODO: handle single row and snaked dilutions that are longer than a column
    |                                     ^^^^ FIX002
291 |   tips: TipRack,
292 |   plate: Plate,
    |

praxis/backend/commons/dilution.py:299:3: D205 1 blank line required between summary line and description
    |
297 |     mix_cycles: int = 10,
298 |   ):
299 |     """Completes a serial dilution. Function assumes you are diluting from the top row of the source plate
    |  ___^
300 | |   and diluting down the columns of the target plate. If you do not specify a source volume, the
301 | |   function will assume the maximum well volume divided by the dilution factor.
302 | | 
303 | |   Args:
304 | |     liquid_handler: LiquidHandler object
305 | |     n_dilutions: Number of dilutions to perform
306 | |     dilution_factor: Factor by which to dilute each time
307 | |     source: Plate with the source wells
308 | |     n_replicates: Number of replicates to perform. Per replicate, the dilution series will be \
309 | |       per column.
310 | |     source_volumes: Volume in the top columns of the source plate. If None, will transfer the \
311 | |       total well volume divided by the dilution factor.
312 | |     target_plate: Plate to transfer to. If None, will transfer on the source plate.
313 | | 
314 | |   """
    | |_____^ D205
315 |     if source_volumes is None:
316 |       source_volumes = [plate[0][0].max_volume] * len(variable_dict)
    |
    = help: Insert single blank line

praxis/backend/commons/dilution.py:320:3: S101 Use of `assert` detected
    |
318 |     [dilution_factors, source_volumes],
319 |   )
320 |   assert isinstance(dilution_factors, list) and isinstance(source_volumes, list)
    |   ^^^^^^ S101
321 |   dilution_factors, source_volumes = await check_list_length(
322 |     [dilution_factors, source_volumes], True, len(variable_dict),
    |

praxis/backend/commons/dilution.py:320:3: PT018 Assertion should be broken down into multiple parts
    |
318 |     [dilution_factors, source_volumes],
319 |   )
320 |   assert isinstance(dilution_factors, list) and isinstance(source_volumes, list)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
321 |   dilution_factors, source_volumes = await check_list_length(
322 |     [dilution_factors, source_volumes], True, len(variable_dict),
    |
    = help: Break down assertion into multiple parts

praxis/backend/commons/dilution.py:322:41: FBT003 Boolean positional value in function call
    |
320 |   assert isinstance(dilution_factors, list) and isinstance(source_volumes, list)
321 |   dilution_factors, source_volumes = await check_list_length(
322 |     [dilution_factors, source_volumes], True, len(variable_dict),
    |                                         ^^^^ FBT003
323 |   )
324 |   initial_wells = [variable_dict[var]["initial_well"] for var in variable_dict]
    |

praxis/backend/commons/dilution.py:337:13: TRY003 Avoid specifying long messages outside the exception class
    |
335 |       snaked.append(var)
336 |     else:
337 |       raise ValueError("Invalid dilution strategy")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
338 |   print([variable_dict[var]["tip_spot"] for var in single_row])
339 |   await liquid_handler.pick_up_tips(
    |

praxis/backend/commons/dilution.py:337:24: EM101 Exception must not use a string literal, assign to variable first
    |
335 |       snaked.append(var)
336 |     else:
337 |       raise ValueError("Invalid dilution strategy")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
338 |   print([variable_dict[var]["tip_spot"] for var in single_row])
339 |   await liquid_handler.pick_up_tips(
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:338:3: T201 `print` found
    |
336 |     else:
337 |       raise ValueError("Invalid dilution strategy")
338 |   print([variable_dict[var]["tip_spot"] for var in single_row])
    |   ^^^^^ T201
339 |   await liquid_handler.pick_up_tips(
340 |     tip_spots=[variable_dict[var]["tip_spot"] for var in single_row],
    |
    = help: Remove `print`

praxis/backend/commons/dilution.py:383:31: EM101 Exception must not use a string literal, assign to variable first
    |
381 |     return
382 |   if len(snaked) > tips.num_items_y:
383 |     raise NotImplementedError("More variables than tips in tip rack")
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
384 |   await liquid_handler.pick_up_tips(
385 |     tip_spots=[variable_dict[var]["tip_spot"] for var in snaked],
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:446:11: PLR0913 Too many arguments in function definition (13 > 5)
    |
446 | async def handle_dilution(
    |           ^^^^^^^^^^^^^^^ PLR0913
447 |   liquid_handler: LiquidHandler,
448 |   antigen_accession_ids: list[str],
    |

praxis/backend/commons/dilution.py:459:3: FBT001 Boolean-typed positional argument in function definition
    |
457 |   buffer_tips: TipRack,
458 |   dilution_tips: TipRack,
459 |   constant_dilution: bool = True,
    |   ^^^^^^^^^^^^^^^^^ FBT001
460 | ) -> None:
461 |   """Handles the dilution series for antigens."""
    |

praxis/backend/commons/dilution.py:459:3: FBT002 Boolean default positional argument in function definition
    |
457 |   buffer_tips: TipRack,
458 |   dilution_tips: TipRack,
459 |   constant_dilution: bool = True,
    |   ^^^^^^^^^^^^^^^^^ FBT002
460 | ) -> None:
461 |   """Handles the dilution series for antigens."""
    |

praxis/backend/commons/dilution.py:461:3: D401 First line of docstring should be in imperative mood: "Handles the dilution series for antigens."
    |
459 |   constant_dilution: bool = True,
460 | ) -> None:
461 |   """Handles the dilution series for antigens."""
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
462 |   if not isinstance(antigen_volumes, list) or not isinstance(dilution_factors, list):
463 |     constant_dilution = True
    |

praxis/backend/commons/dilution.py:464:10: B007 Loop control variable `antigen_accession_id` not used within loop body
    |
462 |   if not isinstance(antigen_volumes, list) or not isinstance(dilution_factors, list):
463 |     constant_dilution = True
464 |   for i, antigen_accession_id in enumerate(antigen_accession_ids):
    |          ^^^^^^^^^^^^^^^^^^^^ B007
465 |     if constant_dilution:
466 |       buffer_transfer_volumes = [
    |
    = help: Rename unused `antigen_accession_id` to `_antigen_accession_id`

praxis/backend/commons/dilution.py:471:9: EM101 Exception must not use a string literal, assign to variable first
    |
469 |     else:
470 |       raise NotImplementedError(
471 |         "More complex dilution factors per variable not implemented",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
472 |       )
473 |     i
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:473:5: B018 Found useless expression. Either assign it to a variable or remove it.
    |
471 |         "More complex dilution factors per variable not implemented",
472 |       )
473 |     i
    |     ^ B018
474 |     column_index = i * dilution_plate.num_items_y
475 |     dilution_wells = [j + (column_index) for j in range(n_dilutions)]
    |

praxis/backend/commons/dilution.py:503:11: PLR0913 Too many arguments in function definition (11 > 5)
    |
503 | async def transfer_buffer(
    |           ^^^^^^^^^^^^^^^ PLR0913
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |

praxis/backend/commons/dilution.py:503:11: ANN201 Missing return type annotation for public function `transfer_buffer`
    |
503 | async def transfer_buffer(
    |           ^^^^^^^^^^^^^^^ ANN201
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:503:11: D103 Missing docstring in public function
    |
503 | async def transfer_buffer(
    |           ^^^^^^^^^^^^^^^ D103
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |

praxis/backend/commons/dilution.py:505:31: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
503 | async def transfer_buffer(
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ TD002
506 |   target_plate: Plate,
507 |   target_wells: int | str | list[int] | list[str] | list[Well],
    |

praxis/backend/commons/dilution.py:505:31: TD003 Missing issue link on the line following this TODO
    |
503 | async def transfer_buffer(
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ TD003
506 |   target_plate: Plate,
507 |   target_wells: int | str | list[int] | list[str] | list[Well],
    |

praxis/backend/commons/dilution.py:505:31: FIX002 Line contains TODO, consider resolving the issue
    |
503 | async def transfer_buffer(
504 |   liquid_handler: LiquidHandler,
505 |   buffer_reservoir: Plate,  # TODO: allow for reservoir
    |                               ^^^^ FIX002
506 |   target_plate: Plate,
507 |   target_wells: int | str | list[int] | list[str] | list[Well],
    |

praxis/backend/commons/dilution.py:511:3: ARG001 Unused function argument: `mix_cycles`
    |
509 |   buffer_total_volume: float | list[float],
510 |   buffer_wells: int | str | list[int] | list[str] | list[Well],
511 |   mix_cycles: int = 0,
    |   ^^^^^^^^^^ ARG001
512 |   mix_proportion: float = 0.5,
513 |   mix_volumes: float | list[float] | None = None,
    |

praxis/backend/commons/dilution.py:512:3: ARG001 Unused function argument: `mix_proportion`
    |
510 |   buffer_wells: int | str | list[int] | list[str] | list[Well],
511 |   mix_cycles: int = 0,
512 |   mix_proportion: float = 0.5,
    |   ^^^^^^^^^^^^^^ ARG001
513 |   mix_volumes: float | list[float] | None = None,
514 |   single_buffer: bool = True,
    |

praxis/backend/commons/dilution.py:513:3: ARG001 Unused function argument: `mix_volumes`
    |
511 |   mix_cycles: int = 0,
512 |   mix_proportion: float = 0.5,
513 |   mix_volumes: float | list[float] | None = None,
    |   ^^^^^^^^^^^ ARG001
514 |   single_buffer: bool = True,
515 | ):
    |

praxis/backend/commons/dilution.py:514:3: FBT001 Boolean-typed positional argument in function definition
    |
512 |   mix_proportion: float = 0.5,
513 |   mix_volumes: float | list[float] | None = None,
514 |   single_buffer: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
515 | ):
516 |   if single_buffer:
    |

praxis/backend/commons/dilution.py:514:3: FBT002 Boolean default positional argument in function definition
    |
512 |   mix_proportion: float = 0.5,
513 |   mix_volumes: float | list[float] | None = None,
514 |   single_buffer: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
515 | ):
516 |   if single_buffer:
    |

praxis/backend/commons/dilution.py:517:5: SIM102 Use a single `if` statement instead of nested `if` statements
    |
515 |   ):
516 |     if single_buffer:
517 |       if isinstance(buffer_total_volume, list):
    |  _____^
518 | |       if len(buffer_total_volume) > 1:
    | |______________________________________^ SIM102
519 |           raise ValueError(
520 |             "Total buffer volume variable list, but single buffer specified",
    |
    = help: Combine `if` statements using `and`

praxis/backend/commons/dilution.py:519:15: TRY003 Avoid specifying long messages outside the exception class
    |
517 |       if isinstance(buffer_total_volume, list):
518 |         if len(buffer_total_volume) > 1:
519 |           raise ValueError(
    |  _______________^
520 | |           "Total buffer volume variable list, but single buffer specified",
521 | |         )
    | |_________^ TRY003
522 |       if sum(buffer_transfer_volumes) > buffer_total_volume:
523 |         raise Value("Buffer volume insufficient")
    |

praxis/backend/commons/dilution.py:520:11: EM101 Exception must not use a string literal, assign to variable first
    |
518 |       if len(buffer_total_volume) > 1:
519 |         raise ValueError(
520 |           "Total buffer volume variable list, but single buffer specified",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
521 |         )
522 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:523:13: TRY003 Avoid specifying long messages outside the exception class
    |
521 |         )
522 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
523 |       raise Value("Buffer volume insufficient")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
524 |   await liquid_handler.aspirate(
525 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |

praxis/backend/commons/dilution.py:523:13: F821 Undefined name `Value`
    |
521 |         )
522 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
523 |       raise Value("Buffer volume insufficient")
    |             ^^^^^ F821
524 |   await liquid_handler.aspirate(
525 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |

praxis/backend/commons/dilution.py:523:19: EM101 Exception must not use a string literal, assign to variable first
    |
521 |         )
522 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
523 |       raise Value("Buffer volume insufficient")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
524 |   await liquid_handler.aspirate(
525 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:525:52: F821 Undefined name `buffer_volumes`
    |
523 |       raise Value("Buffer volume insufficient")
524 |   await liquid_handler.aspirate(
525 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |                                                    ^^^^^^^^^^^^^^ F821
526 |   )
527 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |

praxis/backend/commons/dilution.py:527:66: F821 Undefined name `buffer_volumes`
    |
525 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
526 |   )
527 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |                                                                  ^^^^^^^^^^^^^^ F821
    |

praxis/backend/commons/dilution.py:531:11: ANN201 Missing return type annotation for public function `transfer_top_row`
    |
530 | @liquid_handler_setup_check
531 | async def transfer_top_row(
    |           ^^^^^^^^^^^^^^^^ ANN201
532 |   liquid_handler: LiquidHandler,
533 |   tips: TipRack,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:531:11: D103 Missing docstring in public function
    |
530 | @liquid_handler_setup_check
531 | async def transfer_top_row(
    |           ^^^^^^^^^^^^^^^^ D103
532 |   liquid_handler: LiquidHandler,
533 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:534:27: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
532 |   liquid_handler: LiquidHandler,
533 |   tips: TipRack,
534 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ TD002
535 |   target_plate: Plate,
536 | ):
    |

praxis/backend/commons/dilution.py:534:27: TD003 Missing issue link on the line following this TODO
    |
532 |   liquid_handler: LiquidHandler,
533 |   tips: TipRack,
534 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ TD003
535 |   target_plate: Plate,
536 | ):
    |

praxis/backend/commons/dilution.py:534:27: FIX002 Line contains TODO, consider resolving the issue
    |
532 |   liquid_handler: LiquidHandler,
533 |   tips: TipRack,
534 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ FIX002
535 |   target_plate: Plate,
536 | ):
    |

praxis/backend/commons/dilution.py:539:11: TRY003 Avoid specifying long messages outside the exception class
    |
537 |     n_columns = source_plate.num_items_x
538 |     if source_plate.num_items_x < n_columns or target_plate.num_items_x < n_columns:
539 |       raise ExperimentError(
    |  ___________^
540 | |       f"{'Source' if source_plate.num_items_x < n_columns else 'Target'} \
541 | |       plate does not have enough columns",
542 | |     )
    | |_____^ TRY003
543 |     for i in range(n_columns):
544 |       liquid_handler.pick_up_tips(tip_spots=tips[i * n_columns])
    |

praxis/backend/commons/dilution.py:540:7: EM102 Exception must not use an f-string literal, assign to variable first
    |
538 |     if source_plate.num_items_x < n_columns or target_plate.num_items_x < n_columns:
539 |       raise ExperimentError(
540 |         f"{'Source' if source_plate.num_items_x < n_columns else 'Target'} \
    |  _______^
541 | |       plate does not have enough columns",
    | |_________________________________________^ EM102
542 |       )
543 |     for i in range(n_columns):
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/commons/dilution.py:555:11: C901 `dilution_series` is too complex (12 > 10)
    |
555 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^ C901
556 |   liquid_handler: LiquidHandler,
557 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:555:11: PLR0913 Too many arguments in function definition (8 > 5)
    |
555 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^ PLR0913
556 |   liquid_handler: LiquidHandler,
557 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:555:11: PLR0912 Too many branches (13 > 12)
    |
555 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^ PLR0912
556 |   liquid_handler: LiquidHandler,
557 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:555:11: ANN201 Missing return type annotation for public function `dilution_series`
    |
555 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^ ANN201
556 |   liquid_handler: LiquidHandler,
557 |   tips: TipRack,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/dilution.py:555:11: D417 Missing argument descriptions in the docstring for `dilution_series`: `dilution_factors`, `mix_cycles`, `source_plate`, `tips`
    |
555 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^ D417
556 |   liquid_handler: LiquidHandler,
557 |   tips: TipRack,
    |

praxis/backend/commons/dilution.py:560:27: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
558 |   n_dilutions: int,
559 |   dilution_factors: float | list[float],
560 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ TD002
561 |   mix_cycles: int = 10,
562 |   source_volumes: int | list[int] | None = None,
    |

praxis/backend/commons/dilution.py:560:27: TD003 Missing issue link on the line following this TODO
    |
558 |   n_dilutions: int,
559 |   dilution_factors: float | list[float],
560 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ TD003
561 |   mix_cycles: int = 10,
562 |   source_volumes: int | list[int] | None = None,
    |

praxis/backend/commons/dilution.py:560:27: FIX002 Line contains TODO, consider resolving the issue
    |
558 |   n_dilutions: int,
559 |   dilution_factors: float | list[float],
560 |   source_plate: Plate,  # TODO: allow for reservoir
    |                           ^^^^ FIX002
561 |   mix_cycles: int = 10,
562 |   source_volumes: int | list[int] | None = None,
    |

praxis/backend/commons/dilution.py:565:3: D205 1 blank line required between summary line and description
    |
563 |     target_plate: Plate | None = None,
564 |   ):
565 |     """Completes a dilution series. If using replicates, these are treated as separate dilution series.
    |  ___^
566 | |   Function assumes you are diluting from the top row of the source plate and diluting down the
567 | |   columns of the target plate.
568 | | 
569 | |   Args:
570 | |     liquid_handler: LiquidHandler object
571 | |     n_dilutions: Number of dilutions to perform
572 | |     dilution_factor: Factor by which to dilute each time
573 | |     source: Plate with the source wells
574 | |     n_replicates: Number of replicates to perform. Per replicate, the dilution series will be \
575 | |       per column.
576 | |     source_volumes: Volume in the top columns of the source plate. If None, will transfer the \
577 | |       total well volume divided by the dilution factor.
578 | |     target_plate: Plate to transfer to. If None, will transfer on the source plate.
579 | | 
580 | |   """
    | |_____^ D205
581 |     if isinstance(dilution_factors, list) and len(dilution_factors) != n_replicates:
582 |       raise ExperimentError("Number of dilutions does not match with dilution factors.")
    |
    = help: Insert single blank line

praxis/backend/commons/dilution.py:581:70: F821 Undefined name `n_replicates`
    |
580 |   """
581 |   if isinstance(dilution_factors, list) and len(dilution_factors) != n_replicates:
    |                                                                      ^^^^^^^^^^^^ F821
582 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
583 |   if isinstance(source_volumes, int):
    |

praxis/backend/commons/dilution.py:582:11: TRY003 Avoid specifying long messages outside the exception class
    |
580 |   """
581 |   if isinstance(dilution_factors, list) and len(dilution_factors) != n_replicates:
582 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
583 |   if isinstance(source_volumes, int):
584 |     source_volumes = [source_volumes] * n_replicates
    |

praxis/backend/commons/dilution.py:582:27: EM101 Exception must not use a string literal, assign to variable first
    |
580 |   """
581 |   if isinstance(dilution_factors, list) and len(dilution_factors) != n_replicates:
582 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
583 |   if isinstance(source_volumes, int):
584 |     source_volumes = [source_volumes] * n_replicates
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:584:41: F821 Undefined name `n_replicates`
    |
582 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
583 |   if isinstance(source_volumes, int):
584 |     source_volumes = [source_volumes] * n_replicates
    |                                         ^^^^^^^^^^^^ F821
585 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
    |

praxis/backend/commons/dilution.py:585:66: F821 Undefined name `n_replicates`
    |
583 |   if isinstance(source_volumes, int):
584 |     source_volumes = [source_volumes] * n_replicates
585 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
    |                                                                  ^^^^^^^^^^^^ F821
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
587 |   if not liquid_handler.setup_finished:
    |

praxis/backend/commons/dilution.py:586:11: TRY003 Avoid specifying long messages outside the exception class
    |
584 |     source_volumes = [source_volumes] * n_replicates
585 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
587 |   if not liquid_handler.setup_finished:
588 |     raise ExperimentError("Liquid handler not set up.")
    |

praxis/backend/commons/dilution.py:586:27: EM101 Exception must not use a string literal, assign to variable first
    |
584 |     source_volumes = [source_volumes] * n_replicates
585 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
587 |   if not liquid_handler.setup_finished:
588 |     raise ExperimentError("Liquid handler not set up.")
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:588:11: TRY003 Avoid specifying long messages outside the exception class
    |
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
587 |   if not liquid_handler.setup_finished:
588 |     raise ExperimentError("Liquid handler not set up.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
589 |   if n_dilutions > source_plate.num_items_y + 1:
590 |     raise ExperimentError(
    |

praxis/backend/commons/dilution.py:588:27: EM101 Exception must not use a string literal, assign to variable first
    |
586 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
587 |   if not liquid_handler.setup_finished:
588 |     raise ExperimentError("Liquid handler not set up.")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
589 |   if n_dilutions > source_plate.num_items_y + 1:
590 |     raise ExperimentError(
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:590:11: TRY003 Avoid specifying long messages outside the exception class
    |
588 |       raise ExperimentError("Liquid handler not set up.")
589 |     if n_dilutions > source_plate.num_items_y + 1:
590 |       raise ExperimentError(
    |  ___________^
591 | |       "Number of dilutions exceeds number of wells per column in plate.",
592 | |     )
    | |_____^ TRY003
593 |     if n_replicates > source_plate.num_items_x:
594 |       raise ExperimentError(
    |

praxis/backend/commons/dilution.py:591:7: EM101 Exception must not use a string literal, assign to variable first
    |
589 |   if n_dilutions > source_plate.num_items_y + 1:
590 |     raise ExperimentError(
591 |       "Number of dilutions exceeds number of wells per column in plate.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
592 |     )
593 |   if n_replicates > source_plate.num_items_x:
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:593:6: F821 Undefined name `n_replicates`
    |
591 |       "Number of dilutions exceeds number of wells per column in plate.",
592 |     )
593 |   if n_replicates > source_plate.num_items_x:
    |      ^^^^^^^^^^^^ F821
594 |     raise ExperimentError(
595 |       "Number of replicates exceeds number of wells per row in plate.",
    |

praxis/backend/commons/dilution.py:594:11: TRY003 Avoid specifying long messages outside the exception class
    |
592 |       )
593 |     if n_replicates > source_plate.num_items_x:
594 |       raise ExperimentError(
    |  ___________^
595 | |       "Number of replicates exceeds number of wells per row in plate.",
596 | |     )
    | |_____^ TRY003
597 |     if not target_plate or target_plate == source_plate:
598 |       target_plate = source_plate
    |

praxis/backend/commons/dilution.py:595:7: EM101 Exception must not use a string literal, assign to variable first
    |
593 |   if n_replicates > source_plate.num_items_x:
594 |     raise ExperimentError(
595 |       "Number of replicates exceeds number of wells per row in plate.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
596 |     )
597 |   if not target_plate or target_plate == source_plate:
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/dilution.py:606:18: F821 Undefined name `n_replicates`
    |
604 |       target_plate=target_plate,
605 |     )
606 |   for i in range(n_replicates):
    |                  ^^^^^^^^^^^^ F821
607 |     well_number = i * target_plate.num_items_y
608 |     if source_volumes:
    |

praxis/backend/commons/dilution.py:608:5: SIM108 Use ternary operator `source_volume = source_volumes[i] if source_volumes else source_plate.well_volume(i * source_plate.num_items_y)` instead of `if`-`else`-block
    |
606 |     for i in range(n_replicates):
607 |       well_number = i * target_plate.num_items_y
608 |       if source_volumes:
    |  _____^
609 | |       source_volume = source_volumes[i]
610 | |     else:
611 | |       source_volume = source_plate.well_volume(i * source_plate.num_items_y)
    | |____________________________________________________________________________^ SIM108
612 |       await liquid_handler.pick_up_tips(tips[well_number])
613 |       for j in range(n_dilutions):
    |
    = help: Replace `if`-`else`-block with `source_volume = source_volumes[i] if source_volumes else source_plate.well_volume(i * source_plate.num_items_y)`

praxis/backend/commons/liquid_handling.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/liquid_handling.py:25:3: D401 First line of docstring should be in imperative mood: "Splits a list of resources into sublists based on their column indices."
   |
24 |   async def split_along_columns(resources: list[Container]) -> list[list[Resource]]:
25 |     """Splits a list of resources into sublists based on their column indices.
   |  ___^
26 | | 
27 | |   Args:
28 | |     resources (list[Resource]): The resources to split.
29 | | 
30 | |   Returns:
31 | |     list[list[Resource]]: The resources split into sublists based on their column indices.
32 | | 
33 | |   """
   | |_____^ D401
34 |     if not all(isinstance(resources, Resource) for resource in resources):
35 |       raise ValueError("Invalid well type.")
   |

praxis/backend/commons/liquid_handling.py:35:11: TRY003 Avoid specifying long messages outside the exception class
   |
33 |   """
34 |   if not all(isinstance(resources, Resource) for resource in resources):
35 |     raise ValueError("Invalid well type.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
36 |   if all(isinstance(resource, Plate) for resource in resources):
37 |     return [list(resource) for resource in resources]
   |

praxis/backend/commons/liquid_handling.py:35:22: EM101 Exception must not use a string literal, assign to variable first
   |
33 |   """
34 |   if not all(isinstance(resources, Resource) for resource in resources):
35 |     raise ValueError("Invalid well type.")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
36 |   if all(isinstance(resource, Plate) for resource in resources):
37 |     return [list(resource) for resource in resources]
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:39:23: F821 Undefined name `parse_well_name`
   |
37 |     return [list(resource) for resource in resources]
38 |   if all(isinstance(resource, Well) for resource in resources):
39 |     columns = [(await parse_well_name(well))[0] for well in wells]
   |                       ^^^^^^^^^^^^^^^ F821
40 |   return [
41 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |

praxis/backend/commons/liquid_handling.py:39:61: F821 Undefined name `wells`
   |
37 |     return [list(resource) for resource in resources]
38 |   if all(isinstance(resource, Well) for resource in resources):
39 |     columns = [(await parse_well_name(well))[0] for well in wells]
   |                                                             ^^^^^ F821
40 |   return [
41 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |

praxis/backend/commons/liquid_handling.py:41:44: F821 Undefined name `wells`
   |
39 |     columns = [(await parse_well_name(well))[0] for well in wells]
40 |   return [
41 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |                                            ^^^^^ F821
42 |     for i in range(max(columns) + 1)
43 |   ]
   |

praxis/backend/commons/liquid_handling.py:49:3: D419 Docstring is empty
   |
47 |   mix_proportion: float | None, mix_volumes: float | list[float] | None,
48 | ) -> tuple[float | None, list[float] | None]:
49 |   """ """
   |   ^^^^^^^ D419
50 |   if mix_volumes is None and mix_proportion is None:
51 |     mix_proportion = 0.5
   |

praxis/backend/commons/liquid_handling.py:53:11: TRY003 Avoid specifying long messages outside the exception class
   |
51 |     mix_proportion = 0.5
52 |   elif mix_volumes is not None and mix_proportion is not None:
53 |     raise ValueError("Use either mix proportion or mix volumes, not both.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
54 |   mix_volumes = (
55 |     [mix_volumes]
   |

praxis/backend/commons/liquid_handling.py:53:22: EM101 Exception must not use a string literal, assign to variable first
   |
51 |     mix_proportion = 0.5
52 |   elif mix_volumes is not None and mix_proportion is not None:
53 |     raise ValueError("Use either mix proportion or mix volumes, not both.")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
54 |   mix_volumes = (
55 |     [mix_volumes]
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:67:3: D419 Docstring is empty
   |
65 |   mix_volumes: list[float] | None = None,
66 | ) -> list[float]:
67 |   """ """
   |   ^^^^^^^ D419
68 |   if mix_volumes is None and mix_proportion is None:
69 |     raise ValueError("Either mix_proportion or mix_volumes must be provided.")
   |

praxis/backend/commons/liquid_handling.py:69:11: TRY003 Avoid specifying long messages outside the exception class
   |
67 |   """ """
68 |   if mix_volumes is None and mix_proportion is None:
69 |     raise ValueError("Either mix_proportion or mix_volumes must be provided.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
70 |   if mix_volumes is not None and mix_proportion is not None:
71 |     warnings.warn("Mix proportion and mix volumes are both set, using mix volumes.")
   |

praxis/backend/commons/liquid_handling.py:69:22: EM101 Exception must not use a string literal, assign to variable first
   |
67 |   """ """
68 |   if mix_volumes is None and mix_proportion is None:
69 |     raise ValueError("Either mix_proportion or mix_volumes must be provided.")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
70 |   if mix_volumes is not None and mix_proportion is not None:
71 |     warnings.warn("Mix proportion and mix volumes are both set, using mix volumes.")
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:71:5: B028 No explicit `stacklevel` keyword argument found
   |
69 |     raise ValueError("Either mix_proportion or mix_volumes must be provided.")
70 |   if mix_volumes is not None and mix_proportion is not None:
71 |     warnings.warn("Mix proportion and mix volumes are both set, using mix volumes.")
   |     ^^^^^^^^^^^^^ B028
72 |   if mix_volumes is not None:
73 |     return mix_volumes
   |

praxis/backend/commons/liquid_handling.py:74:3: S101 Use of `assert` detected
   |
72 |   if mix_volumes is not None:
73 |     return mix_volumes
74 |   assert mix_proportion is not None, "Mix proportion must be provided."
   |   ^^^^^^ S101
75 |   return [v * mix_proportion * 10 for v in volumes]  # * 10 for hamilton
   |

praxis/backend/commons/liquid_handling.py:79:11: PLR0913 Too many arguments in function definition (10 > 5)
   |
78 | @liquid_handler_setup_check
79 | async def transfer_with_mixing(
   |           ^^^^^^^^^^^^^^^^^^^^ PLR0913
80 |   liquid_handler: LiquidHandler,
81 |   sources: Container | list[Container],
   |

praxis/backend/commons/liquid_handling.py:86:3: FBT001 Boolean-typed positional argument in function definition
   |
84 |   transfer_tips: TipSpot | TipRack | list[TipSpot] | list[TipRack],
85 |   mix_cycles: int | list[int] = 10,
86 |   return_tips: bool = True,
   |   ^^^^^^^^^^^ FBT001
87 |   mix_proportion: float | None = None,
88 |   mix_volumes: float | list[float] | None = None,
   |

praxis/backend/commons/liquid_handling.py:86:3: FBT002 Boolean default positional argument in function definition
   |
84 |   transfer_tips: TipSpot | TipRack | list[TipSpot] | list[TipRack],
85 |   mix_cycles: int | list[int] = 10,
86 |   return_tips: bool = True,
   |   ^^^^^^^^^^^ FBT002
87 |   mix_proportion: float | None = None,
88 |   mix_volumes: float | list[float] | None = None,
   |

praxis/backend/commons/liquid_handling.py:124:3: S101 Use of `assert` detected
    |
122 |   )
123 |   await coerce_to_list(items=[sources, targets, volumes, transfer_tips, mix_cycles])
124 |   assert (
    |   ^^^^^^ S101
125 |     isinstance(transfer_tips, list)
126 |     and isinstance(sources, list)
    |

praxis/backend/commons/liquid_handling.py:124:3: PT018 Assertion should be broken down into multiple parts
    |
122 |     )
123 |     await coerce_to_list(items=[sources, targets, volumes, transfer_tips, mix_cycles])
124 |     assert (
    |  ___^
125 | |     isinstance(transfer_tips, list)
126 | |     and isinstance(sources, list)
127 | |     and isinstance(targets, list)
128 | |     and isinstance(volumes, list)
129 | |     and isinstance(mix_cycles, list)
130 | |   ), "All arguments must be lists or coercible to lists."
    | |_________________________________________________________^ PT018
131 |     mix_volumes = await generate_mix_volumes(
132 |       volumes=volumes, mix_proportion=mix_proportion, mix_volumes=mix_volumes,
    |
    = help: Break down assertion into multiple parts

praxis/backend/commons/liquid_handling.py:166:11: PLR0913 Too many arguments in function definition (9 > 5)
    |
165 | @liquid_handler_setup_check
166 | async def transfer_with_mixing96(
    |           ^^^^^^^^^^^^^^^^^^^^^^ PLR0913
167 |   liquid_handler: LiquidHandler,
168 |   source: Plate,  # ItemizedResource[Container], TODO: change to ItemizedResource once implemented with PLR
    |

praxis/backend/commons/liquid_handling.py:166:11: D417 Missing argument descriptions in the docstring for `transfer_with_mixing96`: `mix_volume`, `source`, `target`, `volume`
    |
165 | @liquid_handler_setup_check
166 | async def transfer_with_mixing96(
    |           ^^^^^^^^^^^^^^^^^^^^^^ D417
167 |   liquid_handler: LiquidHandler,
168 |   source: Plate,  # ItemizedResource[Container], TODO: change to ItemizedResource once implemented with PLR
    |

praxis/backend/commons/liquid_handling.py:173:3: FBT001 Boolean-typed positional argument in function definition
    |
171 |   transfer_tips: TipRack,
172 |   mix_cycles: int = 10,
173 |   return_tips: bool = True,
    |   ^^^^^^^^^^^ FBT001
174 |   mix_proportion: float | None = None,
175 |   mix_volume: float | None = None,
    |

praxis/backend/commons/liquid_handling.py:173:3: FBT002 Boolean default positional argument in function definition
    |
171 |   transfer_tips: TipRack,
172 |   mix_cycles: int = 10,
173 |   return_tips: bool = True,
    |   ^^^^^^^^^^^ FBT002
174 |   mix_proportion: float | None = None,
175 |   mix_volume: float | None = None,
    |

praxis/backend/commons/liquid_handling.py:207:5: B028 No explicit `stacklevel` keyword argument found
    |
205 |   """
206 |   if mix_proportion is not None and mix_volume is not None:
207 |     warnings.warn(
    |     ^^^^^^^^^^^^^ B028
208 |       "Mix proportion and volume are not currently supported for 96 head transfers. \
209 |       Ignoring.",
    |

praxis/backend/commons/liquid_handling.py:211:3: ERA001 Found commented-out code
    |
209 |       Ignoring.",
210 |     )
211 |   # mix_proportion, mix_volume = await inspect_mix_parameters(mix_proportion, mix_volume)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
212 |   if any(isinstance(i, list) for i in [volume, transfer_tips, mix_cycles, mix_volume]):
213 |     raise ValueError("All arguments must be single values for 96 head use, not lists.")
    |
    = help: Remove commented-out code

praxis/backend/commons/liquid_handling.py:213:11: TRY003 Avoid specifying long messages outside the exception class
    |
211 |   # mix_proportion, mix_volume = await inspect_mix_parameters(mix_proportion, mix_volume)
212 |   if any(isinstance(i, list) for i in [volume, transfer_tips, mix_cycles, mix_volume]):
213 |     raise ValueError("All arguments must be single values for 96 head use, not lists.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
214 |   if not isinstance(source, ItemizedResource) or not isinstance(
215 |     target, ItemizedResource,
    |

praxis/backend/commons/liquid_handling.py:213:22: EM101 Exception must not use a string literal, assign to variable first
    |
211 |   # mix_proportion, mix_volume = await inspect_mix_parameters(mix_proportion, mix_volume)
212 |   if any(isinstance(i, list) for i in [volume, transfer_tips, mix_cycles, mix_volume]):
213 |     raise ValueError("All arguments must be single values for 96 head use, not lists.")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
214 |   if not isinstance(source, ItemizedResource) or not isinstance(
215 |     target, ItemizedResource,
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:217:5: TRY004 Prefer `TypeError` exception for invalid type
    |
215 |     target, ItemizedResource,
216 |   ):
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |

praxis/backend/commons/liquid_handling.py:217:11: TRY003 Avoid specifying long messages outside the exception class
    |
215 |     target, ItemizedResource,
216 |   ):
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |

praxis/backend/commons/liquid_handling.py:217:22: EM101 Exception must not use a string literal, assign to variable first
    |
215 |     target, ItemizedResource,
216 |   ):
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:219:5: TRY004 Prefer `TypeError` exception for invalid type
    |
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
220 |   # mix_volume = mix_proportion * volume if mix_volume is None else mix_volume
221 |   await type_check(
    |

praxis/backend/commons/liquid_handling.py:219:11: TRY003 Avoid specifying long messages outside the exception class
    |
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
220 |   # mix_volume = mix_proportion * volume if mix_volume is None else mix_volume
221 |   await type_check(
    |

praxis/backend/commons/liquid_handling.py:219:22: EM101 Exception must not use a string literal, assign to variable first
    |
217 |     raise ValueError("Sources and targets must be ItemizedResource objects.")
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
220 |   # mix_volume = mix_proportion * volume if mix_volume is None else mix_volume
221 |   await type_check(
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/liquid_handling.py:220:3: ERA001 Found commented-out code
    |
218 |   if not isinstance(transfer_tips, TipRack):
219 |     raise ValueError("Transfer tips must be a TipRack object.")
220 |   # mix_volume = mix_proportion * volume if mix_volume is None else mix_volume
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
221 |   await type_check(
222 |     items=[source, target, volume, transfer_tips],  # , mix_cycles, mix_volumes],
    |
    = help: Remove commented-out code

praxis/backend/commons/liquid_handling.py:229:8: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
227 |   await liquid_handler.aspirate96(
228 |     resource=source, volume=volume,
229 |   )  # TODO: add mix_cycles to aspirate96 and dispense96 and allow for resource to be any container of appropriate size
    |        ^^^^ TD002
230 |   await liquid_handler.dispense(resource=target, volume=volume)
231 |   if return_tips:
    |

praxis/backend/commons/liquid_handling.py:229:8: TD003 Missing issue link on the line following this TODO
    |
227 |   await liquid_handler.aspirate96(
228 |     resource=source, volume=volume,
229 |   )  # TODO: add mix_cycles to aspirate96 and dispense96 and allow for resource to be any container of appropriate size
    |        ^^^^ TD003
230 |   await liquid_handler.dispense(resource=target, volume=volume)
231 |   if return_tips:
    |

praxis/backend/commons/liquid_handling.py:229:8: FIX002 Line contains TODO, consider resolving the issue
    |
227 |   await liquid_handler.aspirate96(
228 |     resource=source, volume=volume,
229 |   )  # TODO: add mix_cycles to aspirate96 and dispense96 and allow for resource to be any container of appropriate size
    |        ^^^^ FIX002
230 |   await liquid_handler.dispense(resource=target, volume=volume)
231 |   if return_tips:
    |

praxis/backend/commons/liquid_handling.py:235:11: ANN201 Missing return type annotation for public function `fast_optimal_transfer`
    |
235 | async def fast_optimal_transfer():
    |           ^^^^^^^^^^^^^^^^^^^^^ ANN201
236 |   pass
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/liquid_handling.py:235:11: D103 Missing docstring in public function
    |
235 | async def fast_optimal_transfer():
    |           ^^^^^^^^^^^^^^^^^^^^^ D103
236 |   pass
    |

praxis/backend/commons/overrides.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/overrides.py:11:5: ANN201 Missing return type annotation for public function `get_class_members`
   |
11 | def get_class_members(library_name: str, subpackage, base_class_name: str):
   |     ^^^^^^^^^^^^^^^^^ ANN201
12 |   """Gets all members of a class, including those in subclasses,
13 |   from a specified library.
   |
   = help: Add return type annotation

praxis/backend/commons/overrides.py:11:42: ANN001 Missing type annotation for function argument `subpackage`
   |
11 | def get_class_members(library_name: str, subpackage, base_class_name: str):
   |                                          ^^^^^^^^^^ ANN001
12 |   """Gets all members of a class, including those in subclasses,
13 |   from a specified library.
   |

praxis/backend/commons/overrides.py:12:3: D205 1 blank line required between summary line and description
   |
11 |   def get_class_members(library_name: str, subpackage, base_class_name: str):
12 |     """Gets all members of a class, including those in subclasses,
   |  ___^
13 | |   from a specified library.
14 | | 
15 | |   Args:
16 | |       library_name (str): The name of the library to import.
17 | |       subpackage (str): The subpackage to search for the base class in.
18 | |       base_class_name (str): The name of the base class to search for.
19 | | 
20 | |   Returns:
21 | |       dict: A dictionary where keys are class names and values are
22 | |             lists of their members.
23 | | 
24 | |   """
   | |_____^ D205
25 |   
26 |     def get_members(cls):
   |
   = help: Insert single blank line

praxis/backend/commons/overrides.py:12:3: D401 First line of docstring should be in imperative mood: "Gets all members of a class, including those in subclasses,"
   |
11 |   def get_class_members(library_name: str, subpackage, base_class_name: str):
12 |     """Gets all members of a class, including those in subclasses,
   |  ___^
13 | |   from a specified library.
14 | | 
15 | |   Args:
16 | |       library_name (str): The name of the library to import.
17 | |       subpackage (str): The subpackage to search for the base class in.
18 | |       base_class_name (str): The name of the base class to search for.
19 | | 
20 | |   Returns:
21 | |       dict: A dictionary where keys are class names and values are
22 | |             lists of their members.
23 | | 
24 | |   """
   | |_____^ D401
25 |   
26 |     def get_members(cls):
   |

praxis/backend/commons/overrides.py:26:7: ANN202 Missing return type annotation for private function `get_members`
   |
24 |   """
25 | 
26 |   def get_members(cls):
   |       ^^^^^^^^^^^ ANN202
27 |     return [name for name, _ in inspect.getmembers(cls)]
   |
   = help: Add return type annotation

praxis/backend/commons/overrides.py:26:19: ANN001 Missing type annotation for function argument `cls`
   |
24 |   """
25 | 
26 |   def get_members(cls):
   |                   ^^^ ANN001
27 |     return [name for name, _ in inspect.getmembers(cls)]
   |

praxis/backend/commons/overrides.py:40:9: PERF403 Use a dictionary comprehension instead of a for-loop
   |
38 |     for name, obj in inspect.getmembers(module):
39 |       if inspect.isclass(obj) and issubclass(obj, base_class):
40 |         all_members[name] = obj
   |         ^^^^^^^^^^^^^^^^^^^^^^^ PERF403
41 | 
42 |   return all_members
   |

praxis/backend/commons/overrides.py:45:5: ANN201 Missing return type annotation for public function `new_init`
   |
45 | def new_init(self, *args, **kwargs):
   |     ^^^^^^^^ ANN201
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/overrides.py:45:5: D103 Missing docstring in public function
   |
45 | def new_init(self, *args, **kwargs):
   |     ^^^^^^^^ D103
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
   |

praxis/backend/commons/overrides.py:45:14: ANN001 Missing type annotation for function argument `self`
   |
45 | def new_init(self, *args, **kwargs):
   |              ^^^^ ANN001
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
   |

praxis/backend/commons/overrides.py:45:20: ANN002 Missing type annotation for `*args`
   |
45 | def new_init(self, *args, **kwargs):
   |                    ^^^^^ ANN002
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
   |

praxis/backend/commons/overrides.py:45:27: ANN003 Missing type annotation for `**kwargs`
   |
45 | def new_init(self, *args, **kwargs):
   |                           ^^^^^^^^ ANN003
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
   |

praxis/backend/commons/overrides.py:46:36: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
45 | def new_init(self, *args, **kwargs):
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
   |                                    ^^^^ TD002
47 |     if args:
48 |       raise ValueError("All arguments must be keyword arguments when using praxis.")
   |

praxis/backend/commons/overrides.py:46:36: TD003 Missing issue link on the line following this TODO
   |
45 | def new_init(self, *args, **kwargs):
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
   |                                    ^^^^ TD003
47 |     if args:
48 |       raise ValueError("All arguments must be keyword arguments when using praxis.")
   |

praxis/backend/commons/overrides.py:46:36: FIX002 Line contains TODO, consider resolving the issue
   |
45 | def new_init(self, *args, **kwargs):
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
   |                                    ^^^^ FIX002
47 |     if args:
48 |       raise ValueError("All arguments must be keyword arguments when using praxis.")
   |

praxis/backend/commons/overrides.py:48:13: TRY003 Avoid specifying long messages outside the exception class
   |
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
48 |       raise ValueError("All arguments must be keyword arguments when using praxis.")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
49 |     if "name" in kwargs:
50 |       self.name = kwargs["name"]
   |

praxis/backend/commons/overrides.py:48:24: EM101 Exception must not use a string literal, assign to variable first
   |
46 |   if isinstance(self, Machine):  # TODO: Change this to a more general check
47 |     if args:
48 |       raise ValueError("All arguments must be keyword arguments when using praxis.")
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
49 |     if "name" in kwargs:
50 |       self.name = kwargs["name"]
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/overrides.py:60:5: ANN201 Missing return type annotation for public function `new_serialize`
   |
60 | def new_serialize(self):
   |     ^^^^^^^^^^^^^ ANN201
61 |   return {
62 |     **super(type(self), self).serialize(),
   |
   = help: Add return type annotation

praxis/backend/commons/overrides.py:60:5: D103 Missing docstring in public function
   |
60 | def new_serialize(self):
   |     ^^^^^^^^^^^^^ D103
61 |   return {
62 |     **super(type(self), self).serialize(),
   |

praxis/backend/commons/overrides.py:60:19: ANN001 Missing type annotation for function argument `self`
   |
60 | def new_serialize(self):
   |                   ^^^^ ANN001
61 |   return {
62 |     **super(type(self), self).serialize(),
   |

praxis/backend/commons/overrides.py:68:3: D205 1 blank line required between summary line and description
   |
67 |   def patch_subclasses() -> dict[str, type[Machine]]:
68 |     """Adds new __init__ and serialize methods to all subclasses of a base class. Specifically, it adds
   |  ___^
69 | |   a name attribute to all subclasses of the Machine class.
70 | | 
71 | |   Args:
72 | |     base_class (T): The base class to add the new methods to.
73 | | 
74 | |   Returns:
75 | |     dict: A dictionary where keys are the names of the subclasses and values are the subclasses
76 | |           with the new methods.
77 | | 
78 | |   """
   | |_____^ D205
79 |     new_objs = {}
80 |     for name, obj in get_class_members(
   |
   = help: Insert single blank line

praxis/backend/commons/overrides.py:68:3: D401 First line of docstring should be in imperative mood: "Adds new __init__ and serialize methods to all subclasses of a base class. Specifically, it adds"
   |
67 |   def patch_subclasses() -> dict[str, type[Machine]]:
68 |     """Adds new __init__ and serialize methods to all subclasses of a base class. Specifically, it adds
   |  ___^
69 | |   a name attribute to all subclasses of the Machine class.
70 | | 
71 | |   Args:
72 | |     base_class (T): The base class to add the new methods to.
73 | | 
74 | |   Returns:
75 | |     dict: A dictionary where keys are the names of the subclasses and values are the subclasses
76 | |           with the new methods.
77 | | 
78 | |   """
   | |_____^ D401
79 |     new_objs = {}
80 |     for name, obj in get_class_members(
   |

praxis/backend/commons/overrides.py:80:7: B007 Loop control variable `name` not used within loop body
   |
78 |   """
79 |   new_objs = {}
80 |   for name, obj in get_class_members(
   |       ^^^^ B007
81 |     library_name="pylabrobot", subpackage="machines", base_class_name=Machine.__name__,
82 |   ).items():
   |
   = help: Rename unused `name` to `_name`

praxis/backend/commons/overrides.py:80:20: PERF102 When using only the values of a dict use the `values()` method
   |
78 |     """
79 |     new_objs = {}
80 |     for name, obj in get_class_members(
   |  ____________________^
81 | |     library_name="pylabrobot", subpackage="machines", base_class_name=Machine.__name__,
82 | |   ).items():
   | |_________^ PERF102
83 |       if inspect.isclass(obj) and issubclass(obj, Machine):
84 |         obj.__init__ = new_init  # type: ignore
   |
   = help: Replace `.items()` with `.values()`

praxis/backend/commons/overrides.py:84:32: PGH003 Use specific rule codes when ignoring type issues
   |
82 |   ).items():
83 |     if inspect.isclass(obj) and issubclass(obj, Machine):
84 |       obj.__init__ = new_init  # type: ignore
   |                                ^^^^^^^^^^^^^^ PGH003
85 |       obj.serialize = new_serialize  # type: ignore
86 |       new_objs[obj.__name__] = obj
   |

praxis/backend/commons/overrides.py:85:38: PGH003 Use specific rule codes when ignoring type issues
   |
83 |     if inspect.isclass(obj) and issubclass(obj, Machine):
84 |       obj.__init__ = new_init  # type: ignore
85 |       obj.serialize = new_serialize  # type: ignore
   |                                      ^^^^^^^^^^^^^^ PGH003
86 |       new_objs[obj.__name__] = obj
87 |   return new_objs
   |

praxis/backend/commons/plate_reading.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/plate_reading.py:8:7: D101 Missing docstring in public class
   |
 8 | class PlateReaderTask(StandaloneTask):
   |       ^^^^^^^^^^^^^^^ D101
 9 |   def __init__(
10 |     self,
   |

praxis/backend/commons/plate_reading.py:9:7: PLR0913 Too many arguments in function definition (8 > 5)
   |
 8 | class PlateReaderTask(StandaloneTask):
 9 |   def __init__(
   |       ^^^^^^^^ PLR0913
10 |     self,
11 |     experiment_name,
   |

praxis/backend/commons/plate_reading.py:9:7: ANN204 Missing return type annotation for special method `__init__`
   |
 8 | class PlateReaderTask(StandaloneTask):
 9 |   def __init__(
   |       ^^^^^^^^ ANN204
10 |     self,
11 |     experiment_name,
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/plate_reading.py:9:7: D107 Missing docstring in `__init__`
   |
 8 | class PlateReaderTask(StandaloneTask):
 9 |   def __init__(
   |       ^^^^^^^^ D107
10 |     self,
11 |     experiment_name,
   |

praxis/backend/commons/plate_reading.py:11:5: ANN001 Missing type annotation for function argument `experiment_name`
   |
 9 |   def __init__(
10 |     self,
11 |     experiment_name,
   |     ^^^^^^^^^^^^^^^ ANN001
12 |     plate_name,
13 |     measurement_type,
   |

praxis/backend/commons/plate_reading.py:12:5: ANN001 Missing type annotation for function argument `plate_name`
   |
10 |     self,
11 |     experiment_name,
12 |     plate_name,
   |     ^^^^^^^^^^ ANN001
13 |     measurement_type,
14 |     wells,
   |

praxis/backend/commons/plate_reading.py:13:5: ANN001 Missing type annotation for function argument `measurement_type`
   |
11 |     experiment_name,
12 |     plate_name,
13 |     measurement_type,
   |     ^^^^^^^^^^^^^^^^ ANN001
14 |     wells,
15 |     estimated_duration,
   |

praxis/backend/commons/plate_reading.py:14:5: ANN001 Missing type annotation for function argument `wells`
   |
12 |     plate_name,
13 |     measurement_type,
14 |     wells,
   |     ^^^^^ ANN001
15 |     estimated_duration,
16 |     registry,
   |

praxis/backend/commons/plate_reading.py:15:5: ANN001 Missing type annotation for function argument `estimated_duration`
   |
13 |     measurement_type,
14 |     wells,
15 |     estimated_duration,
   |     ^^^^^^^^^^^^^^^^^^ ANN001
16 |     registry,
17 |     data_instance,
   |

praxis/backend/commons/plate_reading.py:16:5: ANN001 Missing type annotation for function argument `registry`
   |
14 |     wells,
15 |     estimated_duration,
16 |     registry,
   |     ^^^^^^^^ ANN001
17 |     data_instance,
18 |     config_file="config.ini",
   |

praxis/backend/commons/plate_reading.py:17:5: ANN001 Missing type annotation for function argument `data_instance`
   |
15 |     estimated_duration,
16 |     registry,
17 |     data_instance,
   |     ^^^^^^^^^^^^^ ANN001
18 |     config_file="config.ini",
19 |   ):
   |

praxis/backend/commons/plate_reading.py:18:5: ANN001 Missing type annotation for function argument `config_file`
   |
16 |     registry,
17 |     data_instance,
18 |     config_file="config.ini",
   |     ^^^^^^^^^^^ ANN001
19 |   ):
20 |     super().__init__(
   |

praxis/backend/commons/plate_reading.py:27:13: ANN202 Missing return type annotation for private function `_setup`
   |
25 |     self.wells = wells
26 | 
27 |   async def _setup(self):
   |             ^^^^^^ ANN202
28 |     # Get the estimated next plate reader use time for the main experiment
29 |     next_use = self.registry.get_next_plate_reader_use(self.experiment_name)
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/plate_reading.py:32:28: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
31 |     # Calculate the earliest time this task can finish
32 |     earliest_finish_time = datetime.datetime.now() + datetime.timedelta(
   |                            ^^^^^^^^^^^^^^^^^^^^^^^ DTZ005
33 |       seconds=self.estimated_duration,
34 |     )
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

praxis/backend/commons/plate_reading.py:41:13: TRY002 Create your own exception
   |
39 |       buffer_time = datetime.timedelta(minutes=5)  # 5-minute buffer
40 |     if next_use and earliest_finish_time + buffer_time > next_use:
41 |       raise Exception("Plate reader will be needed by the main experiment soon.")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY002
42 | 
43 |     # Acquire the plate reader lock
   |

praxis/backend/commons/plate_reading.py:41:13: TRY003 Avoid specifying long messages outside the exception class
   |
39 |       buffer_time = datetime.timedelta(minutes=5)  # 5-minute buffer
40 |     if next_use and earliest_finish_time + buffer_time > next_use:
41 |       raise Exception("Plate reader will be needed by the main experiment soon.")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
42 | 
43 |     # Acquire the plate reader lock
   |

praxis/backend/commons/plate_reading.py:41:23: EM101 Exception must not use a string literal, assign to variable first
   |
39 |       buffer_time = datetime.timedelta(minutes=5)  # 5-minute buffer
40 |     if next_use and earliest_finish_time + buffer_time > next_use:
41 |       raise Exception("Plate reader will be needed by the main experiment soon.")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
42 | 
43 |     # Acquire the plate reader lock
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_reading.py:51:13: TRY002 Create your own exception
   |
49 |       acquire_timeout=10,
50 |     ):
51 |       raise Exception("Failed to acquire lock on plate reader.")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY002
52 | 
53 |   async def _execute(self):
   |

praxis/backend/commons/plate_reading.py:51:13: TRY003 Avoid specifying long messages outside the exception class
   |
49 |       acquire_timeout=10,
50 |     ):
51 |       raise Exception("Failed to acquire lock on plate reader.")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
52 | 
53 |   async def _execute(self):
   |

praxis/backend/commons/plate_reading.py:51:23: EM101 Exception must not use a string literal, assign to variable first
   |
49 |       acquire_timeout=10,
50 |     ):
51 |       raise Exception("Failed to acquire lock on plate reader.")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
52 | 
53 |   async def _execute(self):
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_reading.py:53:13: ANN202 Missing return type annotation for private function `_execute`
   |
51 |       raise Exception("Failed to acquire lock on plate reader.")
52 | 
53 |   async def _execute(self):
   |             ^^^^^^^^ ANN202
54 |     # Simulate performing plate reader operation
55 |     print(
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/plate_reading.py:55:5: T201 `print` found
   |
53 |   async def _execute(self):
54 |     # Simulate performing plate reader operation
55 |     print(
   |     ^^^^^ T201
56 |       f"Performing {self.measurement_type} on plate {self.plate_name} for wells {self.wells}.",
57 |     )
   |
   = help: Remove `print`

praxis/backend/commons/plate_reading.py:58:11: F821 Undefined name `asyncio`
   |
56 |       f"Performing {self.measurement_type} on plate {self.plate_name} for wells {self.wells}.",
57 |     )
58 |     await asyncio.sleep(self.estimated_duration)  # Simulate time taken for operation
   |           ^^^^^^^ F821
59 |     print(f"Finished {self.measurement_type} on plate {self.plate_name}.")
   |

praxis/backend/commons/plate_reading.py:59:5: T201 `print` found
   |
57 |     )
58 |     await asyncio.sleep(self.estimated_duration)  # Simulate time taken for operation
59 |     print(f"Finished {self.measurement_type} on plate {self.plate_name}.")
   |     ^^^^^ T201
60 | 
61 |     # Insert usage data into the database
   |
   = help: Remove `print`

praxis/backend/commons/plate_reading.py:73:11: F821 Undefined name `json`
   |
71 |           self.plate_name,
72 |           self.measurement_type,
73 |           json.dumps(self.wells),
   |           ^^^^ F821
74 |           datetime.datetime.now(),
75 |         ),
   |

praxis/backend/commons/plate_reading.py:74:11: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
72 |           self.measurement_type,
73 |           json.dumps(self.wells),
74 |           datetime.datetime.now(),
   |           ^^^^^^^^^^^^^^^^^^^^^^^ DTZ005
75 |         ),
76 |       )
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

praxis/backend/commons/plate_reading.py:78:7: T201 `print` found
   |
76 |       )
77 |       self._data.conn.commit()
78 |       print("Plate reader usage data saved successfully.")
   |       ^^^^^ T201
79 |     except Exception as e:
80 |       print(f"Failed to save plate reader usage data: {e}")
   |
   = help: Remove `print`

praxis/backend/commons/plate_reading.py:79:12: BLE001 Do not catch blind exception: `Exception`
   |
77 |       self._data.conn.commit()
78 |       print("Plate reader usage data saved successfully.")
79 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
80 |       print(f"Failed to save plate reader usage data: {e}")
   |

praxis/backend/commons/plate_reading.py:80:7: T201 `print` found
   |
78 |       print("Plate reader usage data saved successfully.")
79 |     except Exception as e:
80 |       print(f"Failed to save plate reader usage data: {e}")
   |       ^^^^^ T201
81 | 
82 |   async def _stop(self):
   |
   = help: Remove `print`

praxis/backend/commons/plate_reading.py:82:13: ANN202 Missing return type annotation for private function `_stop`
   |
80 |       print(f"Failed to save plate reader usage data: {e}")
81 | 
82 |   async def _stop(self):
   |             ^^^^^ ANN202
83 |     # Release the plate reader lock
84 |     self.registry.release_lock(
   |
   = help: Add return type annotation: `None`

praxis/backend/commons/plate_reading.py:87:5: T201 `print` found
   |
85 |       "plate_reader", self.experiment_name, self.task_accession_id,
86 |     )
87 |     print("Plate reader lock released.")
   |     ^^^^^ T201
   |
   = help: Remove `print`

praxis/backend/commons/plate_staging.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/plate_staging.py:16:11: D103 Missing docstring in public function
   |
16 | async def plate_accession_idx_to_well(plate: Plate, index: int | str | Well) -> Well:
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
17 |   if isinstance(index, str) or isinstance(index, int):
18 |     well = plate[index][0]
   |

praxis/backend/commons/plate_staging.py:17:6: SIM101 Multiple `isinstance` calls for `index`, merge into a single call
   |
16 | async def plate_accession_idx_to_well(plate: Plate, index: int | str | Well) -> Well:
17 |   if isinstance(index, str) or isinstance(index, int):
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SIM101
18 |     well = plate[index][0]
19 |   elif isinstance(index, Well):
   |
   = help: Merge `isinstance` calls for `index`

praxis/backend/commons/plate_staging.py:22:5: TRY004 Prefer `TypeError` exception for invalid type
   |
20 |     well = index
21 |   else:
22 |     raise ValueError("Invalid index type")
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
23 |   return well
   |

praxis/backend/commons/plate_staging.py:22:11: TRY003 Avoid specifying long messages outside the exception class
   |
20 |     well = index
21 |   else:
22 |     raise ValueError("Invalid index type")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
23 |   return well
   |

praxis/backend/commons/plate_staging.py:22:22: EM101 Exception must not use a string literal, assign to variable first
   |
20 |     well = index
21 |   else:
22 |     raise ValueError("Invalid index type")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
23 |   return well
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:26:5: D103 Missing docstring in public function
   |
26 | def get_all_wells(plate: Plate) -> list[Well]:
   |     ^^^^^^^^^^^^^ D103
27 |   return [well for well in plate.get_wells(range(plate.num_items))]
   |

praxis/backend/commons/plate_staging.py:27:10: C416 Unnecessary `list` comprehension (rewrite using `list()`)
   |
26 | def get_all_wells(plate: Plate) -> list[Well]:
27 |   return [well for well in plate.get_wells(range(plate.num_items))]
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C416
   |
   = help: Rewrite using `list()`

praxis/backend/commons/plate_staging.py:30:11: D103 Missing docstring in public function
   |
30 | async def well_to_int(well: Well, plate: Plate) -> int:
   |           ^^^^^^^^^^^ D103
31 |   column, row = await parse_well_name(well)
32 |   return int((column * plate.num_items_y) + row)
   |

praxis/backend/commons/plate_staging.py:35:11: D103 Missing docstring in public function
   |
35 | async def well_axes(
   |           ^^^^^^^^^ D103
36 |   wells: list[Well], axis: Literal[0, 1] | None = None,
37 | ) -> list[int | tuple[int, int]]:
   |

praxis/backend/commons/plate_staging.py:39:11: TRY003 Avoid specifying long messages outside the exception class
   |
37 | ) -> list[int | tuple[int, int]]:
38 |   if not all(isinstance(well, Well) for well in wells):
39 |     raise ValueError("Invalid well type.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
40 |   if axis is None:
41 |     return [
   |

praxis/backend/commons/plate_staging.py:39:22: EM101 Exception must not use a string literal, assign to variable first
   |
37 | ) -> list[int | tuple[int, int]]:
38 |   if not all(isinstance(well, Well) for well in wells):
39 |     raise ValueError("Invalid well type.")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
40 |   if axis is None:
41 |     return [
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:47:11: D103 Missing docstring in public function
   |
47 | async def wells_along_axis(wells: list[Well], axis: int) -> bool:
   |           ^^^^^^^^^^^^^^^^ D103
48 |   if not all(isinstance(well, Well) for well in wells):
49 |     raise ValueError("Invalid well type.")
   |

praxis/backend/commons/plate_staging.py:49:11: TRY003 Avoid specifying long messages outside the exception class
   |
47 | async def wells_along_axis(wells: list[Well], axis: int) -> bool:
48 |   if not all(isinstance(well, Well) for well in wells):
49 |     raise ValueError("Invalid well type.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
50 |   return len(set(well.name.split("_")[-1 - axis] for well in wells)) == 1
   |

praxis/backend/commons/plate_staging.py:49:22: EM101 Exception must not use a string literal, assign to variable first
   |
47 | async def wells_along_axis(wells: list[Well], axis: int) -> bool:
48 |   if not all(isinstance(well, Well) for well in wells):
49 |     raise ValueError("Invalid well type.")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
50 |   return len(set(well.name.split("_")[-1 - axis] for well in wells)) == 1
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:50:14: C401 Unnecessary generator (rewrite as a `set` comprehension)
   |
48 |   if not all(isinstance(well, Well) for well in wells):
49 |     raise ValueError("Invalid well type.")
50 |   return len(set(well.name.split("_")[-1 - axis] for well in wells)) == 1
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C401
   |
   = help: Rewrite as a `set` comprehension

praxis/backend/commons/plate_staging.py:53:11: ANN201 Missing return type annotation for public function `plate_sufficient_for_transfer`
   |
53 | async def plate_sufficient_for_transfer(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |   wells: list[list[Well]],
55 |   target_plate: Plate,
   |
   = help: Add return type annotation: `bool`

praxis/backend/commons/plate_staging.py:53:11: D103 Missing docstring in public function
   |
53 | async def plate_sufficient_for_transfer(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
54 |   wells: list[list[Well]],
55 |   target_plate: Plate,
   |

praxis/backend/commons/plate_staging.py:62:13: TRY003 Avoid specifying long messages outside the exception class
   |
60 |     if replicate_axis == 0:
61 |       if any(target_plate.num_items_x < n_replicates * len(wells) for wells in wells):
62 |         raise ExperimentError(
   |  _____________^
63 | |         "Number of replicates exceeds number of wells per row in target plate",
64 | |       )
   | |_______^ TRY003
65 |       if any(
66 |         target_plate.num_items_y < len(wells) + (offset * len(wells)) for wells in wells
   |

praxis/backend/commons/plate_staging.py:63:9: EM101 Exception must not use a string literal, assign to variable first
   |
61 |     if any(target_plate.num_items_x < n_replicates * len(wells) for wells in wells):
62 |       raise ExperimentError(
63 |         "Number of replicates exceeds number of wells per row in target plate",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
64 |       )
65 |     if any(
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:68:13: TRY003 Avoid specifying long messages outside the exception class
   |
66 |       target_plate.num_items_y < len(wells) + (offset * len(wells)) for wells in wells
67 |     ):
68 |       raise ExperimentError("Number of wells exceeds number of columns in target plate")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
69 |   else:
70 |     if any(target_plate.num_items_y < n_replicates * len(wells) for wells in wells):
   |

praxis/backend/commons/plate_staging.py:68:29: EM101 Exception must not use a string literal, assign to variable first
   |
66 |       target_plate.num_items_y < len(wells) + (offset * len(wells)) for wells in wells
67 |     ):
68 |       raise ExperimentError("Number of wells exceeds number of columns in target plate")
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
69 |   else:
70 |     if any(target_plate.num_items_y < n_replicates * len(wells) for wells in wells):
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:71:13: TRY003 Avoid specifying long messages outside the exception class
   |
69 |     else:
70 |       if any(target_plate.num_items_y < n_replicates * len(wells) for wells in wells):
71 |         raise ExperimentError(
   |  _____________^
72 | |         "Number of replicates exceeds number of wells per column in target \
73 | |         plate",
74 | |       )
   | |_______^ TRY003
75 |       if any(
76 |         target_plate.num_items_x < len(wells) + (offset * len(wells)) for wells in wells
   |

praxis/backend/commons/plate_staging.py:72:9: EM101 Exception must not use a string literal, assign to variable first
   |
70 |       if any(target_plate.num_items_y < n_replicates * len(wells) for wells in wells):
71 |         raise ExperimentError(
72 |           "Number of replicates exceeds number of wells per column in target \
   |  _________^
73 | |         plate",
   | |______________^ EM101
74 |         )
75 |       if any(
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:78:13: TRY003 Avoid specifying long messages outside the exception class
   |
76 |       target_plate.num_items_x < len(wells) + (offset * len(wells)) for wells in wells
77 |     ):
78 |       raise ExperimentError("Number of wells exceeds number of columns in target plate")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
79 |   return True
   |

praxis/backend/commons/plate_staging.py:78:29: EM101 Exception must not use a string literal, assign to variable first
   |
76 |       target_plate.num_items_x < len(wells) + (offset * len(wells)) for wells in wells
77 |     ):
78 |       raise ExperimentError("Number of wells exceeds number of columns in target plate")
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
79 |   return True
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:82:11: D103 Missing docstring in public function
   |
82 | async def group_wells_by_variables(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^ D103
83 |   wells: list[Well], key: str, variables: list[str],
84 | ) -> list[list[Well]]:
   |

praxis/backend/commons/plate_staging.py:86:11: TRY003 Avoid specifying long messages outside the exception class
   |
84 | ) -> list[list[Well]]:
85 |   if not all(isinstance(well, Well) for well in wells):
86 |     raise ValueError("Invalid well type.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
87 |   return [
88 |     [well for well in wells if getattr(well, key, None) == var] for var in variables
   |

praxis/backend/commons/plate_staging.py:86:22: EM101 Exception must not use a string literal, assign to variable first
   |
84 | ) -> list[list[Well]]:
85 |   if not all(isinstance(well, Well) for well in wells):
86 |     raise ValueError("Invalid well type.")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
87 |   return [
88 |     [well for well in wells if getattr(well, key, None) == var] for var in variables
   |
   = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:92:11: D103 Missing docstring in public function
   |
92 | async def well_check(
   |           ^^^^^^^^^^ D103
93 |   wells: list[int | str | Well] | list[Well],
94 |   plate: Plate,
   |

praxis/backend/commons/plate_staging.py:101:11: TRY003 Avoid specifying long messages outside the exception class
    |
 99 |   ]
100 |   if not all(isinstance(well, Well) for well in _wells):
101 |     raise ValueError("Invalid well type.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
102 |   if not all(well in plate.get_wells(range(plate.num_items)) for well in _wells):
103 |     raise ResourceNotFoundError("Well not in source plate")
    |

praxis/backend/commons/plate_staging.py:101:22: EM101 Exception must not use a string literal, assign to variable first
    |
 99 |   ]
100 |   if not all(isinstance(well, Well) for well in _wells):
101 |     raise ValueError("Invalid well type.")
    |                      ^^^^^^^^^^^^^^^^^^^^ EM101
102 |   if not all(well in plate.get_wells(range(plate.num_items)) for well in _wells):
103 |     raise ResourceNotFoundError("Well not in source plate")
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:103:11: TRY003 Avoid specifying long messages outside the exception class
    |
101 |     raise ValueError("Invalid well type.")
102 |   if not all(well in plate.get_wells(range(plate.num_items)) for well in _wells):
103 |     raise ResourceNotFoundError("Well not in source plate")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
104 |   if replicate_axis is not None:
105 |     if not await wells_along_axis(_wells, int(not replicate_axis)):
    |

praxis/backend/commons/plate_staging.py:103:33: EM101 Exception must not use a string literal, assign to variable first
    |
101 |     raise ValueError("Invalid well type.")
102 |   if not all(well in plate.get_wells(range(plate.num_items)) for well in _wells):
103 |     raise ResourceNotFoundError("Well not in source plate")
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
104 |   if replicate_axis is not None:
105 |     if not await wells_along_axis(_wells, int(not replicate_axis)):
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:104:3: SIM102 Use a single `if` statement instead of nested `if` statements
    |
102 |     if not all(well in plate.get_wells(range(plate.num_items)) for well in _wells):
103 |       raise ResourceNotFoundError("Well not in source plate")
104 |     if replicate_axis is not None:
    |  ___^
105 | |     if not await wells_along_axis(_wells, int(not replicate_axis)):
    | |___________________________________________________________________^ SIM102
106 |         raise ExperimentError("Wells not along specified axis")
107 |     return _wells
    |
    = help: Combine `if` statements using `and`

praxis/backend/commons/plate_staging.py:106:13: TRY003 Avoid specifying long messages outside the exception class
    |
104 |   if replicate_axis is not None:
105 |     if not await wells_along_axis(_wells, int(not replicate_axis)):
106 |       raise ExperimentError("Wells not along specified axis")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
107 |   return _wells
    |

praxis/backend/commons/plate_staging.py:106:29: EM101 Exception must not use a string literal, assign to variable first
    |
104 |   if replicate_axis is not None:
105 |     if not await wells_along_axis(_wells, int(not replicate_axis)):
106 |       raise ExperimentError("Wells not along specified axis")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
107 |   return _wells
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:110:11: D103 Missing docstring in public function
    |
110 | async def split_wells_along_columns(wells: list[Well]) -> list[list[Well]]:
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
111 |   if not all(isinstance(well, Well) for well in wells):
112 |     raise ValueError("Invalid well type.")
    |

praxis/backend/commons/plate_staging.py:112:11: TRY003 Avoid specifying long messages outside the exception class
    |
110 | async def split_wells_along_columns(wells: list[Well]) -> list[list[Well]]:
111 |   if not all(isinstance(well, Well) for well in wells):
112 |     raise ValueError("Invalid well type.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
113 |   columns = [(await parse_well_name(well))[0] for well in wells]
114 |   return [
    |

praxis/backend/commons/plate_staging.py:112:22: EM101 Exception must not use a string literal, assign to variable first
    |
110 | async def split_wells_along_columns(wells: list[Well]) -> list[list[Well]]:
111 |   if not all(isinstance(well, Well) for well in wells):
112 |     raise ValueError("Invalid well type.")
    |                      ^^^^^^^^^^^^^^^^^^^^ EM101
113 |   columns = [(await parse_well_name(well))[0] for well in wells]
114 |   return [
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:121:11: C901 `simple_interplate_transfer` is too complex (16 > 10)
    |
120 | @liquid_handler_setup_check
121 | async def simple_interplate_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
122 |   liquid_handler: LiquidHandler,
123 |   tips: TipRack,
    |

praxis/backend/commons/plate_staging.py:121:11: PLR0913 Too many arguments in function definition (12 > 5)
    |
120 | @liquid_handler_setup_check
121 | async def simple_interplate_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
122 |   liquid_handler: LiquidHandler,
123 |   tips: TipRack,
    |

praxis/backend/commons/plate_staging.py:121:11: PLR0912 Too many branches (17 > 12)
    |
120 | @liquid_handler_setup_check
121 | async def simple_interplate_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
122 |   liquid_handler: LiquidHandler,
123 |   tips: TipRack,
    |

praxis/backend/commons/plate_staging.py:121:11: ANN201 Missing return type annotation for public function `simple_interplate_transfer`
    |
120 | @liquid_handler_setup_check
121 | async def simple_interplate_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
122 |   liquid_handler: LiquidHandler,
123 |   tips: TipRack,
    |
    = help: Add return type annotation: `None`

praxis/backend/commons/plate_staging.py:121:11: D103 Missing docstring in public function
    |
120 | @liquid_handler_setup_check
121 | async def simple_interplate_transfer(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
122 |   liquid_handler: LiquidHandler,
123 |   tips: TipRack,
    |

praxis/backend/commons/plate_staging.py:128:3: ARG001 Unused function argument: `offset`
    |
126 |   transfer_volume: float,
127 |   source_wells: list[int | str | Well],
128 |   offset: int = 0,
    |   ^^^^^^ ARG001
129 |   n_replicates: int | None = None,
130 |   mix_cycles: int = 1,
    |

praxis/backend/commons/plate_staging.py:130:3: ARG001 Unused function argument: `mix_cycles`
    |
128 |   offset: int = 0,
129 |   n_replicates: int | None = None,
130 |   mix_cycles: int = 1,
    |   ^^^^^^^^^^ ARG001
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
132 |   use_96: bool = False,
    |

praxis/backend/commons/plate_staging.py:131:3: ARG001 Unused function argument: `replicate_axis`
    |
129 |   n_replicates: int | None = None,
130 |   mix_cycles: int = 1,
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
    |   ^^^^^^^^^^^^^^ ARG001
132 |   use_96: bool = False,
133 |   return_tips: bool = False,
    |

praxis/backend/commons/plate_staging.py:132:3: FBT001 Boolean-typed positional argument in function definition
    |
130 |   mix_cycles: int = 1,
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
132 |   use_96: bool = False,
    |   ^^^^^^ FBT001
133 |   return_tips: bool = False,
134 | ):
    |

praxis/backend/commons/plate_staging.py:132:3: FBT002 Boolean default positional argument in function definition
    |
130 |   mix_cycles: int = 1,
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
132 |   use_96: bool = False,
    |   ^^^^^^ FBT002
133 |   return_tips: bool = False,
134 | ):
    |

praxis/backend/commons/plate_staging.py:133:3: FBT001 Boolean-typed positional argument in function definition
    |
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
132 |   use_96: bool = False,
133 |   return_tips: bool = False,
    |   ^^^^^^^^^^^ FBT001
134 | ):
135 |   # TODO: add transfer_volumes checking
    |

praxis/backend/commons/plate_staging.py:133:3: FBT002 Boolean default positional argument in function definition
    |
131 |   replicate_axis: Literal["x", "y", 0, 1] = "x",
132 |   use_96: bool = False,
133 |   return_tips: bool = False,
    |   ^^^^^^^^^^^ FBT002
134 | ):
135 |   # TODO: add transfer_volumes checking
    |

praxis/backend/commons/plate_staging.py:135:5: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
133 |   return_tips: bool = False,
134 | ):
135 |   # TODO: add transfer_volumes checking
    |     ^^^^ TD002
136 |   _source_wells: list[Well] = [
137 |     await plate_accession_idx_to_well(source_plate, well) for well in source_wells
    |

praxis/backend/commons/plate_staging.py:135:5: TD003 Missing issue link on the line following this TODO
    |
133 |   return_tips: bool = False,
134 | ):
135 |   # TODO: add transfer_volumes checking
    |     ^^^^ TD003
136 |   _source_wells: list[Well] = [
137 |     await plate_accession_idx_to_well(source_plate, well) for well in source_wells
    |

praxis/backend/commons/plate_staging.py:135:5: FIX002 Line contains TODO, consider resolving the issue
    |
133 |   return_tips: bool = False,
134 | ):
135 |   # TODO: add transfer_volumes checking
    |     ^^^^ FIX002
136 |   _source_wells: list[Well] = [
137 |     await plate_accession_idx_to_well(source_plate, well) for well in source_wells
    |

praxis/backend/commons/plate_staging.py:139:3: S101 Use of `assert` detected
    |
137 |     await plate_accession_idx_to_well(source_plate, well) for well in source_wells
138 |   ]
139 |   assert all(isinstance(well, Well) for well in source_wells)
    |   ^^^^^^ S101
140 |   if use_96:
141 |     if n_replicates:
    |

praxis/backend/commons/plate_staging.py:143:15: TRY003 Avoid specifying long messages outside the exception class
    |
141 |     if n_replicates:
142 |       if target_plate.num_items < n_replicates * len(source_wells):
143 |         raise ValueError("Target plate does not have enough wells")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
144 |       if n_replicates * 96 > target_plate.num_items:
145 |         raise ValueError("Target plate does not have enough wells")
    |

praxis/backend/commons/plate_staging.py:143:26: EM101 Exception must not use a string literal, assign to variable first
    |
141 |     if n_replicates:
142 |       if target_plate.num_items < n_replicates * len(source_wells):
143 |         raise ValueError("Target plate does not have enough wells")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
144 |       if n_replicates * 96 > target_plate.num_items:
145 |         raise ValueError("Target plate does not have enough wells")
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:145:15: TRY003 Avoid specifying long messages outside the exception class
    |
143 |         raise ValueError("Target plate does not have enough wells")
144 |       if n_replicates * 96 > target_plate.num_items:
145 |         raise ValueError("Target plate does not have enough wells")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
146 |       if not all(tip.has_tip for tip in liquid_handler.head96.values()):
147 |         await liquid_handler.pick_up_tips96(tip_rack=tips)
    |

praxis/backend/commons/plate_staging.py:145:26: EM101 Exception must not use a string literal, assign to variable first
    |
143 |         raise ValueError("Target plate does not have enough wells")
144 |       if n_replicates * 96 > target_plate.num_items:
145 |         raise ValueError("Target plate does not have enough wells")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
146 |       if not all(tip.has_tip for tip in liquid_handler.head96.values()):
147 |         await liquid_handler.pick_up_tips96(tip_rack=tips)
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:162:7: S101 Use of `assert` detected
    |
160 |         await liquid_handler.drop_tips96(resource=tips)
161 |     else:
162 |       assert target_plate.num_items == source_plate.num_items
    |       ^^^^^^ S101
163 |       if not all(tip.has_tip for tip in liquid_handler.head96.values()):
164 |         await liquid_handler.pick_up_tips96(tip_rack=tips)
    |

praxis/backend/commons/plate_staging.py:177:31: EM101 Exception must not use a string literal, assign to variable first
    |
175 |         await liquid_handler.drop_tips96(resource=tips)
176 |   else:
177 |     raise NotImplementedError("Use of 8 channel not implemented")
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/plate_staging.py:180:11: ANN201 Missing return type annotation for public function `read_plate`
    |
180 | async def read_plate(
    |           ^^^^^^^^^^ ANN201
181 |   liquid_handler: LiquidHandler,
182 |   plate_reader: PlateReader,
    |
    = help: Add return type annotation

praxis/backend/commons/plate_staging.py:180:11: D417 Missing argument descriptions in the docstring for `read_plate`: `final_location`, `liquid_handler`, `plate`, `plate_reader`, `wavelength`
    |
180 | async def read_plate(
    |           ^^^^^^^^^^ D417
181 |   liquid_handler: LiquidHandler,
182 |   plate_reader: PlateReader,
    |

praxis/backend/commons/plate_staging.py:187:3: D401 First line of docstring should be in imperative mood: "Reads the optical density of a plate at a specified wavelength using a plate reader."
    |
185 |     final_location: CarrierSite | Coordinate | None = None,
186 |   ):
187 |     """Reads the optical density of a plate at a specified wavelength using a plate reader.
    |  ___^
188 | | 
189 | |   Parameters
190 | |   ----------
191 | |     liquid_handler (LiquidHandler): The liquid handler used to move the plate.
192 | |     plate_reader (PlateReader): The plate reader used to read the plate.
193 | |     plate (Plate): The plate to be read.
194 | |     wavelength (int, optional): The wavelength at which to read the plate. Defaults to 580.
195 | |     final_location (Optional[CarrierSite], optional): The final location where the plate will be
196 | |     moved after reading.  If not specified, the plate will be moved to its parent location. Defaults to None.
197 | | 
198 | |   Returns
199 | |   -------
200 | |     numpy.ndarray: An array containing the optical density readings of the plate at the specified wavelength.
201 | | 
202 | |   Raises
203 | |   ------
204 | |     ValueError: If the final location is not a valid CarrierSite.
205 | | 
206 | |   """
    | |_____^ D401
207 |     if final_location is None:
208 |       if not isinstance(plate.parent, CarrierSite):
    |

praxis/backend/commons/plate_staging.py:208:5: SIM108 Use ternary operator `final_location = plate.get_absolute_location() if not isinstance(plate.parent, CarrierSite) else plate.parent` instead of `if`-`else`-block
    |
206 |     """
207 |     if final_location is None:
208 |       if not isinstance(plate.parent, CarrierSite):
    |  _____^
209 | |       final_location = plate.get_absolute_location()
210 | |     else:
211 | |       final_location = plate.parent
    | |___________________________________^ SIM108
212 |   
213 |     if not isinstance(final_location, (CarrierSite, Coordinate)):
    |
    = help: Replace `if`-`else`-block with `final_location = plate.get_absolute_location() if not isinstance(plate.parent, CarrierSite) else plate.parent`

praxis/backend/commons/plate_staging.py:213:10: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
211 |       final_location = plate.parent
212 | 
213 |   if not isinstance(final_location, (CarrierSite, Coordinate)):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
214 |     raise ValueError("Invalid final location")
    |
    = help: Convert to `X | Y`

praxis/backend/commons/plate_staging.py:214:5: TRY004 Prefer `TypeError` exception for invalid type
    |
213 |   if not isinstance(final_location, (CarrierSite, Coordinate)):
214 |     raise ValueError("Invalid final location")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
215 | 
216 |   await plate_reader.open()
    |

praxis/backend/commons/plate_staging.py:214:11: TRY003 Avoid specifying long messages outside the exception class
    |
213 |   if not isinstance(final_location, (CarrierSite, Coordinate)):
214 |     raise ValueError("Invalid final location")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
215 | 
216 |   await plate_reader.open()
    |

praxis/backend/commons/plate_staging.py:214:22: EM101 Exception must not use a string literal, assign to variable first
    |
213 |   if not isinstance(final_location, (CarrierSite, Coordinate)):
214 |     raise ValueError("Invalid final location")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^ EM101
215 | 
216 |   await plate_reader.open()
    |
    = help: Assign to variable; remove string literal

praxis/backend/commons/tip_staging.py:1:1: D100 Missing docstring in public module
praxis/backend/commons/tip_staging.py:7:11: ANN201 Missing return type annotation for public function `wash_tips96`
  |
7 | async def wash_tips96(
  |           ^^^^^^^^^^^ ANN201
8 |   liquid_handler: LiquidHandler,
9 |   tip_racks: list[TipRack],
  |
  = help: Add return type annotation: `None`

praxis/backend/commons/tip_staging.py:7:11: D103 Missing docstring in public function
  |
7 | async def wash_tips96(
  |           ^^^^^^^^^^^ D103
8 |   liquid_handler: LiquidHandler,
9 |   tip_racks: list[TipRack],
  |

praxis/backend/commons/tip_staging.py:24:11: D103 Missing docstring in public function
   |
24 | async def split_tips_along_columns(wells: list[Well]) -> list[list[Well]]:
   |           ^^^^^^^^^^^^^^^^^^^^^^^^ D103
25 |   if not all(isinstance(well, Well) for well in wells):
26 |     raise ValueError("Invalid well type.")
   |

praxis/backend/commons/tip_staging.py:26:11: TRY003 Avoid specifying long messages outside the exception class
   |
24 | async def split_tips_along_columns(wells: list[Well]) -> list[list[Well]]:
25 |   if not all(isinstance(well, Well) for well in wells):
26 |     raise ValueError("Invalid well type.")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
27 |   columns = [(await parse_well_name(well))[0] for well in wells]
28 |   return [
   |

praxis/backend/commons/tip_staging.py:26:22: EM101 Exception must not use a string literal, assign to variable first
   |
24 | async def split_tips_along_columns(wells: list[Well]) -> list[list[Well]]:
25 |   if not all(isinstance(well, Well) for well in wells):
26 |     raise ValueError("Invalid well type.")
   |                      ^^^^^^^^^^^^^^^^^^^^ EM101
27 |   columns = [(await parse_well_name(well))[0] for well in wells]
28 |   return [
   |
   = help: Assign to variable; remove string literal

praxis/backend/configure.py:11:7: ANN204 Missing return type annotation for special method `__init__`
   |
 9 |   """Configuration class to handle Praxis configuration settings."""
10 | 
11 |   def __init__(self, config_file: str = "praxis.ini"):
   |       ^^^^^^^^ ANN204
12 |     """Initialize the PraxisConfiguration by loading the specified config file.
   |
   = help: Add return type annotation: `None`

praxis/backend/configure.py:173:5: PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
    |
171 |     """Return the protocol output directory path."""
172 |     path = self._output_directories_section.get("protocol_output", "./protocol_output")
173 |     os.makedirs(path, exist_ok=True)  # Ensure the directory exists
    |     ^^^^^^^^^^^ PTH103
174 |     return path
    |

praxis/backend/configure.py:197:20: PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    |
195 |     Ensures the directory exists.
196 |     """
197 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                    ^^^^^^^^^^^^ PTH118
198 |     path = self._protocol_directories_section.get("default_directory", default_path)
199 |     os.makedirs(
    |

praxis/backend/configure.py:197:33: PTH120 `os.path.dirname()` should be replaced by `Path.parent`
    |
195 |     Ensures the directory exists.
196 |     """
197 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                                 ^^^^^^^^^^^^^^^ PTH120
198 |     path = self._protocol_directories_section.get("default_directory", default_path)
199 |     os.makedirs(
    |

praxis/backend/configure.py:199:5: PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
    |
197 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
198 |     path = self._protocol_directories_section.get("default_directory", default_path)
199 |     os.makedirs(
    |     ^^^^^^^^^^^ PTH103
200 |       path, exist_ok=True,
201 |     )  # Use exist_ok=True to avoid error if it already exists
    |

praxis/backend/configure.py:231:19: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
    |
230 |     # Add default protocol directory
231 |     all_paths.add(os.path.abspath(self.default_protocol_dir))
    |                   ^^^^^^^^^^^^^^^ PTH100
232 | 
233 |     # Add additional directories
    |

praxis/backend/configure.py:235:21: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
    |
233 |     # Add additional directories
234 |     for d in self.additional_directories:
235 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^ PTH100
236 | 
237 |     # Add protocol discovery directories
    |

praxis/backend/configure.py:239:21: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
    |
237 |     # Add protocol discovery directories
238 |     for d in self.protocol_discovery_dirs:
239 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^ PTH100
240 | 
241 |     return sorted(list(all_paths))
    |

praxis/backend/configure.py:241:12: C414 Unnecessary `list` call within `sorted()`
    |
239 |       all_paths.add(os.path.abspath(d))
240 | 
241 |     return sorted(list(all_paths))
    |            ^^^^^^^^^^^^^^^^^^^^^^^ C414
242 | 
243 |   @property
    |
    = help: Remove the inner `list` call

praxis/backend/configure.py:282:10: PTH123 `open()` should be replaced by `Path.open()`
    |
280 |     self._config_parser.set("keycloak", "client_secret", client_secret)
281 | 
282 |     with open(self._config_file_path, "w") as f:
    |          ^^^^ PTH123
283 |       self._config_parser.write(f)
    |

praxis/backend/core/asset_lock_manager.py:30:7: ANN204 Missing return type annotation for special method `__init__`
   |
28 |   """
29 | 
30 |   def __init__(
   |       ^^^^^^^^ ANN204
31 |     self,
32 |     redis_url: str = "redis://localhost:6379/0",
   |
   = help: Add return type annotation: `None`

praxis/backend/core/asset_lock_manager.py:98:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
 96 |     return f"praxis:reservation:{reservation_id}"
 97 | 
 98 |   async def acquire_asset_lock(
    |             ^^^^^^^^^^^^^^^^^^ PLR0913
 99 |     self,
100 |     asset_type: str,
    |

praxis/backend/core/asset_lock_manager.py:122:13: TRY003 Avoid specifying long messages outside the exception class
    |
120 |     """
121 |     if not self._redis_client:
122 |       raise RuntimeError("Redis client not initialized")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
123 | 
124 |     timeout = timeout_seconds or self.lock_timeout_seconds
    |

praxis/backend/core/asset_lock_manager.py:122:26: EM101 Exception must not use a string literal, assign to variable first
    |
120 |     """
121 |     if not self._redis_client:
122 |       raise RuntimeError("Redis client not initialized")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
123 | 
124 |     timeout = timeout_seconds or self.lock_timeout_seconds
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_lock_manager.py:188:7: TRY300 Consider moving this statement to an `else` block
    |
186 |         lock_key,
187 |       )
188 |       return False
    |       ^^^^^^^^^^^^ TRY300
189 | 
190 |     except Exception:
    |

praxis/backend/core/asset_lock_manager.py:214:13: TRY003 Avoid specifying long messages outside the exception class
    |
212 |     """
213 |     if not self._redis_client:
214 |       raise RuntimeError("Redis client not initialized")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
215 | 
216 |     lock_key = self._get_asset_lock_key(asset_type, asset_name)
    |

praxis/backend/core/asset_lock_manager.py:214:26: EM101 Exception must not use a string literal, assign to variable first
    |
212 |     """
213 |     if not self._redis_client:
214 |       raise RuntimeError("Redis client not initialized")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
215 | 
216 |     lock_key = self._get_asset_lock_key(asset_type, asset_name)
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_lock_manager.py:252:7: TRY300 Consider moving this statement to an `else` block
    |
250 |         reservation_id,
251 |       )
252 |       return False
    |       ^^^^^^^^^^^^ TRY300
253 | 
254 |     except Exception:
    |

praxis/backend/core/asset_lock_manager.py:269:13: TRY003 Avoid specifying long messages outside the exception class
    |
267 |     """
268 |     if not self._redis_client:
269 |       raise RuntimeError("Redis client not initialized")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
270 | 
271 |     protocol_locks_key = self._get_protocol_locks_key(protocol_run_id)
    |

praxis/backend/core/asset_lock_manager.py:269:26: EM101 Exception must not use a string literal, assign to variable first
    |
267 |     """
268 |     if not self._redis_client:
269 |       raise RuntimeError("Redis client not initialized")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
270 | 
271 |     protocol_locks_key = self._get_protocol_locks_key(protocol_run_id)
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_lock_manager.py:285:34: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
283 |             # Parse asset info from key
284 |             key_parts = lock_key.split(":")
285 |             if len(key_parts) >= 4:
    |                                  ^ PLR2004
286 |               asset_type = key_parts[2]
287 |               asset_name = key_parts[3]
    |

praxis/backend/core/asset_lock_manager.py:301:9: PERF203 `try`-`except` within a loop incurs performance overhead
    |
299 |                   released_count += 1
300 |   
301 |           except Exception as e:
    |  _________^
302 | |           logger.error(
303 | |             "Error releasing individual lock %s: %s",
304 | |             lock_key,
305 | |             e,
306 | |           )
    | |___________^ PERF203
307 |   
308 |         # Clean up protocol locks tracking
    |

praxis/backend/core/asset_lock_manager.py:301:16: BLE001 Do not catch blind exception: `Exception`
    |
299 |                 released_count += 1
300 | 
301 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
302 |           logger.error(
303 |             "Error releasing individual lock %s: %s",
    |

praxis/backend/core/asset_lock_manager.py:302:11: TRY400 Use `logging.exception` instead of `logging.error`
    |
301 |           except Exception as e:
302 |             logger.error(
    |  ___________^
303 | |             "Error releasing individual lock %s: %s",
304 | |             lock_key,
305 | |             e,
306 | |           )
    | |___________^ TRY400
307 |   
308 |         # Clean up protocol locks tracking
    |
    = help: Replace with `exception`

praxis/backend/core/asset_lock_manager.py:316:7: TRY300 Consider moving this statement to an `else` block
    |
314 |         protocol_run_id,
315 |       )
316 |       return released_count
    |       ^^^^^^^^^^^^^^^^^^^^^ TRY300
317 | 
318 |     except Exception:
    |

praxis/backend/core/asset_lock_manager.py:338:13: TRY003 Avoid specifying long messages outside the exception class
    |
336 |     """
337 |     if not self._redis_client:
338 |       raise RuntimeError("Redis client not initialized")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
339 | 
340 |     lock_key = self._get_asset_lock_key(asset_type, asset_name)
    |

praxis/backend/core/asset_lock_manager.py:338:26: EM101 Exception must not use a string literal, assign to variable first
    |
336 |     """
337 |     if not self._redis_client:
338 |       raise RuntimeError("Redis client not initialized")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
339 | 
340 |     lock_key = self._get_asset_lock_key(asset_type, asset_name)
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_lock_manager.py:356:9: TRY300 Consider moving this statement to an `else` block
    |
354 |             return json.loads(reservation_data_str)
355 |           # Lock exists but no metadata, return basic info
356 |           return {
    |  _________^
357 | |           "reservation_id": lock_value,
358 | |           "asset_type": asset_type,
359 | |           "asset_name": asset_name,
360 | |           "status": "locked_no_metadata",
361 | |         }
    | |_________^ TRY300
362 |   
363 |         except (ValueError, json.JSONDecodeError):
    |

praxis/backend/core/asset_lock_manager.py:384:13: C901 `cleanup_expired_locks` is too complex (14 > 10)
    |
382 |       }
383 | 
384 |   async def cleanup_expired_locks(self) -> int:
    |             ^^^^^^^^^^^^^^^^^^^^^ C901
385 |     """Clean up expired asset locks and orphaned data.
    |

praxis/backend/core/asset_lock_manager.py:384:13: PLR0912 Too many branches (14 > 12)
    |
382 |       }
383 | 
384 |   async def cleanup_expired_locks(self) -> int:
    |             ^^^^^^^^^^^^^^^^^^^^^ PLR0912
385 |     """Clean up expired asset locks and orphaned data.
    |

praxis/backend/core/asset_lock_manager.py:395:13: TRY003 Avoid specifying long messages outside the exception class
    |
393 |     """
394 |     if not self._redis_client:
395 |       raise RuntimeError("Redis client not initialized")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
396 | 
397 |     cleaned_count = 0
    |

praxis/backend/core/asset_lock_manager.py:395:26: EM101 Exception must not use a string literal, assign to variable first
    |
393 |     """
394 |     if not self._redis_client:
395 |       raise RuntimeError("Redis client not initialized")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
396 | 
397 |     cleaned_count = 0
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_lock_manager.py:405:9: PERF401 Use an async list comprehension to create a transformed list
    |
404 |       async for key in self._redis_client.scan_iter(match=lock_pattern):
405 |         lock_keys.append(key)
    |         ^^^^^^^^^^^^^^^^^^^^^ PERF401
406 | 
407 |       logger.info("Found %d asset locks to check for expiration", len(lock_keys))
    |

praxis/backend/core/asset_lock_manager.py:458:16: BLE001 Do not catch blind exception: `Exception`
    |
456 |             logger.debug("Cleaned up invalid lock: %s", lock_key)
457 | 
458 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
459 |           logger.error(
460 |             "Error checking lock %s during cleanup: %s",
    |

praxis/backend/core/asset_lock_manager.py:459:11: TRY400 Use `logging.exception` instead of `logging.error`
    |
458 |           except Exception as e:
459 |             logger.error(
    |  ___________^
460 | |             "Error checking lock %s during cleanup: %s",
461 | |             lock_key,
462 | |             e,
463 | |           )
    | |___________^ TRY400
464 |   
465 |         if cleaned_count > 0:
    |
    = help: Replace with `exception`

praxis/backend/core/asset_lock_manager.py:468:7: TRY300 Consider moving this statement to an `else` block
    |
466 |         logger.info("Cleaned up %d expired/orphaned asset locks", cleaned_count)
467 | 
468 |       return cleaned_count
    |       ^^^^^^^^^^^^^^^^^^^^ TRY300
469 | 
470 |     except Exception:
    |

praxis/backend/core/asset_manager.py:46:57: TCH001 Move application import `praxis.backend.models.resource_instance_orm.ResourceOrm` into a type-checking block
   |
44 |   ResourceStatusEnum,
45 | )
46 | from praxis.backend.models.resource_instance_orm import ResourceOrm
   |                                                         ^^^^^^^^^^^ TCH001
47 | from praxis.backend.services.praxis_orm_service import PraxisORMService
48 | from praxis.backend.utils.errors import (
   |
   = help: Move into type-checking block

praxis/backend/core/asset_manager.py:88:7: ANN204 Missing return type annotation for special method `__init__`
   |
86 |   """Manages the lifecycle and allocation of assets."""
87 | 
88 |   def __init__(self, db_session: AsyncSession, workcell_runtime: WorkcellRuntime):
   |       ^^^^^^^^ ANN204
89 |     """Initialize the AssetManager.
   |
   = help: Add return type annotation: `None`

praxis/backend/core/asset_manager.py:100:61: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
 98 |     self.svc = PraxisORMService()
 99 | 
100 |     self.EXCLUDED_BASE_CLASSES: list[type[Resource]] = [  # TODO: maybe just inspect if it's abstract?
    |                                                             ^^^^ TD002
101 |       Carrier,
102 |       Container,
    |

praxis/backend/core/asset_manager.py:100:61: TD003 Missing issue link on the line following this TODO
    |
 98 |     self.svc = PraxisORMService()
 99 | 
100 |     self.EXCLUDED_BASE_CLASSES: list[type[Resource]] = [  # TODO: maybe just inspect if it's abstract?
    |                                                             ^^^^ TD003
101 |       Carrier,
102 |       Container,
    |

praxis/backend/core/asset_manager.py:100:61: FIX002 Line contains TODO, consider resolving the issue
    |
 98 |     self.svc = PraxisORMService()
 99 | 
100 |     self.EXCLUDED_BASE_CLASSES: list[type[Resource]] = [  # TODO: maybe just inspect if it's abstract?
    |                                                             ^^^^ FIX002
101 |       Carrier,
102 |       Container,
    |

praxis/backend/core/asset_manager.py:232:9: TRY401 Redundant exception object included in `logging.exception` call
    |
230 |         "AM_EXTRACT_ORDER: Error extracting ordering for %s: %s",
231 |         resource_class.__name__,
232 |         e,
    |         ^ TRY401
233 |       )
234 |     return ordering_value
    |

praxis/backend/core/asset_manager.py:256:5: SIM103 Return the negated condition directly
    |
254 |       if plr_class in self.EXCLUDED_BASE_CLASSES:
255 |         return False  # Generic base classes listed are explicitly excluded.
256 |       if not plr_class.__module__.startswith("pylabrobot.resources"):
    |  _____^
257 | |       return False
258 | |     return True
    | |_______________^ SIM103
259 |   
260 |     @async_asset_manager_errors(
    |
    = help: Inline condition

praxis/backend/core/asset_manager.py:266:5: ANN001 Missing type annotation for function argument `plr_resources_package`
    |
264 |   async def sync_pylabrobot_definitions(
265 |     self,
266 |     plr_resources_package=pylabrobot.resources,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
267 |   ) -> tuple[int, int]:
268 |     """Scan and sync PyLabRobot resource definitions.
    |

praxis/backend/core/asset_manager.py:372:13: C901 `apply_deck_instance` is too complex (12 > 10)
    |
370 |     return added_count, updated_count
371 | 
372 |   async def apply_deck_instance(
    |             ^^^^^^^^^^^^^^^^^^^ C901
373 |     self,
374 |     deck_orm_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:403:13: TRY003 Avoid specifying long messages outside the exception class
    |
401 |       )
402 |       if not deck_orm:
403 |         raise AssetAcquisitionError(
    |  _____________^
404 | |         f"Deck ID '{deck_orm_accession_id}' not found.",
405 | |       )
    | |_______^ TRY003
406 |   
407 |       deck_resource_orm = await self.svc.read_resource(
    |

praxis/backend/core/asset_manager.py:404:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
402 |     if not deck_orm:
403 |       raise AssetAcquisitionError(
404 |         f"Deck ID '{deck_orm_accession_id}' not found.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
405 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:410:10: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
408 |       self.db,
409 |       deck_orm.accession_id,
410 |     )  # TODO: make sure these are synced
    |          ^^^^ TD002
411 |     if not deck_resource_orm:
412 |       raise AssetAcquisitionError(
    |

praxis/backend/core/asset_manager.py:410:10: TD003 Missing issue link on the line following this TODO
    |
408 |       self.db,
409 |       deck_orm.accession_id,
410 |     )  # TODO: make sure these are synced
    |          ^^^^ TD003
411 |     if not deck_resource_orm:
412 |       raise AssetAcquisitionError(
    |

praxis/backend/core/asset_manager.py:410:10: FIX002 Line contains TODO, consider resolving the issue
    |
408 |       self.db,
409 |       deck_orm.accession_id,
410 |     )  # TODO: make sure these are synced
    |          ^^^^ FIX002
411 |     if not deck_resource_orm:
412 |       raise AssetAcquisitionError(
    |

praxis/backend/core/asset_manager.py:412:13: TRY003 Avoid specifying long messages outside the exception class
    |
410 |       )  # TODO: make sure these are synced
411 |       if not deck_resource_orm:
412 |         raise AssetAcquisitionError(
    |  _____________^
413 | |         f"Deck Resource ID '{deck_orm.accession_id}' (from Deck '{deck_orm.name}') not found.",
414 | |       )
    | |_______^ TRY003
415 |   
416 |       deck_def_orm = await self.svc.read_resource_definition(
    |

praxis/backend/core/asset_manager.py:413:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
411 |     if not deck_resource_orm:
412 |       raise AssetAcquisitionError(
413 |         f"Deck Resource ID '{deck_orm.accession_id}' (from Deck '{deck_orm.name}') not found.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
414 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:421:13: TRY003 Avoid specifying long messages outside the exception class
    |
419 |       )
420 |       if not deck_def_orm or not deck_def_orm.fqn:
421 |         raise AssetAcquisitionError(
    |  _____________^
422 | |         f"Resource definition for deck '{deck_resource_orm.name}' not found or FQN missing.",
423 | |       )
    | |_______^ TRY003
424 |   
425 |       if (
    |

praxis/backend/core/asset_manager.py:422:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
420 |     if not deck_def_orm or not deck_def_orm.fqn:
421 |       raise AssetAcquisitionError(
422 |         f"Resource definition for deck '{deck_resource_orm.name}' not found or FQN missing.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
423 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:429:13: TRY003 Avoid specifying long messages outside the exception class
    |
427 |         and deck_resource_orm.current_protocol_run_accession_id != protocol_run_accession_id
428 |       ):
429 |         raise AssetAcquisitionError(
    |  _____________^
430 | |         f"Deck resource '{deck_resource_orm.name}' is IN_USE by another run.",
431 | |       )
    | |_______^ TRY003
432 |   
433 |       live_plr_deck_object = await self.workcell_runtime.create_or_get_resource(
    |

praxis/backend/core/asset_manager.py:430:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
428 |     ):
429 |       raise AssetAcquisitionError(
430 |         f"Deck resource '{deck_resource_orm.name}' is IN_USE by another run.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
431 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:438:13: TRY003 Avoid specifying long messages outside the exception class
    |
436 |       )
437 |       if not isinstance(live_plr_deck_object, Deck):
438 |         raise AssetAcquisitionError(
    |  _____________^
439 | |         f"Failed to initialize PLR Deck for '{deck_resource_orm.name}'.",
440 | |       )
    | |_______^ TRY003
441 |   
442 |       # Determine parent machine for location of the deck resource itself
    |

praxis/backend/core/asset_manager.py:439:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
437 |     if not isinstance(live_plr_deck_object, Deck):
438 |       raise AssetAcquisitionError(
439 |         f"Failed to initialize PLR Deck for '{deck_resource_orm.name}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
440 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:452:5: ERA001 Found commented-out code
    |
450 |     # if hasattr(deck_orm, 'deck_parent_machine_accession_id') and
451 |     # deck_orm.deck_parent_machine_accession_id:
452 |     #    parent_machine_accession_id_for_deck = deck_orm.deck_parent_machine_accession_id
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
453 |     #    # Potentially log parent machine name
454 |     # elif deck_orm.deck_parent_machine: # If relationship is loaded
    |
    = help: Remove commented-out code

praxis/backend/core/asset_manager.py:454:5: ERA001 Found commented-out code
    |
452 |     #    parent_machine_accession_id_for_deck = deck_orm.deck_parent_machine_accession_id
453 |     #    # Potentially log parent machine name
454 |     # elif deck_orm.deck_parent_machine: # If relationship is loaded
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
455 |     #    parent_machine_accession_id_for_deck = deck_orm.deck_parent_machine.accession_id
456 |     #    parent_machine_name_for_log =
    |
    = help: Remove commented-out code

praxis/backend/core/asset_manager.py:455:5: ERA001 Found commented-out code
    |
453 |     #    # Potentially log parent machine name
454 |     # elif deck_orm.deck_parent_machine: # If relationship is loaded
455 |     #    parent_machine_accession_id_for_deck = deck_orm.deck_parent_machine.accession_id
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
456 |     #    parent_machine_name_for_log =
457 |     # deck_orm.deck_parent_machine.name
    |
    = help: Remove commented-out code

praxis/backend/core/asset_manager.py:508:17: TRY003 Avoid specifying long messages outside the exception class
    |
506 |             ResourceStatusEnum.AVAILABLE_ON_DECK,
507 |           ]:
508 |             raise AssetAcquisitionError(
    |  _________________^
509 | |             f"Resource {item_to_place_accession_id} for position "
510 | |             f"'{position_item_orm.position_accession_id}' unavailable (status: "
511 | |             f"{item_to_place_orm.current_status}).",
512 | |           )
    | |___________^ TRY003
513 |   
514 |           item_def_orm = await self.svc.read_resource_definition(
    |

praxis/backend/core/asset_manager.py:509:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
507 |           ]:
508 |             raise AssetAcquisitionError(
509 |               f"Resource {item_to_place_accession_id} for position "
    |  _____________^
510 | |             f"'{position_item_orm.position_accession_id}' unavailable (status: "
511 | |             f"{item_to_place_orm.current_status}).",
    | |___________________________________________________^ EM102
512 |             )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:519:17: TRY003 Avoid specifying long messages outside the exception class
    |
517 |           )
518 |           if not item_def_orm or not item_def_orm.fqn:
519 |             raise AssetAcquisitionError(
    |  _________________^
520 | |             f"FQN not found for resource definition '{item_to_place_orm.fqn}'.",
521 | |           )
    | |___________^ TRY003
522 |   
523 |           await self.workcell_runtime.create_or_get_resource(
    |

praxis/backend/core/asset_manager.py:520:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
518 |         if not item_def_orm or not item_def_orm.fqn:
519 |           raise AssetAcquisitionError(
520 |             f"FQN not found for resource definition '{item_to_place_orm.fqn}'.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
521 |           )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:553:5: S101 Use of `assert` detected
    |
551 |       deck_orm.name,
552 |     )
553 |     assert isinstance(
    |     ^^^^^^ S101
554 |       live_plr_deck_object,
555 |       Deck,
    |

praxis/backend/core/asset_manager.py:564:5: ARG002 Unused method argument: `constraints`
    |
562 |     requested_asset_name_in_protocol: str,
563 |     fqn_constraint: str,
564 |     constraints: dict[str, Any] | None = None,
    |     ^^^^^^^^^^^ ARG002
565 |   ) -> tuple[Any, uuid.UUID, str]:
566 |     """Acquire a Machine that is available or already in use by the current run.
    |

praxis/backend/core/asset_manager.py:595:15: TRY003 Avoid specifying long messages outside the exception class
    |
593 |         cls_obj = getattr(module, class_name)
594 |         if issubclass(cls_obj, Deck):  # Direct check against Deck
595 |           raise AssetAcquisitionError(
    |  _______________^
596 | |           f"Attempted to acquire Deck FQN '{fqn_constraint}' via acquire_machine. Use acquire_resource.",
597 | |         )
    | |_________^ TRY003
598 |       except (ImportError, AttributeError, ValueError) as e:
599 |         logger.warning(
    |

praxis/backend/core/asset_manager.py:596:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
594 |       if issubclass(cls_obj, Deck):  # Direct check against Deck
595 |         raise AssetAcquisitionError(
596 |           f"Attempted to acquire Deck FQN '{fqn_constraint}' via acquire_machine. Use acquire_resource.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
597 |         )
598 |     except (ImportError, AttributeError, ValueError) as e:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:600:9: G004 Logging statement uses f-string
    |
598 |     except (ImportError, AttributeError, ValueError) as e:
599 |       logger.warning(
600 |         f"Could not dynamically verify FQN '{fqn_constraint}' during machine acquisition safeguard: {e}",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
601 |       )
602 |     # Also check against resource definitions just in case it's cataloged as a deck
    |

praxis/backend/core/asset_manager.py:611:13: TRY003 Avoid specifying long messages outside the exception class
    |
609 |         or (potential_deck_def.fqn and "deck" in potential_deck_def.fqn.lower())
610 |       ):
611 |         raise AssetAcquisitionError(
    |  _____________^
612 | |         f"FQN '{fqn_constraint}' matches a cataloged Deck resource. Use acquire_resource.",
613 | |       )
    | |_______^ TRY003
614 |   
615 |       selected_machine_orm: MachineOrm | None = None
    |

praxis/backend/core/asset_manager.py:612:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
610 |     ):
611 |       raise AssetAcquisitionError(
612 |         f"FQN '{fqn_constraint}' matches a cataloged Deck resource. Use acquire_resource.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
613 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:638:15: TRY003 Avoid specifying long messages outside the exception class
    |
636 |           )
637 |         else:
638 |           raise AssetAcquisitionError(
    |  _______________^
639 | |           f"No machine found for FQN '{fqn_constraint}' (Status: AVAILABLE or IN_USE by this run).",
640 | |         )
    | |_________^ TRY003
641 |   
642 |       if not selected_machine_orm:
    |

praxis/backend/core/asset_manager.py:639:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
637 |       else:
638 |         raise AssetAcquisitionError(
639 |           f"No machine found for FQN '{fqn_constraint}' (Status: AVAILABLE or IN_USE by this run).",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
640 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:643:13: TRY003 Avoid specifying long messages outside the exception class
    |
642 |       if not selected_machine_orm:
643 |         raise AssetAcquisitionError(
    |  _____________^
644 | |         f"Machine selection failed for '{requested_asset_name_in_protocol}'.",
645 | |       )
    | |_______^ TRY003
646 |   
647 |       live_plr_machine = await self.workcell_runtime.initialize_machine(
    |

praxis/backend/core/asset_manager.py:644:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
642 |     if not selected_machine_orm:
643 |       raise AssetAcquisitionError(
644 |         f"Machine selection failed for '{requested_asset_name_in_protocol}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
645 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:657:13: TRY003 Avoid specifying long messages outside the exception class
    |
655 |           status_details=f"Backend init failed for run {protocol_run_accession_id}.",
656 |         )
657 |         raise AssetAcquisitionError(
    |  _____________^
658 | |         f"Failed to initialize backend for machine '{selected_machine_orm.name}'.",
659 | |       )
    | |_______^ TRY003
660 |   
661 |       if (
    |

praxis/backend/core/asset_manager.py:658:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
656 |       )
657 |       raise AssetAcquisitionError(
658 |         f"Failed to initialize backend for machine '{selected_machine_orm.name}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
659 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:673:15: TRY003 Avoid specifying long messages outside the exception class
    |
671 |         )
672 |         if not updated_machine_orm:
673 |           raise AssetAcquisitionError(
    |  _______________^
674 | |           f"CRITICAL: Failed to update DB status for machine '{selected_machine_orm.name}'.",
675 | |         )
    | |_________^ TRY003
676 |         selected_machine_orm = updated_machine_orm  # Use the updated ORM
    |

praxis/backend/core/asset_manager.py:674:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
672 |       if not updated_machine_orm:
673 |         raise AssetAcquisitionError(
674 |           f"CRITICAL: Failed to update DB status for machine '{selected_machine_orm.name}'.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
675 |         )
676 |       selected_machine_orm = updated_machine_orm  # Use the updated ORM
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:685:13: C901 `acquire_resource` is too complex (21 > 10)
    |
683 |     return live_plr_machine, selected_machine_orm.accession_id, "machine"
684 | 
685 |   async def acquire_resource(
    |             ^^^^^^^^^^^^^^^^ C901
686 |     self,
687 |     protocol_run_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:685:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
683 |     return live_plr_machine, selected_machine_orm.accession_id, "machine"
684 | 
685 |   async def acquire_resource(
    |             ^^^^^^^^^^^^^^^^ PLR0913
686 |     self,
687 |     protocol_run_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:685:13: PLR0912 Too many branches (23 > 12)
    |
683 |     return live_plr_machine, selected_machine_orm.accession_id, "machine"
684 | 
685 |   async def acquire_resource(
    |             ^^^^^^^^^^^^^^^^ PLR0912
686 |     self,
687 |     protocol_run_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:685:13: PLR0915 Too many statements (68 > 50)
    |
683 |     return live_plr_machine, selected_machine_orm.accession_id, "machine"
684 | 
685 |   async def acquire_resource(
    |             ^^^^^^^^^^^^^^^^ PLR0915
686 |     self,
687 |     protocol_run_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:729:15: TRY003 Avoid specifying long messages outside the exception class
    |
727 |         )
728 |         if not instance_orm:
729 |           raise AssetAcquisitionError(
    |  _______________^
730 | |           f"Specified resource ID {user_choice_instance_accession_id} not found.",
731 | |         )
    | |_________^ TRY003
732 |         if instance_orm.fqn != fqn:
733 |           raise AssetAcquisitionError(
    |

praxis/backend/core/asset_manager.py:730:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
728 |       if not instance_orm:
729 |         raise AssetAcquisitionError(
730 |           f"Specified resource ID {user_choice_instance_accession_id} not found.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
731 |         )
732 |       if instance_orm.fqn != fqn:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:733:15: TRY003 Avoid specifying long messages outside the exception class
    |
731 |           )
732 |         if instance_orm.fqn != fqn:
733 |           raise AssetAcquisitionError(
    |  _______________^
734 | |           f"Chosen instance {user_choice_instance_accession_id} (Def: {instance_orm.fqn}) "
735 | |           f"mismatches constraint {fqn}.",
736 | |         )
    | |_________^ TRY003
737 |         if instance_orm.current_status == ResourceStatusEnum.IN_USE:
738 |           if instance_orm.current_protocol_run_accession_id != uuid.UUID(
    |

praxis/backend/core/asset_manager.py:734:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
732 |         if instance_orm.fqn != fqn:
733 |           raise AssetAcquisitionError(
734 |             f"Chosen instance {user_choice_instance_accession_id} (Def: {instance_orm.fqn}) "
    |  ___________^
735 | |           f"mismatches constraint {fqn}.",
    | |_________________________________________^ EM102
736 |           )
737 |         if instance_orm.current_status == ResourceStatusEnum.IN_USE:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:741:17: TRY003 Avoid specifying long messages outside the exception class
    |
739 |             str(protocol_run_accession_id),
740 |           ):
741 |             raise AssetAcquisitionError(
    |  _________________^
742 | |             f" {user_choice_instance_accession_id} IN_USE by another run.",
743 | |           )
    | |___________^ TRY003
744 |         elif instance_orm.current_status not in [
745 |           ResourceStatusEnum.AVAILABLE_IN_STORAGE,
    |

praxis/backend/core/asset_manager.py:742:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
740 |         ):
741 |           raise AssetAcquisitionError(
742 |             f" {user_choice_instance_accession_id} IN_USE by another run.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
743 |           )
744 |       elif instance_orm.current_status not in [
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:748:15: TRY003 Avoid specifying long messages outside the exception class
    |
746 |           ResourceStatusEnum.AVAILABLE_ON_DECK,
747 |         ]:
748 |           raise AssetAcquisitionError(
    |  _______________^
749 | |           f"Chosen instance {user_choice_instance_accession_id} not available (Status: "
750 | |           f"{instance_orm.current_status.name}).",
751 | |         )
    | |_________^ TRY003
752 |         resource_instance_to_acquire = instance_orm
753 |       else:
    |

praxis/backend/core/asset_manager.py:749:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
747 |         ]:
748 |           raise AssetAcquisitionError(
749 |             f"Chosen instance {user_choice_instance_accession_id} not available (Status: "
    |  ___________^
750 | |           f"{instance_orm.current_status.name}).",
    | |_________________________________________________^ EM102
751 |           )
752 |         resource_instance_to_acquire = instance_orm
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:783:13: TRY003 Avoid specifying long messages outside the exception class
    |
782 |       if not resource_instance_to_acquire:
783 |         raise AssetAcquisitionError(
    |  _____________^
784 | |         f"No instance found for definition '{fqn}' matching criteria for run '{protocol_run_accession_id}'.",
785 | |       )
    | |_______^ TRY003
786 |   
787 |       resource_def_orm = await self.svc.read_resource_definition(
    |

praxis/backend/core/asset_manager.py:784:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
782 |     if not resource_instance_to_acquire:
783 |       raise AssetAcquisitionError(
784 |         f"No instance found for definition '{fqn}' matching criteria for run '{protocol_run_accession_id}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
785 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:798:13: TRY003 Avoid specifying long messages outside the exception class
    |
796 |           status_details=f"FQN missing for def {resource_instance_to_acquire.fqn}",
797 |         )
798 |         raise AssetAcquisitionError(
    |  _____________^
799 | |         f"FQN not found for resource definition '{resource_instance_to_acquire.fqn}'.",
800 | |       )
    | |_______^ TRY003
801 |   
802 |       live_plr_resource = await self.workcell_runtime.create_or_get_resource(
    |

praxis/backend/core/asset_manager.py:799:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
797 |       )
798 |       raise AssetAcquisitionError(
799 |         f"FQN not found for resource definition '{resource_instance_to_acquire.fqn}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
800 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:813:13: TRY003 Avoid specifying long messages outside the exception class
    |
811 |           status_details="PLR object creation failed.",
812 |         )
813 |         raise AssetAcquisitionError(
    |  _____________^
814 | |         f"Failed to create/get PLR object for '{resource_instance_to_acquire.name}'.",
815 | |       )
    | |_______^ TRY003
816 |   
817 |       target_deck_resource_accession_id: uuid.UUID | None = None
    |

praxis/backend/core/asset_manager.py:814:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
812 |       )
813 |       raise AssetAcquisitionError(
814 |         f"Failed to create/get PLR object for '{resource_instance_to_acquire.name}'.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
815 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:833:17: TRY003 Avoid specifying long messages outside the exception class
    |
831 |           )
832 |           if not target_deck_instance:
833 |             raise AssetAcquisitionError(
    |  _________________^
834 | |             f"Target deck resource '{deck_user_name}' not found.",
835 | |           )
    | |___________^ TRY003
836 |           # Verify target_deck_instance is a deck
837 |           target_deck_def = await self.svc.read_resource_definition(
    |

praxis/backend/core/asset_manager.py:834:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
832 |         if not target_deck_instance:
833 |           raise AssetAcquisitionError(
834 |             f"Target deck resource '{deck_user_name}' not found.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
835 |           )
836 |         # Verify target_deck_instance is a deck
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:850:17: TRY003 Avoid specifying long messages outside the exception class
    |
848 |           )
849 |         ):
850 |           raise AssetAcquisitionError(f"Target '{deck_user_name}' is not a deck type.")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
851 |         target_deck_resource_accession_id = target_deck_instance.accession_id
852 |         target_position_name = position_on_deck
    |

praxis/backend/core/asset_manager.py:850:39: EM102 Exception must not use an f-string literal, assign to variable first
    |
848 |           )
849 |         ):
850 |           raise AssetAcquisitionError(f"Target '{deck_user_name}' is not a deck type.")
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
851 |         target_deck_resource_accession_id = target_deck_instance.accession_id
852 |         target_position_name = position_on_deck
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:861:15: TRY003 Avoid specifying long messages outside the exception class
    |
859 |             '{target_position_name}' for run {protocol_run_accession_id}"
860 |         elif deck_user_name or position_on_deck:
861 |           raise AssetAcquisitionError(
    |  _______________^
862 | |           "Partial location constraint: 'deck_name' and 'position_name' required.",
863 | |         )
    | |_________^ TRY003
864 |       elif is_acquiring_a_deck_resource and location_constraints:
865 |         logger.warning(
    |

praxis/backend/core/asset_manager.py:862:11: EM101 Exception must not use a string literal, assign to variable first
    |
860 |       elif deck_user_name or position_on_deck:
861 |         raise AssetAcquisitionError(
862 |           "Partial location constraint: 'deck_name' and 'position_name' required.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
863 |         )
864 |     elif is_acquiring_a_deck_resource and location_constraints:
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/asset_manager.py:906:15: TRY003 Avoid specifying long messages outside the exception class
    |
904 |         )
905 |         if not updated_resource_instance:
906 |           raise AssetAcquisitionError(
    |  _______________^
907 | |           f"CRITICAL: Failed to update DB for resource '{resource_instance_to_acquire.name}'.",
908 | |         )
    | |_________^ TRY003
909 |         resource_instance_to_acquire = updated_resource_instance  # Use updated ORM
    |

praxis/backend/core/asset_manager.py:907:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
905 |       if not updated_resource_instance:
906 |         raise AssetAcquisitionError(
907 |           f"CRITICAL: Failed to update DB for resource '{resource_instance_to_acquire.name}'.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
908 |         )
909 |       resource_instance_to_acquire = updated_resource_instance  # Use updated ORM
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:918:13: ANN201 Missing return type annotation for public function `release_machine`
    |
916 |     return live_plr_resource, resource_instance_to_acquire.accession_id, "resource"
917 | 
918 |   async def release_machine(
    |             ^^^^^^^^^^^^^^^ ANN201
919 |     self,
920 |     machine_orm_accession_id: uuid.UUID,
    |
    = help: Add return type annotation: `None`

praxis/backend/core/asset_manager.py:928:9: G004 Logging statement uses f-string
    |
926 |     if not machine_to_release:
927 |       logger.warning(
928 |         f"AM_RELEASE_MACHINE: Machine ID {machine_orm_accession_id} not found.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
929 |       )
930 |       return
    |

praxis/backend/core/asset_manager.py:941:9: G004 Logging statement uses f-string
    |
939 |       if "deck" in machine_to_release.fqn.lower() or "Deck" in machine_to_release.fqn:
940 |         logger.error(
941 |           f"AM_RELEASE_MACHINE: Attempt to release Deck-like FQN "
    |  _________^
942 | |         f"'{machine_to_release.fqn}' via release_machine. Use release_resource.",
    | |________________________________________________________________________________^ G004
943 |         )
944 |         return  # Avoid proceeding
    |

praxis/backend/core/asset_manager.py:955:13: TRY003 Avoid specifying long messages outside the exception class
    |
953 |       )
954 |       if not updated_machine:
955 |         raise AssetReleaseError(
    |  _____________^
956 | |         f"Failed to update DB status for machine ID {machine_orm_accession_id} after shutdown.",
957 | |       )
    | |_______^ TRY003
958 |       logger.info(
959 |         "AM_RELEASE_MACHINE: Machine '%s' released, status %s.",
    |

praxis/backend/core/asset_manager.py:956:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
954 |     if not updated_machine:
955 |       raise AssetReleaseError(
956 |         f"Failed to update DB status for machine ID {machine_orm_accession_id} after shutdown.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
957 |       )
958 |     logger.info(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:964:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
962 |     )
963 | 
964 |   async def release_resource(
    |             ^^^^^^^^^^^^^^^^ PLR0913
965 |     self,
966 |     resource_orm_accession_id: uuid.UUID,
    |

praxis/backend/core/asset_manager.py:964:13: ANN201 Missing return type annotation for public function `release_resource`
    |
962 |     )
963 | 
964 |   async def release_resource(
    |             ^^^^^^^^^^^^^^^^ ANN201
965 |     self,
966 |     resource_orm_accession_id: uuid.UUID,
    |
    = help: Add return type annotation: `None`

praxis/backend/core/asset_manager.py:1019:7: S110 `try`-`except`-`pass` detected, consider logging the exception
     |
1017 |           if issubclass(plr_class, Deck):
1018 |             is_releasing_a_deck_resource = True
1019 |         except Exception:
     |  _______^
1020 | |         pass  # Ignore import/check errors, rely on category
     | |____________^ S110
1021 |   
1022 |       if is_releasing_a_deck_resource:
     |

praxis/backend/core/asset_manager.py:1019:14: BLE001 Do not catch blind exception: `Exception`
     |
1017 |         if issubclass(plr_class, Deck):
1018 |           is_releasing_a_deck_resource = True
1019 |       except Exception:
     |              ^^^^^^^^^ BLE001
1020 |         pass  # Ignore import/check errors, rely on category
     |

praxis/backend/core/asset_manager.py:1066:13: TRY003 Avoid specifying long messages outside the exception class
     |
1064 |       )
1065 |       if not updated_resource:
1066 |         raise AssetReleaseError(
     |  _____________^
1067 | |         f"Failed to update DB for resource ID {resource_orm_accession_id} on release.",
1068 | |       )
     | |_______^ TRY003
1069 |       logger.info(
1070 |         "AM_RELEASE_RESOURCE: Resource '%s' released, status %s.",
     |

praxis/backend/core/asset_manager.py:1067:9: EM102 Exception must not use an f-string literal, assign to variable first
     |
1065 |     if not updated_resource:
1066 |       raise AssetReleaseError(
1067 |         f"Failed to update DB for resource ID {resource_orm_accession_id} on release.",
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1068 |       )
1069 |     logger.info(
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:1132:11: TRY301 Abstract `raise` to an inner function
     |
1130 |           cls_obj = getattr(importlib.import_module(module_path), class_name)
1131 |           if issubclass(cls_obj, Deck):
1132 |             raise AssetAcquisitionError(
     |  ___________^
1133 | |             f"Asset type '{asset_fqn}' appears to be a Deck but not found in ResourceCatalog. Ensure it's synced.",
1134 | |           )
     | |___________^ TRY301
1135 |         except Exception:
1136 |           pass
     |

praxis/backend/core/asset_manager.py:1132:17: TRY003 Avoid specifying long messages outside the exception class
     |
1130 |           cls_obj = getattr(importlib.import_module(module_path), class_name)
1131 |           if issubclass(cls_obj, Deck):
1132 |             raise AssetAcquisitionError(
     |  _________________^
1133 | |             f"Asset type '{asset_fqn}' appears to be a Deck but not found in ResourceCatalog. Ensure it's synced.",
1134 | |           )
     | |___________^ TRY003
1135 |         except Exception:
1136 |           pass
     |

praxis/backend/core/asset_manager.py:1133:13: EM102 Exception must not use an f-string literal, assign to variable first
     |
1131 |         if issubclass(cls_obj, Deck):
1132 |           raise AssetAcquisitionError(
1133 |             f"Asset type '{asset_fqn}' appears to be a Deck but not found in ResourceCatalog. Ensure it's synced.",
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1134 |           )
1135 |       except Exception:
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/asset_manager.py:1135:7: S110 `try`-`except`-`pass` detected, consider logging the exception
     |
1133 |               f"Asset type '{asset_fqn}' appears to be a Deck but not found in ResourceCatalog. Ensure it's synced.",
1134 |             )
1135 |         except Exception:
     |  _______^
1136 | |         pass
     | |____________^ S110
1137 |   
1138 |       return await self.acquire_machine(
     |

praxis/backend/core/asset_manager.py:1135:14: BLE001 Do not catch blind exception: `Exception`
     |
1133 |             f"Asset type '{asset_fqn}' appears to be a Deck but not found in ResourceCatalog. Ensure it's synced.",
1134 |           )
1135 |       except Exception:
     |              ^^^^^^^^^ BLE001
1136 |         pass
     |

praxis/backend/core/celery.py:2:1: D400 First line should end with a period
  |
1 |   # pylint: disable=fixme
2 | / """Celery application factory. # broad-except is handled in celery_tasks.py
3 | | 
4 | | This module provides the configured Celery application instance
5 | | for use by worker and application code.
6 | | """
  | |___^ D400
7 |   from celery import Celery
  |
  = help: Add period

praxis/backend/core/celery.py:2:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 |   # pylint: disable=fixme
2 | / """Celery application factory. # broad-except is handled in celery_tasks.py
3 | | 
4 | | This module provides the configured Celery application instance
5 | | for use by worker and application code.
6 | | """
  | |___^ D415
7 |   from celery import Celery
  |
  = help: Add closing punctuation

praxis/backend/core/celery.py:37:3: ERA001 Found commented-out code
   |
35 |   # Example: Clean up old completed tasks
36 |   # "cleanup-completed-runs": {
37 |   #     "task": "praxis.backend.core.celery_tasks.cleanup_completed_protocol_runs",
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
38 |   #     "schedule": crontab(minute=0, hour=2),  # Daily at 2 AM
39 |   # },
   |
   = help: Remove commented-out code

praxis/backend/core/celery.py:38:3: ERA001 Found commented-out code
   |
36 |   # "cleanup-completed-runs": {
37 |   #     "task": "praxis.backend.core.celery_tasks.cleanup_completed_protocol_runs",
38 |   #     "schedule": crontab(minute=0, hour=2),  # Daily at 2 AM
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
39 |   # },
40 | }
   |
   = help: Remove commented-out code

praxis/backend/core/celery_tasks.py:33:7: ANN204 Missing return type annotation for special method `__init__`
   |
31 |   """A context object to hold shared dependencies for Celery tasks."""
32 | 
33 |   def __init__(
   |       ^^^^^^^^ ANN204
34 |     self,
35 |     db_session_factory: async_sessionmaker[AsyncSession],
   |
   = help: Add return type annotation: `None`

praxis/backend/core/celery_tasks.py:36:19: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `orchestrator`
   |
34 |     self,
35 |     db_session_factory: async_sessionmaker[AsyncSession],
36 |     orchestrator: Any | None = None,  # Avoid circular import with type hint
   |                   ^^^^^^^^^^ ANN401
37 |   ):
38 |     """Initialize the protocol execution context.
   |

praxis/backend/core/celery_tasks.py:53:5: ANN201 Missing return type annotation for public function `initialize_celery_context`
   |
53 | def initialize_celery_context(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |   db_session_factory: async_sessionmaker[AsyncSession],
55 |   orchestrator: Any,
   |
   = help: Add return type annotation: `None`

praxis/backend/core/celery_tasks.py:55:17: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `orchestrator`
   |
53 | def initialize_celery_context(
54 |   db_session_factory: async_sessionmaker[AsyncSession],
55 |   orchestrator: Any,
   |                 ^^^ ANN401
56 | ):
57 |   """Initialize the global context for Celery tasks with necessary dependencies.
   |

praxis/backend/core/celery_tasks.py:62:10: PLW0603 Using the global statement to update `_execution_context` is discouraged
   |
60 |   that all Celery workers have access to the database and orchestrator.
61 |   """
62 |   global _execution_context
   |          ^^^^^^^^^^^^^^^^^^ PLW0603
63 |   if not _execution_context:
64 |     _execution_context = ProtocolExecutionContext(db_session_factory, orchestrator)
   |

praxis/backend/core/celery_tasks.py:70:3: ANN001 Missing type annotation for function argument `self`
   |
68 | @celery_app.task(bind=True, name="execute_protocol_run")
69 | def execute_protocol_run_task(
70 |   self,
   |   ^^^^ ANN001
71 |   protocol_run_id: str,
72 |   user_params: dict[str, Any],
   |

praxis/backend/core/celery_tasks.py:113:5: TRY300 Consider moving this statement to an `else` block
    |
111 |     # ensures that any unhandled error during async execution is caught, logged, and
112 |     # the protocol run status is updated to FAILED, preventing silent failures.
113 |     return result  # type: ignore
    |     ^^^^^^^^^^^^^ TRY300
114 |   except Exception as e:  # pylint: disable=broad-except
115 |     error_msg = f"Protocol execution failed for run_id={protocol_run_id}: {e}"
    |

praxis/backend/core/celery_tasks.py:113:20: PGH003 Use specific rule codes when ignoring type issues
    |
111 |     # ensures that any unhandled error during async execution is caught, logged, and
112 |     # the protocol run status is updated to FAILED, preventing silent failures.
113 |     return result  # type: ignore
    |                    ^^^^^^^^^^^^^^ PGH003
114 |   except Exception as e:  # pylint: disable=broad-except
115 |     error_msg = f"Protocol execution failed for run_id={protocol_run_id}: {e}"
    |

praxis/backend/core/celery_tasks.py:116:17: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
114 |   except Exception as e:  # pylint: disable=broad-except
115 |     error_msg = f"Protocol execution failed for run_id={protocol_run_id}: {e}"
116 |     task_logger.error(error_msg, exc_info=True)
    |                 ^^^^^ G201
117 |     # Attempt to update the run status to FAILED in the database.
118 |     try:
    |

praxis/backend/core/celery_tasks.py:122:12: BLE001 Do not catch blind exception: `Exception`
    |
120 |     # Justification: This is a last-resort error handler. If updating the DB
121 |     # status fails, we must catch it to prevent the Celery worker from crashing.
122 |     except Exception as update_error:  # pylint: disable=broad-except
    |            ^^^^^^^^^ BLE001
123 |       task_logger.error(
124 |         "Critical error: Failed to update protocol run status after task failure. Error: %s",
    |

praxis/backend/core/celery_tasks.py:123:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
121 |       # status fails, we must catch it to prevent the Celery worker from crashing.
122 |       except Exception as update_error:  # pylint: disable=broad-except
123 |         task_logger.error(
    |  _______^
124 | |         "Critical error: Failed to update protocol run status after task failure. Error: %s",
125 | |         update_error,
126 | |       )
    | |_______^ TRY400
127 |       return {"success": False, "error": error_msg}
    |
    = help: Replace with `exception`

praxis/backend/core/celery_tasks.py:153:11: TRY003 Avoid specifying long messages outside the exception class
    |
151 |   """
152 |   if not _execution_context or not _execution_context.orchestrator:
153 |     raise RuntimeError("Execution context or orchestrator is not available.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
154 | 
155 |   async with _execution_context.db_session_factory() as db_session:
    |

praxis/backend/core/celery_tasks.py:153:24: EM101 Exception must not use a string literal, assign to variable first
    |
151 |   """
152 |   if not _execution_context or not _execution_context.orchestrator:
153 |     raise RuntimeError("Execution context or orchestrator is not available.")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
154 | 
155 |   async with _execution_context.db_session_factory() as db_session:
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/celery_tasks.py:161:9: TRY301 Abstract `raise` to an inner function
    |
159 |       )
160 |       if not protocol_run_orm:
161 |         raise ValueError(f"Protocol run {protocol_run_id} not found.")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
162 | 
163 |       # Update status to RUNNING and log the Celery task ID.
    |

praxis/backend/core/celery_tasks.py:161:15: TRY003 Avoid specifying long messages outside the exception class
    |
159 |       )
160 |       if not protocol_run_orm:
161 |         raise ValueError(f"Protocol run {protocol_run_id} not found.")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
162 | 
163 |       # Update status to RUNNING and log the Celery task ID.
    |

praxis/backend/core/celery_tasks.py:161:26: EM102 Exception must not use an f-string literal, assign to variable first
    |
159 |       )
160 |       if not protocol_run_orm:
161 |         raise ValueError(f"Protocol run {protocol_run_id} not found.")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
162 | 
163 |       # Update status to RUNNING and log the Celery task ID.
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/celery_tasks.py:194:19: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
192 |     # log it, and ensure the database state is updated to FAILED before re-raising.
193 |     except Exception as e:  # pylint: disable=broad-except
194 |       task_logger.error(
    |                   ^^^^^ G201
195 |         "Error during async protocol execution for run_id=%s: %s",
196 |         protocol_run_id,
    |

praxis/backend/core/celery_tasks.py:217:11: ANN202 Missing return type annotation for private function `_update_run_status_on_error`
    |
217 | async def _update_run_status_on_error(protocol_run_id: uuid.UUID, error_message: str):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
218 |   """A final-resort function to update a protocol run's status to FAILED."""
219 |   if not _execution_context:
    |
    = help: Add return type annotation: `None`

praxis/backend/core/celery_tasks.py:218:3: D401 First line of docstring should be in imperative mood: "A final-resort function to update a protocol run's status to FAILED."
    |
217 | async def _update_run_status_on_error(protocol_run_id: uuid.UUID, error_message: str):
218 |   """A final-resort function to update a protocol run's status to FAILED."""
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
219 |   if not _execution_context:
220 |     task_logger.error(
    |

praxis/backend/core/celery_tasks.py:245:12: BLE001 Do not catch blind exception: `Exception`
    |
243 |     # Catching broad Exception is necessary to prevent further unhandled exceptions
244 |     # from crashing the Celery worker during its own error handling process.
245 |     except Exception as e:  # pylint: disable=broad-except
    |            ^^^^^^^^^ BLE001
246 |       # If this fails, we log it, but there's little else we can do.
247 |       task_logger.critical(
    |

praxis/backend/core/celery_tasks.py:256:3: D401 First line of docstring should be in imperative mood: "A simple health check task to verify that Celery workers are responsive."
    |
254 | @celery_app.task(name="health_check")
255 | def health_check() -> dict[str, str]:
256 |   """A simple health check task to verify that Celery workers are responsive."""
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
257 |   return {
258 |     "status": "healthy",
    |

praxis/backend/core/decorators.py:75:7: ANN204 Missing return type annotation for special method `__init__`
   |
73 |   """A container for runtime information about a protocol function."""
74 | 
75 |   def __init__(
   |       ^^^^^^^^ ANN204
76 |     self,
77 |     pydantic_definition: FunctionProtocolDefinitionModel,
   |
   = help: Add return type annotation: `None`

praxis/backend/core/decorators.py:114:5: C901 `_create_protocol_definition` is too complex (11 > 10)
    |
114 | def _create_protocol_definition(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
115 |   func: Callable,
116 |   name: str | None,
    |

praxis/backend/core/decorators.py:114:5: PLR0913 Too many arguments in function definition (14 > 5)
    |
114 | def _create_protocol_definition(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
115 |   func: Callable,
116 |   name: str | None,
    |

praxis/backend/core/decorators.py:119:3: FBT001 Boolean-typed positional argument in function definition
    |
117 |   version: str,
118 |   description: str | None,
119 |   solo: bool,
    |   ^^^^ FBT001
120 |   is_top_level: bool,
121 |   preconfigure_deck: bool,
    |

praxis/backend/core/decorators.py:120:3: FBT001 Boolean-typed positional argument in function definition
    |
118 |   description: str | None,
119 |   solo: bool,
120 |   is_top_level: bool,
    |   ^^^^^^^^^^^^ FBT001
121 |   preconfigure_deck: bool,
122 |   deck_param_name: str,
    |

praxis/backend/core/decorators.py:121:3: FBT001 Boolean-typed positional argument in function definition
    |
119 |   solo: bool,
120 |   is_top_level: bool,
121 |   preconfigure_deck: bool,
    |   ^^^^^^^^^^^^^^^^^ FBT001
122 |   deck_param_name: str,
123 |   deck_construction: Callable | None,
    |

praxis/backend/core/decorators.py:133:11: TRY003 Avoid specifying long messages outside the exception class
    |
131 |     resolved_name = name or func.__name__
132 |     if not resolved_name:
133 |       raise ValueError(
    |  ___________^
134 | |       "Protocol function name cannot be empty (either provide 'name' argument or use "
135 | |       "a named function).",
136 | |     )
    | |_____^ TRY003
137 |     if (
138 |       is_top_level
    |

praxis/backend/core/decorators.py:134:7: EM101 Exception must not use a string literal, assign to variable first
    |
132 |     if not resolved_name:
133 |       raise ValueError(
134 |         "Protocol function name cannot be empty (either provide 'name' argument or use "
    |  _______^
135 | |       "a named function).",
    | |__________________________^ EM101
136 |       )
137 |     if (
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/decorators.py:142:11: TRY003 Avoid specifying long messages outside the exception class
    |
140 |       and not re.match(top_level_name_format, resolved_name)
141 |     ):
142 |       raise ValueError(
    |  ___________^
143 | |       f"Top-level protocol name '{resolved_name}' does not match format: "
144 | |       f"{top_level_name_format}",
145 | |     )
    | |_____^ TRY003
146 |   
147 |     sig = inspect.signature(func)
    |

praxis/backend/core/decorators.py:143:7: EM102 Exception must not use an f-string literal, assign to variable first
    |
141 |     ):
142 |       raise ValueError(
143 |         f"Top-level protocol name '{resolved_name}' does not match format: "
    |  _______^
144 | |       f"{top_level_name_format}",
    | |________________________________^ EM102
145 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:189:9: PLR1714 Consider merging multiple comparisons. Use a `set` if the elements are hashable.
    |
187 |       if param_name_sig == state_param_name:
188 |         is_state_type_match = (
189 |           fqn == "PraxisState"
    |  _________^
190 | |         or fqn == "praxis.backend.core.definitions.PraxisState"
191 | |         or fqn == "PraxisState"
    | |_______________________________^ PLR1714
192 |         )
193 |         is_dict_type_match = fqn == "dict"
    |
    = help: Merge multiple comparisons

praxis/backend/core/decorators.py:216:11: TRY003 Avoid specifying long messages outside the exception class
    |
215 |     if preconfigure_deck and not found_deck_param:
216 |       raise TypeError(
    |  ___________^
217 | |       f"Protocol '{resolved_name}' (preconfigure_deck=True) missing "
218 | |       f"'{deck_param_name}' param.",
219 | |     )
    | |_____^ TRY003
220 |     if is_top_level and not found_state_param_details:
221 |       raise TypeError(
    |

praxis/backend/core/decorators.py:217:7: EM102 Exception must not use an f-string literal, assign to variable first
    |
215 |     if preconfigure_deck and not found_deck_param:
216 |       raise TypeError(
217 |         f"Protocol '{resolved_name}' (preconfigure_deck=True) missing "
    |  _______^
218 | |       f"'{deck_param_name}' param.",
    | |___________________________________^ EM102
219 |       )
220 |     if is_top_level and not found_state_param_details:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:221:11: TRY003 Avoid specifying long messages outside the exception class
    |
219 |       )
220 |     if is_top_level and not found_state_param_details:
221 |       raise TypeError(
    |  ___________^
222 | |       f"Top-level protocol '{resolved_name}' must define a '{state_param_name}' "
223 | |       "parameter.",
224 | |     )
    | |_____^ TRY003
225 |   
226 |     protocol_definition = FunctionProtocolDefinitionModel(
    |

praxis/backend/core/decorators.py:222:7: EM102 Exception must not use an f-string literal, assign to variable first
    |
220 |     if is_top_level and not found_state_param_details:
221 |       raise TypeError(
222 |         f"Top-level protocol '{resolved_name}' must define a '{state_param_name}' "
    |  _______^
223 | |       "parameter.",
    | |__________________^ EM102
224 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:269:5: TRY300 Consider moving this statement to an `else` block
    |
267 |       parent_function_call_log_accession_id=parent_log_id,
268 |     )
269 |     return call_log_entry_orm.accession_id
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
270 |   except Exception:  # pylint: disable=broad-except
271 |     logger.exception(
    |

praxis/backend/core/decorators.py:277:5: C901 `protocol_function` is too complex (26 > 10)
    |
277 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^ C901
278 |   name: str | None = None,
279 |   version: str = "0.1.0",
    |

praxis/backend/core/decorators.py:277:5: PLR0913 Too many arguments in function definition (13 > 5)
    |
277 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^ PLR0913
278 |   name: str | None = None,
279 |   version: str = "0.1.0",
    |

praxis/backend/core/decorators.py:277:5: PLR0915 Too many statements (89 > 50)
    |
277 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^ PLR0915
278 |   name: str | None = None,
279 |   version: str = "0.1.0",
    |

praxis/backend/core/decorators.py:277:5: ANN201 Missing return type annotation for public function `protocol_function`
    |
277 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^ ANN201
278 |   name: str | None = None,
279 |   version: str = "0.1.0",
    |
    = help: Add return type annotation

praxis/backend/core/decorators.py:281:3: FBT001 Boolean-typed positional argument in function definition
    |
279 |   version: str = "0.1.0",
280 |   description: str | None = None,
281 |   solo: bool = False,
    |   ^^^^ FBT001
282 |   is_top_level: bool = False,
283 |   preconfigure_deck: bool = False,
    |

praxis/backend/core/decorators.py:281:3: FBT002 Boolean default positional argument in function definition
    |
279 |   version: str = "0.1.0",
280 |   description: str | None = None,
281 |   solo: bool = False,
    |   ^^^^ FBT002
282 |   is_top_level: bool = False,
283 |   preconfigure_deck: bool = False,
    |

praxis/backend/core/decorators.py:282:3: FBT001 Boolean-typed positional argument in function definition
    |
280 |   description: str | None = None,
281 |   solo: bool = False,
282 |   is_top_level: bool = False,
    |   ^^^^^^^^^^^^ FBT001
283 |   preconfigure_deck: bool = False,
284 |   deck_param_name: str = DEFAULT_DECK_PARAM_NAME,
    |

praxis/backend/core/decorators.py:282:3: FBT002 Boolean default positional argument in function definition
    |
280 |   description: str | None = None,
281 |   solo: bool = False,
282 |   is_top_level: bool = False,
    |   ^^^^^^^^^^^^ FBT002
283 |   preconfigure_deck: bool = False,
284 |   deck_param_name: str = DEFAULT_DECK_PARAM_NAME,
    |

praxis/backend/core/decorators.py:283:3: FBT001 Boolean-typed positional argument in function definition
    |
281 |   solo: bool = False,
282 |   is_top_level: bool = False,
283 |   preconfigure_deck: bool = False,
    |   ^^^^^^^^^^^^^^^^^ FBT001
284 |   deck_param_name: str = DEFAULT_DECK_PARAM_NAME,
285 |   deck_construction: Callable | None = None,  # New argument
    |

praxis/backend/core/decorators.py:283:3: FBT002 Boolean default positional argument in function definition
    |
281 |   solo: bool = False,
282 |   is_top_level: bool = False,
283 |   preconfigure_deck: bool = False,
    |   ^^^^^^^^^^^^^^^^^ FBT002
284 |   deck_param_name: str = DEFAULT_DECK_PARAM_NAME,
285 |   deck_construction: Callable | None = None,  # New argument
    |

praxis/backend/core/decorators.py:320:7: C901 `decorator` is too complex (25 > 10)
    |
318 |   actual_tags = tags or []
319 | 
320 |   def decorator(func: Callable):
    |       ^^^^^^^^^ C901
321 |     protocol_definition, found_state_param_details = _create_protocol_definition(
322 |       func=func,
    |

praxis/backend/core/decorators.py:320:7: PLR0915 Too many statements (85 > 50)
    |
318 |   actual_tags = tags or []
319 | 
320 |   def decorator(func: Callable):
    |       ^^^^^^^^^ PLR0915
321 |     protocol_definition, found_state_param_details = _create_protocol_definition(
322 |       func=func,
    |

praxis/backend/core/decorators.py:320:7: ANN202 Missing return type annotation for private function `decorator`
    |
318 |   actual_tags = tags or []
319 | 
320 |   def decorator(func: Callable):
    |       ^^^^^^^^^ ANN202
321 |     protocol_definition, found_state_param_details = _create_protocol_definition(
322 |       func=func,
    |
    = help: Add return type annotation

praxis/backend/core/decorators.py:337:5: SLF001 Private member accessed: `_protocol_definition`
    |
335 |       top_level_name_format=top_level_name_format,
336 |     )
337 |     func._protocol_definition = protocol_definition
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
338 | 
339 |     protocol_runtime_info = ProtocolRuntimeInfo(
    |

praxis/backend/core/decorators.py:348:15: C901 `wrapper` is too complex (24 > 10)
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |               ^^^^^^^ C901
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |

praxis/backend/core/decorators.py:348:15: PLR0912 Too many branches (26 > 12)
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |               ^^^^^^^ PLR0912
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |

praxis/backend/core/decorators.py:348:15: PLR0915 Too many statements (79 > 50)
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |               ^^^^^^^ PLR0915
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |

praxis/backend/core/decorators.py:348:15: ANN202 Missing return type annotation for private function `wrapper`
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |               ^^^^^^^ ANN202
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |
    = help: Add return type annotation

praxis/backend/core/decorators.py:348:23: ANN002 Missing type annotation for `*args`
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |                       ^^^^^ ANN002
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |

praxis/backend/core/decorators.py:348:30: ANN003 Missing type annotation for `**kwargs`
    |
347 |     @functools.wraps(func)
348 |     async def wrapper(*args, **kwargs):
    |                              ^^^^^^^^ ANN003
349 |       current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |       if not current_meta or not current_meta.db_accession_id:
    |

praxis/backend/core/decorators.py:351:15: TRY003 Avoid specifying long messages outside the exception class
    |
349 |         current_meta = PROTOCOL_REGISTRY.get(protocol_unique_key)
350 |         if not current_meta or not current_meta.db_accession_id:
351 |           raise RuntimeError(
    |  _______________^
352 | |           f"Protocol '{protocol_unique_key}' not registered or missing DB ID.",
353 | |         )
    | |_________^ TRY003
354 |   
355 |         parent_context = praxis_run_context_cv.get()
    |

praxis/backend/core/decorators.py:352:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
350 |       if not current_meta or not current_meta.db_accession_id:
351 |         raise RuntimeError(
352 |           f"Protocol '{protocol_unique_key}' not registered or missing DB ID.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
353 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:357:15: TRY003 Avoid specifying long messages outside the exception class
    |
355 |         parent_context = praxis_run_context_cv.get()
356 |         if parent_context is None:
357 |           raise RuntimeError(
    |  _______________^
358 | |           "No PraxisRunContext found in contextvars. Ensure this function is called "
359 | |           "within a valid Praxis run context.",
360 | |         )
    | |_________^ TRY003
361 |   
362 |         this_function_def_db_accession_id = current_meta.db_accession_id
    |

praxis/backend/core/decorators.py:358:11: EM101 Exception must not use a string literal, assign to variable first
    |
356 |         if parent_context is None:
357 |           raise RuntimeError(
358 |             "No PraxisRunContext found in contextvars. Ensure this function is called "
    |  ___________^
359 | |           "within a valid Praxis run context.",
    | |______________________________________________^ EM101
360 |           )
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/decorators.py:374:9: SIM102 Use a single `if` statement instead of nested `if` statements
    |
372 |           if state_details["expects_praxis_state"]:
373 |             processed_kwargs[state_arg_name_in_sig] = parent_context.canonical_state
374 |           elif state_details["expects_dict"]:
    |  _________^
375 | |           if state_arg_name_in_sig not in processed_kwargs:
    | |___________________________________________________________^ SIM102
376 |               processed_kwargs[state_arg_name_in_sig] = (
377 |                 parent_context.canonical_state.data.copy()
    |
    = help: Combine `if` statements using `and`

praxis/backend/core/decorators.py:395:15: TRY003 Avoid specifying long messages outside the exception class
    |
393 |       )
394 |       if not current_call_log_db_accession_id:
395 |         raise RuntimeError("Failed to log function call start.")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
396 | 
397 |       context_for_this_call = parent_context.create_context_for_nested_call(
    |

praxis/backend/core/decorators.py:395:28: EM101 Exception must not use a string literal, assign to variable first
    |
393 |       )
394 |       if not current_call_log_db_accession_id:
395 |         raise RuntimeError("Failed to log function call start.")
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
396 | 
397 |       context_for_this_call = parent_context.create_context_for_nested_call(
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/decorators.py:463:18: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
461 |               except AttributeError:
462 |                 serialized_result = json.dumps(result, default=str)
463 |             elif isinstance(result, (Resource, Deck)):
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
464 |               serialized_result = json.dumps(repr(result))
465 |             else:
    |
    = help: Convert to `X | Y`

praxis/backend/core/decorators.py:520:9: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
518 |       )
519 |       await db_session.commit()
520 |       # TODO: Dispatch to intervention handler
    |         ^^^^ TD002
521 | 
522 |     elif command == "PAUSE":
    |

praxis/backend/core/decorators.py:520:9: TD003 Missing issue link on the line following this TODO
    |
518 |       )
519 |       await db_session.commit()
520 |       # TODO: Dispatch to intervention handler
    |         ^^^^ TD003
521 | 
522 |     elif command == "PAUSE":
    |

praxis/backend/core/decorators.py:520:9: FIX002 Line contains TODO, consider resolving the issue
    |
518 |       )
519 |       await db_session.commit()
520 |       # TODO: Dispatch to intervention handler
    |         ^^^^ FIX002
521 | 
522 |     elif command == "PAUSE":
    |

praxis/backend/core/decorators.py:597:15: TRY003 Avoid specifying long messages outside the exception class
    |
595 |         )
596 |         await db_session.commit()
597 |         raise ProtocolCancelledError(f"Run {run_accession_id} cancelled by user.")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
598 | 
599 |     elif command == "CANCEL":
    |

praxis/backend/core/decorators.py:597:38: EM102 Exception must not use an f-string literal, assign to variable first
    |
595 |         )
596 |         await db_session.commit()
597 |         raise ProtocolCancelledError(f"Run {run_accession_id} cancelled by user.")
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
598 | 
599 |     elif command == "CANCEL":
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:613:13: TRY003 Avoid specifying long messages outside the exception class
    |
611 |       )
612 |       await db_session.commit()
613 |       raise ProtocolCancelledError(f"Run {run_accession_id} cancelled by user.")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
614 | 
615 |     elif command == "INTERVENE":
    |

praxis/backend/core/decorators.py:613:36: EM102 Exception must not use an f-string literal, assign to variable first
    |
611 |       )
612 |       await db_session.commit()
613 |       raise ProtocolCancelledError(f"Run {run_accession_id} cancelled by user.")
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
614 | 
615 |     elif command == "INTERVENE":
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/decorators.py:622:9: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
620 |       )
621 |       await db_session.commit()
622 |       # TODO: dispatch to intervention handler
    |         ^^^^ TD002
    |

praxis/backend/core/decorators.py:622:9: TD003 Missing issue link on the line following this TODO
    |
620 |       )
621 |       await db_session.commit()
622 |       # TODO: dispatch to intervention handler
    |         ^^^^ TD003
    |

praxis/backend/core/decorators.py:622:9: FIX002 Line contains TODO, consider resolving the issue
    |
620 |       )
621 |       await db_session.commit()
622 |       # TODO: dispatch to intervention handler
    |         ^^^^ FIX002
    |

praxis/backend/core/orchestrator.py:29:43: PLC0414 Import alias does not rename original package
   |
27 |   ResourceStatusEnum,
28 | )
29 | from praxis.backend.services.state import PraxisState as PraxisState
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
30 | from praxis.backend.utils.errors import (
31 |   AssetAcquisitionError,
   |
   = help: Remove import alias

praxis/backend/core/orchestrator.py:51:7: ANN204 Missing return type annotation for special method `__init__`
   |
49 |   """
50 | 
51 |   def __init__(
   |       ^^^^^^^^ ANN204
52 |     self,
53 |     db_session_factory: async_sessionmaker[AsyncSession],
   |
   = help: Add return type annotation: `None`

praxis/backend/core/orchestrator.py:209:17: TRY003 Avoid specifying long messages outside the exception class
    |
207 |             )
208 |             await db_session.commit()
209 |             raise ProtocolCancelledError(
    |  _________________^
210 | |             f"Run {run_accession_id} cancelled by user during pause.",
211 | |           )
    | |___________^ TRY003
212 |       elif command == "CANCEL":
213 |         logger.info("ORCH: Run %s CANCELLED before execution.", run_accession_id)
    |

praxis/backend/core/orchestrator.py:210:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
208 |           await db_session.commit()
209 |           raise ProtocolCancelledError(
210 |             f"Run {run_accession_id} cancelled by user during pause.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
211 |           )
212 |     elif command == "CANCEL":
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/orchestrator.py:222:13: TRY003 Avoid specifying long messages outside the exception class
    |
220 |         )
221 |         await db_session.commit()
222 |         raise ProtocolCancelledError(
    |  _____________^
223 | |         f"Run {run_accession_id} cancelled by user before execution.",
224 | |       )
    | |_______^ TRY003
225 |   
226 |     async def _execute_protocol_main_logic(
    |

praxis/backend/core/orchestrator.py:223:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
221 |       await db_session.commit()
222 |       raise ProtocolCancelledError(
223 |         f"Run {run_accession_id} cancelled by user before execution.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
224 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/orchestrator.py:226:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
224 |       )
225 | 
226 |   async def _execute_protocol_main_logic(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
227 |     self,
228 |     protocol_run_orm: ProtocolRunOrm,
    |

praxis/backend/core/orchestrator.py:244:13: TRY003 Avoid specifying long messages outside the exception class
    |
242 |     main_workcell_container = self.workcell_runtime.get_main_workcell()
243 |     if not main_workcell_container:
244 |       raise RuntimeError("Main Workcell container not available from WorkcellRuntime.")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
245 | 
246 |     (
    |

praxis/backend/core/orchestrator.py:244:26: EM101 Exception must not use a string literal, assign to variable first
    |
242 |     main_workcell_container = self.workcell_runtime.get_main_workcell()
243 |     if not main_workcell_container:
244 |       raise RuntimeError("Main Workcell container not available from WorkcellRuntime.")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
245 | 
246 |     (
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/orchestrator.py:265:32: SLF001 Private member accessed: `_load_callable_from_fqn`
    |
263 |     deck_construction_func: Callable | None = None
264 |     if protocol_pydantic_def.deck_construction_function_fqn:
265 |       deck_construction_func = self.protocol_code_manager._load_callable_from_fqn(
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
266 |         protocol_pydantic_def.deck_construction_function_fqn,
267 |       )
    |

praxis/backend/core/orchestrator.py:303:13: C901 `_prepare_arguments` is too complex (21 > 10)
    |
301 |     return result, acquired_assets_info  # Return acquired_assets_info
302 | 
303 |   async def _prepare_arguments(
    |             ^^^^^^^^^^^^^^^^^^ C901
304 |     self,
305 |     db_session: AsyncSession,
    |

praxis/backend/core/orchestrator.py:303:13: PLR0912 Too many branches (24 > 12)
    |
301 |     return result, acquired_assets_info  # Return acquired_assets_info
302 | 
303 |   async def _prepare_arguments(
    |             ^^^^^^^^^^^^^^^^^^ PLR0912
304 |     self,
305 |     db_session: AsyncSession,
    |

praxis/backend/core/orchestrator.py:303:13: PLR0915 Too many statements (70 > 50)
    |
301 |     return result, acquired_assets_info  # Return acquired_assets_info
302 | 
303 |   async def _prepare_arguments(
    |             ^^^^^^^^^^^^^^^^^^ PLR0915
304 |     self,
305 |     db_session: AsyncSession,
    |

praxis/backend/core/orchestrator.py:327:15: TRY003 Avoid specifying long messages outside the exception class
    |
325 |           logger.debug("Using user input for param '%s'.", param_meta.name)
326 |         elif not param_meta.optional:
327 |           raise ValueError(
    |  _______________^
328 | |           "Mandatory parameter '%s' missing for protocol '%s'.",
329 | |           param_meta.name,
330 | |           protocol_pydantic_def.name,
331 | |         )
    | |_________^ TRY003
332 |         else:
333 |           logger.debug("Optional param '%s' not provided by user.", param_meta.name)
    |

praxis/backend/core/orchestrator.py:328:11: EM101 Exception must not use a string literal, assign to variable first
    |
326 |       elif not param_meta.optional:
327 |         raise ValueError(
328 |           "Mandatory parameter '%s' missing for protocol '%s'.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
329 |           param_meta.name,
330 |           protocol_pydantic_def.name,
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/orchestrator.py:395:7: PERF203 `try`-`except` within a loop incurs performance overhead
    |
393 |             live_obj,
394 |           )
395 |         except AssetAcquisitionError as e:
    |  _______^
396 | |         if asset_req_model.optional:
397 | |           logger.warning(
398 | |             "ORCH-ACQUIRE: Optional asset '%s' could not be acquired: %s."
399 | |             " Proceeding as it's optional.",
400 | |             asset_req_model.name,
401 | |             e,
402 | |           )
403 | |           final_args[asset_req_model.name] = None
404 | |         else:
405 | |           error_msg = (
406 | |             "Failed to acquire mandatory asset '%s' for protocol '%s': %s"
407 | |           ) % (
408 | |             asset_req_model.name,
409 | |             protocol_pydantic_def.name,
410 | |             e,
411 | |           )
412 | |           logger.error(error_msg)
413 | |           raise ValueError(error_msg) from e
    | |____________________________________________^ PERF203
414 |         except Exception as e_general:
415 |           error_msg = ("Unexpected error acquiring asset '%s' for protocol '%s': %s") % (
    |

praxis/backend/core/orchestrator.py:405:23: UP031 Use format specifiers instead of percent format
    |
403 |             final_args[asset_req_model.name] = None
404 |           else:
405 |             error_msg = (
    |  _______________________^
406 | |             "Failed to acquire mandatory asset '%s' for protocol '%s': %s"
407 | |           ) % (
408 | |             asset_req_model.name,
409 | |             protocol_pydantic_def.name,
410 | |             e,
411 | |           )
    | |___________^ UP031
412 |             logger.error(error_msg)
413 |             raise ValueError(error_msg) from e
    |
    = help: Replace with format specifiers

praxis/backend/core/orchestrator.py:412:11: TRY400 Use `logging.exception` instead of `logging.error`
    |
410 |             e,
411 |           )
412 |           logger.error(error_msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^ TRY400
413 |           raise ValueError(error_msg) from e
414 |       except Exception as e_general:
    |
    = help: Replace with `exception`

praxis/backend/core/orchestrator.py:415:21: UP031 Use format specifiers instead of percent format
    |
413 |             raise ValueError(error_msg) from e
414 |         except Exception as e_general:
415 |           error_msg = ("Unexpected error acquiring asset '%s' for protocol '%s': %s") % (
    |  _____________________^
416 | |           asset_req_model.name,
417 | |           protocol_pydantic_def.name,
418 | |           e_general,
419 | |         )
    | |_________^ UP031
420 |           logger.exception(error_msg)
421 |           raise ValueError(error_msg) from e_general
    |
    = help: Replace with format specifiers

praxis/backend/core/orchestrator.py:437:15: TRY003 Avoid specifying long messages outside the exception class
    |
435 |           False,
436 |         ):
437 |           raise ValueError(
    |  _______________^
438 | |           "Mandatory deck parameter '%s' for preconfiguration not provided.",
439 | |           deck_param_name,
440 | |         )
    | |_________^ TRY003
441 |   
442 |         if deck_accession_identifier_from_user is not None:
    |

praxis/backend/core/orchestrator.py:438:11: EM101 Exception must not use a string literal, assign to variable first
    |
436 |       ):
437 |         raise ValueError(
438 |           "Mandatory deck parameter '%s' for preconfiguration not provided.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
439 |           deck_param_name,
440 |         )
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/orchestrator.py:443:16: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
442 |       if deck_accession_identifier_from_user is not None:
443 |         if not isinstance(deck_accession_identifier_from_user, (str, uuid.UUID)):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
444 |           raise ValueError(
445 |             "Deck identifier for preconfiguration ('%s') must be a string "
    |
    = help: Convert to `X | Y`

praxis/backend/core/orchestrator.py:444:17: TRY003 Avoid specifying long messages outside the exception class
    |
442 |         if deck_accession_identifier_from_user is not None:
443 |           if not isinstance(deck_accession_identifier_from_user, (str, uuid.UUID)):
444 |             raise ValueError(
    |  _________________^
445 | |             "Deck identifier for preconfiguration ('%s') must be a string "
446 | |             "(name) or UUID (ID), got %s.",
447 | |             deck_param_name,
448 | |             type(deck_accession_identifier_from_user),
449 | |           )
    | |___________^ TRY003
450 |   
451 |           logger.info(
    |

praxis/backend/core/orchestrator.py:445:13: EM101 Exception must not use a string literal, assign to variable first
    |
443 |           if not isinstance(deck_accession_identifier_from_user, (str, uuid.UUID)):
444 |             raise ValueError(
445 |               "Deck identifier for preconfiguration ('%s') must be a string "
    |  _____________^
446 | |             "(name) or UUID (ID), got %s.",
    | |__________________________________________^ EM101
447 |               deck_param_name,
448 |               type(deck_accession_identifier_from_user),
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/orchestrator.py:464:19: TRY003 Avoid specifying long messages outside the exception class
    |
462 |             )
463 |             if not deck_config_orm:
464 |               raise ValueError(
    |  ___________________^
465 | |               "Deck configuration named '%s' not found.",
466 | |               deck_accession_identifier_from_user,
467 | |             )
    | |_____________^ TRY003
468 |             deck_config_orm_accession_id_to_apply = deck_config_orm.accession_id
469 |           else:
    |

praxis/backend/core/orchestrator.py:465:15: EM101 Exception must not use a string literal, assign to variable first
    |
463 |           if not deck_config_orm:
464 |             raise ValueError(
465 |               "Deck configuration named '%s' not found.",
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
466 |               deck_accession_identifier_from_user,
467 |             )
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/orchestrator.py:515:7: S101 Use of `assert` detected
    |
513 |     try:
514 |       # Attempt to rollback workcell state
515 |       assert isinstance(
    |       ^^^^^^ S101
516 |         praxis_state,
517 |         PraxisState,
    |

praxis/backend/core/orchestrator.py:519:7: S101 Use of `assert` detected
    |
517 |         PraxisState,
518 |       ), "praxis_state must be an instance of PraxisState."
519 |       assert praxis_state is not None, "praxis_state must not be None."
    |       ^^^^^^ S101
520 |       last_good_snapshot = praxis_state.get("workcell_last_successful_snapshot")
521 |       if last_good_snapshot:
    |

praxis/backend/core/orchestrator.py:532:12: BLE001 Do not catch blind exception: `Exception`
    |
530 |           run_accession_id,
531 |         )
532 |     except Exception as rollback_error:  # pylint: disable=broad-except
    |            ^^^^^^^^^ BLE001
533 |       logger.critical(
534 |         "ORCH: CRITICAL - Failed to rollback workcell state for run %s: %s",
    |

praxis/backend/core/orchestrator.py:633:9: PERF203 `try`-`except` within a loop incurs performance overhead
    |
631 |               asset_orm_accession_id,
632 |             )
633 |           except Exception as release_err:  # pylint: disable=broad-except
    |  _________^
634 | |           logger.error(
635 | |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
636 | |             asset_info.get("name_in_protocol", "UnknownAsset"),
637 | |             asset_info.get("orm_accession_id"),
638 | |             release_err,
639 | |             exc_info=True,
640 | |           )
    | |___________^ PERF203
641 |   
642 |       await db_session.merge(protocol_run_orm)
    |

praxis/backend/core/orchestrator.py:634:18: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
632 |           )
633 |         except Exception as release_err:  # pylint: disable=broad-except
634 |           logger.error(
    |                  ^^^^^ G201
635 |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
636 |             asset_info.get("name_in_protocol", "UnknownAsset"),
    |

praxis/backend/core/orchestrator.py:644:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
642 |     await db_session.merge(protocol_run_orm)
643 | 
644 |   async def execute_protocol(
    |             ^^^^^^^^^^^^^^^^ PLR0913
645 |     self,
646 |     protocol_name: str,
    |

praxis/backend/core/orchestrator.py:696:21: UP031 Use format specifiers instead of percent format
    |
695 |         if not protocol_def_orm or not protocol_def_orm.accession_id:
696 |           error_msg = (
    |  _____________________^
697 | |           "Protocol '%s' (v:%s, commit:%s, src:%s) not found or invalid DB ID."
698 | |         ) % (protocol_name, protocol_version, commit_hash, source_name)
    | |_______________________________________________________________________^ UP031
699 |           logger.error(error_msg)
700 |           raise ValueError(error_msg)
    |
    = help: Replace with format specifiers

praxis/backend/core/orchestrator.py:755:14: BLE001 Do not catch blind exception: `Exception`
    |
753 |       except ProtocolCancelledError:
754 |         pass  # Status already updated by the handler
755 |       except Exception as e:  # pylint: disable=broad-except
    |              ^^^^^^^^^ BLE001
756 |         await self._handle_protocol_execution_error(
757 |           run_accession_id,
    |

praxis/backend/core/orchestrator.py:774:18: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
772 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
773 |         except Exception as db_final_err:  # pylint: disable=broad-except
774 |           logger.error(
    |                  ^^^^^ G201
775 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
776 |             run_accession_id,
    |

praxis/backend/core/orchestrator.py:877:14: BLE001 Do not catch blind exception: `Exception`
    |
875 |       except ProtocolCancelledError:
876 |         pass  # Status already updated by the handler
877 |       except Exception as e:  # pylint: disable=broad-except
    |              ^^^^^^^^^ BLE001
878 |         await self._handle_protocol_execution_error(
879 |           run_accession_id,
    |

praxis/backend/core/orchestrator.py:906:18: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
904 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
905 |         except Exception as db_final_err:
906 |           logger.error(
    |                  ^^^^^ G201
907 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
908 |             run_accession_id,
    |

praxis/backend/core/protocol_code_manager.py:32:5: ANN201 Missing return type annotation for public function `temporary_sys_path`
   |
31 | @contextlib.contextmanager
32 | def temporary_sys_path(path_to_add: str | None):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
33 |   """Add a path to sys.path temporarily.
   |
   = help: Add return type annotation

praxis/backend/core/protocol_code_manager.py:92:7: ANN204 Missing return type annotation for special method `__init__`
   |
90 |   """
91 | 
92 |   def __init__(self):
   |       ^^^^^^^^ ANN204
93 |     """Initialize the Protocol Code Manager."""
94 |     logger.info("ProtocolCodeManager initialized.")
   |
   = help: Add return type annotation: `None`

praxis/backend/core/protocol_code_manager.py:100:5: FBT001 Boolean-typed positional argument in function definition
    |
 98 |     command: list[str],
 99 |     cwd: str,
100 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^ FBT001
101 |     timeout: int = 300,
102 |   ) -> str:
    |

praxis/backend/core/protocol_code_manager.py:100:5: FBT002 Boolean default positional argument in function definition
    |
 98 |     command: list[str],
 99 |     cwd: str,
100 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^ FBT002
101 |     timeout: int = 300,
102 |   ) -> str:
    |

praxis/backend/core/protocol_code_manager.py:156:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
154 |         e.stdout.decode(errors="ignore").strip() if e.stdout else "N/A",
155 |       )
156 |       logger.error(error_message)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
157 |       raise RuntimeError(error_message) from e
158 |     except subprocess.CalledProcessError as e:
    |
    = help: Replace with `exception`

praxis/backend/core/protocol_code_manager.py:182:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
180 |         stdout_output,
181 |       )
182 |       logger.error(error_message)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
183 |       raise RuntimeError(error_message) from e
184 |     except FileNotFoundError:  # pragma: no cover
    |
    = help: Replace with `exception`

praxis/backend/core/protocol_code_manager.py:185:23: UP031 Use format specifiers instead of percent format
    |
183 |         raise RuntimeError(error_message) from e
184 |       except FileNotFoundError:  # pragma: no cover
185 |         error_message = (
    |  _______________________^
186 | |         "CODE-GIT: Git command not found. Ensure git is installed. Command: %s"
187 | |       ) % (" ".join(command))
    | |_____________________________^ UP031
188 |         logger.error(error_message)
189 |         raise RuntimeError(error_message) from None
    |
    = help: Replace with format specifiers

praxis/backend/core/protocol_code_manager.py:188:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
186 |         "CODE-GIT: Git command not found. Ensure git is installed. Command: %s"
187 |       ) % (" ".join(command))
188 |       logger.error(error_message)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
189 |       raise RuntimeError(error_message) from None
    |
    = help: Replace with `exception`

praxis/backend/core/protocol_code_manager.py:207:8: PTH110 `os.path.exists()` should be replaced by `Path.exists()`
    |
205 |     """
206 |     is_git_repo = False
207 |     if os.path.exists(checkout_path):
    |        ^^^^^^^^^^^^^^ PTH110
208 |       try:
209 |         result = await self._run_git_command(
    |

praxis/backend/core/protocol_code_manager.py:237:17: TRY003 Avoid specifying long messages outside the exception class
    |
235 |           )
236 |           if current_remote_url != git_url:
237 |             raise ValueError(
    |  _________________^
238 | |             f"Path '{checkout_path}' for repo '{repo_name_for_logging}' is a Git repository, "
239 | |             f"but its remote 'origin' URL ('{current_remote_url}') does not match the expected "
240 | |             f"URL ('{git_url}'). Manual intervention required.",
241 | |           )
    | |___________^ TRY003
242 |         except RuntimeError as e:
243 |           raise ValueError(
    |

praxis/backend/core/protocol_code_manager.py:238:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
236 |           if current_remote_url != git_url:
237 |             raise ValueError(
238 |               f"Path '{checkout_path}' for repo '{repo_name_for_logging}' is a Git repository, "
    |  _____________^
239 | |             f"but its remote 'origin' URL ('{current_remote_url}') does not match the expected "
240 | |             f"URL ('{git_url}'). Manual intervention required.",
    | |_______________________________________________________________^ EM102
241 |             )
242 |         except RuntimeError as e:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:243:15: TRY003 Avoid specifying long messages outside the exception class
    |
241 |             )
242 |         except RuntimeError as e:
243 |           raise ValueError(
    |  _______________^
244 | |           f"Failed to verify remote URL for existing repo at '{checkout_path}'. Error: {e}",
245 | |         ) from e
    | |_________^ TRY003
246 |   
247 |         logger.info(
    |

praxis/backend/core/protocol_code_manager.py:244:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
242 |       except RuntimeError as e:
243 |         raise ValueError(
244 |           f"Failed to verify remote URL for existing repo at '{checkout_path}'. Error: {e}",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
245 |         ) from e
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:256:10: PTH110 `os.path.exists()` should be replaced by `Path.exists()`
    |
254 |       )
255 |     else:
256 |       if os.path.exists(checkout_path):
    |          ^^^^^^^^^^^^^^ PTH110
257 |         if os.listdir(checkout_path):
258 |           raise ValueError(
    |

praxis/backend/core/protocol_code_manager.py:258:17: TRY003 Avoid specifying long messages outside the exception class
    |
256 |         if os.path.exists(checkout_path):
257 |           if os.listdir(checkout_path):
258 |             raise ValueError(
    |  _________________^
259 | |             f"Path '{checkout_path}' for repo '{repo_name_for_logging}' exists, "
260 | |             f"is not Git, and not empty. Cannot clone.",
261 | |           )
    | |___________^ TRY003
262 |           logger.info(
263 |             "CODE-GIT: Path '%s' for repo '%s' exists and is empty. Cloning into it.",
    |

praxis/backend/core/protocol_code_manager.py:259:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
257 |           if os.listdir(checkout_path):
258 |             raise ValueError(
259 |               f"Path '{checkout_path}' for repo '{repo_name_for_logging}' exists, "
    |  _____________^
260 | |             f"is not Git, and not empty. Cannot clone.",
    | |_______________________________________________________^ EM102
261 |             )
262 |           logger.info(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:274:11: PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
    |
272 |         )
273 |         try:
274 |           os.makedirs(checkout_path, exist_ok=True)
    |           ^^^^^^^^^^^ PTH103
275 |         except OSError as e:
276 |           raise ValueError(f"Failed to create directory '{checkout_path}': {e}") from e
    |

praxis/backend/core/protocol_code_manager.py:276:17: TRY003 Avoid specifying long messages outside the exception class
    |
274 |           os.makedirs(checkout_path, exist_ok=True)
275 |         except OSError as e:
276 |           raise ValueError(f"Failed to create directory '{checkout_path}': {e}") from e
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
277 | 
278 |       logger.info(
    |

praxis/backend/core/protocol_code_manager.py:276:28: EM102 Exception must not use an f-string literal, assign to variable first
    |
274 |           os.makedirs(checkout_path, exist_ok=True)
275 |         except OSError as e:
276 |           raise ValueError(f"Failed to create directory '{checkout_path}': {e}") from e
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
277 | 
278 |       logger.info(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:317:13: TRY003 Avoid specifying long messages outside the exception class
    |
315 |       )
316 |       if current_commit != resolved_target_commit:
317 |         raise RuntimeError(
    |  _____________^
318 | |         f"Failed to checkout commit '{commit_hash}'. HEAD is at '{current_commit}', "
319 | |         f"expected '{resolved_target_commit}'. Repo: '{repo_name_for_logging}'",
320 | |       )
    | |_______^ TRY003
321 |       logger.info(
322 |         "CODE-GIT: Successfully checked out '%s' (resolved to '%s').",
    |

praxis/backend/core/protocol_code_manager.py:318:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
316 |       if current_commit != resolved_target_commit:
317 |         raise RuntimeError(
318 |           f"Failed to checkout commit '{commit_hash}'. HEAD is at '{current_commit}', "
    |  _________^
319 | |         f"expected '{resolved_target_commit}'. Repo: '{repo_name_for_logging}'",
    | |_______________________________________________________________________________^ EM102
320 |         )
321 |       logger.info(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:354:13: TRY003 Avoid specifying long messages outside the exception class
    |
353 |       if not hasattr(module, function_name):
354 |         raise AttributeError(
    |  _____________^
355 | |         f"Function '{function_name}' not found in module '{module_name}' "
356 | |         f"from path '{module_path or 'PYTHONPATH'}'.",
357 | |       )
    | |_______^ TRY003
358 |   
359 |       func_wrapper = getattr(module, function_name)
    |

praxis/backend/core/protocol_code_manager.py:355:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
353 |       if not hasattr(module, function_name):
354 |         raise AttributeError(
355 |           f"Function '{function_name}' not found in module '{module_name}' "
    |  _________^
356 | |         f"from path '{module_path or 'PYTHONPATH'}'.",
    | |_____________________________________________________^ EM102
357 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:367:13: TRY003 Avoid specifying long messages outside the exception class
    |
365 |         pydantic_def, FunctionProtocolDefinitionModel,
366 |       ):
367 |         raise AttributeError(
    |  _____________^
368 | |         f"Function '{function_name}' in '{module_name}' is not a valid @protocol_function "
369 | |         f"(missing or invalid _protocol_definition attribute).",
370 | |       )
    | |_______^ TRY003
371 |   
372 |       return func_wrapper, pydantic_def
    |

praxis/backend/core/protocol_code_manager.py:368:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
366 |       ):
367 |         raise AttributeError(
368 |           f"Function '{function_name}' in '{module_name}' is not a valid @protocol_function "
    |  _________^
369 | |         f"(missing or invalid _protocol_definition attribute).",
    | |_______________________________________________________________^ EM102
370 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:390:13: TRY003 Avoid specifying long messages outside the exception class
    |
388 |     """
389 |     if not fqn or "." not in fqn:
390 |       raise ValueError(f"Invalid fully qualified name for callable: {fqn}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
391 | 
392 |     module_name, callable_name = fqn.rsplit(".", 1)
    |

praxis/backend/core/protocol_code_manager.py:390:24: EM102 Exception must not use an f-string literal, assign to variable first
    |
388 |     """
389 |     if not fqn or "." not in fqn:
390 |       raise ValueError(f"Invalid fully qualified name for callable: {fqn}")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
391 | 
392 |     module_name, callable_name = fqn.rsplit(".", 1)
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:436:15: TRY003 Avoid specifying long messages outside the exception class
    |
435 |         if not checkout_path or not commit_hash_to_checkout or not repo.git_url:
436 |           raise ValueError(
    |  _______________^
437 | |           f"Incomplete Git source info for protocol '{protocol_def_orm.name}'.",
438 | |         )
    | |_________^ TRY003
439 |   
440 |         await self._ensure_git_repo_and_fetch(repo.git_url, checkout_path, repo.name)
    |

praxis/backend/core/protocol_code_manager.py:437:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
435 |       if not checkout_path or not commit_hash_to_checkout or not repo.git_url:
436 |         raise ValueError(
437 |           f"Incomplete Git source info for protocol '{protocol_def_orm.name}'.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
438 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:452:14: PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
    |
450 |     ):
451 |       fs_source = protocol_def_orm.file_system_source
452 |       if not os.path.isdir(fs_source.base_path):
    |              ^^^^^^^^^^^^^ PTH112
453 |         raise ValueError(
454 |           f"Invalid base path '{fs_source.base_path}' for FS source '{fs_source.name}'.",
    |

praxis/backend/core/protocol_code_manager.py:453:15: TRY003 Avoid specifying long messages outside the exception class
    |
451 |         fs_source = protocol_def_orm.file_system_source
452 |         if not os.path.isdir(fs_source.base_path):
453 |           raise ValueError(
    |  _______________^
454 | |           f"Invalid base path '{fs_source.base_path}' for FS source '{fs_source.name}'.",
455 | |         )
    | |_________^ TRY003
456 |         module_path_to_add_for_sys_path = fs_source.base_path
    |

praxis/backend/core/protocol_code_manager.py:454:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
452 |       if not os.path.isdir(fs_source.base_path):
453 |         raise ValueError(
454 |           f"Invalid base path '{fs_source.base_path}' for FS source '{fs_source.name}'.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
455 |         )
456 |       module_path_to_add_for_sys_path = fs_source.base_path
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_code_manager.py:484:7: TRY300 Consider moving this statement to an `else` block
    |
482 |         )
483 | 
484 |       return func_wrapper, pydantic_def
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
485 | 
486 |     except Exception as e:
    |

praxis/backend/core/protocol_code_manager.py:487:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
486 |     except Exception as e:
487 |       logger.error(
    |              ^^^^^ G201
488 |         "Failed to load protocol function '%s' from module '%s': %s",
489 |         protocol_def_orm.function_name,
    |

praxis/backend/core/protocol_execution_service.py:38:7: ANN204 Missing return type annotation for special method `__init__`
   |
36 |   """
37 | 
38 |   def __init__(
   |       ^^^^^^^^ ANN204
39 |     self,
40 |     db_session_factory: async_sessionmaker[AsyncSession],
   |
   = help: Add return type annotation: `None`

praxis/backend/core/protocol_execution_service.py:74:13: PLR0913 Too many arguments in function definition (6 > 5)
   |
72 |     logger.info("ProtocolExecutionService initialized.")
73 | 
74 |   async def execute_protocol_immediately(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
75 |     self,
76 |     protocol_name: str,
   |

praxis/backend/core/protocol_execution_service.py:74:13: ANN201 Missing return type annotation for public function `execute_protocol_immediately`
   |
72 |     logger.info("ProtocolExecutionService initialized.")
73 | 
74 |   async def execute_protocol_immediately(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
75 |     self,
76 |     protocol_name: str,
   |
   = help: Add return type annotation

praxis/backend/core/protocol_execution_service.py:113:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
111 |     )
112 | 
113 |   async def schedule_protocol_execution(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
114 |     self,
115 |     protocol_name: str,
    |

praxis/backend/core/protocol_execution_service.py:113:13: ANN201 Missing return type annotation for public function `schedule_protocol_execution`
    |
111 |     )
112 | 
113 |   async def schedule_protocol_execution(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
114 |     self,
115 |     protocol_name: str,
    |
    = help: Add return type annotation

praxis/backend/core/protocol_execution_service.py:187:15: TRY003 Avoid specifying long messages outside the exception class
    |
185 |       if not success:
186 |         logger.error("Failed to schedule protocol run %s", run_accession_id)
187 |         raise RuntimeError(f"Failed to schedule protocol run {run_accession_id}")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
188 | 
189 |       logger.info(
    |

praxis/backend/core/protocol_execution_service.py:187:28: EM102 Exception must not use an f-string literal, assign to variable first
    |
185 |       if not success:
186 |         logger.error("Failed to schedule protocol run %s", run_accession_id)
187 |         raise RuntimeError(f"Failed to schedule protocol run {run_accession_id}")
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
188 | 
189 |       logger.info(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/protocol_execution_service.py:244:86: PGH003 Use specific rule codes when ignoring type issues
    |
242 |       if protocol_run_orm.output_data_json:
243 |         try:
244 |           status_info["output_data"] = json.load(protocol_run_orm.output_data_json)  # type: ignore
    |                                                                                      ^^^^^^^^^^^^^^ PGH003
245 |         except json.JSONDecodeError:
246 |           status_info["output_data_raw"] = protocol_run_orm.output_data_json
    |

praxis/backend/core/protocol_execution_service.py:281:14: BLE001 Do not catch blind exception: `Exception`
    |
279 |         await db_session.commit()
280 |         database_cancelled = True
281 |       except Exception as e:
    |              ^^^^^^^^^ BLE001
282 |         logger.error(
283 |           "Failed to update database status for cancelled run %s: %s",
    |

praxis/backend/core/protocol_execution_service.py:282:9: TRY400 Use `logging.exception` instead of `logging.error`
    |
280 |           database_cancelled = True
281 |         except Exception as e:
282 |           logger.error(
    |  _________^
283 | |           "Failed to update database status for cancelled run %s: %s",
284 | |           protocol_run_id,
285 | |           e,
286 | |         )
    | |_________^ TRY400
287 |           database_cancelled = False
    |
    = help: Replace with `exception`

praxis/backend/core/run_context.py:32:43: PLC0414 Import alias does not rename original package
   |
30 | from sqlalchemy.ext.asyncio import AsyncSession
31 | 
32 | from praxis.backend.services.state import PraxisState as PraxisState
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
33 | 
34 | PROTOCOL_REGISTRY: dict[str, Any] = {}
   |
   = help: Remove import alias

praxis/backend/core/run_context.py:35:17: UP007 Use `X | Y` for type annotations
   |
34 | PROTOCOL_REGISTRY: dict[str, Any] = {}
35 | DeckInputType = Union[str, os.PathLike, io.IOBase, Deck]
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP007
36 | 
37 | logger = logging.getLogger(__name__)
   |
   = help: Convert to `X | Y`

praxis/backend/core/run_context.py:66:5: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
64 |   _call_sequence_next_val: int = 1  # Internal counter, starts at 1
65 | 
66 |   # TODO: CTX-1: Consider if user_accession_id, workcell_accession_id, etc., should be here.
   |     ^^^^ TD002
67 | 
68 |   def get_and_increment_sequence_val(self) -> int:
   |

praxis/backend/core/run_context.py:66:5: TD003 Missing issue link on the line following this TODO
   |
64 |   _call_sequence_next_val: int = 1  # Internal counter, starts at 1
65 | 
66 |   # TODO: CTX-1: Consider if user_accession_id, workcell_accession_id, etc., should be here.
   |     ^^^^ TD003
67 | 
68 |   def get_and_increment_sequence_val(self) -> int:
   |

praxis/backend/core/run_context.py:66:5: FIX002 Line contains TODO, consider resolving the issue
   |
64 |   _call_sequence_next_val: int = 1  # Internal counter, starts at 1
65 | 
66 |   # TODO: CTX-1: Consider if user_accession_id, workcell_accession_id, etc., should be here.
   |     ^^^^ FIX002
67 | 
68 |   def get_and_increment_sequence_val(self) -> int:
   |

praxis/backend/core/run_context.py:98:5: SLF001 Private member accessed: `_call_sequence_next_val`
   |
96 |       current_call_log_db_accession_id=new_parent_call_log_db_accession_id,
97 |     )
98 |     nested_ctx._call_sequence_next_val = self._call_sequence_next_val
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
99 |     return nested_ctx
   |

praxis/backend/core/run_context.py:106:9: ANN202 Missing return type annotation for private function `make_serializable`
    |
104 |   try:
105 | 
106 |     def make_serializable(item):
    |         ^^^^^^^^^^^^^^^^^ ANN202
107 |       if isinstance(item, BaseModel):  # Check for Pydantic models
108 |         try:
    |
    = help: Add return type annotation

praxis/backend/core/run_context.py:106:27: ANN001 Missing type annotation for function argument `item`
    |
104 |   try:
105 | 
106 |     def make_serializable(item):
    |                           ^^^^ ANN001
107 |       if isinstance(item, BaseModel):  # Check for Pydantic models
108 |         try:
    |

praxis/backend/core/run_context.py:113:10: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
111 |           pass  # Not a Pydantic model, proceed to other checks
112 | 
113 |       if isinstance(item, (PraxisRunContext, PraxisState)):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
114 |         return f"<{type(item).__name__} object>"
115 |       if isinstance(item, (Resource, Deck)):  # PLR objects
    |
    = help: Convert to `X | Y`

praxis/backend/core/run_context.py:115:10: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
113 |       if isinstance(item, (PraxisRunContext, PraxisState)):
114 |         return f"<{type(item).__name__} object>"
115 |       if isinstance(item, (Resource, Deck)):  # PLR objects
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
116 |         return repr(item)  # repr() often includes name and key details
    |
    = help: Convert to `X | Y`

praxis/backend/core/scheduler.py:2:1: D205 1 blank line required between summary line and description
  |
1 |   # pylint: disable=too-many-arguments,fixme
2 | / """Protocol Scheduler - Manages protocol execution scheduling and asset allocation.
3 | | # broad-except is justified at method level.
4 | | 
5 | | This module provides the scheduling layer between the API and the Orchestrator,
6 | | handling asset analysis, reservation, and asynchronous task queueing.
7 | | """
  | |___^ D205
8 |   
9 |   import json
  |
  = help: Insert single blank line

praxis/backend/core/scheduler.py:39:7: ANN204 Missing return type annotation for special method `__init__`
   |
37 |   """Represents a scheduled protocol run with asset reservations."""
38 | 
39 |   def __init__(
   |       ^^^^^^^^ ANN204
40 |     self,
41 |     protocol_run_id: uuid.UUID,
   |
   = help: Add return type annotation: `None`

praxis/backend/core/scheduler.py:75:7: ANN204 Missing return type annotation for special method `__init__`
   |
73 |   """
74 | 
75 |   def __init__(
   |       ^^^^^^^^ ANN204
76 |     self,
77 |     db_session_factory: async_sessionmaker[AsyncSession],
   |
   = help: Add return type annotation: `None`

praxis/backend/core/scheduler.py:107:5: ARG002 Unused method argument: `user_params`
    |
105 |     self,
106 |     protocol_def_orm: FunctionProtocolDefinitionOrm,
107 |     user_params: dict[str, Any],
    |     ^^^^^^^^^^^ ARG002
108 |   ) -> list[RuntimeAssetRequirement]:
109 |     """Analyze a protocol definition to determine asset requirements.
    |

praxis/backend/core/scheduler.py:165:7: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
163 |       logger.debug("Added deck requirement: %s", protocol_def_orm.deck_param_name)
164 | 
165 |     # TODO: Future enhancement - analyze protocol steps for granular asset needs
    |       ^^^^ TD002
166 |     # This would involve parsing the protocol function to understand:
167 |     # - Sequential vs parallel asset usage
    |

praxis/backend/core/scheduler.py:165:7: TD003 Missing issue link on the line following this TODO
    |
163 |       logger.debug("Added deck requirement: %s", protocol_def_orm.deck_param_name)
164 | 
165 |     # TODO: Future enhancement - analyze protocol steps for granular asset needs
    |       ^^^^ TD003
166 |     # This would involve parsing the protocol function to understand:
167 |     # - Sequential vs parallel asset usage
    |

praxis/backend/core/scheduler.py:165:7: FIX002 Line contains TODO, consider resolving the issue
    |
163 |       logger.debug("Added deck requirement: %s", protocol_def_orm.deck_param_name)
164 | 
165 |     # TODO: Future enhancement - analyze protocol steps for granular asset needs
    |       ^^^^ FIX002
166 |     # This would involve parsing the protocol function to understand:
167 |     # - Sequential vs parallel asset usage
    |

praxis/backend/core/scheduler.py:234:7: TRY300 Consider moving this statement to an `else` block
    |
232 |         protocol_run_id,
233 |       )
234 |       return True
    |       ^^^^^^^^^^^ TRY300
235 | 
236 |     # pylint: disable-next=broad-except
    |

praxis/backend/core/scheduler.py:240:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
238 |     # ensures that any unhandled error leads to a rollback of reservations and a False return.
239 |     except Exception as e:
240 |       logger.error(
    |              ^^^^^ G201
241 |         "Error during asset reservation for run %s: %s",
242 |         protocol_run_id,
    |

praxis/backend/core/scheduler.py:335:13: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
333 |           protocol_name=protocol_def.name,
334 |           required_assets=requirements,
335 |           # TODO: Estimate duration based on protocol analysis
    |             ^^^^ TD002
336 |           estimated_duration_ms=None,
337 |         )
    |

praxis/backend/core/scheduler.py:335:13: TD003 Missing issue link on the line following this TODO
    |
333 |           protocol_name=protocol_def.name,
334 |           required_assets=requirements,
335 |           # TODO: Estimate duration based on protocol analysis
    |             ^^^^ TD003
336 |           estimated_duration_ms=None,
337 |         )
    |

praxis/backend/core/scheduler.py:335:13: FIX002 Line contains TODO, consider resolving the issue
    |
333 |           protocol_name=protocol_def.name,
334 |           required_assets=requirements,
335 |           # TODO: Estimate duration based on protocol analysis
    |             ^^^^ FIX002
336 |           estimated_duration_ms=None,
337 |         )
    |

praxis/backend/core/scheduler.py:373:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
372 |     except Exception as e:
373 |       logger.error(
    |              ^^^^^ G201
374 |         "Error scheduling protocol execution for run %s: %s",
375 |         protocol_run_orm.accession_id,
    |

praxis/backend/core/scheduler.py:407:57: PGH003 Use specific rule codes when ignoring type issues
    |
405 |       try:
406 |         # Try to use Celery task
407 |         task_result = execute_protocol_run_task.delay(  # type: ignore
    |                                                         ^^^^^^^^^^^^^^ PGH003
408 |           str(protocol_run_id), user_params, initial_state,
409 |         )
    |

praxis/backend/core/scheduler.py:413:15: TRY003 Avoid specifying long messages outside the exception class
    |
411 |         except AttributeError as e:
412 |           # Fallback: direct call to Celery task is not supported
413 |           raise RuntimeError(
    |  _______________^
414 | |           "Direct call to execute_protocol_run_task is not supported. Celery worker must be running.",
415 | |         ) from e
    | |_________^ TRY003
416 |   
417 |         logger.info(
    |

praxis/backend/core/scheduler.py:414:11: EM101 Exception must not use a string literal, assign to variable first
    |
412 |         # Fallback: direct call to Celery task is not supported
413 |         raise RuntimeError(
414 |           "Direct call to execute_protocol_run_task is not supported. Celery worker must be running.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
415 |         ) from e
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/scheduler.py:430:7: TRY300 Consider moving this statement to an `else` block
    |
428 |         schedule_entry.celery_task_id = celery_task_id
429 | 
430 |       return True
    |       ^^^^^^^^^^^ TRY300
431 | 
432 |     except Exception as e:
    |

praxis/backend/core/scheduler.py:433:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
432 |     except Exception as e:
433 |       logger.error(
    |              ^^^^^ G201
434 |         "Failed to queue execution task for run %s: %s",
435 |         protocol_run_id,
    |

praxis/backend/core/scheduler.py:471:7: TRY300 Consider moving this statement to an `else` block
    |
469 |         return True
470 |       logger.warning("Run %s not found in active schedules", protocol_run_id)
471 |       return False
    |       ^^^^^^^^^^^^ TRY300
472 | 
473 |     except Exception as e:
    |

praxis/backend/core/scheduler.py:474:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
473 |     except Exception as e:
474 |       logger.error(
    |              ^^^^^ G201
475 |         "Error cancelling scheduled run %s: %s",
476 |         protocol_run_id,
    |

praxis/backend/core/workcell.py:21:1: TID252 Prefer absolute imports over relative imports from parent modules
   |
19 |   from pylabrobot.resources import Deck, Resource
20 |   
21 | / from ..models import (
22 | |   AssetRequirementModel,
23 | |   MachineCategoryEnum,
24 | |   ResourceCategoryEnum,
25 | | )
   | |_^ TID252
26 |   from ..utils.logging import get_logger
   |
   = help: Replace relative imports from parent modules with absolute imports

praxis/backend/core/workcell.py:21:1: TID252 Prefer absolute imports over relative imports from parent modules
   |
19 |   from pylabrobot.resources import Deck, Resource
20 |   
21 | / from ..models import (
22 | |   AssetRequirementModel,
23 | |   MachineCategoryEnum,
24 | |   ResourceCategoryEnum,
25 | | )
   | |_^ TID252
26 |   from ..utils.logging import get_logger
   |
   = help: Replace relative imports from parent modules with absolute imports

praxis/backend/core/workcell.py:21:1: TID252 Prefer absolute imports over relative imports from parent modules
   |
19 |   from pylabrobot.resources import Deck, Resource
20 |   
21 | / from ..models import (
22 | |   AssetRequirementModel,
23 | |   MachineCategoryEnum,
24 | |   ResourceCategoryEnum,
25 | | )
   | |_^ TID252
26 |   from ..utils.logging import get_logger
   |
   = help: Replace relative imports from parent modules with absolute imports

praxis/backend/core/workcell.py:26:1: TID252 Prefer absolute imports over relative imports from parent modules
   |
24 |   ResourceCategoryEnum,
25 | )
26 | from ..utils.logging import get_logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TID252
27 | 
28 | logger = get_logger(__name__)
   |
   = help: Replace relative imports from parent modules with absolute imports

praxis/backend/core/workcell.py:64:13: TRY003 Avoid specifying long messages outside the exception class
   |
62 |     """
63 |     if not save_file.endswith(".json"):
64 |       raise ValueError("save_file must be a JSON file ending in .json")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
65 | 
66 |     self.name = name
   |

praxis/backend/core/workcell.py:64:24: EM101 Exception must not use a string literal, assign to variable first
   |
62 |     """
63 |     if not save_file.endswith(".json"):
64 |       raise ValueError("save_file must be a JSON file ending in .json")
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
65 | 
66 |     self.name = name
   |
   = help: Assign to variable; remove string literal

praxis/backend/core/workcell.py:152:13: TRY003 Avoid specifying long messages outside the exception class
    |
150 |       liquid_handler.deck = deck
151 |     else:
152 |       raise KeyError(f"Liquid handler '{liquid_handler_accession_id}' not found.")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
153 | 
154 |   def serialize_all_state(self) -> dict[str, Any]:
    |

praxis/backend/core/workcell.py:152:22: EM102 Exception must not use an f-string literal, assign to variable first
    |
150 |       liquid_handler.deck = deck
151 |     else:
152 |       raise KeyError(f"Liquid handler '{liquid_handler_accession_id}' not found.")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
153 | 
154 |   def serialize_all_state(self) -> dict[str, Any]:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell.py:162:7: ANN201 Missing return type annotation for public function `load_all_state`
    |
160 |     return state
161 | 
162 |   def load_all_state(self, state: dict[str, Any]):
    |       ^^^^^^^^^^^^^^ ANN201
163 |     """Load the state for all resources from a dictionary."""
164 |     for child in self.get_all_children():
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell.py:168:7: ANN201 Missing return type annotation for public function `save_state_to_file`
    |
166 |         child.load_state(state[child.name])
167 | 
168 |   def save_state_to_file(self, fn: str, indent: int | None = 4):
    |       ^^^^^^^^^^^^^^^^^^ ANN201
169 |     """Save the current state of all workcell resources to a JSON file."""
170 |     with open(fn, "w", encoding="utf-8") as f:
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell.py:170:10: PTH123 `open()` should be replaced by `Path.open()`
    |
168 |   def save_state_to_file(self, fn: str, indent: int | None = 4):
169 |     """Save the current state of all workcell resources to a JSON file."""
170 |     with open(fn, "w", encoding="utf-8") as f:
    |          ^^^^ PTH123
171 |       json.dump(self.serialize_all_state(), f, indent=indent)
    |

praxis/backend/core/workcell.py:173:7: ANN201 Missing return type annotation for public function `load_state_from_file`
    |
171 |       json.dump(self.serialize_all_state(), f, indent=indent)
172 | 
173 |   def load_state_from_file(self, fn: str):
    |       ^^^^^^^^^^^^^^^^^^^^ ANN201
174 |     """Load the state of all workcell resources from a JSON file."""
175 |     with open(fn, encoding="utf-8") as f:
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell.py:175:10: PTH123 `open()` should be replaced by `Path.open()`
    |
173 |   def load_state_from_file(self, fn: str):
174 |     """Load the state of all workcell resources from a JSON file."""
175 |     with open(fn, encoding="utf-8") as f:
    |          ^^^^ PTH123
176 |       content = json.load(f)
177 |     self.load_all_state(content)
    |

praxis/backend/core/workcell.py:187:11: TRY003 Avoid specifying long messages outside the exception class
    |
185 |     if key in self.refs:
186 |       return self.refs[key]
187 |     raise KeyError(f"'{key}' is not a valid asset category.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
    |

praxis/backend/core/workcell.py:187:20: EM102 Exception must not use an f-string literal, assign to variable first
    |
185 |     if key in self.refs:
186 |       return self.refs[key]
187 |     raise KeyError(f"'{key}' is not a valid asset category.")
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell.py:198:7: ANN204 Missing return type annotation for special method `__init__`
    |
196 |   """
197 | 
198 |   def __init__(
    |       ^^^^^^^^ ANN204
199 |     self,
200 |     parent_workcell: Workcell,
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell.py:213:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `__getattr__`
    |
211 |     return asset_name in self._required_asset_names
212 | 
213 |   def __getattr__(self, name: str) -> Any:
    |                                       ^^^ ANN401
214 |     """Delegate attribute access to the parent workcell for required assets."""
215 |     if name.startswith("_"):
    |

praxis/backend/core/workcell.py:221:13: TRY003 Avoid specifying long messages outside the exception class
    |
219 |       # Enforce that protocols can only access assets they have declared.
220 |       if name not in self._required_asset_names:
221 |         raise AttributeError(
    |  _____________^
222 | |         f"Protocol '{self.protocol_name}' attempted to access asset '{name}' "
223 | |         "but did not declare it as a requirement.",
224 | |       )
    | |_______^ TRY003
225 |   
226 |       # Safely delegate the attribute access to the parent Workcell
    |

praxis/backend/core/workcell.py:222:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
220 |       if name not in self._required_asset_names:
221 |         raise AttributeError(
222 |           f"Protocol '{self.protocol_name}' attempted to access asset '{name}' "
    |  _________^
223 | |         "but did not declare it as a requirement.",
    | |__________________________________________________^ EM102
224 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:53:11: TRY003 Avoid specifying long messages outside the exception class
   |
51 |   """Import and return a class dynamically from its fully qualified name."""
52 |   if not class_fqn or "." not in class_fqn:
53 |     raise ValueError("Invalid fully qualified class name: %s", class_fqn)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
54 |   module_name, class_name = class_fqn.rsplit(".", 1)
55 |   imported_module = importlib.import_module(module_name)
   |

praxis/backend/core/workcell_runtime.py:53:22: EM101 Exception must not use a string literal, assign to variable first
   |
51 |   """Import and return a class dynamically from its fully qualified name."""
52 |   if not class_fqn or "." not in class_fqn:
53 |     raise ValueError("Invalid fully qualified class name: %s", class_fqn)
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
54 |   module_name, class_name = class_fqn.rsplit(".", 1)
55 |   imported_module = importlib.import_module(module_name)
   |
   = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:67:7: ANN204 Missing return type annotation for special method `__init__`
   |
65 |   """
66 | 
67 |   def __init__(
   |       ^^^^^^^^ ANN204
68 |     self,
69 |     db_session_factory: async_sessionmaker[AsyncSession],
   |
   = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:67:7: D417 Missing argument description in the docstring for `__init__`: `config`
   |
65 |   """
66 | 
67 |   def __init__(
   |       ^^^^^^^^ D417
68 |     self,
69 |     db_session_factory: async_sessionmaker[AsyncSession],
   |

praxis/backend/core/workcell_runtime.py:97:13: ANN202 Missing return type annotation for private function `_link_workcell_to_db`
   |
95 |     logger.info("WorkcellRuntime initialized.")
96 | 
97 |   async def _link_workcell_to_db(self):
   |             ^^^^^^^^^^^^^^^^^^^^ ANN202
98 |     """Links the in-memory Workcell to its persistent DB entry."""
99 |     if self._workcell_db_accession_id is None:
   |
   = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:125:13: ANN202 Missing return type annotation for private function `_continuous_state_sync_loop`
    |
123 |           )
124 | 
125 |   async def _continuous_state_sync_loop(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
126 |     """Synchronize workcell state internally and continuously (DB & Disk)."""
127 |     if self._workcell_db_accession_id is None:
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:168:7: PERF203 `try`-`except` within a loop incurs performance overhead
    |
166 |             )
167 |   
168 |         except asyncio.CancelledError:
    |  _______^
169 | |         logger.info("Workcell state sync loop cancelled.")
170 | |         break
    | |_____________^ PERF203
171 |         # Justification: This is a top-level background task loop. A broad except
172 |         # is necessary to catch any unexpected errors during the sync process,
    |

praxis/backend/core/workcell_runtime.py:176:16: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
174 |       # runtime from crashing due to a transient issue.
175 |       except Exception as e:  # pylint: disable=broad-except
176 |         logger.error(
    |                ^^^^^ G201
177 |           "Error during continuous workcell state sync for ID %s: %s",
178 |           self._workcell_db_accession_id,
    |

praxis/backend/core/workcell_runtime.py:185:13: ANN201 Missing return type annotation for public function `start_workcell_state_sync`
    |
183 |         await asyncio.sleep(5)
184 | 
185 |   async def start_workcell_state_sync(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
186 |     """Start the continuous workcell state synchronization task."""
187 |     await self._link_workcell_to_db()
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:198:13: ANN201 Missing return type annotation for public function `stop_workcell_state_sync`
    |
196 |     )
197 | 
198 |   async def stop_workcell_state_sync(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
199 |     """Stop the continuous workcell state synchronization task and performs final disk backup."""
200 |     if self._state_sync_task:
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:202:7: SIM105 Use `contextlib.suppress(asyncio.CancelledError)` instead of `try`-`except`-`pass`
    |
200 |       if self._state_sync_task:
201 |         self._state_sync_task.cancel()
202 |         try:
    |  _______^
203 | |         await self._state_sync_task
204 | |       except asyncio.CancelledError:
205 | |         pass
    | |____________^ SIM105
206 |         self._state_sync_task = None
207 |       else:
    |
    = help: Replace with `contextlib.suppress(asyncio.CancelledError)`

praxis/backend/core/workcell_runtime.py:215:66: PGH003 Use specific rule codes when ignoring type issues
    |
213 |         "_final_exit.json",
214 |       )
215 |       self._main_workcell.save_state_to_file(final_backup_path)  # type: ignore
    |                                                                  ^^^^^^^^^^^^^^ PGH003
216 |       logger.info("Workcell state saved to disk on exit: %s", final_backup_path)
    |

praxis/backend/core/workcell_runtime.py:233:14: BLE001 Do not catch blind exception: `Exception`
    |
231 |       # Justification: This is a final cleanup step on shutdown. A broad except
232 |       # is necessary to log any error without crashing the shutdown process.
233 |       except Exception as e:  # pylint: disable=broad-except
    |              ^^^^^^^^^ BLE001
234 |         logger.error(
235 |           "Failed to commit final workcell state to DB on exit for ID %s: %s",
    |

praxis/backend/core/workcell_runtime.py:234:9: TRY400 Use `logging.exception` instead of `logging.error`
    |
232 |         # is necessary to log any error without crashing the shutdown process.
233 |         except Exception as e:  # pylint: disable=broad-except
234 |           logger.error(
    |  _________^
235 | |           "Failed to commit final workcell state to DB on exit for ID %s: %s",
236 | |           self._workcell_db_accession_id,
237 | |           e,
238 | |         )
    | |_________^ TRY400
239 |   
240 |     def get_main_workcell(self) -> Workcell:
    |
    = help: Replace with `exception`

praxis/backend/core/workcell_runtime.py:243:13: TRY003 Avoid specifying long messages outside the exception class
    |
241 |     """Return the main Workcell instance managed by the runtime."""
242 |     if self._main_workcell is None:
243 |       raise WorkcellRuntimeError("Main Workcell instance is not initialized.")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
244 |     return self._main_workcell
    |

praxis/backend/core/workcell_runtime.py:243:34: EM101 Exception must not use a string literal, assign to variable first
    |
241 |     """Return the main Workcell instance managed by the runtime."""
242 |     if self._main_workcell is None:
243 |       raise WorkcellRuntimeError("Main Workcell instance is not initialized.")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
244 |     return self._main_workcell
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:250:7: ANN201 Missing return type annotation for public function `apply_state_snapshot`
    |
248 |     return self._main_workcell.serialize_all_state()
249 | 
250 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]):
    |       ^^^^^^^^^^^^^^^^^^^^ ANN201
251 |     """Apply a previously captured JSON state to the workcell."""
252 |     self._main_workcell.load_all_state(snapshot_json)
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:259:13: C901 `_get_calculated_location` is too complex (11 > 10)
    |
257 |     suffix=" - Ensure the deck type definition exists in the database.",
258 |   )
259 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ C901
260 |     self,
261 |     target_deck: Deck,
    |

praxis/backend/core/workcell_runtime.py:259:13: PLR0912 Too many branches (14 > 12)
    |
257 |     suffix=" - Ensure the deck type definition exists in the database.",
258 |   )
259 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
260 |     self,
261 |     target_deck: Deck,
    |

praxis/backend/core/workcell_runtime.py:298:10: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
296 |         deck_type_id,
297 |       )
298 |       if isinstance(position_accession_id, (str, int, uuid.UUID)):
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
299 |         async with self.db_session_factory() as db_session:
300 |           all_deck_position_definitions = await svc.read_position_definitions_for_deck_type(
    |
    = help: Convert to `X | Y`

praxis/backend/core/workcell_runtime.py:319:17: TRY003 Avoid specifying long messages outside the exception class
    |
317 |                 z=found_position_def.nominal_z_mm if found_position_def.nominal_z_mm is not None else 0.0,
318 |               )
319 |             raise WorkcellRuntimeError(
    |  _________________^
320 | |             f"Position '{position_accession_id}' not found in predefined deck position "
321 | |             f"definitions for deck type ID {deck_type_id}.",
322 | |           )
    | |___________^ TRY003
323 |         else:
324 |           raise WorkcellRuntimeError(
    |

praxis/backend/core/workcell_runtime.py:320:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
318 |               )
319 |             raise WorkcellRuntimeError(
320 |               f"Position '{position_accession_id}' not found in predefined deck position "
    |  _____________^
321 | |             f"definitions for deck type ID {deck_type_id}.",
    | |___________________________________________________________^ EM102
322 |             )
323 |         else:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:324:15: TRY003 Avoid specifying long messages outside the exception class
    |
322 |             )
323 |         else:
324 |           raise WorkcellRuntimeError(
    |  _______________^
325 | |           f"No positioning configuration provided for deck type ID "
326 | |           f"{deck_type_id}. Cannot determine position location.",
327 | |         )
    | |_________^ TRY003
328 |       else:
329 |         method_name = positioning_config.method_name
    |

praxis/backend/core/workcell_runtime.py:325:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
323 |         else:
324 |           raise WorkcellRuntimeError(
325 |             f"No positioning configuration provided for deck type ID "
    |  ___________^
326 | |           f"{deck_type_id}. Cannot determine position location.",
    | |________________________________________________________________^ EM102
327 |           )
328 |       else:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:336:15: TRY003 Avoid specifying long messages outside the exception class
    |
334 |         position_method = getattr(target_deck, method_name, None)
335 |         if position_method is None or not callable(position_method):
336 |           raise WorkcellRuntimeError(
    |  _______________^
337 | |           f"Deck does not have a valid position method '{method_name}' as configured.",
338 | |         )
    | |_________^ TRY003
339 |   
340 |         converted_position_arg: str | int
    |

praxis/backend/core/workcell_runtime.py:337:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
335 |       if position_method is None or not callable(position_method):
336 |         raise WorkcellRuntimeError(
337 |           f"Deck does not have a valid position method '{method_name}' as configured.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
338 |         )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:345:17: TRY003 Avoid specifying long messages outside the exception class
    |
343 |             converted_position_arg = int(position_accession_id)
344 |           except (ValueError, TypeError) as e:
345 |             raise TypeError(
    |  _________________^
346 | |             f"Expected integer for position_accession_id '{position_accession_id}' for method "
347 | |             f"'{method_name}' but got invalid type/value: {e}",
348 | |           ) from e
    | |___________^ TRY003
349 |         else:
350 |           converted_position_arg = str(position_accession_id)
    |

praxis/backend/core/workcell_runtime.py:346:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
344 |           except (ValueError, TypeError) as e:
345 |             raise TypeError(
346 |               f"Expected integer for position_accession_id '{position_accession_id}' for method "
    |  _____________^
347 | |             f"'{method_name}' but got invalid type/value: {e}",
    | |______________________________________________________________^ EM102
348 |             ) from e
349 |         else:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:360:15: TRY003 Avoid specifying long messages outside the exception class
    |
359 |         except TypeError as e:
360 |           raise WorkcellRuntimeError(
    |  _______________^
361 | |           f"Error calling PLR method '{method_name}' with arguments "
362 | |           f"'{arg_name}={converted_position_arg}' and params '{method_params}': {e}. "
363 | |           "Check if method signature matches configuration.",
364 | |         ) from e
    | |_________^ TRY003
365 |         # Justification: This wraps a dynamic call to a PyLabRobot method, which could
366 |         # raise any number of unexpected errors. Catching broadly ensures we can
    |

praxis/backend/core/workcell_runtime.py:361:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
359 |         except TypeError as e:
360 |           raise WorkcellRuntimeError(
361 |             f"Error calling PLR method '{method_name}' with arguments "
    |  ___________^
362 | |           f"'{arg_name}={converted_position_arg}' and params '{method_params}': {e}. "
363 | |           "Check if method signature matches configuration.",
    | |____________________________________________________________^ EM102
364 |           ) from e
365 |         # Justification: This wraps a dynamic call to a PyLabRobot method, which could
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:370:15: TRY003 Avoid specifying long messages outside the exception class
    |
368 |         except Exception as e:  # pylint: disable=broad-except
369 |           logger.exception("Unexpected error when calling PLR method '%s'", method_name)
370 |           raise WorkcellRuntimeError(
    |  _______________^
371 | |           f"Unexpected error when calling PLR method '{method_name}': {e}",
372 | |         ) from e
    | |_________^ TRY003
373 |   
374 |         if not isinstance(calculated_location, Coordinate):
    |

praxis/backend/core/workcell_runtime.py:371:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
369 |         logger.exception("Unexpected error when calling PLR method '%s'", method_name)
370 |         raise WorkcellRuntimeError(
371 |           f"Unexpected error when calling PLR method '{method_name}': {e}",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
372 |         ) from e
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:375:83: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
374 |       if not isinstance(calculated_location, Coordinate):
375 |         if isinstance(calculated_location, tuple) and len(calculated_location) == 3:
    |                                                                                   ^ PLR2004
376 |           calculated_location = Coordinate(
377 |             x=calculated_location[0],
    |

praxis/backend/core/workcell_runtime.py:382:17: TRY003 Avoid specifying long messages outside the exception class
    |
380 |             )
381 |           else:
382 |             raise TypeError(
    |  _________________^
383 | |             f"Expected PLR method '{method_name}' to return a Coordinate or (x,y,z) "
384 | |             f"tuple, but got {type(calculated_location)}: {calculated_location}",
385 | |           )
    | |___________^ TRY003
386 |         return calculated_location
    |

praxis/backend/core/workcell_runtime.py:383:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
381 |           else:
382 |             raise TypeError(
383 |               f"Expected PLR method '{method_name}' to return a Coordinate or (x,y,z) "
    |  _____________^
384 | |             f"tuple, but got {type(calculated_location)}: {calculated_location}",
    | |________________________________________________________________________________^ EM102
385 |             )
386 |         return calculated_location
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:392:13: C901 `initialize_machine` is too complex (21 > 10)
    |
390 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
391 |   )
392 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:
    |             ^^^^^^^^^^^^^^^^^^ C901
393 |     """Initialize and connects to a machine's PyLabRobot machine/resource.
    |

praxis/backend/core/workcell_runtime.py:392:13: PLR0912 Too many branches (24 > 12)
    |
390 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
391 |   )
392 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:
    |             ^^^^^^^^^^^^^^^^^^ PLR0912
393 |     """Initialize and connects to a machine's PyLabRobot machine/resource.
    |

praxis/backend/core/workcell_runtime.py:392:13: PLR0915 Too many statements (81 > 50)
    |
390 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
391 |   )
392 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:
    |             ^^^^^^^^^^^^^^^^^^ PLR0915
393 |     """Initialize and connects to a machine's PyLabRobot machine/resource.
    |

praxis/backend/core/workcell_runtime.py:411:13: TRY003 Avoid specifying long messages outside the exception class
    |
409 |       """
410 |       if not hasattr(machine_orm, "id") or machine_orm.accession_id is None:
411 |         raise WorkcellRuntimeError(
    |  _____________^
412 | |         "Invalid machine_orm object passed to initialize_machine (no id).",
413 | |       )
    | |_______^ TRY003
414 |   
415 |       if machine_orm.accession_id in self._active_machines:
    |

praxis/backend/core/workcell_runtime.py:412:9: EM101 Exception must not use a string literal, assign to variable first
    |
410 |     if not hasattr(machine_orm, "id") or machine_orm.accession_id is None:
411 |       raise WorkcellRuntimeError(
412 |         "Invalid machine_orm object passed to initialize_machine (no id).",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
413 |       )
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:442:17: TRY003 Avoid specifying long messages outside the exception class
    |
440 |           )
441 |           if not isinstance(shared_plr_instance, Machine):
442 |             raise TypeError(
    |  _________________^
443 | |             f"Linked Resource ID {resource_orm.accession_id} is active "
444 | |             f"but its PLR object  '{type(shared_plr_instance).__name__}' is "
445 | |             f"not a valid Machine instance.",
446 | |           )
    | |___________^ TRY003
447 |   
448 |       machine_instance: Machine
    |

praxis/backend/core/workcell_runtime.py:443:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
441 |           if not isinstance(shared_plr_instance, Machine):
442 |             raise TypeError(
443 |               f"Linked Resource ID {resource_orm.accession_id} is active "
    |  _____________^
444 | |             f"but its PLR object  '{type(shared_plr_instance).__name__}' is "
445 | |             f"not a valid Machine instance.",
    | |____________________________________________^ EM102
446 |             )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:459:9: N806 Variable `TargetClass` in function should be lowercase
    |
457 |       )
458 |       try:
459 |         TargetClass = _get_class_from_fqn(machine_orm.fqn)
    |         ^^^^^^^^^^^ N806
460 |         machine_config = machine_orm.properties_json or {}
461 |         instance_name = machine_orm.name
    |

praxis/backend/core/workcell_runtime.py:492:11: TRY301 Abstract `raise` to an inner function
    |
491 |           if not isinstance(machine_instance, Machine):
492 |             raise TypeError(
    |  ___________^
493 | |             f"Machine '{machine_orm.name}' initialized, but it is "
494 | |             f"not a valid PyLabRobot Machine instance. "
495 | |             f"Type is {type(machine_instance).__name__}.",
496 | |           )
    | |___________^ TRY301
497 |   
498 |           if (
    |

praxis/backend/core/workcell_runtime.py:492:17: TRY003 Avoid specifying long messages outside the exception class
    |
491 |           if not isinstance(machine_instance, Machine):
492 |             raise TypeError(
    |  _________________^
493 | |             f"Machine '{machine_orm.name}' initialized, but it is "
494 | |             f"not a valid PyLabRobot Machine instance. "
495 | |             f"Type is {type(machine_instance).__name__}.",
496 | |           )
    | |___________^ TRY003
497 |   
498 |           if (
    |

praxis/backend/core/workcell_runtime.py:493:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
491 |           if not isinstance(machine_instance, Machine):
492 |             raise TypeError(
493 |               f"Machine '{machine_orm.name}' initialized, but it is "
    |  _____________^
494 | |             f"not a valid PyLabRobot Machine instance. "
495 | |             f"Type is {type(machine_instance).__name__}.",
    | |_________________________________________________________^ EM102
496 |             )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:513:11: TRY301 Abstract `raise` to an inner function
    |
511 |               raise WorkcellRuntimeError(error_message) from e
512 |           else:
513 |             raise WorkcellRuntimeError(
    |  ___________^
514 | |             f"Machine '{machine_orm.name}' does not have a valid" " setup() method that is callable and awaitable.",
515 | |           )
    | |___________^ TRY301
516 |         # Justification: This wraps the dynamic instantiation and setup of a PyLabRobot
517 |         # object, which can fail in numerous ways (missing dependencies, connection
    |

praxis/backend/core/workcell_runtime.py:513:17: TRY003 Avoid specifying long messages outside the exception class
    |
511 |               raise WorkcellRuntimeError(error_message) from e
512 |           else:
513 |             raise WorkcellRuntimeError(
    |  _________________^
514 | |             f"Machine '{machine_orm.name}' does not have a valid" " setup() method that is callable and awaitable.",
515 | |           )
    | |___________^ TRY003
516 |         # Justification: This wraps the dynamic instantiation and setup of a PyLabRobot
517 |         # object, which can fail in numerous ways (missing dependencies, connection
    |

praxis/backend/core/workcell_runtime.py:514:13: ISC001 Implicitly concatenated string literals on one line
    |
512 |         else:
513 |           raise WorkcellRuntimeError(
514 |             f"Machine '{machine_orm.name}' does not have a valid" " setup() method that is callable and awaitable.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
515 |           )
516 |       # Justification: This wraps the dynamic instantiation and setup of a PyLabRobot
    |
    = help: Combine string literals

praxis/backend/core/workcell_runtime.py:514:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
512 |         else:
513 |           raise WorkcellRuntimeError(
514 |             f"Machine '{machine_orm.name}' does not have a valid" " setup() method that is callable and awaitable.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
515 |           )
516 |       # Justification: This wraps the dynamic instantiation and setup of a PyLabRobot
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:579:15: TRY003 Avoid specifying long messages outside the exception class
    |
577 |         machine_deck: Deck = machine_instance.deck
578 |         if not isinstance(machine_deck, Deck):
579 |           raise TypeError(
    |  _______________^
580 | |           f"Machine '{machine_orm.name}' has a 'deck' attribute, "
581 | |           f"but it is not a Deck instance. Type is {type(machine_deck)}.",
582 | |         )
    | |_________^ TRY003
583 |   
584 |         async with self.db_session_factory() as db_session:
    |

praxis/backend/core/workcell_runtime.py:580:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
578 |         if not isinstance(machine_deck, Deck):
579 |           raise TypeError(
580 |             f"Machine '{machine_orm.name}' has a 'deck' attribute, "
    |  ___________^
581 | |           f"but it is not a Deck instance. Type is {type(machine_deck)}.",
    | |_________________________________________________________________________^ EM102
582 |           )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:626:13: C901 `create_or_get_resource` is too complex (12 > 10)
    |
624 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
625 |   )
626 |   async def create_or_get_resource(
    |             ^^^^^^^^^^^^^^^^^^^^^^ C901
627 |     self,
628 |     resource_orm: ResourceOrm,
    |

praxis/backend/core/workcell_runtime.py:626:13: PLR0912 Too many branches (13 > 12)
    |
624 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
625 |   )
626 |   async def create_or_get_resource(
    |             ^^^^^^^^^^^^^^^^^^^^^^ PLR0912
627 |     self,
628 |     resource_orm: ResourceOrm,
    |

praxis/backend/core/workcell_runtime.py:649:13: TRY003 Avoid specifying long messages outside the exception class
    |
647 |       """
648 |       if not hasattr(resource_orm, "id") or resource_orm.accession_id is None:
649 |         raise ValueError(
    |  _____________^
650 | |         "Invalid resource_orm object passed to create_or_get_resource (no id).",
651 | |       )
    | |_______^ TRY003
652 |   
653 |       if resource_orm.accession_id in self._active_resources:
    |

praxis/backend/core/workcell_runtime.py:650:9: EM101 Exception must not use a string literal, assign to variable first
    |
648 |     if not hasattr(resource_orm, "id") or resource_orm.accession_id is None:
649 |       raise ValueError(
650 |         "Invalid resource_orm object passed to create_or_get_resource (no id).",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
651 |       )
    |
    = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:680:17: TRY003 Avoid specifying long messages outside the exception class
    |
678 |           )
679 |           if not isinstance(shared_plr_instance, Resource):
680 |             raise TypeError(
    |  _________________^
681 | |             f"Linked Machine ID {machine_orm.accession_id} is active but its PLR object "
682 | |             f"'{type(shared_plr_instance).__name__}' is not a PyLabRobot Resource. "
683 | |             f"Cannot use as resource.",
684 | |           )
    | |___________^ TRY003
685 |   
686 |       resource_instance: Resource
    |

praxis/backend/core/workcell_runtime.py:681:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
679 |           if not isinstance(shared_plr_instance, Resource):
680 |             raise TypeError(
681 |               f"Linked Machine ID {machine_orm.accession_id} is active but its PLR object "
    |  _____________^
682 | |             f"'{type(shared_plr_instance).__name__}' is not a PyLabRobot Resource. "
683 | |             f"Cannot use as resource.",
    | |______________________________________^ EM102
684 |             )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:698:9: N806 Variable `ResourceClass` in function should be lowercase
    |
697 |       try:
698 |         ResourceClass = _get_class_from_fqn(resource_definition_fqn)
    |         ^^^^^^^^^^^^^ N806
699 |         resource_instance = ResourceClass(name=resource_orm.name)
700 |       # Justification: This wraps the dynamic instantiation of a PyLabRobot resource,
    |

praxis/backend/core/workcell_runtime.py:784:13: TRY003 Avoid specifying long messages outside the exception class
    |
782 |       machine = self._active_machines.get(machine_orm_accession_id)
783 |       if machine is None:
784 |         raise WorkcellRuntimeError(
    |  _____________^
785 | |         f"Machine with ORM ID {machine_orm_accession_id} not found in active machines.",
786 | |       )
    | |_______^ TRY003
787 |       if not isinstance(machine, Machine):
788 |         raise TypeError(
    |

praxis/backend/core/workcell_runtime.py:785:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
783 |     if machine is None:
784 |       raise WorkcellRuntimeError(
785 |         f"Machine with ORM ID {machine_orm_accession_id} not found in active machines.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
786 |       )
787 |     if not isinstance(machine, Machine):
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:788:13: TRY003 Avoid specifying long messages outside the exception class
    |
786 |         )
787 |       if not isinstance(machine, Machine):
788 |         raise TypeError(
    |  _____________^
789 | |         f"Machine with ORM ID {machine_orm_accession_id} is not a valid Machine instance. Type is {type(machine)}.",
790 | |       )
    | |_______^ TRY003
791 |       return machine
    |

praxis/backend/core/workcell_runtime.py:789:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
787 |     if not isinstance(machine, Machine):
788 |       raise TypeError(
789 |         f"Machine with ORM ID {machine_orm_accession_id} is not a valid Machine instance. Type is {type(machine)}.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
790 |       )
791 |     return machine
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:809:11: TRY003 Avoid specifying long messages outside the exception class
    |
807 |         if active_machine is machine:
808 |           return orm_accession_id
809 |       raise WorkcellRuntimeError(
    |  ___________^
810 | |       f"Machine instance {machine} not found in active machines.",
811 | |     )
    | |_____^ TRY003
812 |   
813 |     def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID:
    |

praxis/backend/core/workcell_runtime.py:810:7: EM102 Exception must not use an f-string literal, assign to variable first
    |
808 |         return orm_accession_id
809 |     raise WorkcellRuntimeError(
810 |       f"Machine instance {machine} not found in active machines.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
811 |     )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:829:11: TRY003 Avoid specifying long messages outside the exception class
    |
827 |       if active_deck is deck:
828 |         return orm_accession_id
829 |     raise WorkcellRuntimeError(f"Deck instance {deck} not found in active decks.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
830 | 
831 |   def get_active_resource(
    |

praxis/backend/core/workcell_runtime.py:829:32: EM102 Exception must not use an f-string literal, assign to variable first
    |
827 |       if active_deck is deck:
828 |         return orm_accession_id
829 |     raise WorkcellRuntimeError(f"Deck instance {deck} not found in active decks.")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
830 | 
831 |   def get_active_resource(
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:846:13: TRY003 Avoid specifying long messages outside the exception class
    |
844 |       resource = self._active_resources.get(resource_orm_accession_id)
845 |       if resource is None:
846 |         raise WorkcellRuntimeError(
    |  _____________^
847 | |         f"Resource instance with ORM ID {resource_orm_accession_id} not found in active \
848 | |           resources.",
849 | |       )
    | |_______^ TRY003
850 |       if not isinstance(resource, Resource):
851 |         raise TypeError(
    |

praxis/backend/core/workcell_runtime.py:847:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
845 |       if resource is None:
846 |         raise WorkcellRuntimeError(
847 |           f"Resource instance with ORM ID {resource_orm_accession_id} not found in active \
    |  _________^
848 | |           resources.",
    | |_____________________^ EM102
849 |         )
850 |       if not isinstance(resource, Resource):
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:851:13: TRY003 Avoid specifying long messages outside the exception class
    |
849 |         )
850 |       if not isinstance(resource, Resource):
851 |         raise TypeError(
    |  _____________^
852 | |         f"Resource instance with ORM ID {resource_orm_accession_id} is not a valid \
853 | |           PyLabRobot Resource instance. Type is {type(resource)}.",
854 | |       )
    | |_______^ TRY003
855 |       return resource
    |

praxis/backend/core/workcell_runtime.py:852:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
850 |       if not isinstance(resource, Resource):
851 |         raise TypeError(
852 |           f"Resource instance with ORM ID {resource_orm_accession_id} is not a valid \
    |  _________^
853 | |           PyLabRobot Resource instance. Type is {type(resource)}.",
    | |__________________________________________________________________^ EM102
854 |         )
855 |       return resource
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:870:11: TRY003 Avoid specifying long messages outside the exception class
    |
868 |       if active_resource is resource:
869 |         return orm_accession_id
870 |     raise WorkcellRuntimeError(f"Resource instance {resource}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
871 | 
872 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck:
    |

praxis/backend/core/workcell_runtime.py:870:32: EM102 Exception must not use an f-string literal, assign to variable first
    |
868 |       if active_resource is resource:
869 |         return orm_accession_id
870 |     raise WorkcellRuntimeError(f"Resource instance {resource}")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
871 | 
872 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:884:13: TRY003 Avoid specifying long messages outside the exception class
    |
882 |       deck = self._active_decks.get(deck_orm_accession_id)
883 |       if deck is None:
884 |         raise WorkcellRuntimeError(
    |  _____________^
885 | |         f"Deck with ORM ID {deck_orm_accession_id} not found in active decks.",
886 | |       )
    | |_______^ TRY003
887 |       if not isinstance(deck, Deck):
888 |         raise TypeError(
    |

praxis/backend/core/workcell_runtime.py:885:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
883 |     if deck is None:
884 |       raise WorkcellRuntimeError(
885 |         f"Deck with ORM ID {deck_orm_accession_id} not found in active decks.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
886 |       )
887 |     if not isinstance(deck, Deck):
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:888:13: TRY003 Avoid specifying long messages outside the exception class
    |
886 |         )
887 |       if not isinstance(deck, Deck):
888 |         raise TypeError(
    |  _____________^
889 | |         f"Deck with ORM ID {deck_orm_accession_id} is not a valid PyLabRobot Deck instance. Type is {type(deck)}.",
890 | |       )
    | |_______^ TRY003
891 |       return deck
    |

praxis/backend/core/workcell_runtime.py:889:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
887 |     if not isinstance(deck, Deck):
888 |       raise TypeError(
889 |         f"Deck with ORM ID {deck_orm_accession_id} is not a valid PyLabRobot Deck instance. Type is {type(deck)}.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
890 |       )
891 |     return deck
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:897:13: ANN201 Missing return type annotation for public function `shutdown_machine`
    |
895 |     suffix=" - Ensure the machine ORM ID is valid and the machine is active.",
896 |   )
897 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID):
    |             ^^^^^^^^^^^^^^^^ ANN201
898 |     """Shut down and removes a live PyLabRobot machine instance.
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:925:11: TRY301 Abstract `raise` to an inner function
    |
923 |             await machine_instance.stop()
924 |           else:
925 |             raise WorkcellRuntimeError(
    |  ___________^
926 | |             f"No stop() method for \
927 | |             {machine_instance.__class__.__name__} machine {machine_orm_accession_id} \
928 | |               that is callable and awaitable.",
929 | |           )
    | |___________^ TRY301
930 |           async with self.db_session_factory() as db_session:
931 |             await svc.update_machine_status(
    |

praxis/backend/core/workcell_runtime.py:925:17: TRY003 Avoid specifying long messages outside the exception class
    |
923 |             await machine_instance.stop()
924 |           else:
925 |             raise WorkcellRuntimeError(
    |  _________________^
926 | |             f"No stop() method for \
927 | |             {machine_instance.__class__.__name__} machine {machine_orm_accession_id} \
928 | |               that is callable and awaitable.",
929 | |           )
    | |___________^ TRY003
930 |           async with self.db_session_factory() as db_session:
931 |             await svc.update_machine_status(
    |

praxis/backend/core/workcell_runtime.py:926:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
924 |           else:
925 |             raise WorkcellRuntimeError(
926 |               f"No stop() method for \
    |  _____________^
927 | |             {machine_instance.__class__.__name__} machine {machine_orm_accession_id} \
928 | |               that is callable and awaitable.",
    | |______________________________________________^ EM102
929 |             )
930 |           async with self.db_session_factory() as db_session:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:951:9: TRY301 Abstract `raise` to an inner function
    |
949 |             )
950 |             await db_session.commit()
951 |           raise WorkcellRuntimeError(
    |  _________^
952 | |           f"Machine with ID {machine_orm_accession_id} is not currently active and is \
953 | |           unexpectedly offline.",
954 | |         )
    | |_________^ TRY301
955 |   
956 |       # Justification: This wraps the machine's `stop()` method, which can raise
    |

praxis/backend/core/workcell_runtime.py:951:15: TRY003 Avoid specifying long messages outside the exception class
    |
949 |             )
950 |             await db_session.commit()
951 |           raise WorkcellRuntimeError(
    |  _______________^
952 | |           f"Machine with ID {machine_orm_accession_id} is not currently active and is \
953 | |           unexpectedly offline.",
954 | |         )
    | |_________^ TRY003
955 |   
956 |       # Justification: This wraps the machine's `stop()` method, which can raise
    |

praxis/backend/core/workcell_runtime.py:952:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
950 |             await db_session.commit()
951 |           raise WorkcellRuntimeError(
952 |             f"Machine with ID {machine_orm_accession_id} is not currently active and is \
    |  ___________^
953 | |           unexpectedly offline.",
    | |________________________________^ EM102
954 |           )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:962:15: TRY003 Avoid specifying long messages outside the exception class
    |
960 |       except Exception as e:  # pylint: disable=broad-except
961 |         if machine_instance is None:
962 |           raise WorkcellRuntimeError(
    |  _______________^
963 | |           f"No active machine instance found for machine ID {machine_orm_accession_id}.",
964 | |         ) from e
    | |_________^ TRY003
965 |         self._active_machines[machine_orm_accession_id] = machine_instance
966 |         async with self.db_session_factory() as db_session:
    |

praxis/backend/core/workcell_runtime.py:963:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
961 |       if machine_instance is None:
962 |         raise WorkcellRuntimeError(
963 |           f"No active machine instance found for machine ID {machine_orm_accession_id}.",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
964 |         ) from e
965 |       self._active_machines[machine_orm_accession_id] = machine_instance
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:974:13: TRY003 Avoid specifying long messages outside the exception class
    |
972 |           )
973 |           await db_session.commit()
974 |         raise WorkcellRuntimeError(
    |  _____________^
975 | |         f"Error shutting down machine ID {machine_orm_accession_id}: \
976 | |         {str(e)[:250]}",
977 | |       ) from e
    | |_______^ TRY003
978 |   
979 |     @log_workcell_runtime_errors(
    |

praxis/backend/core/workcell_runtime.py:975:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
973 |           await db_session.commit()
974 |         raise WorkcellRuntimeError(
975 |           f"Error shutting down machine ID {machine_orm_accession_id}: \
    |  _________^
976 | |         {str(e)[:250]}",
    | |_______________________^ EM102
977 |         ) from e
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:983:13: C901 `assign_resource_to_deck` is too complex (14 > 10)
    |
981 |     suffix=" - Ensure the resource and deck are valid and connected.",
982 |   )
983 |   async def assign_resource_to_deck(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ C901
984 |     self,
985 |     resource_orm_accession_id: uuid.UUID,
    |

praxis/backend/core/workcell_runtime.py:983:13: PLR0912 Too many branches (17 > 12)
    |
981 |     suffix=" - Ensure the resource and deck are valid and connected.",
982 |   )
983 |   async def assign_resource_to_deck(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
984 |     self,
985 |     resource_orm_accession_id: uuid.UUID,
    |

praxis/backend/core/workcell_runtime.py:983:13: ANN201 Missing return type annotation for public function `assign_resource_to_deck`
    |
981 |     suffix=" - Ensure the resource and deck are valid and connected.",
982 |   )
983 |   async def assign_resource_to_deck(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
984 |     self,
985 |     resource_orm_accession_id: uuid.UUID,
    |
    = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:1008:13: TRY003 Avoid specifying long messages outside the exception class
     |
1006 |       """
1007 |       if location is None and position_accession_id is None:
1008 |         raise WorkcellRuntimeError(
     |  _____________^
1009 | |         "Either 'location' or 'position_accession_id' must be provided to assign a resource to a deck.",
1010 | |       )
     | |_______^ TRY003
1011 |   
1012 |       if target in self._active_machines:
     |

praxis/backend/core/workcell_runtime.py:1009:9: EM101 Exception must not use a string literal, assign to variable first
     |
1007 |     if location is None and position_accession_id is None:
1008 |       raise WorkcellRuntimeError(
1009 |         "Either 'location' or 'position_accession_id' must be provided to assign a resource to a deck.",
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
1010 |       )
     |
     = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:1017:13: TRY003 Avoid specifying long messages outside the exception class
     |
1015 |         inferred_target_type = "deck_orm_accession_id"
1016 |       else:
1017 |         raise WorkcellRuntimeError(
     |  _____________^
1018 | |         f"Target ORM ID {target} not found in active machines or decks.",
1019 | |       )
     | |_______^ TRY003
1020 |   
1021 |       resource = self.get_active_resource(resource_orm_accession_id)
     |

praxis/backend/core/workcell_runtime.py:1018:9: EM102 Exception must not use an f-string literal, assign to variable first
     |
1016 |     else:
1017 |       raise WorkcellRuntimeError(
1018 |         f"Target ORM ID {target} not found in active machines or decks.",
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1019 |       )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1032:17: TRY003 Avoid specifying long messages outside the exception class
     |
1030 |           target_deck = getattr(target_machine, "deck", None)
1031 |           if not isinstance(target_deck, Deck):
1032 |             raise WorkcellRuntimeError(
     |  _________________^
1033 | |             f"Machine ID {machine_orm_accession_id} does not have an associated deck.",
1034 | |           )
     | |___________^ TRY003
1035 |           deck_orm_accession_id = self.get_active_deck_accession_id(target_deck)
1036 |         case _:
     |

praxis/backend/core/workcell_runtime.py:1033:13: EM102 Exception must not use an f-string literal, assign to variable first
     |
1031 |         if not isinstance(target_deck, Deck):
1032 |           raise WorkcellRuntimeError(
1033 |             f"Machine ID {machine_orm_accession_id} does not have an associated deck.",
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1034 |           )
1035 |         deck_orm_accession_id = self.get_active_deck_accession_id(target_deck)
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1037:15: TRY003 Avoid specifying long messages outside the exception class
     |
1035 |           deck_orm_accession_id = self.get_active_deck_accession_id(target_deck)
1036 |         case _:
1037 |           raise WorkcellRuntimeError(
     |  _______________^
1038 | |           f"Unexpected target type: {inferred_target_type}. Expected deck_orm_accession_id or \
1039 | |             machine_orm_accession_id.",
1040 | |         )
     | |_________^ TRY003
1041 |   
1042 |       async with self.db_session_factory() as db_session:
     |

praxis/backend/core/workcell_runtime.py:1038:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1036 |         case _:
1037 |           raise WorkcellRuntimeError(
1038 |             f"Unexpected target type: {inferred_target_type}. Expected deck_orm_accession_id or \
     |  ___________^
1039 | |             machine_orm_accession_id.",
     | |______________________________________^ EM102
1040 |           )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1045:15: TRY003 Avoid specifying long messages outside the exception class
     |
1043 |         deck_orm = await svc.read_deck(db_session, deck_orm_accession_id)
1044 |         if deck_orm is None:
1045 |           raise WorkcellRuntimeError(
     |  _______________^
1046 | |           f"Deck ORM ID {deck_orm_accession_id} not found in database.",
1047 | |         )
     | |_________^ TRY003
1048 |         deck_orm_type_definition_accession_id = deck_orm.deck_type_id
     |

praxis/backend/core/workcell_runtime.py:1046:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1044 |       if deck_orm is None:
1045 |         raise WorkcellRuntimeError(
1046 |           f"Deck ORM ID {deck_orm_accession_id} not found in database.",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1047 |         )
1048 |       deck_orm_type_definition_accession_id = deck_orm.deck_type_id
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1051:15: TRY003 Avoid specifying long messages outside the exception class
     |
1050 |         if deck_orm_type_definition_accession_id is None:
1051 |           raise WorkcellRuntimeError(
     |  _______________^
1052 | |           f"Deck ORM ID {deck_orm_accession_id} does not have a valid deck type definition.",
1053 | |         )
     | |_________^ TRY003
1054 |   
1055 |         deck_type_definition_orm = await svc.read_deck_type_definition(
     |

praxis/backend/core/workcell_runtime.py:1052:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1050 |       if deck_orm_type_definition_accession_id is None:
1051 |         raise WorkcellRuntimeError(
1052 |           f"Deck ORM ID {deck_orm_accession_id} does not have a valid deck type definition.",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1053 |         )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1061:15: TRY003 Avoid specifying long messages outside the exception class
     |
1060 |         if deck_type_definition_orm is None:
1061 |           raise WorkcellRuntimeError(
     |  _______________^
1062 | |           f"Deck type definition for deck ORM ID {deck_orm_accession_id} not found in database.",
1063 | |         )
     | |_________^ TRY003
1064 |   
1065 |         positioning_config = PositioningConfig.model_validate(
     |

praxis/backend/core/workcell_runtime.py:1062:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1060 |       if deck_type_definition_orm is None:
1061 |         raise WorkcellRuntimeError(
1062 |           f"Deck type definition for deck ORM ID {deck_orm_accession_id} not found in database.",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1063 |         )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1087:15: TRY003 Avoid specifying long messages outside the exception class
     |
1085 |           )
1086 |         else:
1087 |           raise WorkcellRuntimeError(
     |  _______________^
1088 | |           "Internal error: Neither location nor position_accession_id provided after initial check.",
1089 | |         )
     | |_________^ TRY003
1090 |   
1091 |         try:
     |

praxis/backend/core/workcell_runtime.py:1088:11: EM101 Exception must not use a string literal, assign to variable first
     |
1086 |       else:
1087 |         raise WorkcellRuntimeError(
1088 |           "Internal error: Neither location nor position_accession_id provided after initial check.",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
1089 |         )
     |
     = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:1108:15: TRY003 Avoid specifying long messages outside the exception class
     |
1106 |         # clear error message about the assignment failure.
1107 |         except Exception as e:  # pylint: disable=broad-except
1108 |           raise WorkcellRuntimeError(
     |  _______________^
1109 | |           f"Error assigning resource '{resource.name}' to  "
1110 | |           f"location {final_location_for_plr} on deck ID {deck_orm.accession_id}: {str(e)[:250]}",
1111 | |         ) from e
     | |_________^ TRY003
1112 |   
1113 |     @log_workcell_runtime_errors(
     |

praxis/backend/core/workcell_runtime.py:1109:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1107 |         except Exception as e:  # pylint: disable=broad-except
1108 |           raise WorkcellRuntimeError(
1109 |             f"Error assigning resource '{resource.name}' to  "
     |  ___________^
1110 | |           f"location {final_location_for_plr} on deck ID {deck_orm.accession_id}: {str(e)[:250]}",
     | |_________________________________________________________________________________________________^ EM102
1111 |           ) from e
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1117:13: ANN201 Missing return type annotation for public function `clear_deck_position`
     |
1115 |     suffix=" - Ensure the deck ORM ID and position name are valid.",
1116 |   )
1117 |   async def clear_deck_position(
     |             ^^^^^^^^^^^^^^^^^^^ ANN201
1118 |     self,
1119 |     deck_orm_accession_id: uuid.UUID,
     |
     = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:1139:13: TRY003 Avoid specifying long messages outside the exception class
     |
1138 |       if not isinstance(deck, Deck):
1139 |         raise WorkcellRuntimeError(
     |  _____________^
1140 | |         "Deck from workcell runtime is not a Deck instance."
1141 | |         "This indicates a major error as non-Deck objects"
1142 | |         " should not be in the active decks.",
1143 | |       )
     | |_______^ TRY003
1144 |       logger.info(
1145 |         "WorkcellRuntime: Clearing position '%s' on deck ID %s.",
     |

praxis/backend/core/workcell_runtime.py:1140:9: EM101 Exception must not use a string literal, assign to variable first
     |
1138 |       if not isinstance(deck, Deck):
1139 |         raise WorkcellRuntimeError(
1140 |           "Deck from workcell runtime is not a Deck instance."
     |  _________^
1141 | |         "This indicates a major error as non-Deck objects"
1142 | |         " should not be in the active decks.",
     | |_____________________________________________^ EM101
1143 |         )
1144 |       logger.info(
     |
     = help: Assign to variable; remove string literal

praxis/backend/core/workcell_runtime.py:1181:8: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_machine_action`
     |
1179 |     action_name: str,
1180 |     params: dict[str, Any] | None = None,
1181 |   ) -> Any:
     |        ^^^ ANN401
1182 |     """Execute a method/action on a live PyLabRobot machine instance.
     |

praxis/backend/core/workcell_runtime.py:1221:11: TRY003 Avoid specifying long messages outside the exception class
     |
1219 |         )
1220 |         return getattr(machine, action_name)(**(params or {}))
1221 |       raise AttributeError(
     |  ___________^
1222 | |       f"Machine for ID {machine_orm_accession_id} (type: {type(machine).__name__}) has no action '{action_name}'.",
1223 | |     )
     | |_____^ TRY003
1224 |   
1225 |     @log_workcell_runtime_errors(
     |

praxis/backend/core/workcell_runtime.py:1222:7: EM102 Exception must not use an f-string literal, assign to variable first
     |
1220 |       return getattr(machine, action_name)(**(params or {}))
1221 |     raise AttributeError(
1222 |       f"Machine for ID {machine_orm_accession_id} (type: {type(machine).__name__}) has no action '{action_name}'.",
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1223 |     )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1229:13: ANN201 Missing return type annotation for public function `shutdown_all_machines`
     |
1227 |     suffix=" - Ensure all machines are properly initialized and connected.",
1228 |   )
1229 |   async def shutdown_all_machines(self):
     |             ^^^^^^^^^^^^^^^^^^^^^ ANN201
1230 |     """Shut down all currently active PyLabRobot machine instances."""
1231 |     logger.info("WorkcellRuntime: Shutting down all active machines...")
     |
     = help: Add return type annotation: `None`

praxis/backend/core/workcell_runtime.py:1239:7: PERF203 `try`-`except` within a loop incurs performance overhead
     |
1237 |           )
1238 |           await self.shutdown_machine(machine_accession_id)
1239 |         except WorkcellRuntimeError as e:
     |  _______^
1240 | |         logger.error(
1241 | |           "WorkcellRuntime: Error shutting down machine ID %s: %s",
1242 | |           machine_accession_id,
1243 | |           str(e),
1244 | |         )
1245 | |         continue
     | |________________^ PERF203
1246 |       logger.info("WorkcellRuntime: All active machines processed for shutdown.")
     |

praxis/backend/core/workcell_runtime.py:1240:9: TRY400 Use `logging.exception` instead of `logging.error`
     |
1238 |           await self.shutdown_machine(machine_accession_id)
1239 |         except WorkcellRuntimeError as e:
1240 |           logger.error(
     |  _________^
1241 | |           "WorkcellRuntime: Error shutting down machine ID %s: %s",
1242 | |           machine_accession_id,
1243 | |           str(e),
1244 | |         )
     | |_________^ TRY400
1245 |           continue
1246 |       logger.info("WorkcellRuntime: All active machines processed for shutdown.")
     |
     = help: Replace with `exception`

praxis/backend/core/workcell_runtime.py:1277:15: TRY003 Avoid specifying long messages outside the exception class
     |
1276 |         if deck_orm is None or not hasattr(deck_orm, "id") or deck_orm.accession_id is None:
1277 |           raise WorkcellRuntimeError(
     |  _______________^
1278 | |           f"Deck ORM ID {deck_orm_accession_id} not found in database.",
1279 | |         )
     | |_________^ TRY003
1280 |   
1281 |         response_positions: list[dict[str, Any]] = []
     |

praxis/backend/core/workcell_runtime.py:1278:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1276 |       if deck_orm is None or not hasattr(deck_orm, "id") or deck_orm.accession_id is None:
1277 |         raise WorkcellRuntimeError(
1278 |           f"Deck ORM ID {deck_orm_accession_id} not found in database.",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1279 |         )
     |
     = help: Assign to variable; remove f-string literal

praxis/backend/core/workcell_runtime.py:1344:16: BLE001 Do not catch blind exception: `Exception`
     |
1342 |         # could raise unexpected errors. A broad catch allows us to log a warning
1343 |         # and continue, rather than crashing the state representation process.
1344 |         except Exception as e:  # pylint: disable=broad-except
     |                ^^^^^^^^^ BLE001
1345 |           logger.warning(
1346 |             "Could not get size from live deck object for ID %s: %s",
     |

praxis/backend/core/workcell_runtime.py:1360:14: RET504 Unnecessary assignment to `deck_state_data` before `return` statement
     |
1358 |         "positions": response_positions,
1359 |       }
1360 |       return deck_state_data
     |              ^^^^^^^^^^^^^^^ RET504
1361 | 
1362 |   async def get_last_initialized_deck_object(self) -> Deck | None:
     |
     = help: Remove unnecessary assignment

praxis/backend/core/workcell_runtime.py:1372:13: ANN201 Missing return type annotation for public function `clear_resource_instance`
     |
1370 |     suffix=" - Ensure the resource is valid and exists in active resources.",
1371 |   )
1372 |   async def clear_resource_instance(self, resource_orm_accession_id: uuid.UUID):
     |             ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1373 |     """Clear a resource from the workcell runtime.
     |
     = help: Add return type annotation: `None`

praxis/backend/models/asset_orm.py:47:21: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   |
45 |   )
46 | 
47 |   __mapper_args__ = {"polymorphic_on": asset_type, "polymorphic_identity": "asset"}
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF012
48 | 
49 |   def __repr__(self):
   |

praxis/backend/models/asset_orm.py:49:7: ANN204 Missing return type annotation for special method `__repr__`
   |
47 |   __mapper_args__ = {"polymorphic_on": asset_type, "polymorphic_identity": "asset"}
48 | 
49 |   def __repr__(self):
   |       ^^^^^^^^ ANN204
50 |     """Render string representation of the Asset."""
51 |     return (
   |
   = help: Add return type annotation: `str`

praxis/backend/models/deck_orm.py:61:21: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   |
60 |   __tablename__ = "decks"
61 |   __mapper_args__ = {"polymorphic_identity": "deck"}
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF012
62 | 
63 |   accession_id: Mapped[uuid.UUID] = mapped_column(
   |

praxis/backend/models/deck_orm.py:83:18: PGH003 Use specific rule codes when ignoring type issues
   |
81 |     UUID,
82 |     ForeignKey("deck_type_definitions.accession_id"),
83 |     index=True,  # type: ignore
   |                  ^^^^^^^^^^^^^^ PGH003
84 |   )
85 |   deck_type: Mapped["DeckTypeDefinitionOrm"] = relationship(
   |

praxis/backend/models/deck_orm.py:212:6: PGH003 Use specific rule codes when ignoring type issues
    |
210 |     ForeignKey("deck_type_definitions.accession_id"),
211 |     index=True,
212 |   )  # type: ignore
    |      ^^^^^^^^^^^^^^ PGH003
213 |   position_accession_id: Mapped[str] = mapped_column(String, nullable=False)
    |

praxis/backend/models/enums.py:1:1: D100 Missing docstring in public module
praxis/backend/models/filters.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """General-purpose Pydantic models for search and filtering criteria across service layers.
2 | | """
  | |___^ D200
3 |   
4 |   from datetime import datetime
  |
  = help: Reformat to one line

praxis/backend/models/filters.py:11:3: D200 One-line docstring should fit on one line
   |
10 |   class SearchFilters(BaseModel):
11 |     """A general-purpose model for search and filtering criteria across service layers.
   |  ___^
12 | |   """
   | |_____^ D200
13 |   
14 |     limit: int = Field(100, ge=1, le=1000, description="Maximum number of results to return.")
   |
   = help: Reformat to one line

praxis/backend/models/filters.py:29:9: D106 Missing docstring in public nested class
   |
27 |   parent_accession_id: UUID7 | None = Field(None, description="Filter by parent asset ID.")
28 | 
29 |   class Config:
   |         ^^^^^^ D106
30 |     from_attributes = True
31 |     use_enum_values = True
   |

praxis/backend/models/function_data_output_orm.py:295:7: ANN204 Missing return type annotation for special method `__repr__`
    |
293 |   )
294 | 
295 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
296 |     """Return a string representation of the FunctionDataOutputOrm instance."""
297 |     return (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/function_data_output_orm.py:380:7: ANN204 Missing return type annotation for special method `__repr__`
    |
378 |   )
379 | 
380 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
381 |     """Return a string representation of the WellDataOutputOrm instance."""
382 |     return f"<WellDataOutputOrm(id={self.accession_id}, well={self.well_name}, value={self.data_value})>"
    |
    = help: Add return type annotation: `str`

praxis/backend/models/function_data_output_pydantic_models.py:133:7: ANN201 Missing return type annotation for public function `validate_data_content`
    |
131 |     "file_path",
132 |   )
133 |   def validate_data_content(cls, v, values):
    |       ^^^^^^^^^^^^^^^^^^^^^ ANN201
134 |     """Ensure at least one data field is provided."""
135 |     data_fields = [
    |
    = help: Add return type annotation

praxis/backend/models/function_data_output_pydantic_models.py:133:29: N805 First argument of a method should be named `self`
    |
131 |     "file_path",
132 |   )
133 |   def validate_data_content(cls, v, values):
    |                             ^^^ N805
134 |     """Ensure at least one data field is provided."""
135 |     data_fields = [
    |
    = help: Rename `cls` to `self`

praxis/backend/models/function_data_output_pydantic_models.py:133:34: ANN001 Missing type annotation for function argument `v`
    |
131 |     "file_path",
132 |   )
133 |   def validate_data_content(cls, v, values):
    |                                  ^ ANN001
134 |     """Ensure at least one data field is provided."""
135 |     data_fields = [
    |

praxis/backend/models/function_data_output_pydantic_models.py:133:37: ANN001 Missing type annotation for function argument `values`
    |
131 |     "file_path",
132 |   )
133 |   def validate_data_content(cls, v, values):
    |                                     ^^^^^^ ANN001
134 |     """Ensure at least one data field is provided."""
135 |     data_fields = [
    |

praxis/backend/models/function_data_output_pydantic_models.py:146:13: TRY003 Avoid specifying long messages outside the exception class
    |
145 |     if non_none_count == 0:
146 |       raise ValueError("At least one data field must be provided")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
147 | 
148 |     return v
    |

praxis/backend/models/function_data_output_pydantic_models.py:146:24: EM101 Exception must not use a string literal, assign to variable first
    |
145 |     if non_none_count == 0:
146 |       raise ValueError("At least one data field must be provided")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
147 | 
148 |     return v
    |
    = help: Assign to variable; remove string literal

praxis/backend/models/function_data_output_pydantic_models.py:286:8: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
284 |     None,
285 |     description="Updated metadata",
286 |   )  # TODO: figure out how to integrate this
    |        ^^^^ TD002
    |

praxis/backend/models/function_data_output_pydantic_models.py:286:8: TD003 Missing issue link on the line following this TODO
    |
284 |     None,
285 |     description="Updated metadata",
286 |   )  # TODO: figure out how to integrate this
    |        ^^^^ TD003
    |

praxis/backend/models/function_data_output_pydantic_models.py:286:8: FIX002 Line contains TODO, consider resolving the issue
    |
284 |     None,
285 |     description="Updated metadata",
286 |   )  # TODO: figure out how to integrate this
    |        ^^^^ FIX002
    |

praxis/backend/models/function_data_output_pydantic_models.py:372:34: FBT003 Boolean positional value in function call
    |
370 |   export_format: str = Field(..., description="Export format (csv, json, xlsx, etc.)")
371 | 
372 |   include_metadata: bool = Field(True, description="Whether to include metadata")
    |                                  ^^^^ FBT003
373 | 
374 |   include_spatial_info: bool = Field(
    |

praxis/backend/models/function_data_output_pydantic_models.py:375:5: FBT003 Boolean positional value in function call
    |
374 |   include_spatial_info: bool = Field(
375 |     True,
    |     ^^^^ FBT003
376 |     description="Whether to include spatial information",
377 |   )
    |

praxis/backend/models/function_data_output_pydantic_models.py:380:5: FBT003 Boolean positional value in function call
    |
379 |   flatten_structure: bool = Field(
380 |     False,
    |     ^^^^^ FBT003
381 |     description="Whether to flatten hierarchical data",
382 |   )
    |

praxis/backend/models/machine_orm.py:37:48: TCH001 Move application import `praxis.backend.models.workcell_orm.WorkcellOrm` into a type-checking block
   |
35 | from praxis.backend.models.asset_orm import Asset
36 | from praxis.backend.models.enums import AssetType
37 | from praxis.backend.models.workcell_orm import WorkcellOrm
   |                                                ^^^^^^^^^^^ TCH001
   |
   = help: Move into type-checking block

praxis/backend/models/machine_orm.py:78:7: ANN206 Missing return type annotation for classmethod `resources`
   |
77 |   @classmethod
78 |   def resources(cls):
   |       ^^^^^^^^^ ANN206
79 |     """Return a list of resource categories that map to this enum."""
80 |     return [
   |
   = help: Add return type annotation

praxis/backend/models/machine_orm.py:104:21: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
    |
103 |   __tablename__ = "machines"
104 |   __mapper_args__ = {"polymorphic_identity": AssetType.MACHINE}
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF012
105 | 
106 |   accession_id: Mapped[uuid.UUID] = mapped_column(
    |

praxis/backend/models/machine_orm.py:183:8: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
181 |     UUID(as_uuid=True),
182 |     nullable=True,
183 |   )  # TODO: Add ForeignKey to protocol_runs
    |        ^^^^ TD002
184 | 
185 |   def __repr__(self):
    |

praxis/backend/models/machine_orm.py:183:8: TD003 Missing issue link on the line following this TODO
    |
181 |     UUID(as_uuid=True),
182 |     nullable=True,
183 |   )  # TODO: Add ForeignKey to protocol_runs
    |        ^^^^ TD003
184 | 
185 |   def __repr__(self):
    |

praxis/backend/models/machine_orm.py:183:8: FIX002 Line contains TODO, consider resolving the issue
    |
181 |     UUID(as_uuid=True),
182 |     nullable=True,
183 |   )  # TODO: Add ForeignKey to protocol_runs
    |        ^^^^ FIX002
184 | 
185 |   def __repr__(self):
    |

praxis/backend/models/machine_orm.py:185:7: ANN204 Missing return type annotation for special method `__repr__`
    |
183 |   )  # TODO: Add ForeignKey to protocol_runs
184 | 
185 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
186 |     """Return a string representation of the MachineOrm object."""
187 |     return (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:102:7: ANN204 Missing return type annotation for special method `__repr__`
    |
100 |   )
101 | 
102 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
103 |     """Return a string representation of the ProtocolSourceRepositoryOrm instance."""
104 |     return f"<ProtocolSourceRepositoryOrm(id={self.accession_id}, name='{self.name}', \
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:135:7: ANN204 Missing return type annotation for special method `__repr__`
    |
133 |   )
134 | 
135 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
136 |     """Return a string representation of the FileSystemProtocolSourceOrm instance."""
137 |     return (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:228:7: ANN204 Missing return type annotation for special method `__repr__`
    |
226 |   )
227 | 
228 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
229 |     """Return a string representation of the FunctionProtocolDefinitionOrm instance."""
230 |     return f"<FunctionProtocolDefinitionOrm(id={self.accession_id}, name='{self.name}',\
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:267:7: ANN204 Missing return type annotation for special method `__repr__`
    |
265 |   )
266 | 
267 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
268 |     """Return a string representation of the ParameterDefinitionOrm instance."""
269 |     return f"<ParameterDefinitionOrm(name='{self.name}', \
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:300:5: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
298 |     "FunctionProtocolDefinitionOrm", back_populates="asset_requirements",
299 |   )
300 |   # TODO: link to resource and machine definitions if needed
    |     ^^^^ TD002
301 | 
302 |   __table_args__ = (
    |

praxis/backend/models/protocol_definitions_orm.py:300:5: TD003 Missing issue link on the line following this TODO
    |
298 |     "FunctionProtocolDefinitionOrm", back_populates="asset_requirements",
299 |   )
300 |   # TODO: link to resource and machine definitions if needed
    |     ^^^^ TD003
301 | 
302 |   __table_args__ = (
    |

praxis/backend/models/protocol_definitions_orm.py:300:5: FIX002 Line contains TODO, consider resolving the issue
    |
298 |     "FunctionProtocolDefinitionOrm", back_populates="asset_requirements",
299 |   )
300 |   # TODO: link to resource and machine definitions if needed
    |     ^^^^ FIX002
301 | 
302 |   __table_args__ = (
    |

praxis/backend/models/protocol_definitions_orm.py:310:7: ANN204 Missing return type annotation for special method `__repr__`
    |
308 |   )
309 | 
310 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
311 |     """Return a string representation of the AssetDefinitionOrm instance."""
312 |     return f"<AssetDefinitionOrm(name='{self.name}', \
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:372:7: ANN204 Missing return type annotation for special method `__repr__`
    |
370 |   )
371 | 
372 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
373 |     """Return a string representation of the ProtocolRunOrm instance."""
374 |     return (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_definitions_orm.py:430:7: ANN204 Missing return type annotation for special method `__repr__`
    |
428 |   )
429 | 
430 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
431 |     """Return a string representation of the FunctionCallLogOrm instance."""
432 |     return (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/protocol_pydantic_models.py:192:7: ANN204 Missing return type annotation for special method `__init__`
    |
190 |   """
191 | 
192 |   def __init__(
    |       ^^^^^^^^ ANN204
193 |     self,
194 |     asset_definition: AssetRequirementModel,  # The static asset definition
    |
    = help: Add return type annotation: `None`

praxis/backend/models/resource_orm.py:244:7: ANN204 Missing return type annotation for special method `__repr__`
    |
242 |   is_machine: Mapped[bool] = mapped_column(Boolean, default=False)
243 | 
244 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
245 |     """Return a string representation of the ResourceDefinitionOrm object."""
246 |     return f"<ResourceDefinitionOrm(name='{self.name}', category='{self.plr_category}')>"
    |
    = help: Add return type annotation: `str`

praxis/backend/models/resource_orm.py:258:21: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
    |
257 |   __tablename__ = "resources"
258 |   __mapper_args__ = {"polymorphic_identity": "resource"}
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF012
259 | 
260 |   accession_id: Mapped[uuid.UUID] = mapped_column(
    |

praxis/backend/models/resource_orm.py:329:7: ANN204 Missing return type annotation for special method `__repr__`
    |
327 |   )
328 | 
329 |   def __repr__(self):
    |       ^^^^^^^^ ANN204
330 |     """Return a string representation of the ResourceOrm object."""
331 |     fqn = (
    |
    = help: Add return type annotation: `str`

praxis/backend/models/resource_orm.py:332:37: PGH003 Use specific rule codes when ignoring type issues
    |
330 |     """Return a string representation of the ResourceOrm object."""
331 |     fqn = (
332 |       self.resource_definition.fqn  # type: ignore
    |                                     ^^^^^^^^^^^^^^ PGH003
333 |       if self.resource_definition and hasattr(self.resource_definition, "fqn")
334 |       else "N/A"
    |

praxis/backend/models/resource_pydantic_models.py:85:40: RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   |
84 |   parent: Optional["ResourceResponse"] = None
85 |   children: list["ResourceResponse"] = []
   |                                        ^^ RUF012
86 | 
87 |   class Config(AssetResponse.Config, ResourceBase.Config):
   |

praxis/backend/models/scheduler_orm.py:375:1: ERA001 Found commented-out code
    |
374 | # In ProtocolRunOrm:
375 | # schedule_entry = relationship("ScheduleEntryOrm", back_populates="protocol_run", uselist=False)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
376 | 
377 | # In AssetOrm:
    |
    = help: Remove commented-out code

praxis/backend/models/scheduler_orm.py:378:1: ERA001 Found commented-out code
    |
377 | # In AssetOrm:
378 | # asset_reservations = relationship("AssetReservationOrm", foreign_keys="AssetReservationOrm.asset_instance_accession_id")
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
379 | 
380 | # In MachineOrm:
    |
    = help: Remove commented-out code

praxis/backend/models/scheduler_orm.py:378:121: E501 Line too long (122 > 120)
    |
377 | # In AssetOrm:
378 | # asset_reservations = relationship("AssetReservationOrm", foreign_keys="AssetReservationOrm.asset_instance_accession_id")
    |                                                                                                                         ^^ E501
379 | 
380 | # In MachineOrm:
    |

praxis/backend/models/scheduler_orm.py:381:1: ERA001 Found commented-out code
    |
380 | # In MachineOrm:
381 | # asset_reservations = relationship("AssetReservationOrm", foreign_keys="AssetReservationOrm.machine_accession_id")
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
    |
    = help: Remove commented-out code

praxis/backend/models/user_management_orm.py:51:7: ANN204 Missing return type annotation for special method `__repr__`
   |
49 |   )
50 | 
51 |   def __repr__(self):
   |       ^^^^^^^^ ANN204
52 |     """Return a string representation of the UserOrm object."""
53 |     return (
   |
   = help: Add return type annotation: `str`

praxis/backend/models/workcell_orm.py:33:7: ANN206 Missing return type annotation for classmethod `choices`
   |
32 |   @classmethod
33 |   def choices(cls):
   |       ^^^^^^^ ANN206
34 |     """Return a list of valid status choices."""
35 |     return [
   |
   = help: Add return type annotation

praxis/backend/models/workcell_orm.py:88:7: ANN204 Missing return type annotation for special method `__repr__`
   |
86 |   )
87 | 
88 |   def __repr__(self):
   |       ^^^^^^^^ ANN204
89 |     """Return a string representation of the WorkcellOrm object."""
90 |     return (
   |
   = help: Add return type annotation: `str`

praxis/backend/services/deck.py:35:5: D200 One-line docstring should fit on one line
   |
34 |   class DeckService(CRUDBase[DeckOrm, DeckCreate, DeckUpdate]):
35 |       """Service for deck-related operations.
   |  _____^
36 | |     """
   | |_______^ D200
37 |   
38 |       async def create(self, db: AsyncSession, *, obj_in: DeckCreate) -> DeckOrm:
   |
   = help: Reformat to one line

praxis/backend/services/deck.py:74:19: TRY201 Use `raise` without specifying exception name
   |
72 |             )
73 |             await db.rollback()
74 |             raise e
   |                   ^ TRY201
75 | 
76 |         return deck_orm
   |
   = help: Remove exception name

praxis/backend/services/deck.py:78:43: A002 Argument `id` is shadowing a Python builtin
   |
76 |         return deck_orm
77 | 
78 |     async def get(self, db: AsyncSession, id: UUID) -> DeckOrm | None:
   |                                           ^^ A002
79 |         """Retrieve a specific deck by its ID."""
80 |         logger.info("Attempting to retrieve deck with ID: %s.", id)
   |

praxis/backend/services/deck.py:193:19: TRY201 Use `raise` without specifying exception name
    |
191 |                 db_obj.accession_id,
192 |             )
193 |             raise e
    |                   ^ TRY201
194 | 
195 |     async def remove(self, db: AsyncSession, *, id: UUID) -> bool:
    |
    = help: Remove exception name

praxis/backend/services/deck.py:195:49: A002 Argument `id` is shadowing a Python builtin
    |
193 |             raise e
194 | 
195 |     async def remove(self, db: AsyncSession, *, id: UUID) -> bool:
    |                                                 ^^ A002
196 |         """Delete a specific deck by its ID."""
197 |         logger.info("Attempting to delete deck with ID: %s.", id)
    |

praxis/backend/services/deck.py:211:13: TRY300 Consider moving this statement to an `else` block
    |
209 |                 deck_orm.name,
210 |             )
211 |             return True
    |             ^^^^^^^^^^^ TRY300
212 |         except IntegrityError as e:
213 |             await db.rollback()
    |

praxis/backend/services/deck.py:226:19: TRY201 Use `raise` without specifying exception name
    |
224 |                 id,
225 |             )
226 |             raise e
    |                   ^ TRY201
227 | 
228 |     async def get_all_decks(self, db: AsyncSession) -> list[DeckOrm]:
    |
    = help: Remove exception name

praxis/backend/services/deck_position.py:1:1: D100 Missing docstring in public module
praxis/backend/services/deck_position.py:66:21: ISC001 Implicitly concatenated string literals on one line
   |
65 |   if not deck_orm:
66 |     error_message = f"DeckOrm with id {deck_accession_id} not found. " "Cannot create position item."
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
67 |     logger.error(error_message)
68 |     raise ValueError(error_message)
   |
   = help: Combine string literals

praxis/backend/services/deck_position.py:78:23: ISC001 Implicitly concatenated string literals on one line
   |
76 |     )
77 |     if not resource_instance_result.scalar_one_or_none():
78 |       error_message = f"ResourceOrm with id {resource_instance_accession_id} not found. " "Cannot create position item."
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
79 |       logger.error(error_message)
80 |       raise ValueError(error_message)
   |
   = help: Combine string literals

praxis/backend/services/deck_position.py:83:3: SIM102 Use a single `if` statement instead of nested `if` statements
   |
82 |     # Validate expected resource definition if provided
83 |     if expected_resource_definition_name is not None:
   |  ___^
84 | |     if not await read_resource_definition(db, expected_resource_definition_name):
   | |_________________________________________________________________________________^ SIM102
85 |         error_message = (
86 |           f"ResourceDefinitionOrm with name '{expected_resource_definition_name}' "
   |
   = help: Combine `if` statements using `and`

praxis/backend/services/deck_position.py:109:5: TRY300 Consider moving this statement to an `else` block
    |
107 |       deck_accession_id,
108 |     )
109 |     return position_item
    |     ^^^^^^^^^^^^^^^^^^^^ TRY300
110 |   except IntegrityError as e:
111 |     await db.rollback()
    |

praxis/backend/services/deck_position.py:115:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
113 |       f"Integrity error creating position item '{name}' to deck instance ID {deck_accession_id}. Details: {e}"
114 |     )
115 |     logger.error(error_message)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
116 |     return None
    |
    = help: Replace with `exception`

praxis/backend/services/deck_position.py:219:23: ISC001 Implicitly concatenated string literals on one line
    |
217 |     )
218 |     if not resource_instance_result.scalar_one_or_none():
219 |       error_message = f"ResourceOrm with id {resource_instance_accession_id} not found. " "Cannot update position item."
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
220 |       logger.error(error_message)
221 |       raise ValueError(error_message)
    |
    = help: Combine string literals

praxis/backend/services/deck_position.py:249:5: TRY300 Consider moving this statement to an `else` block
    |
247 |     await db.refresh(position_item)  # Refresh to get the latest state
248 |     logger.info("Successfully updated position item ID %s.", position_item_accession_id)
249 |     return position_item
    |     ^^^^^^^^^^^^^^^^^^^^ TRY300
250 |   except IntegrityError as e:
251 |     await db.rollback()
    |

praxis/backend/services/deck_position.py:253:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
251 |     await db.rollback()
252 |     error_message = f"Integrity error updating position item ID {position_item_accession_id}. Details: {e}"
253 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
254 |     return None
    |

praxis/backend/services/deck_position.py:292:5: TRY300 Consider moving this statement to an `else` block
    |
290 |     await db.commit()
291 |     logger.info("Successfully deleted position item ID %s.", position_item_accession_id)
292 |     return True
    |     ^^^^^^^^^^^ TRY300
293 |   except IntegrityError as e:
294 |     await db.rollback()
    |

praxis/backend/services/deck_position.py:299:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
297 |       f"This might be due to foreign key constraints. Details: {e}"
298 |     )
299 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
300 |     return False  # Return False as deletion failed due to integrity
301 |   except Exception as e:
    |

praxis/backend/services/deck_position.py:307:11: TRY201 Use `raise` without specifying exception name
    |
305 |       position_item_accession_id,
306 |     )
307 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/deck_position.py:310:11: C901 `_process_position_definitions` is too complex (11 > 10)
    |
310 | async def _process_position_definitions(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
311 |   db: AsyncSession,
312 |   deck_type_orm: DeckTypeDefinitionOrm,
    |

praxis/backend/services/deck_position.py:310:11: ANN202 Missing return type annotation for private function `_process_position_definitions`
    |
310 | async def _process_position_definitions(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
311 |   db: AsyncSession,
312 |   deck_type_orm: DeckTypeDefinitionOrm,
    |
    = help: Add return type annotation: `None`

praxis/backend/services/deck_position.py:316:3: D205 1 blank line required between summary line and description
    |
314 |     log_prefix: str,
315 |   ):
316 |     """Helper function to handle the deletion and creation of position definitions.
    |  ___^
317 | |   This logic is common to both create and update.
318 | |   """
    | |_____^ D205
319 |     if position_definitions_data is not None:
320 |       logger.info(
    |
    = help: Insert single blank line

praxis/backend/services/deck_position.py:316:3: D401 First line of docstring should be in imperative mood: "Helper function to handle the deletion and creation of position definitions."
    |
314 |     log_prefix: str,
315 |   ):
316 |     """Helper function to handle the deletion and creation of position definitions.
    |  ___^
317 | |   This logic is common to both create and update.
318 | |   """
    | |_____^ D401
319 |     if position_definitions_data is not None:
320 |       logger.info(
    |

praxis/backend/services/deck_position.py:363:51: PGH003 Use specific rule codes when ignoring type issues
    |
362 |       new_position = DeckPositionDefinitionOrm(
363 |         deck_type_id=deck_type_orm.accession_id,  # type: ignore
    |                                                   ^^^^^^^^^^^^^^ PGH003
364 |         name=name,
365 |         nominal_x_mm=position_data.get("location_x_mm"),
    |

praxis/backend/services/deck_position.py:376:11: C901 `create_deck_position_definitions` is too complex (13 > 10)
    |
376 | async def create_deck_position_definitions(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
377 |   db: AsyncSession,
378 |   deck_type_id: uuid.UUID,
    |

praxis/backend/services/deck_position.py:434:7: ISC001 Implicitly concatenated string literals on one line
    |
432 |   if not deck_type_orm:
433 |     error_message = (
434 |       f"{log_prefix} DeckTypeDefinitionOrm with id {deck_type_id} not found." " Cannot create position definitions."
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
435 |     )
436 |     logger.error(error_message)
    |
    = help: Combine string literals

praxis/backend/services/deck_position.py:499:14: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
497 |         f"position name conflict or other integrity constraint. Details: {e}"
498 |       )
499 |       logger.error(error_message, exc_info=True)
    |              ^^^^^ G201
500 |       raise ValueError(error_message) from e
501 |     error_message = f"{log_prefix} Database integrity error while creating position "
    |

praxis/backend/services/deck_position.py:503:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
501 |     error_message = f"{log_prefix} Database integrity error while creating position "
502 |     f"definitions. Details: {e}"
503 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
504 |     raise ValueError(error_message) from e
505 |   except Exception as e:
    |

praxis/backend/services/deck_position.py:511:11: TRY201 Use `raise` without specifying exception name
    |
509 |       log_prefix,
510 |     )
511 |     raise e
    |           ^ TRY201
512 | 
513 |   return created_positions
    |
    = help: Remove exception name

praxis/backend/services/deck_position.py:516:11: C901 `update_deck_position_definition` is too complex (15 > 10)
    |
516 | async def update_deck_position_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
517 |   db: AsyncSession,
518 |   deck_type_id: uuid.UUID,
    |

praxis/backend/services/deck_position.py:516:11: PLR0913 Too many arguments in function definition (13 > 5)
    |
516 | async def update_deck_position_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
517 |   db: AsyncSession,
518 |   deck_type_id: uuid.UUID,
    |

praxis/backend/services/deck_position.py:516:11: PLR0912 Too many branches (14 > 12)
    |
516 | async def update_deck_position_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
517 |   db: AsyncSession,
518 |   deck_type_id: uuid.UUID,
    |

praxis/backend/services/deck_position.py:516:11: PLR0915 Too many statements (52 > 50)
    |
516 | async def update_deck_position_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
517 |   db: AsyncSession,
518 |   deck_type_id: uuid.UUID,
    |

praxis/backend/services/deck_position.py:624:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
622 |       f"This might occur if a unique constraint is violated. Details: {e}"
623 |     )
624 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
625 |     raise ValueError(error_message) from e
626 |   except Exception as e:
    |

praxis/backend/services/deck_position.py:629:11: TRY201 Use `raise` without specifying exception name
    |
627 |     await db.rollback()
628 |     logger.exception("%s Unexpected error during update. Rolling back.", log_prefix)
629 |     raise e
    |           ^ TRY201
630 | 
631 |   logger.info("%s Update operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/deck_position.py:685:11: TRY201 Use `raise` without specifying exception name
    |
683 |     await db.rollback()
684 |     logger.exception("%s Unexpected error during deletion. Rolling back.", log_prefix)
685 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/deck_position.py:717:21: ISC001 Implicitly concatenated string literals on one line
    |
715 |   )
716 |   if not deck_type_exists_result.scalar_one_or_none():
717 |     error_message = f"DeckTypeDefinitionOrm with id {deck_type_id} not found. " "Cannot retrieve position definitions."
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
718 |     logger.error(error_message)
719 |     raise ValueError(error_message)
    |
    = help: Combine string literals

praxis/backend/services/deck_type_definition.py:36:11: C901 `_process_position_definitions` is too complex (13 > 10)
   |
36 | async def _process_position_definitions(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
37 |   db: AsyncSession,
38 |   deck_type_orm: DeckTypeDefinitionOrm,
   |

praxis/backend/services/deck_type_definition.py:36:11: ANN202 Missing return type annotation for private function `_process_position_definitions`
   |
36 | async def _process_position_definitions(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
37 |   db: AsyncSession,
38 |   deck_type_orm: DeckTypeDefinitionOrm,
   |
   = help: Add return type annotation: `None`

praxis/backend/services/deck_type_definition.py:134:11: PLR0913 Too many arguments in function definition (11 > 5)
    |
134 | async def create_deck_type_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
135 |   db: AsyncSession,
136 |   fqn: str,
    |

praxis/backend/services/deck_type_definition.py:229:5: TRY300 Consider moving this statement to an `else` block
    |
227 |       deck_type_orm.accession_id,
228 |     )
229 |     return deck_type_orm
    |     ^^^^^^^^^^^^^^^^^^^^ TRY300
230 |   except IntegrityError as e:
231 |     await db.rollback()
    |

praxis/backend/services/deck_type_definition.py:239:11: TRY201 Use `raise` without specifying exception name
    |
237 |     error_message = f"{log_prefix} Unexpected error creating deck type. Rolling back."
238 |     logger.exception(error_message)
239 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/deck_type_definition.py:242:11: C901 `update_deck_type_definition` is too complex (16 > 10)
    |
242 | async def update_deck_type_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
243 |   db: AsyncSession,
244 |   deck_type_accession_id: UUID,
    |

praxis/backend/services/deck_type_definition.py:242:11: PLR0913 Too many arguments in function definition (18 > 5)
    |
242 | async def update_deck_type_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
243 |   db: AsyncSession,
244 |   deck_type_accession_id: UUID,
    |

praxis/backend/services/deck_type_definition.py:242:11: PLR0912 Too many branches (16 > 12)
    |
242 | async def update_deck_type_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
243 |   db: AsyncSession,
244 |   deck_type_accession_id: UUID,
    |

praxis/backend/services/deck_type_definition.py:242:11: PLR0915 Too many statements (80 > 50)
    |
242 | async def update_deck_type_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
243 |   db: AsyncSession,
244 |   deck_type_accession_id: UUID,
    |

praxis/backend/services/deck_type_definition.py:383:11: TRY201 Use `raise` without specifying exception name
    |
381 |     await db.rollback()
382 |     logger.exception("%s Unexpected error during update. Rolling back.", log_prefix)
383 |     raise e
    |           ^ TRY201
384 | 
385 |   logger.info("%s Update operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/deck_type_definition.py:495:11: TRY201 Use `raise` without specifying exception name
    |
493 |     await db.rollback()
494 |     logger.exception("%s Unexpected error during deletion. Rolling back.", log_prefix)
495 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/discovery_service.py:76:7: C901 `_extract_protocol_definitions_from_paths` is too complex (19 > 10)
   |
74 |     self.db_session_factory = db_session_factory
75 | 
76 |   def _extract_protocol_definitions_from_paths(
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
77 |     self,
78 |     search_paths: str | list[str],
   |

praxis/backend/services/discovery_service.py:76:7: PLR0912 Too many branches (21 > 12)
   |
74 |     self.db_session_factory = db_session_factory
75 | 
76 |   def _extract_protocol_definitions_from_paths(
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
77 |     self,
78 |     search_paths: str | list[str],
   |

praxis/backend/services/discovery_service.py:76:7: PLR0915 Too many statements (61 > 50)
   |
74 |     self.db_session_factory = db_session_factory
75 | 
76 |   def _extract_protocol_definitions_from_paths(
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0915
77 |     self,
78 |     search_paths: str | list[str],
   |

praxis/backend/services/discovery_service.py:113:96: PGH003 Use specific rule codes when ignoring type issues
    |
111 |       search_paths = [search_paths]
112 | 
113 |     extracted_definitions: list[tuple[FunctionProtocolDefinitionModel, Callable | None]] = []  # type: ignore
    |                                                                                                ^^^^^^^^^^^^^^ PGH003
114 |     processed_func_accession_ids: set[int] = set()
115 |     loaded_module_names: set[str] = set()
    |

praxis/backend/services/discovery_service.py:119:23: PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
    |
118 |     for path_item in search_paths:
119 |       abs_path_item = os.path.abspath(path_item)
    |                       ^^^^^^^^^^^^^^^ PTH100
120 |       if not os.path.isdir(abs_path_item):
121 |         print(f"Warning: Search path '{abs_path_item}' is not a directory. Skipping.")
    |

praxis/backend/services/discovery_service.py:120:14: PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
    |
118 |     for path_item in search_paths:
119 |       abs_path_item = os.path.abspath(path_item)
120 |       if not os.path.isdir(abs_path_item):
    |              ^^^^^^^^^^^^^ PTH112
121 |         print(f"Warning: Search path '{abs_path_item}' is not a directory. Skipping.")
122 |         continue
    |

praxis/backend/services/discovery_service.py:121:9: T201 `print` found
    |
119 |       abs_path_item = os.path.abspath(path_item)
120 |       if not os.path.isdir(abs_path_item):
121 |         print(f"Warning: Search path '{abs_path_item}' is not a directory. Skipping.")
    |         ^^^^^ T201
122 |         continue
    |
    = help: Remove `print`

praxis/backend/services/discovery_service.py:124:34: PTH120 `os.path.dirname()` should be replaced by `Path.parent`
    |
122 |         continue
123 | 
124 |       potential_package_parent = os.path.dirname(abs_path_item)
    |                                  ^^^^^^^^^^^^^^^ PTH120
125 |       path_added_to_sys = False
126 |       if potential_package_parent not in sys.path:
    |

praxis/backend/services/discovery_service.py:133:32: PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    |
131 |         for file in files:
132 |           if file.endswith(".py") and not file.startswith("_"):
133 |             module_file_path = os.path.join(root, file)
    |                                ^^^^^^^^^^^^ PTH118
134 |             rel_module_path = os.path.relpath(
135 |               module_file_path,
    |

praxis/backend/services/discovery_service.py:138:34: PTH122 `os.path.splitext()` should be replaced by `Path.suffix`, `Path.stem`, and `Path.parent`
    |
136 |               potential_package_parent,
137 |             )
138 |             module_import_name = os.path.splitext(rel_module_path)[0].replace(
    |                                  ^^^^^^^^^^^^^^^^ PTH122
139 |               os.sep,
140 |               ".",
    |

praxis/backend/services/discovery_service.py:151:19: B007 Loop control variable `name` not used within loop body
    |
149 |               loaded_module_names.add(module_import_name)
150 | 
151 |               for name, func_obj in inspect.getmembers(module, inspect.isfunction):
    |                   ^^^^ B007
152 |                 if func_obj.__module__ != module_import_name:
153 |                   continue
    |
    = help: Rename unused `name` to `_name`

praxis/backend/services/discovery_service.py:206:46: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
205 |                   inferred_model = FunctionProtocolDefinitionModel(
206 |                     accession_id=uuid7(),  # TODO: ensure that if a reinspection happens it is assigned the already existing
    |                                              ^^^^ TD002
207 |                     name=func_obj.__name__,
208 |                     version="0.0.0-inferred",
    |

praxis/backend/services/discovery_service.py:206:46: TD003 Missing issue link on the line following this TODO
    |
205 |                   inferred_model = FunctionProtocolDefinitionModel(
206 |                     accession_id=uuid7(),  # TODO: ensure that if a reinspection happens it is assigned the already existing
    |                                              ^^^^ TD003
207 |                     name=func_obj.__name__,
208 |                     version="0.0.0-inferred",
    |

praxis/backend/services/discovery_service.py:206:46: FIX002 Line contains TODO, consider resolving the issue
    |
205 |                   inferred_model = FunctionProtocolDefinitionModel(
206 |                     accession_id=uuid7(),  # TODO: ensure that if a reinspection happens it is assigned the already existing
    |                                              ^^^^ FIX002
207 |                     name=func_obj.__name__,
208 |                     version="0.0.0-inferred",
    |

praxis/backend/services/discovery_service.py:206:121: E501 Line too long (124 > 120)
    |
205 |                   inferred_model = FunctionProtocolDefinitionModel(
206 |                     accession_id=uuid7(),  # TODO: ensure that if a reinspection happens it is assigned the already existing
    |                                                                                                                         ^^^^ E501
207 |                     name=func_obj.__name__,
208 |                     version="0.0.0-inferred",
    |

praxis/backend/services/discovery_service.py:218:20: BLE001 Do not catch blind exception: `Exception`
    |
216 |                   )
217 |                   extracted_definitions.append((inferred_model, func_obj))
218 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
219 |               logger.error(
220 |                 f"DiscoveryService: Could not import/process module "
    |

praxis/backend/services/discovery_service.py:219:15: TRY400 Use `logging.exception` instead of `logging.error`
    |
217 |                     extracted_definitions.append((inferred_model, func_obj))
218 |               except Exception as e:
219 |                 logger.error(
    |  _______________^
220 | |                 f"DiscoveryService: Could not import/process module "
221 | |                 f"'{module_import_name}' from '{module_file_path}': {e}",
222 | |               )
    | |_______________^ TRY400
223 |                 traceback.print_exc()
224 |         if path_added_to_sys and potential_package_parent in sys.path:
    |
    = help: Replace with `exception`

praxis/backend/services/discovery_service.py:220:17: G004 Logging statement uses f-string
    |
218 |               except Exception as e:
219 |                 logger.error(
220 |                   f"DiscoveryService: Could not import/process module "
    |  _________________^
221 | |                 f"'{module_import_name}' from '{module_file_path}': {e}",
    | |________________________________________________________________________^ G004
222 |                 )
223 |                 traceback.print_exc()
    |

praxis/backend/services/discovery_service.py:229:13: C901 `discover_and_upsert_protocols` is too complex (12 > 10)
    |
227 |     return extracted_definitions
228 | 
229 |   async def discover_and_upsert_protocols(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
230 |     self,
231 |     search_paths: str | list[str],  # Re-added search_paths argument
    |

praxis/backend/services/discovery_service.py:267:7: G004 Logging statement uses f-string
    |
266 |     logger.info(
267 |       f"DiscoveryService: Starting protocol discovery in paths: {search_paths}...",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
268 |     )
269 |     extracted_definitions = self._extract_protocol_definitions_from_paths(search_paths)
    |

praxis/backend/services/discovery_service.py:276:7: G004 Logging statement uses f-string
    |
275 |     logger.info(
276 |       f"DiscoveryService: Found {len(extracted_definitions)} protocol functions. Upserting to DB...",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
277 |     )
278 |     upserted_definitions_orm: list[Any] = []
    |

praxis/backend/services/discovery_service.py:284:17: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
282 |         protocol_name_for_error = protocol_pydantic_model.name
283 |         protocol_version_for_error = protocol_pydantic_model.version
284 |         try:  # TODO: have these pull from the protocol database  ORM
    |                 ^^^^ TD002
285 |           if source_repository_accession_id and commit_hash:
286 |             protocol_pydantic_model.source_repository_name = str(
    |

praxis/backend/services/discovery_service.py:284:17: TD003 Missing issue link on the line following this TODO
    |
282 |         protocol_name_for_error = protocol_pydantic_model.name
283 |         protocol_version_for_error = protocol_pydantic_model.version
284 |         try:  # TODO: have these pull from the protocol database  ORM
    |                 ^^^^ TD003
285 |           if source_repository_accession_id and commit_hash:
286 |             protocol_pydantic_model.source_repository_name = str(
    |

praxis/backend/services/discovery_service.py:284:17: FIX002 Line contains TODO, consider resolving the issue
    |
282 |         protocol_name_for_error = protocol_pydantic_model.name
283 |         protocol_version_for_error = protocol_pydantic_model.version
284 |         try:  # TODO: have these pull from the protocol database  ORM
    |                 ^^^^ FIX002
285 |           if source_repository_accession_id and commit_hash:
286 |             protocol_pydantic_model.source_repository_name = str(
    |

praxis/backend/services/discovery_service.py:307:11: SIM102 Use a single `if` statement instead of nested `if` statements
    |
306 |             func_ref_protocol_def = getattr(func_ref, "_protocol_definition", None)
307 |             if func_ref and func_ref_protocol_def is protocol_pydantic_model:
    |  ___________^
308 | |             if hasattr(def_orm, "id") and def_orm.accession_id is not None:
    | |___________________________________________________________________________^ SIM102
309 |                 func_ref_protocol_def.db_accession_id = def_orm.accession_id
    |
    = help: Combine `if` statements using `and`

praxis/backend/services/discovery_service.py:316:18: PGH003 Use specific rule codes when ignoring type issues
    |
314 |               pydantic_def_in_registry = PROTOCOL_REGISTRY[protocol_unique_key].get(
315 |                 "pydantic_definition",
316 |               )  # type: ignore
    |                  ^^^^^^^^^^^^^^ PGH003
317 |               if pydantic_def_in_registry and isinstance(
318 |                 pydantic_def_in_registry,
    |

praxis/backend/services/discovery_service.py:324:17: G004 Logging statement uses f-string
    |
322 |               else:
323 |                 logger.warning(
324 |                   f"DiscoveryService: Upserted ORM object for '{protocol_unique_key}' has"
    |  _________________^
325 | |                 f" no 'id'. Cannot update PROTOCOL_REGISTRY.",
    | |_____________________________________________________________^ G004
326 |                 )
    |

praxis/backend/services/discovery_service.py:328:16: BLE001 Do not catch blind exception: `Exception`
    |
326 |               )
327 | 
328 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
329 |           logger.error(
330 |             f"ERROR: Failed to process or upsert protocol '{protocol_name_for_error} "
    |

praxis/backend/services/discovery_service.py:329:11: TRY400 Use `logging.exception` instead of `logging.error`
    |
328 |           except Exception as e:
329 |             logger.error(
    |  ___________^
330 | |             f"ERROR: Failed to process or upsert protocol '{protocol_name_for_error} "
331 | |             f"v{protocol_version_for_error}': {e}",
332 | |           )
    | |___________^ TRY400
333 |             traceback.print_exc()
334 |         # Commit happens when the session context manager exits if no exceptions
    |
    = help: Replace with `exception`

praxis/backend/services/discovery_service.py:330:13: G004 Logging statement uses f-string
    |
328 |           except Exception as e:
329 |             logger.error(
330 |               f"ERROR: Failed to process or upsert protocol '{protocol_name_for_error} "
    |  _____________^
331 | |             f"v{protocol_version_for_error}': {e}",
    | |__________________________________________________^ G004
332 |             )
333 |             traceback.print_exc()
    |

praxis/backend/services/discovery_service.py:340:7: G004 Logging statement uses f-string
    |
338 |     )
339 |     logger.info(
340 |       f"Successfully upserted {num_successful_upserts} protocol definition(s) to DB.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
341 |     )
342 |     return upserted_definitions_orm
    |

praxis/backend/services/entity_linking.py:1:1: D100 Missing docstring in public module
praxis/backend/services/entity_linking.py:52:11: TRY003 Avoid specifying long messages outside the exception class
   |
50 |     definition = result.scalar_one_or_none()
51 |     if not definition:
52 |       raise ValueError(
   |  ___________^
53 | |       f"Resource definition '{name}' not found. Cannot create resource instance.",
54 | |     )
   | |_____^ TRY003
55 |     return definition
   |

praxis/backend/services/entity_linking.py:53:7: EM102 Exception must not use an f-string literal, assign to variable first
   |
51 |   if not definition:
52 |     raise ValueError(
53 |       f"Resource definition '{name}' not found. Cannot create resource instance.",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
54 |     )
55 |   return definition
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/services/entity_linking.py:62:11: C901 `_create_or_link_resource_counterpart_for_machine` is too complex (11 > 10)
   |
60 |   suffix=" Please ensure the parameters are correct and the resource definition exists.",
61 | )
62 | async def _create_or_link_resource_counterpart_for_machine(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
63 |   db: AsyncSession,
64 |   machine_orm: "MachineOrm",
   |

praxis/backend/services/entity_linking.py:62:11: PLR0913 Too many arguments in function definition (7 > 5)
   |
60 |   suffix=" Please ensure the parameters are correct and the resource definition exists.",
61 | )
62 | async def _create_or_link_resource_counterpart_for_machine(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
63 |   db: AsyncSession,
64 |   machine_orm: "MachineOrm",
   |

praxis/backend/services/entity_linking.py:65:3: FBT001 Boolean-typed positional argument in function definition
   |
63 |   db: AsyncSession,
64 |   machine_orm: "MachineOrm",
65 |   is_resource: bool,
   |   ^^^^^^^^^^^ FBT001
66 |   resource_counterpart_accession_id: uuid.UUID | None,
67 |   resource_def_name: str | None = None,  # Needed if creating a new resource
   |

praxis/backend/services/entity_linking.py:100:17: TRY003 Avoid specifying long messages outside the exception class
    |
 98 |           )
 99 |           if not new_resource_instance:
100 |             raise ValueError(
    |  _________________^
101 | |             f"{log_prefix} ResourceOrm with ID {resource_counterpart_accession_id} not found for linking.",
102 | |           )
    | |___________^ TRY003
103 |           machine_orm.resource_counterpart = new_resource_instance
104 |           logger.info(
    |

praxis/backend/services/entity_linking.py:101:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
 99 |         if not new_resource_instance:
100 |           raise ValueError(
101 |             f"{log_prefix} ResourceOrm with ID {resource_counterpart_accession_id} not found for linking.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
102 |           )
103 |         machine_orm.resource_counterpart = new_resource_instance
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/entity_linking.py:139:13: TRY003 Avoid specifying long messages outside the exception class
    |
138 |       if not resource_def_name:
139 |         raise ValueError(
    |  _____________^
140 | |         f"{log_prefix} Cannot create new ResourceOrm: 'resource_def_name' is required when 'is_resource' is True and no 'resource_counterpart_accession_id' is provided.",
141 | |       )
    | |_______^ TRY003
142 |   
143 |       logger.info("%s Creating new ResourceOrm as counterpart.", log_prefix)
    |

praxis/backend/services/entity_linking.py:140:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
138 |     if not resource_def_name:
139 |       raise ValueError(
140 |         f"{log_prefix} Cannot create new ResourceOrm: 'resource_def_name' is required when 'is_resource' is True and no 'resource_counterpart_accession_id' is provided.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
141 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/entity_linking.py:140:121: E501 Line too long (170 > 120)
    |
138 |     if not resource_def_name:
139 |       raise ValueError(
140 |         f"{log_prefix} Cannot create new ResourceOrm: 'resource_def_name' is required when 'is_resource' is True and no 'resource_counterpart_accession_id' is provided.",
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
141 |       )
    |

praxis/backend/services/entity_linking.py:180:11: PLR0913 Too many arguments in function definition (8 > 5)
    |
178 |   suffix=" Please ensure the parameters are correct and the resource instance exists.",
179 | )
180 | async def _create_or_link_machine_counterpart_for_resource(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
181 |   db: AsyncSession,
182 |   resource_orm: "ResourceOrm",
    |

praxis/backend/services/entity_linking.py:183:3: FBT001 Boolean-typed positional argument in function definition
    |
181 |   db: AsyncSession,
182 |   resource_orm: "ResourceOrm",
183 |   is_machine: bool,
    |   ^^^^^^^^^^ FBT001
184 |   machine_counterpart_accession_id: uuid.UUID | None = None,
185 |   machine_name: str | None = None,
    |

praxis/backend/services/entity_linking.py:215:17: TRY003 Avoid specifying long messages outside the exception class
    |
213 |           )
214 |           if not new_machine_counterpart:
215 |             raise ValueError(
    |  _________________^
216 | |             f"{log_prefix} MachineOrm with ID {machine_counterpart_accession_id} not found for linking.",
217 | |           )
    | |___________^ TRY003
218 |           resource_orm.machine_counterpart = new_machine_counterpart
219 |           logger.info(
    |

praxis/backend/services/entity_linking.py:216:13: EM102 Exception must not use an f-string literal, assign to variable first
    |
214 |         if not new_machine_counterpart:
215 |           raise ValueError(
216 |             f"{log_prefix} MachineOrm with ID {machine_counterpart_accession_id} not found for linking.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
217 |           )
218 |         resource_orm.machine_counterpart = new_machine_counterpart
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/entity_linking.py:258:13: TRY003 Avoid specifying long messages outside the exception class
    |
257 |       if not machine_name or not machine_fqn:
258 |         raise ValueError(
    |  _____________^
259 | |         f"{log_prefix} Cannot create new MachineOrm: 'machine_name' and 'machine_fqn' are required when 'is_machine' is True and no 'machine_counterpart_accession_id' is provided.",
260 | |       )
    | |_______^ TRY003
261 |   
262 |       logger.info("%s Creating new MachineOrm as counterpart.", log_prefix)
    |

praxis/backend/services/entity_linking.py:259:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
257 |     if not machine_name or not machine_fqn:
258 |       raise ValueError(
259 |         f"{log_prefix} Cannot create new MachineOrm: 'machine_name' and 'machine_fqn' are required when 'is_machine' is True and no 'machine_counterpart_accession_id' is provided.",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
260 |       )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/entity_linking.py:259:121: E501 Line too long (181 > 120)
    |
257 |     if not machine_name or not machine_fqn:
258 |       raise ValueError(
259 |         f"{log_prefix} Cannot create new MachineOrm: 'machine_name' and 'machine_fqn' are required when 'is_machine' is True and no 'machine_counterpart_accession_id' is provided.",
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
260 |       )
    |

praxis/backend/services/entity_linking.py:321:1: PGH003 Use specific rule codes when ignoring type issues
    |
321 | # type: ignore
    | ^^^^^^^^^^^^^^ PGH003
    |

praxis/backend/services/entity_linking.py:351:1: PGH003 Use specific rule codes when ignoring type issues
    |
351 | # type: ignore
    | ^^^^^^^^^^^^^^ PGH003
    |

praxis/backend/services/entity_linking.py:381:1: PGH003 Use specific rule codes when ignoring type issues
    |
381 | # type: ignore
    | ^^^^^^^^^^^^^^ PGH003
    |

praxis/backend/services/function_output_data.py:86:64: DTZ003 `datetime.datetime.utcnow()` used
   |
84 |     data_quality_score=data_output.data_quality_score,
85 |     measurement_conditions_json=data_output.measurement_conditions_json,
86 |     measurement_timestamp=data_output.measurement_timestamp or datetime.datetime.utcnow(),
   |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ003
87 |     sequence_in_function=data_output.sequence_in_function,
88 |     derived_from_data_output_accession_id=data_output.derived_from_data_output_accession_id,
   |
   = help: Use `datetime.datetime.now(tz=...)` instead

praxis/backend/services/function_output_data.py:102:5: TRY300 Consider moving this statement to an `else` block
    |
100 |       data_output_orm.accession_id,
101 |     )
102 |     return data_output_orm
    |     ^^^^^^^^^^^^^^^^^^^^^^ TRY300
103 | 
104 |   except IntegrityError as e:
    |

praxis/backend/services/function_output_data.py:107:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
105 |     await db.rollback()
106 |     error_message = f"{log_prefix} Database integrity error: {e}"
107 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
108 |     raise ValueError(error_message) from e
109 |   except Exception as e:
    |

praxis/backend/services/function_output_data.py:112:11: TRY201 Use `raise` without specifying exception name
    |
110 |     await db.rollback()
111 |     logger.exception("%s Unexpected error during creation.", log_prefix)
112 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/function_output_data.py:251:5: TRY300 Consider moving this statement to an `else` block
    |
249 |     await db.refresh(data_output_orm)
250 |     logger.info("%s Successfully updated data output.", log_prefix)
251 |     return data_output_orm
    |     ^^^^^^^^^^^^^^^^^^^^^^ TRY300
252 |   except Exception as e:
253 |     await db.rollback()
    |

praxis/backend/services/function_output_data.py:255:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
253 |     await db.rollback()
254 |     error_msg = f"Failed to update data output: {e!s}"
255 |     logger.error("%s %s", log_prefix, error_msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
256 |     raise ValueError(error_msg) from e
    |
    = help: Replace with `exception`

praxis/backend/services/function_output_data.py:297:5: TRY300 Consider moving this statement to an `else` block
    |
296 |     logger.info("%s Successfully deleted data output.", log_prefix)
297 |     return True
    |     ^^^^^^^^^^^ TRY300
298 | 
299 |   except Exception as e:
    |

praxis/backend/services/function_output_data.py:302:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
300 |     await db.rollback()
301 |     error_msg = f"Failed to delete data output: {e!s}"
302 |     logger.error("%s %s", log_prefix, error_msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
303 |     raise ValueError(error_msg) from e
    |
    = help: Replace with `exception`

praxis/backend/services/machine.py:40:5: D200 One-line docstring should fit on one line
   |
39 |   class MachineService(CRUDBase[MachineOrm, MachineCreate, MachineUpdate]):
40 |       """Service for machine-related operations.
   |  _____^
41 | |     """
   | |_______^ D200
42 |   
43 |       def __init__(self, model: type[MachineOrm]):
   |
   = help: Reformat to one line

praxis/backend/services/machine.py:43:9: ANN204 Missing return type annotation for special method `__init__`
   |
41 |     """
42 | 
43 |     def __init__(self, model: type[MachineOrm]):
   |         ^^^^^^^^ ANN204
44 |         super().__init__(model)
45 |         self.machine_data_service_log = partial(
   |
   = help: Add return type annotation: `None`

praxis/backend/services/machine.py:43:9: D107 Missing docstring in `__init__`
   |
41 |     """
42 | 
43 |     def __init__(self, model: type[MachineOrm]):
   |         ^^^^^^^^ D107
44 |         super().__init__(model)
45 |         self.machine_data_service_log = partial(
   |

praxis/backend/services/machine.py:54:6: F821 Undefined name `machine_data_service_log`
   |
52 |         )
53 | 
54 |     @machine_data_service_log(
   |      ^^^^^^^^^^^^^^^^^^^^^^^^ F821
55 |         prefix="Machine Data Service: Creating machine - ",
56 |         suffix=" - Ensure the machine data is valid and unique.",
   |

praxis/backend/services/machine.py:134:19: TRY201 Use `raise` without specifying exception name
    |
132 |             await db.rollback()
133 |             logger.exception("%s Unexpected error during creation. Rolling back.", log_prefix)
134 |             raise e
    |                   ^ TRY201
135 | 
136 |         logger.info("%s Creation operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/machine.py:139:6: F821 Undefined name `machine_data_service_log`
    |
137 |         return machine_orm
138 | 
139 |     @machine_data_service_log(
    |      ^^^^^^^^^^^^^^^^^^^^^^^^ F821
140 |         prefix="Machine Data Service: Updating machine - ",
141 |         suffix=" - Ensure the machine data is valid and unique.",
    |

praxis/backend/services/machine.py:189:13: SIM401 Use `update_data.get("is_resource", db_obj.resource_counterpart_accession_id is not None)` instead of an `if` block
    |
187 |           # Handle `is_resource` update and potential resource counterpart linking
188 |           effective_is_resource = (
189 |               update_data["is_resource"]
    |  _____________^
190 | |             if "is_resource" in update_data
191 | |             else (db_obj.resource_counterpart_accession_id is not None)
    | |_______________________________________________________________________^ SIM401
192 |           )
    |
    = help: Replace with `update_data.get("is_resource", db_obj.resource_counterpart_accession_id is not None)`

praxis/backend/services/machine.py:223:19: TRY201 Use `raise` without specifying exception name
    |
221 |             await db.rollback()
222 |             logger.exception("%s Unexpected error during update. Rolling back.", log_prefix)
223 |             raise e
    |                   ^ TRY201
224 | 
225 |         logger.info("%s Update operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/machine.py:355:19: TRY201 Use `raise` without specifying exception name
    |
353 |                 machine_accession_id,
354 |             )
355 |             raise e
    |                   ^ TRY201
356 |         return machine_orm
    |
    = help: Remove exception name

praxis/backend/services/machine.py:358:49: A002 Argument `id` is shadowing a Python builtin
    |
356 |         return machine_orm
357 | 
358 |     async def delete(self, db: AsyncSession, *, id: uuid.UUID) -> bool:
    |                                                 ^^ A002
359 |         """Delete a specific machine by its ID."""
360 |         logger.info("Attempting to delete machine with ID: %s.", id)
    |

praxis/backend/services/machine.py:373:13: TRY300 Consider moving this statement to an `else` block
    |
371 |                 machine_orm.name,
372 |             )
373 |             return True
    |             ^^^^^^^^^^^ TRY300
374 |         except IntegrityError as e:
375 |             await db.rollback()
    |

praxis/backend/services/machine.py:388:19: TRY201 Use `raise` without specifying exception name
    |
386 |                 id,
387 |             )
388 |             raise e
    |                   ^ TRY201
389 | 
390 |     async def get_all_machines(self, db: AsyncSession) -> Sequence[MachineOrm]:
    |
    = help: Remove exception name

praxis/backend/services/plate_parsing.py:18:11: C901 `read_plate_dimensions` is too complex (15 > 10)
   |
18 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^ C901
19 |   db: AsyncSession,
20 |   plate_resource_instance_accession_id: UUID,
   |

praxis/backend/services/plate_parsing.py:18:11: PLR0911 Too many return statements (10 > 6)
   |
18 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^ PLR0911
19 |   db: AsyncSession,
20 |   plate_resource_instance_accession_id: UUID,
   |

praxis/backend/services/plate_parsing.py:18:11: PLR0912 Too many branches (14 > 12)
   |
18 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^ PLR0912
19 |   db: AsyncSession,
20 |   plate_resource_instance_accession_id: UUID,
   |

praxis/backend/services/plate_parsing.py:69:11: PERF203 `try`-`except` within a loop incurs performance overhead
   |
67 |               max_row = max(max_row, row_idx)
68 |               max_col = max(max_col, col_idx)
69 |             except ValueError:
   |  ___________^
70 | |             continue
   | |____________________^ PERF203
71 |   
72 |           if max_row > 0 or max_col > 0:
   |

praxis/backend/services/plate_parsing.py:107:40: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
106 |   """
107 |   if not well_name or len(well_name) < 2:
    |                                        ^ PLR2004
108 |     raise ValueError(f"Invalid well name: {well_name}")
    |

praxis/backend/services/plate_parsing.py:108:11: TRY003 Avoid specifying long messages outside the exception class
    |
106 |   """
107 |   if not well_name or len(well_name) < 2:
108 |     raise ValueError(f"Invalid well name: {well_name}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
109 | 
110 |   # Parse row (letter)
    |

praxis/backend/services/plate_parsing.py:108:22: EM102 Exception must not use an f-string literal, assign to variable first
    |
106 |   """
107 |   if not well_name or len(well_name) < 2:
108 |     raise ValueError(f"Invalid well name: {well_name}")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
109 | 
110 |   # Parse row (letter)
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/plate_parsing.py:113:11: TRY003 Avoid specifying long messages outside the exception class
    |
111 |   row_letter = well_name[0].upper()
112 |   if not row_letter.isalpha():
113 |     raise ValueError(f"Invalid row letter in well name: {well_name}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
114 | 
115 |   row_idx = ord(row_letter) - ord("A")
    |

praxis/backend/services/plate_parsing.py:113:22: EM102 Exception must not use an f-string literal, assign to variable first
    |
111 |   row_letter = well_name[0].upper()
112 |   if not row_letter.isalpha():
113 |     raise ValueError(f"Invalid row letter in well name: {well_name}")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
114 | 
115 |   row_idx = ord(row_letter) - ord("A")
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/plate_parsing.py:122:5: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
120 |     col_idx = col_num - 1  # Convert to 0-based
121 |   except ValueError:
122 |     raise ValueError(f"Invalid column number in well name: {well_name}")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
123 | 
124 |   return row_idx, col_idx
    |

praxis/backend/services/plate_parsing.py:122:11: TRY003 Avoid specifying long messages outside the exception class
    |
120 |     col_idx = col_num - 1  # Convert to 0-based
121 |   except ValueError:
122 |     raise ValueError(f"Invalid column number in well name: {well_name}")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
123 | 
124 |   return row_idx, col_idx
    |

praxis/backend/services/plate_parsing.py:122:22: EM102 Exception must not use an f-string literal, assign to variable first
    |
120 |     col_idx = col_num - 1  # Convert to 0-based
121 |   except ValueError:
122 |     raise ValueError(f"Invalid column number in well name: {well_name}")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
123 | 
124 |   return row_idx, col_idx
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/praxis_orm_service.py:47:7: ANN204 Missing return type annotation for special method `__new__`
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |       ^^^^^^^ ANN204
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |
   = help: Add return type annotation

praxis/backend/services/praxis_orm_service.py:47:20: ANN002 Missing type annotation for `*args`
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |                    ^^^^^ ANN002
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |

praxis/backend/services/praxis_orm_service.py:47:21: ARG003 Unused class method argument: `args`
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |                     ^^^^ ARG003
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |

praxis/backend/services/praxis_orm_service.py:47:27: ANN003 Missing type annotation for `**kwargs`
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |                           ^^^^^^^^ ANN003
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |

praxis/backend/services/praxis_orm_service.py:47:29: ARG003 Unused class method argument: `kwargs`
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |                             ^^^^^^ ARG003
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |

praxis/backend/services/praxis_orm_service.py:47:39: PGH003 Use specific rule codes when ignoring type issues
   |
45 |   _retry_delay = 1  # seconds
46 | 
47 |   def __new__(cls, *args, **kwargs):  # type: ignore
   |                                       ^^^^^^^^^^^^^^ PGH003
48 |     """Implement the singleton pattern for PraxisDBService."""
49 |     if cls._instance is None:
   |

praxis/backend/services/praxis_orm_service.py:54:13: ANN206 Missing return type annotation for classmethod `initialize`
   |
53 |   @classmethod
54 |   async def initialize(
   |             ^^^^^^^^^^ ANN206
55 |     cls,
56 |     keycloak_dsn: str | None = None,
   |
   = help: Add return type annotation

praxis/backend/services/praxis_orm_service.py:104:40: SLF001 Private member accessed: `_closed`
    |
102 |       while retries < cls._max_retries:
103 |         try:
104 |           if not cls._keycloak_pool or cls._keycloak_pool._closed:
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
105 |             logger.info(
106 |               "Attempting to connect to Keycloak database: %s",
    |

praxis/backend/services/praxis_orm_service.py:116:13: S101 Use of `assert` detected
    |
114 |               timeout=10.0,
115 |             )
116 |             assert (
    |             ^^^^^^ S101
117 |               cls._keycloak_pool is not None
118 |             ), "Failed to create Keycloak database pool"
    |

praxis/backend/services/praxis_orm_service.py:119:63: PGH003 Use specific rule codes when ignoring type issues
    |
117 |               cls._keycloak_pool is not None
118 |             ), "Failed to create Keycloak database pool"
119 |             async with cls._keycloak_pool.acquire() as conn:  # type: ignore
    |                                                               ^^^^^^^^^^^^^^ PGH003
120 |               await conn.execute("SELECT 1")  # type: ignore
121 |             logger.info("Successfully connected to Keycloak database.")
    |

praxis/backend/services/praxis_orm_service.py:120:47: PGH003 Use specific rule codes when ignoring type issues
    |
118 |             ), "Failed to create Keycloak database pool"
119 |             async with cls._keycloak_pool.acquire() as conn:  # type: ignore
120 |               await conn.execute("SELECT 1")  # type: ignore
    |                                               ^^^^^^^^^^^^^^ PGH003
121 |             logger.info("Successfully connected to Keycloak database.")
122 |             break
    |

praxis/backend/services/praxis_orm_service.py:139:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
137 |               current_retry_delay *= 2
138 |             else:
139 |               logger.error(
    |  _____________^
140 | |               "Failed to connect to Keycloak database after %d attempts.",
141 | |               cls._max_retries,
142 | |             )
    | |_____________^ TRY400
143 |               raise ConnectionError(
144 |                 f"Could not establish Keycloak database connection: {last_error}",
    |
    = help: Replace with `exception`

praxis/backend/services/praxis_orm_service.py:143:19: TRY003 Avoid specifying long messages outside the exception class
    |
141 |                 cls._max_retries,
142 |               )
143 |               raise ConnectionError(
    |  ___________________^
144 | |               f"Could not establish Keycloak database connection: {last_error}",
145 | |             ) from last_error
    | |_____________^ TRY003
146 |           except Exception:
147 |             logger.exception("Unexpected error during Keycloak database initialization.")
    |

praxis/backend/services/praxis_orm_service.py:144:15: EM102 Exception must not use an f-string literal, assign to variable first
    |
142 |             )
143 |             raise ConnectionError(
144 |               f"Could not establish Keycloak database connection: {last_error}",
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
145 |             ) from last_error
146 |         except Exception:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/praxis_orm_service.py:151:15: TRY003 Avoid specifying long messages outside the exception class
    |
150 |         if not cls._keycloak_pool and keycloak_dsn:
151 |           raise ConnectionError(
    |  _______________^
152 | |           f"Failed to initialize Keycloak pool. Last error: {last_error}",
153 | |         )
    | |_________^ TRY003
154 |       else:
155 |         logger.info(
    |

praxis/backend/services/praxis_orm_service.py:152:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
150 |       if not cls._keycloak_pool and keycloak_dsn:
151 |         raise ConnectionError(
152 |           f"Failed to initialize Keycloak pool. Last error: {last_error}",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
153 |         )
154 |     else:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/praxis_orm_service.py:223:53: PGH003 Use specific rule codes when ignoring type issues
    |
221 |     try:
222 |       conn = await self._keycloak_pool.acquire()
223 |       if not isinstance(conn, asyncpg.Connection):  # type: ignore
    |                                                     ^^^^^^^^^^^^^^ PGH003
224 |         error_message = "Failed to acquire Keycloak connection from pool."
225 |         logger.error(error_message)
    |

praxis/backend/services/praxis_orm_service.py:227:19: PGH003 Use specific rule codes when ignoring type issues
    |
225 |         logger.error(error_message)
226 |         raise ConnectionError(error_message)
227 |       yield conn  # type: ignore
    |                   ^^^^^^^^^^^^^^ PGH003
228 |       logger.debug("Keycloak connection released.")
229 |     finally:
    |

praxis/backend/services/praxis_orm_service.py:271:13: ANN201 Missing return type annotation for public function `execute_sql`
    |
269 |       return users_dict
270 | 
271 |   async def execute_sql(self, sql_statement: str, params: dict | None = None):
    |             ^^^^^^^^^^^ ANN201
272 |     """Execute a raw SQL statement on the Praxis database.
    |
    = help: Add return type annotation: `None`

praxis/backend/services/praxis_orm_service.py:307:20: SLF001 Private member accessed: `_mapping`
    |
306 |       result = await session.execute(text(sql_query), params)
307 |       rows = [dict(row._mapping) for row in result]
    |                    ^^^^^^^^^^^^ SLF001
308 |       logger.debug("Fetched %d rows.", len(rows))
309 |       return rows
    |

praxis/backend/services/praxis_orm_service.py:338:80: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `fetch_val_sql`
    |
336 |       return None
337 | 
338 |   async def fetch_val_sql(self, sql_query: str, params: dict | None = None) -> Any:
    |                                                                                ^^^ ANN401
339 |     """Fetch a single scalar value from a raw SQL query on the Praxis database.
    |

praxis/backend/services/praxis_orm_service.py:360:13: ANN201 Missing return type annotation for public function `close`
    |
358 |       return value
359 | 
360 |   async def close(self):
    |             ^^^^^ ANN201
361 |     """Close the Keycloak database connection pool.
    |
    = help: Add return type annotation: `None`

praxis/backend/services/praxis_orm_service.py:368:36: SLF001 Private member accessed: `_closed`
    |
366 |     """
367 |     logger.info("Attempting to close PraxisDBService resources.")
368 |     if self._keycloak_pool and not self._keycloak_pool._closed:  # type: ignore
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
369 |       await self._keycloak_pool.close()  # type: ignore
370 |       logger.info("Keycloak database pool closed.")
    |

praxis/backend/services/praxis_orm_service.py:368:66: PGH003 Use specific rule codes when ignoring type issues
    |
366 |     """
367 |     logger.info("Attempting to close PraxisDBService resources.")
368 |     if self._keycloak_pool and not self._keycloak_pool._closed:  # type: ignore
    |                                                                  ^^^^^^^^^^^^^^ PGH003
369 |       await self._keycloak_pool.close()  # type: ignore
370 |       logger.info("Keycloak database pool closed.")
    |

praxis/backend/services/praxis_orm_service.py:369:42: PGH003 Use specific rule codes when ignoring type issues
    |
367 |     logger.info("Attempting to close PraxisDBService resources.")
368 |     if self._keycloak_pool and not self._keycloak_pool._closed:  # type: ignore
369 |       await self._keycloak_pool.close()  # type: ignore
    |                                          ^^^^^^^^^^^^^^ PGH003
370 |       logger.info("Keycloak database pool closed.")
371 |     # The SQLAlchemy engine (from which AsyncSessionLocal is derived) should
    |

praxis/backend/services/praxis_orm_service.py:389:3: N806 Variable `PROJECT_ROOT` in function should be lowercase
    |
387 |   """
388 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
389 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
    |   ^^^^^^^^^^^^ N806
390 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |

praxis/backend/services/praxis_orm_service.py:390:3: N806 Variable `CONFIG_FILE_PATH` in function should be lowercase
    |
388 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
389 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
390 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |   ^^^^^^^^^^^^^^^^ N806
391 | 
392 |   if not CONFIG_FILE_PATH.exists():
    |

praxis/backend/services/praxis_orm_service.py:412:7: TRY300 Consider moving this statement to an `else` block
    |
410 |       dsn = f"postgresql://{user}:{password}@{host}:{port}/{dbname}"
411 |       logger.info("Successfully retrieved Keycloak DSN from config.")
412 |       return dsn
    |       ^^^^^^^^^^ TRY300
413 |     except Exception as e:
414 |       logger.error("Error reading Keycloak DSN from praxis.ini: %s", e)
    |

praxis/backend/services/praxis_orm_service.py:413:12: BLE001 Do not catch blind exception: `Exception`
    |
411 |       logger.info("Successfully retrieved Keycloak DSN from config.")
412 |       return dsn
413 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
414 |       logger.error("Error reading Keycloak DSN from praxis.ini: %s", e)
415 |       return None
    |

praxis/backend/services/praxis_orm_service.py:414:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
412 |       return dsn
413 |     except Exception as e:
414 |       logger.error("Error reading Keycloak DSN from praxis.ini: %s", e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
415 |       return None
416 |   logger.info("Keycloak database section not found in praxis.ini.")
    |
    = help: Replace with `exception`

praxis/backend/services/protocol_output_data.py:131:35: PGH003 Use specific rule codes when ignoring type issues
    |
129 |     total_data_outputs=total_data_outputs or 0,
130 |     data_types=data_types,
131 |     machines_used=machines_used,  # type: ignore
    |                                   ^^^^^^^^^^^^^^ PGH003
132 |     resource_with_data=resource_with_data,  # type: ignore
133 |     data_timeline=data_timeline,
    |

praxis/backend/services/protocol_output_data.py:132:45: PGH003 Use specific rule codes when ignoring type issues
    |
130 |     data_types=data_types,
131 |     machines_used=machines_used,  # type: ignore
132 |     resource_with_data=resource_with_data,  # type: ignore
    |                                             ^^^^^^^^^^^^^^ PGH003
133 |     data_timeline=data_timeline,
134 |     file_attachments=file_attachments,
    |

praxis/backend/services/protocols.py:42:5: D200 One-line docstring should fit on one line
   |
41 |   class ProtocolRunService(CRUDBase[ProtocolRunOrm, ProtocolRunCreate, ProtocolRunUpdate]):
42 |       """Service for protocol run operations.
   |  _____^
43 | |     """
   | |_______^ D200
44 |   
45 |       async def create(self, db: AsyncSession, *, obj_in: ProtocolRunCreate) -> ProtocolRunOrm:
   |
   = help: Reformat to one line

praxis/backend/services/protocols.py:87:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   |
85 |                 f"be due to a duplicate GUID. Details: {e}"
86 |             )
87 |             logger.error(error_message, exc_info=True)
   |                    ^^^^^ G201
88 |             raise ValueError(error_message) from e
89 |         except Exception as e:
   |

praxis/backend/services/protocols.py:95:19: TRY201 Use `raise` without specifying exception name
   |
93 |                 run_accession_id,
94 |             )
95 |             raise e
   |                   ^ TRY201
96 |         return db_protocol_run
   |
   = help: Remove exception name

praxis/backend/services/protocols.py:179:15: PLR0913 Too many arguments in function definition (6 > 5)
    |
177 |         return protocol_run
178 | 
179 |     async def update_protocol_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
180 |         self,
181 |         db: AsyncSession,
    |

praxis/backend/services/protocols.py:228:87: PGH003 Use specific rule codes when ignoring type issues
    |
226 |                 )
227 |                 if db_protocol_run.start_time and db_protocol_run.end_time:
228 |                     duration = db_protocol_run.end_time - db_protocol_run.start_time  # type: ignore
    |                                                                                       ^^^^^^^^^^^^^^ PGH003
229 |                     db_protocol_run.duration_ms = int(duration.total_seconds() * 1000)
230 |                     logger.debug(
    |

praxis/backend/services/protocols.py:248:68: PGH003 Use specific rule codes when ignoring type issues
    |
246 |                     )
247 |                 if new_status == ProtocolRunStatusEnum.FAILED and error_info:
248 |                     db_protocol_run.output_data_json = error_info  # type: ignore
    |                                                                    ^^^^^^^^^^^^^^ PGH003
249 |                     logger.error(
250 |                         "Protocol run ID %s failed with error info: %s",
    |

praxis/backend/services/protocols.py:268:23: TRY201 Use `raise` without specifying exception name
    |
266 |                     protocol_run_accession_id,
267 |                 )
268 |                 raise e
    |                       ^ TRY201
269 |             return db_protocol_run
270 |         logger.warning(
    |
    = help: Remove exception name

praxis/backend/services/resource.py:35:5: D200 One-line docstring should fit on one line
   |
34 |   class ResourceService(CRUDBase[ResourceOrm, ResourceCreate, ResourceUpdate]):
35 |       """Service for resource-related operations.
   |  _____^
36 | |     """
   | |_______^ D200
37 |   
38 |       def __init__(self, model: type[ResourceOrm]):
   |
   = help: Reformat to one line

praxis/backend/services/resource.py:38:9: ANN204 Missing return type annotation for special method `__init__`
   |
36 |     """
37 | 
38 |     def __init__(self, model: type[ResourceOrm]):
   |         ^^^^^^^^ ANN204
39 |         super().__init__(model)
40 |         self.log_resource_data_service_errors = partial(
   |
   = help: Add return type annotation: `None`

praxis/backend/services/resource.py:38:9: D107 Missing docstring in `__init__`
   |
36 |     """
37 | 
38 |     def __init__(self, model: type[ResourceOrm]):
   |         ^^^^^^^^ D107
39 |         super().__init__(model)
40 |         self.log_resource_data_service_errors = partial(
   |

praxis/backend/services/resource.py:49:6: F821 Undefined name `log_resource_data_service_errors`
   |
47 |         )
48 | 
49 |     @log_resource_data_service_errors(
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F821
50 |         prefix="Resource Data Service: Creating resource - ",
51 |         suffix=(
   |

praxis/backend/services/resource.py:94:19: TRY201 Use `raise` without specifying exception name
   |
92 |             )
93 |             await db.rollback()
94 |             raise e
   |                   ^ TRY201
95 | 
96 |         return resource_orm
   |
   = help: Remove exception name

praxis/backend/services/resource.py:99:33: A002 Argument `id` is shadowing a Python builtin
    |
 98 |     async def get(
 99 |         self, db: AsyncSession, id: UUID,
    |                                 ^^ A002
100 |     ) -> ResourceOrm | None:
101 |         """Retrieve a specific resource by its ID."""
    |

praxis/backend/services/resource.py:232:19: TRY201 Use `raise` without specifying exception name
    |
230 |                 db_obj.accession_id,
231 |             )
232 |             raise e
    |                   ^ TRY201
233 | 
234 |     async def remove(self, db: AsyncSession, *, id: UUID) -> bool:
    |
    = help: Remove exception name

praxis/backend/services/resource.py:234:49: A002 Argument `id` is shadowing a Python builtin
    |
232 |             raise e
233 | 
234 |     async def remove(self, db: AsyncSession, *, id: UUID) -> bool:
    |                                                 ^^ A002
235 |         """Delete a specific resource by its ID."""
236 |         logger.info("Attempting to delete resource with ID: %s.", id)
    |

praxis/backend/services/resource.py:250:13: TRY300 Consider moving this statement to an `else` block
    |
248 |                 resource_orm.name,
249 |             )
250 |             return True
    |             ^^^^^^^^^^^ TRY300
251 |         except IntegrityError as e:
252 |             await db.rollback()
    |

praxis/backend/services/resource.py:265:19: TRY201 Use `raise` without specifying exception name
    |
263 |                 id,
264 |             )
265 |             raise e
    |                   ^ TRY201
266 | 
267 |     async def get_all_resources(self, db: AsyncSession) -> list[ResourceOrm]:
    |
    = help: Remove exception name

praxis/backend/services/resource_type_definition.py:40:11: PLR0913 Too many arguments in function definition (10 > 5)
   |
38 |   suffix=" Please ensure the parameters are correct and the resource definition does not already exist.",
39 | )
40 | async def create_resource_definition(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
41 |   db: AsyncSession,
42 |   name: str,
   |

praxis/backend/services/resource_type_definition.py:46:3: FBT001 Boolean-typed positional argument in function definition
   |
44 |   resource_type: str | None = None,
45 |   description: str | None = None,
46 |   is_consumable: bool = True,
   |   ^^^^^^^^^^^^^ FBT001
47 |   nominal_volume_ul: float | None = None,
48 |   material: str | None = None,
   |

praxis/backend/services/resource_type_definition.py:46:3: FBT002 Boolean default positional argument in function definition
   |
44 |   resource_type: str | None = None,
45 |   description: str | None = None,
46 |   is_consumable: bool = True,
   |   ^^^^^^^^^^^^^ FBT002
47 |   nominal_volume_ul: float | None = None,
48 |   material: str | None = None,
   |

praxis/backend/services/resource_type_definition.py:138:11: TRY201 Use `raise` without specifying exception name
    |
136 |     await db.rollback()
137 |     logger.exception("%s Unexpected error during creation. Rolling back.", log_prefix)
138 |     raise e
    |           ^ TRY201
139 | 
140 |   logger.info("%s Creation operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/resource_type_definition.py:148:11: C901 `update_resource_definition` is too complex (12 > 10)
    |
146 |   suffix=(" Please ensure the parameters are correct and the resource definition exists."),
147 | )
148 | async def update_resource_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
149 |   db: AsyncSession,
150 |   name: str,  # Identifier for the resource definition to update
    |

praxis/backend/services/resource_type_definition.py:148:11: PLR0913 Too many arguments in function definition (10 > 5)
    |
146 |   suffix=(" Please ensure the parameters are correct and the resource definition exists."),
147 | )
148 | async def update_resource_definition(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
149 |   db: AsyncSession,
150 |   name: str,  # Identifier for the resource definition to update
    |

praxis/backend/services/resource_type_definition.py:244:11: TRY201 Use `raise` without specifying exception name
    |
242 |     await db.rollback()
243 |     logger.exception("%s Unexpected error during update. Rolling back.", log_prefix)
244 |     raise e
    |           ^ TRY201
245 | 
246 |   logger.info("%s Update operation completed.", log_prefix)
    |
    = help: Remove exception name

praxis/backend/services/resource_type_definition.py:409:5: TRY300 Consider moving this statement to an `else` block
    |
407 |       name,
408 |     )
409 |     return True
    |     ^^^^^^^^^^^ TRY300
410 |   except IntegrityError as e:
411 |     await db.rollback()
    |

praxis/backend/services/resource_type_definition.py:424:11: TRY201 Use `raise` without specifying exception name
    |
422 |       name,
423 |     )
424 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/scheduler.py:55:11: PLR0913 Too many arguments in function definition (7 > 5)
   |
53 |   suffix=" - Ensure the protocol run ID is valid and unique.",
54 | )
55 | async def create_schedule_entry(
   |           ^^^^^^^^^^^^^^^^^^^^^ PLR0913
56 |   db: AsyncSession,
57 |   protocol_run_accession_id: uuid.UUID,
   |

praxis/backend/services/scheduler.py:148:5: TRY300 Consider moving this statement to an `else` block
    |
146 |     )
147 | 
148 |     return schedule_entry
    |     ^^^^^^^^^^^^^^^^^^^^^ TRY300
149 | 
150 |   except Exception as exc:
    |

praxis/backend/services/scheduler.py:153:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
151 |     await db.rollback()
152 |     error_message = f"{log_prefix} Failed to create schedule entry: {exc}"
153 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
154 |     raise Exception(error_message) from exc
    |

praxis/backend/services/scheduler.py:154:11: TRY002 Create your own exception
    |
152 |     error_message = f"{log_prefix} Failed to create schedule entry: {exc}"
153 |     logger.error(error_message, exc_info=True)
154 |     raise Exception(error_message) from exc
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ TRY002
    |

praxis/backend/services/scheduler.py:160:3: FBT001 Boolean-typed positional argument in function definition
    |
158 |   db: AsyncSession,
159 |   schedule_entry_accession_id: uuid.UUID,
160 |   include_reservations: bool = True,
    |   ^^^^^^^^^^^^^^^^^^^^ FBT001
161 | ) -> ScheduleEntryOrm | None:
162 |   """Read a schedule entry by ID.
    |

praxis/backend/services/scheduler.py:160:3: FBT002 Boolean default positional argument in function definition
    |
158 |   db: AsyncSession,
159 |   schedule_entry_accession_id: uuid.UUID,
160 |   include_reservations: bool = True,
    |   ^^^^^^^^^^^^^^^^^^^^ FBT002
161 | ) -> ScheduleEntryOrm | None:
162 |   """Read a schedule entry by ID.
    |

praxis/backend/services/scheduler.py:189:3: FBT001 Boolean-typed positional argument in function definition
    |
187 |   db: AsyncSession,
188 |   protocol_run_accession_id: uuid.UUID,
189 |   include_reservations: bool = True,
    |   ^^^^^^^^^^^^^^^^^^^^ FBT001
190 | ) -> ScheduleEntryOrm | None:
191 |   """Read a schedule entry by protocol run ID.
    |

praxis/backend/services/scheduler.py:189:3: FBT002 Boolean default positional argument in function definition
    |
187 |   db: AsyncSession,
188 |   protocol_run_accession_id: uuid.UUID,
189 |   include_reservations: bool = True,
    |   ^^^^^^^^^^^^^^^^^^^^ FBT002
190 | ) -> ScheduleEntryOrm | None:
191 |   """Read a schedule entry by protocol run ID.
    |

praxis/backend/services/scheduler.py:215:11: C901 `list_schedule_entries` is too complex (13 > 10)
    |
215 | async def list_schedule_entries(
    |           ^^^^^^^^^^^^^^^^^^^^^ C901
216 |   db: AsyncSession,
217 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:215:11: PLR0913 Too many arguments in function definition (10 > 5)
    |
215 | async def list_schedule_entries(
    |           ^^^^^^^^^^^^^^^^^^^^^ PLR0913
216 |   db: AsyncSession,
217 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:215:11: PLR0912 Too many branches (14 > 12)
    |
215 | async def list_schedule_entries(
    |           ^^^^^^^^^^^^^^^^^^^^^ PLR0912
216 |   db: AsyncSession,
217 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:215:11: D417 Missing argument description in the docstring for `list_schedule_entries`: `filters`
    |
215 | async def list_schedule_entries(
    |           ^^^^^^^^^^^^^^^^^^^^^ D417
216 |   db: AsyncSession,
217 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:220:3: ARG001 Unused function argument: `priority_min`
    |
218 |   status_filter: list[ScheduleStatusEnum] | None = None, # Specific filter
219 |   protocol_run_ids: list[uuid.UUID] | None = None, # Specific filter
220 |   priority_min: int | None = None, # Specific filter
    |   ^^^^^^^^^^^^ ARG001
221 |   priority_max: int | None = None, # Specific filter
222 |   include_completed: bool = False, # Specific filter
    |

praxis/backend/services/scheduler.py:221:3: ARG001 Unused function argument: `priority_max`
    |
219 |   protocol_run_ids: list[uuid.UUID] | None = None, # Specific filter
220 |   priority_min: int | None = None, # Specific filter
221 |   priority_max: int | None = None, # Specific filter
    |   ^^^^^^^^^^^^ ARG001
222 |   include_completed: bool = False, # Specific filter
223 |   include_cancelled: bool = False, # Specific filter
    |

praxis/backend/services/scheduler.py:222:3: FBT001 Boolean-typed positional argument in function definition
    |
220 |   priority_min: int | None = None, # Specific filter
221 |   priority_max: int | None = None, # Specific filter
222 |   include_completed: bool = False, # Specific filter
    |   ^^^^^^^^^^^^^^^^^ FBT001
223 |   include_cancelled: bool = False, # Specific filter
224 |   order_by: str = "created_at",
    |

praxis/backend/services/scheduler.py:222:3: FBT002 Boolean default positional argument in function definition
    |
220 |   priority_min: int | None = None, # Specific filter
221 |   priority_max: int | None = None, # Specific filter
222 |   include_completed: bool = False, # Specific filter
    |   ^^^^^^^^^^^^^^^^^ FBT002
223 |   include_cancelled: bool = False, # Specific filter
224 |   order_by: str = "created_at",
    |

praxis/backend/services/scheduler.py:223:3: FBT001 Boolean-typed positional argument in function definition
    |
221 |   priority_max: int | None = None, # Specific filter
222 |   include_completed: bool = False, # Specific filter
223 |   include_cancelled: bool = False, # Specific filter
    |   ^^^^^^^^^^^^^^^^^ FBT001
224 |   order_by: str = "created_at",
225 |   order_desc: bool = True,
    |

praxis/backend/services/scheduler.py:223:3: FBT002 Boolean default positional argument in function definition
    |
221 |   priority_max: int | None = None, # Specific filter
222 |   include_completed: bool = False, # Specific filter
223 |   include_cancelled: bool = False, # Specific filter
    |   ^^^^^^^^^^^^^^^^^ FBT002
224 |   order_by: str = "created_at",
225 |   order_desc: bool = True,
    |

praxis/backend/services/scheduler.py:225:3: FBT001 Boolean-typed positional argument in function definition
    |
223 |   include_cancelled: bool = False, # Specific filter
224 |   order_by: str = "created_at",
225 |   order_desc: bool = True,
    |   ^^^^^^^^^^ FBT001
226 | ) -> list[ScheduleEntryOrm]:
227 |   """List schedule entries with optional filters.
    |

praxis/backend/services/scheduler.py:225:3: FBT002 Boolean default positional argument in function definition
    |
223 |   include_cancelled: bool = False, # Specific filter
224 |   order_by: str = "created_at",
225 |   order_desc: bool = True,
    |   ^^^^^^^^^^ FBT002
226 | ) -> list[ScheduleEntryOrm]:
227 |   """List schedule entries with optional filters.
    |

praxis/backend/services/scheduler.py:295:3: SIM108 Use ternary operator `stmt = stmt.order_by(desc(order_col)) if order_desc else stmt.order_by(asc(order_col))` instead of `if`-`else`-block
    |
293 |       order_col = ScheduleEntryOrm.created_at
294 |   
295 |     if order_desc:
    |  ___^
296 | |     stmt = stmt.order_by(desc(order_col))
297 | |   else:
298 | |     stmt = stmt.order_by(asc(order_col))
    | |________________________________________^ SIM108
299 |   
300 |     # Include reservations
    |
    = help: Replace `if`-`else`-block with `stmt = stmt.order_by(desc(order_col)) if order_desc else stmt.order_by(asc(order_col))`

praxis/backend/services/scheduler.py:307:11: PLR0913 Too many arguments in function definition (6 > 5)
    |
307 | async def update_schedule_entry_status(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
308 |   db: AsyncSession,
309 |   schedule_entry_accession_id: uuid.UUID,
    |

praxis/backend/services/scheduler.py:465:11: PLR0913 Too many arguments in function definition (10 > 5)
    |
463 |   suffix=" - Ensure the schedule entry ID is valid.",
464 | )
465 | async def create_asset_reservation(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
466 |   db: AsyncSession,
467 |   schedule_entry_accession_id: uuid.UUID,
    |

praxis/backend/services/scheduler.py:535:5: TRY300 Consider moving this statement to an `else` block
    |
533 |     )
534 | 
535 |     return reservation
    |     ^^^^^^^^^^^^^^^^^^ TRY300
536 | 
537 |   except Exception as exc:
    |

praxis/backend/services/scheduler.py:540:12: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
538 |     await db.rollback()
539 |     error_message = f"{log_prefix} Failed to create asset reservation: {exc}"
540 |     logger.error(error_message, exc_info=True)
    |            ^^^^^ G201
541 |     raise Exception(error_message) from exc
    |

praxis/backend/services/scheduler.py:541:11: TRY002 Create your own exception
    |
539 |     error_message = f"{log_prefix} Failed to create asset reservation: {exc}"
540 |     logger.error(error_message, exc_info=True)
541 |     raise Exception(error_message) from exc
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ TRY002
    |

praxis/backend/services/scheduler.py:568:11: PLR0913 Too many arguments in function definition (7 > 5)
    |
568 | async def list_asset_reservations(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
569 |   db: AsyncSession,
570 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:568:11: D417 Missing argument description in the docstring for `list_asset_reservations`: `filters`
    |
568 | async def list_asset_reservations(
    |           ^^^^^^^^^^^^^^^^^^^^^^^ D417
569 |   db: AsyncSession,
570 |   filters: SearchFilters,
    |

praxis/backend/services/scheduler.py:575:3: FBT001 Boolean-typed positional argument in function definition
    |
573 |   asset_name: str | None = None, # Specific filter
574 |   status_filter: list[AssetReservationStatusEnum] | None = None, # Specific filter
575 |   active_only: bool = False, # Specific filter
    |   ^^^^^^^^^^^ FBT001
576 | ) -> list[AssetReservationOrm]:
577 |   """List asset reservations with optional filters.
    |

praxis/backend/services/scheduler.py:575:3: FBT002 Boolean default positional argument in function definition
    |
573 |   asset_name: str | None = None, # Specific filter
574 |   status_filter: list[AssetReservationStatusEnum] | None = None, # Specific filter
575 |   active_only: bool = False, # Specific filter
    |   ^^^^^^^^^^^ FBT002
576 | ) -> list[AssetReservationOrm]:
577 |   """List asset reservations with optional filters.
    |

praxis/backend/services/scheduler.py:730:11: PLR0913 Too many arguments in function definition (10 > 5)
    |
730 | async def log_schedule_event(
    |           ^^^^^^^^^^^^^^^^^^ PLR0913
731 |   db: AsyncSession,
732 |   schedule_entry_accession_id: uuid.UUID,
    |

praxis/backend/services/scheduler.py:740:3: ARG001 Unused function argument: `triggered_by`
    |
738 |   message: str | None = None,
739 |   duration_ms: int | None = None,
740 |   triggered_by: str | None = None,
    |   ^^^^^^^^^^^^ ARG001
741 | ) -> ScheduleHistoryOrm:
742 |   """Log a scheduling event for history and analytics.
    |

praxis/backend/services/state.py:172:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `__getitem__`
    |
170 |       raise
171 | 
172 |   def __getitem__(self, key: str) -> Any:
    |                                      ^^^ ANN401
173 |     """Retrieve a value from the state data using the given key."""
174 |     if key not in self._data:
    |

praxis/backend/services/state.py:184:42: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
182 |     return self._data[key]
183 | 
184 |   def __setitem__(self, key: str, value: Any) -> None:
    |                                          ^^^ ANN401
185 |     """Set a value in the state data using the given key."""
186 |     if not isinstance(key, str):
    |

praxis/backend/services/state.py:208:34: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
206 |     self._save_to_redis()
207 | 
208 |   def set(self, key: str, value: Any) -> None:
    |                                  ^^^ ANN401
209 |     """Set a value in the state data. Alias for state[key] = value."""
210 |     self.__setitem__(key, value)
    |

praxis/backend/services/state.py:252:7: ANN201 Missing return type annotation for public function `keys`
    |
250 |     return len(self._data)
251 | 
252 |   def keys(self):
    |       ^^^^ ANN201
253 |     """Return the keys of the state data."""
254 |     return self._data.keys()
    |
    = help: Add return type annotation

praxis/backend/services/state.py:256:7: ANN201 Missing return type annotation for public function `values`
    |
254 |     return self._data.keys()
255 | 
256 |   def values(self):
    |       ^^^^^^ ANN201
257 |     """Return the values of the state data."""
258 |     return self._data.values()
    |
    = help: Add return type annotation

praxis/backend/services/state.py:260:7: ANN201 Missing return type annotation for public function `items`
    |
258 |     return self._data.values()
259 | 
260 |   def items(self):
    |       ^^^^^ ANN201
261 |     """Return the items (key-value pairs) of the state data."""
262 |     return self._data.items()
    |
    = help: Add return type annotation

praxis/backend/services/state.py:264:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `__getattr__`
    |
262 |     return self._data.items()
263 | 
264 |   def __getattr__(self, name: str) -> Any:
    |                                       ^^^ ANN401
265 |     """Access state data as attributes."""
266 |     if name == "_data":
    |

praxis/backend/services/state.py:275:11: ISC001 Implicitly concatenated string literals on one line
    |
273 |     if name in self.__dict__:
274 |       return self.__dict__[name]
275 |     msg = f"'{type(self).__name__}' object has no attribute '{name}' and no key '{name}' in" " state data"
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ISC001
276 |     raise AttributeError(msg)
    |
    = help: Combine string literals

praxis/backend/services/state.py:278:43: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
276 |     raise AttributeError(msg)
277 | 
278 |   def __setattr__(self, name: str, value: Any) -> None:
    |                                           ^^^ ANN401
279 |     """Set state data as attributes."""
280 |     if name in ["run_accession_id", "redis_key", "redis_client", "_data"]:
    |

praxis/backend/services/utils/crud_base.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Generic CRUD base class for SQLAlchemy models.
2 | | """
  | |___^ D200
3 |   from typing import Any, Generic, TypeVar
  |
  = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:24:5: D200 One-line docstring should fit on one line
   |
23 |   class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
24 |       """Generic CRUD base class for SQLAlchemy models.
   |  _____^
25 | |     """
   | |_______^ D200
26 |   
27 |       def __init__(self, model: type[ModelType]):
   |
   = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:27:9: ANN204 Missing return type annotation for special method `__init__`
   |
25 |     """
26 | 
27 |     def __init__(self, model: type[ModelType]):
   |         ^^^^^^^^ ANN204
28 |         """CRUD object with default methods to Create, Read, Update, Delete (CRUD).
29 |         **Parameters**
   |
   = help: Add return type annotation: `None`

praxis/backend/services/utils/crud_base.py:28:9: D205 1 blank line required between summary line and description
   |
27 |       def __init__(self, model: type[ModelType]):
28 |           """CRUD object with default methods to Create, Read, Update, Delete (CRUD).
   |  _________^
29 | |         **Parameters**
30 | |         * `model`: A SQLAlchemy model class
31 | |         """
   | |___________^ D205
32 |           self.model = model
   |
   = help: Insert single blank line

praxis/backend/services/utils/crud_base.py:28:9: D400 First line should end with a period
   |
27 |       def __init__(self, model: type[ModelType]):
28 |           """CRUD object with default methods to Create, Read, Update, Delete (CRUD).
   |  _________^
29 | |         **Parameters**
30 | |         * `model`: A SQLAlchemy model class
31 | |         """
   | |___________^ D400
32 |           self.model = model
   |
   = help: Add period

praxis/backend/services/utils/crud_base.py:28:9: D415 First line should end with a period, question mark, or exclamation point
   |
27 |       def __init__(self, model: type[ModelType]):
28 |           """CRUD object with default methods to Create, Read, Update, Delete (CRUD).
   |  _________^
29 | |         **Parameters**
30 | |         * `model`: A SQLAlchemy model class
31 | |         """
   | |___________^ D415
32 |           self.model = model
   |
   = help: Add closing punctuation

praxis/backend/services/utils/crud_base.py:34:43: A002 Argument `id` is shadowing a Python builtin
   |
32 |         self.model = model
33 | 
34 |     async def get(self, db: AsyncSession, id: Any) -> ModelType | None:
   |                                           ^^ A002
35 |         """Get a single object by its primary key.
36 |         """
   |

praxis/backend/services/utils/crud_base.py:34:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `id`
   |
32 |         self.model = model
33 | 
34 |     async def get(self, db: AsyncSession, id: Any) -> ModelType | None:
   |                                               ^^^ ANN401
35 |         """Get a single object by its primary key.
36 |         """
   |

praxis/backend/services/utils/crud_base.py:35:9: D200 One-line docstring should fit on one line
   |
34 |       async def get(self, db: AsyncSession, id: Any) -> ModelType | None:
35 |           """Get a single object by its primary key.
   |  _________^
36 | |         """
   | |___________^ D200
37 |           statement = select(self.model).where(self.model.id == id)
38 |           result = await db.execute(statement)
   |
   = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:44:9: D200 One-line docstring should fit on one line
   |
42 |           self, db: AsyncSession, *, filters: SearchFilters,
43 |       ) -> list[ModelType]:
44 |           """Get multiple objects with filtering, sorting, and pagination.
   |  _________^
45 | |         """
   | |___________^ D200
46 |           statement = select(self.model)
47 |           statement = apply_search_filters(statement, self.model, filters.search_filters)
   |
   = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:57:9: D200 One-line docstring should fit on one line
   |
56 |       async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
57 |           """Create a new object.
   |  _________^
58 | |         """
   | |___________^ D200
59 |           obj_in_data = jsonable_encoder(obj_in)
60 |           db_obj = self.model(**obj_in_data)  # type: ignore
   |
   = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:60:45: PGH003 Use specific rule codes when ignoring type issues
   |
58 |         """
59 |         obj_in_data = jsonable_encoder(obj_in)
60 |         db_obj = self.model(**obj_in_data)  # type: ignore
   |                                             ^^^^^^^^^^^^^^ PGH003
61 |         db.add(db_obj)
62 |         await db.commit()
   |

praxis/backend/services/utils/crud_base.py:73:9: D200 One-line docstring should fit on one line
   |
71 |           obj_in: UpdateSchemaType | dict[str, Any],
72 |       ) -> ModelType:
73 |           """Update an existing object.
   |  _________^
74 | |         """
   | |___________^ D200
75 |           obj_data = jsonable_encoder(db_obj)
76 |           if isinstance(obj_in, dict):
   |
   = help: Reformat to one line

praxis/backend/services/utils/crud_base.py:76:9: SIM108 Use ternary operator `update_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)` instead of `if`-`else`-block
   |
74 |           """
75 |           obj_data = jsonable_encoder(db_obj)
76 |           if isinstance(obj_in, dict):
   |  _________^
77 | |             update_data = obj_in
78 | |         else:
79 | |             update_data = obj_in.dict(exclude_unset=True)
   | |_________________________________________________________^ SIM108
80 |           for field in obj_data:
81 |               if field in update_data:
   |
   = help: Replace `if`-`else`-block with `update_data = obj_in if isinstance(obj_in, dict) else obj_in.dict(exclude_unset=True)`

praxis/backend/services/utils/crud_base.py:88:49: A002 Argument `id` is shadowing a Python builtin
   |
86 |         return db_obj
87 | 
88 |     async def remove(self, db: AsyncSession, *, id: Any) -> ModelType | None:
   |                                                 ^^ A002
89 |         """Delete an object by its primary key.
90 |         """
   |

praxis/backend/services/utils/crud_base.py:88:53: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `id`
   |
86 |         return db_obj
87 | 
88 |     async def remove(self, db: AsyncSession, *, id: Any) -> ModelType | None:
   |                                                     ^^^ ANN401
89 |         """Delete an object by its primary key.
90 |         """
   |

praxis/backend/services/utils/crud_base.py:89:9: D200 One-line docstring should fit on one line
   |
88 |       async def remove(self, db: AsyncSession, *, id: Any) -> ModelType | None:
89 |           """Delete an object by its primary key.
   |  _________^
90 | |         """
   | |___________^ D200
91 |           statement = select(self.model).where(self.model.id == id)
92 |           result = await db.execute(statement)
   |
   = help: Reformat to one line

praxis/backend/services/well_outputs.py:67:5: TRY400 Use `logging.exception` instead of `logging.error`
   |
65 |   except ValueError as e:
66 |     error_msg = f"Invalid well name format: {e}"
67 |     logger.error("%s %s", log_prefix, error_msg)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
68 |     raise ValueError(error_msg) from e
   |
   = help: Replace with `exception`

praxis/backend/services/well_outputs.py:97:5: TRY300 Consider moving this statement to an `else` block
   |
95 |       well_output.accession_id,
96 |     )
97 |     return well_output
   |     ^^^^^^^^^^^^^^^^^^ TRY300
98 |   except Exception as e:
99 |     await db.rollback()
   |

praxis/backend/services/well_outputs.py:101:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
 99 |     await db.rollback()
100 |     error_msg = f"Failed to create well data output: {e!s}"
101 |     logger.error("%s %s", log_prefix, error_msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
102 |     raise ValueError(error_msg) from e
    |
    = help: Replace with `exception`

praxis/backend/services/well_outputs.py:172:5: TRY300 Consider moving this statement to an `else` block
    |
170 |       "%s Successfully created %d well data outputs.", log_prefix, len(well_outputs),
171 |     )
172 |     return well_outputs
    |     ^^^^^^^^^^^^^^^^^^^ TRY300
173 | 
174 |   except Exception as e:
    |

praxis/backend/services/well_outputs.py:177:11: TRY201 Use `raise` without specifying exception name
    |
175 |     await db.rollback()
176 |     logger.exception("%s Error creating well data outputs.", log_prefix)
177 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/well_outputs.py:261:5: TRY300 Consider moving this statement to an `else` block
    |
259 |       "%s Successfully created %d well data outputs.", log_prefix, len(well_outputs),
260 |     )
261 |     return well_outputs
    |     ^^^^^^^^^^^^^^^^^^^ TRY300
262 | 
263 |   except Exception as e:
    |

praxis/backend/services/well_outputs.py:266:11: TRY201 Use `raise` without specifying exception name
    |
264 |     await db.rollback()
265 |     logger.exception("%s Error creating well data outputs.", log_prefix)
266 |     raise e
    |           ^ TRY201
    |
    = help: Remove exception name

praxis/backend/services/well_outputs.py:298:11: PLR0913 Too many arguments in function definition (9 > 5)
    |
298 | async def read_well_data_outputs(
    |           ^^^^^^^^^^^^^^^^^^^^^^ PLR0913
299 |   db: AsyncSession,
300 |   plate_resource_id: UUID | None = None,
    |

praxis/backend/services/well_outputs.py:427:5: TRY300 Consider moving this statement to an `else` block
    |
425 |     await db.refresh(well_output)
426 |     logger.info("%s Successfully updated well data output.", log_prefix)
427 |     return well_output
    |     ^^^^^^^^^^^^^^^^^^ TRY300
428 |   except Exception as e:
429 |     await db.rollback()
    |

praxis/backend/services/well_outputs.py:431:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
429 |     await db.rollback()
430 |     error_msg = f"Failed to update well data output: {e!s}"
431 |     logger.error("%s %s", log_prefix, error_msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
432 |     raise ValueError(error_msg) from e
    |
    = help: Replace with `exception`

praxis/backend/services/well_outputs.py:478:5: TRY300 Consider moving this statement to an `else` block
    |
476 |       deleted_count,
477 |     )
478 |     return deleted_count > 0
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
479 |   except Exception as e:
480 |     await db.rollback()
    |

praxis/backend/services/well_outputs.py:482:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
480 |     await db.rollback()
481 |     error_msg = f"Failed to delete well data output: {e!s}"
482 |     logger.error("%s %s", log_prefix, error_msg)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
483 |     raise ValueError(error_msg) from e
    |
    = help: Replace with `exception`

praxis/backend/services/workcell.py:35:5: D200 One-line docstring should fit on one line
   |
34 |   class WorkcellService(CRUDBase[WorkcellOrm, WorkcellCreate, WorkcellUpdate]):
35 |       """Service for workcell-related operations.
   |  _____^
36 | |     """
   | |_______^ D200
37 |   
38 |       async def create(self, db: AsyncSession, *, obj_in: WorkcellCreate) -> WorkcellOrm:
   |
   = help: Reformat to one line

praxis/backend/services/workcell.py:60:13: TRY300 Consider moving this statement to an `else` block
   |
58 |                 workcell_orm.accession_id,
59 |             )
60 |             return workcell_orm
   |             ^^^^^^^^^^^^^^^^^^^ TRY300
61 |         except IntegrityError as e:
62 |             await db.rollback()
   |

praxis/backend/services/workcell.py:66:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   |
64 |                 f"Workcell with name '{obj_in.name}' already exists. Details: {e}"
65 |             )
66 |             logger.error(error_message, exc_info=True)
   |                    ^^^^^ G201
67 |             raise ValueError(error_message) from e
68 |         except Exception as e:
   |

praxis/backend/services/workcell.py:71:19: TRY201 Use `raise` without specifying exception name
   |
69 |             logger.exception("Error creating workcell '%s'. Rolling back.", obj_in.name)
70 |             await db.rollback()
71 |             raise e
   |                   ^ TRY201
72 | 
73 |     async def get(self, db: AsyncSession, id: uuid.UUID) -> WorkcellOrm | None:
   |
   = help: Remove exception name

praxis/backend/services/workcell.py:73:43: A002 Argument `id` is shadowing a Python builtin
   |
71 |             raise e
72 | 
73 |     async def get(self, db: AsyncSession, id: uuid.UUID) -> WorkcellOrm | None:
   |                                           ^^ A002
74 |         """Retrieve a specific workcell by its ID."""
75 |         logger.info("Attempting to retrieve workcell with ID: %s.", id)
   |

praxis/backend/services/workcell.py:157:13: TRY300 Consider moving this statement to an `else` block
    |
155 |                 db_obj.name,
156 |             )
157 |             return db_obj
    |             ^^^^^^^^^^^^^ TRY300
158 |         except IntegrityError as e:
159 |             await db.rollback()
    |

praxis/backend/services/workcell.py:161:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
159 |             await db.rollback()
160 |             error_message = f"Workcell with name '{obj_in.name}' already exists. Details: {e}"
161 |             logger.error(error_message, exc_info=True)
    |                    ^^^^^ G201
162 |             raise ValueError(error_message) from e
163 |         except Exception as e:
    |

praxis/backend/services/workcell.py:170:19: TRY201 Use `raise` without specifying exception name
    |
168 |                 db_obj.accession_id,
169 |             )
170 |             raise e
    |                   ^ TRY201
171 | 
172 |     async def remove(self, db: AsyncSession, *, id: uuid.UUID) -> bool:
    |
    = help: Remove exception name

praxis/backend/services/workcell.py:172:49: A002 Argument `id` is shadowing a Python builtin
    |
170 |             raise e
171 | 
172 |     async def remove(self, db: AsyncSession, *, id: uuid.UUID) -> bool:
    |                                                 ^^ A002
173 |         """Delete a specific workcell by its ID."""
174 |         logger.info("Attempting to delete workcell with ID: %s.", id)
    |

praxis/backend/services/workcell.py:188:13: TRY300 Consider moving this statement to an `else` block
    |
186 |                 workcell_orm.name,
187 |             )
188 |             return True
    |             ^^^^^^^^^^^ TRY300
189 |         except IntegrityError as e:
190 |             await db.rollback()
    |

praxis/backend/services/workcell.py:195:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
193 |                 f" foreign key constraints, e.g., associated machines. Details: {e}"
194 |             )
195 |             logger.error(error_message, exc_info=True)
    |                    ^^^^^ G201
196 |             return False
197 |         except Exception as e:
    |

praxis/backend/services/workcell.py:203:19: TRY201 Use `raise` without specifying exception name
    |
201 |                 id,
202 |             )
203 |             raise e
    |                   ^ TRY201
204 | 
205 |     async def read_workcell_state(
    |
    = help: Remove exception name

praxis/backend/services/workcell.py:213:21: G004 Logging statement uses f-string
    |
211 |             if workcell_orm and workcell_orm.latest_state_json:
212 |                 logger.debug(
213 |                     f"Retrieved workcell state from DB for ID {workcell_accession_id}.",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
214 |                 )
215 |                 return workcell_orm.latest_state_json
    |

praxis/backend/services/workcell.py:217:17: G004 Logging statement uses f-string
    |
215 |                 return workcell_orm.latest_state_json
216 |             logger.info(
217 |                 f"No state found for workcell ID {workcell_accession_id} in DB.",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
218 |             )
219 |             return None
    |

praxis/backend/services/workcell.py:219:13: TRY300 Consider moving this statement to an `else` block
    |
217 |                 f"No state found for workcell ID {workcell_accession_id} in DB.",
218 |             )
219 |             return None
    |             ^^^^^^^^^^^ TRY300
220 |         except Exception as e:
221 |             logger.error(
    |

praxis/backend/services/workcell.py:221:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
219 |             return None
220 |         except Exception as e:
221 |             logger.error(
    |                    ^^^^^ G201
222 |                 f"Failed to retrieve workcell state from DB for ID {workcell_accession_id}: {e}",
223 |                 exc_info=True,
    |

praxis/backend/services/workcell.py:222:17: G004 Logging statement uses f-string
    |
220 |         except Exception as e:
221 |             logger.error(
222 |                 f"Failed to retrieve workcell state from DB for ID {workcell_accession_id}: {e}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
223 |                 exc_info=True,
224 |             )
    |

praxis/backend/services/workcell.py:237:17: TRY301 Abstract `raise` to an inner function
    |
235 |               workcell_orm = await db_session.get(self.model, workcell_accession_id)
236 |               if not workcell_orm:
237 |                   raise ValueError(
    |  _________________^
238 | |                     f"WorkcellOrm with ID {workcell_accession_id} not found for state update.",
239 | |                 )
    | |_________________^ TRY301
240 |   
241 |               workcell_orm.latest_state_json = state_json
    |

praxis/backend/services/workcell.py:237:23: TRY003 Avoid specifying long messages outside the exception class
    |
235 |               workcell_orm = await db_session.get(self.model, workcell_accession_id)
236 |               if not workcell_orm:
237 |                   raise ValueError(
    |  _______________________^
238 | |                     f"WorkcellOrm with ID {workcell_accession_id} not found for state update.",
239 | |                 )
    | |_________________^ TRY003
240 |   
241 |               workcell_orm.latest_state_json = state_json
    |

praxis/backend/services/workcell.py:238:21: EM102 Exception must not use an f-string literal, assign to variable first
    |
236 |             if not workcell_orm:
237 |                 raise ValueError(
238 |                     f"WorkcellOrm with ID {workcell_accession_id} not found for state update.",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
239 |                 )
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/services/workcell.py:248:17: G004 Logging statement uses f-string
    |
246 |             await db_session.flush()
247 |             logger.debug(
248 |                 f"Workcell state for ID {workcell_accession_id} updated in DB.",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
249 |             )
250 |             return workcell_orm
    |

praxis/backend/services/workcell.py:250:13: TRY300 Consider moving this statement to an `else` block
    |
248 |                 f"Workcell state for ID {workcell_accession_id} updated in DB.",
249 |             )
250 |             return workcell_orm
    |             ^^^^^^^^^^^^^^^^^^^ TRY300
251 |         except Exception as e:
252 |             logger.error(
    |

praxis/backend/services/workcell.py:252:20: G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
    |
250 |             return workcell_orm
251 |         except Exception as e:
252 |             logger.error(
    |                    ^^^^^ G201
253 |                 f"Failed to update workcell state in DB for ID {workcell_accession_id}: {e}",
254 |                 exc_info=True,
    |

praxis/backend/services/workcell.py:253:17: G004 Logging statement uses f-string
    |
251 |         except Exception as e:
252 |             logger.error(
253 |                 f"Failed to update workcell state in DB for ID {workcell_accession_id}: {e}",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ G004
254 |                 exc_info=True,
255 |             )
    |

praxis/backend/utils/__init__.py:1:1: F403 `from ..services.state import *` used; unable to detect undefined names
  |
1 | from ..services.state import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F403
2 | from .db import *
3 | from .errors import *
  |

praxis/backend/utils/__init__.py:1:1: TID252 Prefer absolute imports over relative imports from parent modules
  |
1 | from ..services.state import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TID252
2 | from .db import *
3 | from .errors import *
  |
  = help: Replace relative imports from parent modules with absolute imports

praxis/backend/utils/__init__.py:1:1: D104 Missing docstring in public package
praxis/backend/utils/__init__.py:2:1: F403 `from .db import *` used; unable to detect undefined names
  |
1 | from ..services.state import *
2 | from .db import *
  | ^^^^^^^^^^^^^^^^^ F403
3 | from .errors import *
4 | from .logging import *
  |

praxis/backend/utils/__init__.py:3:1: F403 `from .errors import *` used; unable to detect undefined names
  |
1 | from ..services.state import *
2 | from .db import *
3 | from .errors import *
  | ^^^^^^^^^^^^^^^^^^^^^ F403
4 | from .logging import *
5 | from .notify import *
  |

praxis/backend/utils/__init__.py:4:1: F403 `from .logging import *` used; unable to detect undefined names
  |
2 | from .db import *
3 | from .errors import *
4 | from .logging import *
  | ^^^^^^^^^^^^^^^^^^^^^^ F403
5 | from .notify import *
6 | from .redis_lock import *
  |

praxis/backend/utils/__init__.py:5:1: F403 `from .notify import *` used; unable to detect undefined names
  |
3 | from .errors import *
4 | from .logging import *
5 | from .notify import *
  | ^^^^^^^^^^^^^^^^^^^^^ F403
6 | from .redis_lock import *
7 | from .sanitation import *
  |

praxis/backend/utils/__init__.py:6:1: F403 `from .redis_lock import *` used; unable to detect undefined names
  |
4 | from .logging import *
5 | from .notify import *
6 | from .redis_lock import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^ F403
7 | from .sanitation import *
8 | from .schemas import *
  |

praxis/backend/utils/__init__.py:7:1: F403 `from .sanitation import *` used; unable to detect undefined names
  |
5 | from .notify import *
6 | from .redis_lock import *
7 | from .sanitation import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^ F403
8 | from .schemas import *
9 | from .uuid import uuid4, uuid7
  |

praxis/backend/utils/__init__.py:8:1: F403 `from .schemas import *` used; unable to detect undefined names
  |
6 | from .redis_lock import *
7 | from .sanitation import *
8 | from .schemas import *
  | ^^^^^^^^^^^^^^^^^^^^^^ F403
9 | from .uuid import uuid4, uuid7
  |

praxis/backend/utils/__init__.py:9:19: F401 `.uuid.uuid4` imported but unused; consider removing, adding to `__all__`, or using a redundant alias
  |
7 | from .sanitation import *
8 | from .schemas import *
9 | from .uuid import uuid4, uuid7
  |                   ^^^^^ F401
  |
  = help: Use an explicit re-export: `uuid4 as uuid4`

praxis/backend/utils/__init__.py:9:26: F401 `.uuid.uuid7` imported but unused; consider removing, adding to `__all__`, or using a redundant alias
  |
7 | from .sanitation import *
8 | from .schemas import *
9 | from .uuid import uuid4, uuid7
  |                          ^^^^^ F401
  |
  = help: Use an explicit re-export: `uuid7 as uuid7`

praxis/backend/utils/accession_resolver.py:63:11: TRY003 Avoid specifying long messages outside the exception class
   |
61 |     # This case should not be hit if using FastAPI's type hints correctly,
62 |     # but it's good practice to handle it.
63 |     raise TypeError(f"Invalid accession type provided: {type(accession)}")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
64 | 
65 |   # If we reach this point, 'obj' is None, meaning no entity was found.
   |

praxis/backend/utils/accession_resolver.py:63:21: EM102 Exception must not use an f-string literal, assign to variable first
   |
61 |     # This case should not be hit if using FastAPI's type hints correctly,
62 |     # but it's good practice to handle it.
63 |     raise TypeError(f"Invalid accession type provided: {type(accession)}")
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
64 | 
65 |   # If we reach this point, 'obj' is None, meaning no entity was found.
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/accession_resolver.py:66:9: TRY003 Avoid specifying long messages outside the exception class
   |
65 |   # If we reach this point, 'obj' is None, meaning no entity was found.
66 |   raise ValueError(f"{entity_type_name} with accession '{accession}' not found.")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
   |

praxis/backend/utils/accession_resolver.py:66:20: EM102 Exception must not use an f-string literal, assign to variable first
   |
65 |   # If we reach this point, 'obj' is None, meaning no entity was found.
66 |   raise ValueError(f"{entity_type_name} with accession '{accession}' not found.")
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/db.py:19:9: TRY003 Avoid specifying long messages outside the exception class
   |
17 |   if not CONFIG_FILE_PATH.exists():
18 |     logger.error("Configuration file praxis.ini not found at %s", CONFIG_FILE_PATH)
19 |     raise FileNotFoundError(
   |  _________^
20 | |     f"Configuration file praxis.ini not found at {CONFIG_FILE_PATH}",
21 | |   )
   | |___^ TRY003
22 |   
23 |   config_parser = ConfigParser()
   |

praxis/backend/utils/db.py:20:5: EM102 Exception must not use an f-string literal, assign to variable first
   |
18 |   logger.error("Configuration file praxis.ini not found at %s", CONFIG_FILE_PATH)
19 |   raise FileNotFoundError(
20 |     f"Configuration file praxis.ini not found at {CONFIG_FILE_PATH}",
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
21 |   )
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/db.py:31:8: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
29 |   praxis_db_password = config_parser.get(
30 |     "database", "password", fallback="password",
31 |   )  # TODO: Use a secure method for production
   |        ^^^^ TD002
32 |   praxis_db_host = config_parser.get("database", "host", fallback="localhost")
33 |   praxis_db_port = config_parser.get("database", "port", fallback="5432")
   |

praxis/backend/utils/db.py:31:8: TD003 Missing issue link on the line following this TODO
   |
29 |   praxis_db_password = config_parser.get(
30 |     "database", "password", fallback="password",
31 |   )  # TODO: Use a secure method for production
   |        ^^^^ TD003
32 |   praxis_db_host = config_parser.get("database", "host", fallback="localhost")
33 |   praxis_db_port = config_parser.get("database", "port", fallback="5432")
   |

praxis/backend/utils/db.py:31:8: FIX002 Line contains TODO, consider resolving the issue
   |
29 |   praxis_db_password = config_parser.get(
30 |     "database", "password", fallback="password",
31 |   )  # TODO: Use a secure method for production
   |        ^^^^ FIX002
32 |   praxis_db_host = config_parser.get("database", "host", fallback="localhost")
33 |   praxis_db_port = config_parser.get("database", "port", fallback="5432")
   |

praxis/backend/utils/db.py:39:8: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
37 |   praxis_db_password = os.getenv(
38 |     "POSTGRES_PASSWORD", praxis_db_password,
39 |   )  # TODO: Use a secure method for production
   |        ^^^^ TD002
40 |   praxis_db_host = os.getenv("POSTGRES_HOST", praxis_db_host)
41 |   praxis_db_port = os.getenv("POSTGRES_PORT", praxis_db_port)
   |

praxis/backend/utils/db.py:39:8: TD003 Missing issue link on the line following this TODO
   |
37 |   praxis_db_password = os.getenv(
38 |     "POSTGRES_PASSWORD", praxis_db_password,
39 |   )  # TODO: Use a secure method for production
   |        ^^^^ TD003
40 |   praxis_db_host = os.getenv("POSTGRES_HOST", praxis_db_host)
41 |   praxis_db_port = os.getenv("POSTGRES_PORT", praxis_db_port)
   |

praxis/backend/utils/db.py:39:8: FIX002 Line contains TODO, consider resolving the issue
   |
37 |   praxis_db_password = os.getenv(
38 |     "POSTGRES_PASSWORD", praxis_db_password,
39 |   )  # TODO: Use a secure method for production
   |        ^^^^ FIX002
40 |   praxis_db_host = os.getenv("POSTGRES_HOST", praxis_db_host)
41 |   praxis_db_port = os.getenv("POSTGRES_PORT", praxis_db_port)
   |

praxis/backend/utils/db.py:53:8: BLE001 Do not catch blind exception: `Exception`
   |
51 |   )
52 | 
53 | except Exception as e:
   |        ^^^^^^^^^ BLE001
54 |   logger.error("Error reading Praxis database configuration from praxis.ini: %s", e)
55 |   praxis_database_url = "postgresql+asyncpg://user:password@localhost:5432/praxis_db"
   |

praxis/backend/utils/db.py:54:3: TRY400 Use `logging.exception` instead of `logging.error`
   |
53 | except Exception as e:
54 |   logger.error("Error reading Praxis database configuration from praxis.ini: %s", e)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
55 |   praxis_database_url = "postgresql+asyncpg://user:password@localhost:5432/praxis_db"
56 |   logger.warning(
   |
   = help: Replace with `exception`

praxis/backend/utils/db.py:98:8: BLE001 Do not catch blind exception: `Exception`
   |
96 |       "Keycloak DSN not available from this module for PraxisDBService.",
97 |     )
98 | except Exception as e:
   |        ^^^^^^^^^ BLE001
99 |   logger.error("Error reading Keycloak database DSN from praxis.ini: %s", e)
   |

praxis/backend/utils/db.py:99:3: TRY400 Use `logging.exception` instead of `logging.error`
    |
 97 |     )
 98 | except Exception as e:
 99 |   logger.error("Error reading Keycloak database DSN from praxis.ini: %s", e)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
100 | 
101 | KEYCLOAK_DSN_FROM_CONFIG = keycloak_dsn_from_config
    |
    = help: Replace with `exception`

praxis/backend/utils/db.py:142:11: ANN201 Missing return type annotation for public function `init_praxis_db_schema`
    |
141 | # --- Database Initialization Function (for Praxis DB Schema) ---
142 | async def init_praxis_db_schema():
    |           ^^^^^^^^^^^^^^^^^^^^^ ANN201
143 |   """Initialize the Praxis database schema.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/db.py:159:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
157 |     )
158 |   except Exception as e:
159 |     logger.error("Error creating Praxis database tables: %s", e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
160 |     raise
    |
    = help: Replace with `exception`

praxis/backend/utils/errors.py:12:7: ANN204 Missing return type annotation for special method `__init__`
   |
10 |   """
11 | 
12 |   def __init__(self, message: str):
   |       ^^^^^^^^ ANN204
13 |     """Initialize a new instance of the PraxisError.
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:35:7: ANN204 Missing return type annotation for special method `__init__`
   |
33 |   """
34 | 
35 |   def __init__(self, message: str):
   |       ^^^^^^^^ ANN204
36 |     """Initialize a new instance of the OrchestratorError.
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:58:7: ANN204 Missing return type annotation for special method `__init__`
   |
56 |   """
57 | 
58 |   def __init__(self, message: str):
   |       ^^^^^^^^ ANN204
59 |     """Initialize a new instance of the DataError.
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:81:7: ANN204 Missing return type annotation for special method `__init__`
   |
79 |   """
80 | 
81 |   def __init__(self, message: str):
   |       ^^^^^^^^ ANN204
82 |     """Initialize a new instance of the ModelError.
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:104:7: ANN204 Missing return type annotation for special method `__init__`
    |
102 |   """
103 | 
104 |   def __init__(self, message: str):
    |       ^^^^^^^^ ANN204
105 |     """Initialize a new instance of the AssetAcquisitionError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:127:7: ANN204 Missing return type annotation for special method `__init__`
    |
125 |   """
126 | 
127 |   def __init__(self, message: str):
    |       ^^^^^^^^ ANN204
128 |     """Initialize a new instance of the AssetReleaseError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:150:7: ANN204 Missing return type annotation for special method `__init__`
    |
148 |   """
149 | 
150 |   def __init__(self, message: str = "Protocol run was cancelled."):
    |       ^^^^^^^^ ANN204
151 |     """Initialize a new instance of the ProtocolCancelledError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:174:7: ANN204 Missing return type annotation for special method `__init__`
    |
172 |   """
173 | 
174 |   def __init__(self, message: str):
    |       ^^^^^^^^ ANN204
175 |     """Initialize a new instance of the WorkcellRuntimeError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:192:7: ANN204 Missing return type annotation for special method `__init__`
    |
190 |   """Base exception for PyLabRobot-related errors within Praxis."""
191 | 
192 |   def __init__(self, message: str, original_plr_exception: Exception | None = None):
    |       ^^^^^^^^ ANN204
193 |     """Initialize a new instance of the PylabRobotError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:208:7: ANN204 Missing return type annotation for special method `__init__`
    |
206 |   """Specific error for PyLabRobot 'TooLittleLiquidError' scenarios."""
207 | 
208 |   def __init__(
    |       ^^^^^^^^ ANN204
209 |     self,
210 |     message="Too little liquid for transfer.",
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:210:5: ANN001 Missing type annotation for function argument `message`
    |
208 |   def __init__(
209 |     self,
210 |     message="Too little liquid for transfer.",
    |     ^^^^^^^ ANN001
211 |     details=None,
212 |     original_plr_exception: Exception | None = None,
    |

praxis/backend/utils/errors.py:211:5: ANN001 Missing type annotation for function argument `details`
    |
209 |     self,
210 |     message="Too little liquid for transfer.",
211 |     details=None,
    |     ^^^^^^^ ANN001
212 |     original_plr_exception: Exception | None = None,
213 |   ):
    |

praxis/backend/utils/errors.py:230:7: ANN204 Missing return type annotation for special method `__init__`
    |
228 |   """Generic placeholder for other PyLabRobot errors."""
229 | 
230 |   def __init__(
    |       ^^^^^^^^ ANN204
231 |     self,
232 |     message="A PyLabRobot operation failed.",
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/errors.py:232:5: ANN001 Missing type annotation for function argument `message`
    |
230 |   def __init__(
231 |     self,
232 |     message="A PyLabRobot operation failed.",
    |     ^^^^^^^ ANN001
233 |     original_plr_exception: Exception | None = None,
234 |   ):
    |

praxis/backend/utils/errors.py:247:7: ANN204 Missing return type annotation for special method `__init__`
    |
245 |   """
246 | 
247 |   def __init__(self, message: str):
    |       ^^^^^^^^ ANN204
248 |     """Initialize a new instance of the PraxisAPIError.
    |
    = help: Add return type annotation: `None`

praxis/backend/utils/logging.py:10:5: ANN201 Missing return type annotation for public function `get_logger`
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |     ^^^^^^^^^^ ANN201
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |
   = help: Add return type annotation

praxis/backend/utils/logging.py:10:16: ANN001 Missing type annotation for function argument `name`
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                ^^^^ ANN001
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

praxis/backend/utils/logging.py:10:26: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^ TD002
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

praxis/backend/utils/logging.py:10:26: TD003 Missing issue link on the line following this TODO
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^ TD003
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

praxis/backend/utils/logging.py:10:26: FIX002 Line contains TODO, consider resolving the issue
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^ FIX002
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

praxis/backend/utils/logging.py:21:5: PLR0913 Too many arguments in function definition (8 > 5)
   |
21 | def _process_exception(
   |     ^^^^^^^^^^^^^^^^^^ PLR0913
22 |   logger_instance: logging.Logger,
23 |   exception: Exception,
   |

praxis/backend/utils/logging.py:25:3: FBT001 Boolean-typed positional argument in function definition
   |
23 |   exception: Exception,
24 |   exception_type: type[Exception],
25 |   raises: bool,
   |   ^^^^^^ FBT001
26 |   raises_exception: type[Exception],
27 |   prefix: str,
   |

praxis/backend/utils/logging.py:29:12: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
   |
27 |   prefix: str,
28 |   suffix: str,
29 |   return_: Any,
   |            ^^^ ANN401
30 | ) -> Any:
31 |   """Process the exception to generate a custom error message."""
   |

praxis/backend/utils/logging.py:30:6: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_process_exception`
   |
28 |   suffix: str,
29 |   return_: Any,
30 | ) -> Any:
   |      ^^^ ANN401
31 |   """Process the exception to generate a custom error message."""
32 |   error_message = f"{prefix}{exception.__class__.__name__}: \
   |

praxis/backend/utils/logging.py:51:5: PLR0913 Too many arguments in function definition (7 > 5)
   |
51 | def log_async_runtime_errors(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
   |

praxis/backend/utils/logging.py:54:3: FBT001 Boolean-typed positional argument in function definition
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^ FBT001
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

praxis/backend/utils/logging.py:54:3: FBT002 Boolean default positional argument in function definition
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^ FBT002
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

praxis/backend/utils/logging.py:58:12: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
   |
56 |   prefix: str = "",
57 |   suffix: str = "",
58 |   return_: Any = None,
   |            ^^^ ANN401
59 | ) -> Callable:
60 |   """Log specified exceptions in a function and optionally re-raise them.
   |

praxis/backend/utils/logging.py:94:30: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                              ^^^ ANN401
95 |       try:
96 |         return await func(*args, **kwargs)
   |

praxis/backend/utils/logging.py:94:45: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                             ^^^ ANN401
95 |       try:
96 |         return await func(*args, **kwargs)
   |

praxis/backend/utils/logging.py:94:53: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                                     ^^^ ANN401
95 |       try:
96 |         return await func(*args, **kwargs)
   |

praxis/backend/utils/logging.py:97:14: BLE001 Do not catch blind exception: `Exception`
   |
95 |       try:
96 |         return await func(*args, **kwargs)
97 |       except Exception as e:
   |              ^^^^^^^^^ BLE001
98 |         _process_exception(
99 |           logger_instance=logger_instance,
   |

praxis/backend/utils/logging.py:114:5: PLR0913 Too many arguments in function definition (7 > 5)
    |
114 | def log_runtime_errors(
    |     ^^^^^^^^^^^^^^^^^^ PLR0913
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
    |

praxis/backend/utils/logging.py:117:3: FBT001 Boolean-typed positional argument in function definition
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^ FBT001
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

praxis/backend/utils/logging.py:117:3: FBT002 Boolean default positional argument in function definition
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^ FBT002
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

praxis/backend/utils/logging.py:121:12: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
    |
119 |   prefix: str = "",
120 |   suffix: str = "",
121 |   return_: Any = None,
    |            ^^^ ANN401
122 | ) -> Callable:
123 |   """Log specified exceptions in a function and optionally re-raise them.
    |

praxis/backend/utils/logging.py:157:24: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                        ^^^ ANN401
158 |       try:
159 |         return func(*args, **kwargs)
    |

praxis/backend/utils/logging.py:157:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                       ^^^ ANN401
158 |       try:
159 |         return func(*args, **kwargs)
    |

praxis/backend/utils/logging.py:157:47: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                               ^^^ ANN401
158 |       try:
159 |         return func(*args, **kwargs)
    |

praxis/backend/utils/logging.py:160:14: BLE001 Do not catch blind exception: `Exception`
    |
158 |       try:
159 |         return func(*args, **kwargs)
160 |       except Exception as e:
    |              ^^^^^^^^^ BLE001
161 |         _process_exception(
162 |           logger_instance=logger_instance,
    |

praxis/backend/utils/notify.py:7:1: TID252 Prefer absolute imports over relative imports from parent modules
  |
5 | from email.mime.text import MIMEText
6 | 
7 | from ..configure import PraxisConfiguration
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TID252
8 | 
9 | CELLPHONE_CARRIER_GATEWAYS = {
  |
  = help: Replace relative imports from parent modules with absolute imports

praxis/backend/utils/notify.py:40:7: ANN204 Missing return type annotation for special method `__init__`
   |
38 |   """A utility class for sending email and SMS notifications."""
39 | 
40 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password):
   |       ^^^^^^^^ ANN204
41 |     """Initialize the Notifier with SMTP server details."""
42 |     self.smtp_server = smtp_server
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/notify.py:40:22: ANN001 Missing type annotation for function argument `smtp_server`
   |
38 |   """A utility class for sending email and SMS notifications."""
39 | 
40 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password):
   |                      ^^^^^^^^^^^ ANN001
41 |     """Initialize the Notifier with SMTP server details."""
42 |     self.smtp_server = smtp_server
   |

praxis/backend/utils/notify.py:40:35: ANN001 Missing type annotation for function argument `smtp_port`
   |
38 |   """A utility class for sending email and SMS notifications."""
39 | 
40 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password):
   |                                   ^^^^^^^^^ ANN001
41 |     """Initialize the Notifier with SMTP server details."""
42 |     self.smtp_server = smtp_server
   |

praxis/backend/utils/notify.py:40:46: ANN001 Missing type annotation for function argument `smtp_username`
   |
38 |   """A utility class for sending email and SMS notifications."""
39 | 
40 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password):
   |                                              ^^^^^^^^^^^^^ ANN001
41 |     """Initialize the Notifier with SMTP server details."""
42 |     self.smtp_server = smtp_server
   |

praxis/backend/utils/notify.py:40:61: ANN001 Missing type annotation for function argument `smtp_password`
   |
38 |   """A utility class for sending email and SMS notifications."""
39 | 
40 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password):
   |                                                             ^^^^^^^^^^^^^ ANN001
41 |     """Initialize the Notifier with SMTP server details."""
42 |     self.smtp_server = smtp_server
   |

praxis/backend/utils/notify.py:47:7: ANN201 Missing return type annotation for public function `send_email`
   |
45 |     self.smtp_password = smtp_password
46 | 
47 |   def send_email(
   |       ^^^^^^^^^^ ANN201
48 |     self, sender_email: str, recipient_email: str, subject: str, body: str,
49 |   ):
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/notify.py:69:7: T201 `print` found
   |
67 |         server.login(self.smtp_username, self.smtp_password)
68 |         server.send_message(message)
69 |       print("Email sent!")
   |       ^^^^^ T201
70 |     except Exception as e:
71 |       print(f"Error sending email: {e}")
   |
   = help: Remove `print`

praxis/backend/utils/notify.py:70:12: BLE001 Do not catch blind exception: `Exception`
   |
68 |         server.send_message(message)
69 |       print("Email sent!")
70 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
71 |       print(f"Error sending email: {e}")
   |

praxis/backend/utils/notify.py:71:7: T201 `print` found
   |
69 |       print("Email sent!")
70 |     except Exception as e:
71 |       print(f"Error sending email: {e}")
   |       ^^^^^ T201
72 | 
73 |   def send_text(
   |
   = help: Remove `print`

praxis/backend/utils/notify.py:73:7: ANN201 Missing return type annotation for public function `send_text`
   |
71 |       print(f"Error sending email: {e}")
72 | 
73 |   def send_text(
   |       ^^^^^^^^^ ANN201
74 |     self,
75 |     sender_email: str,
   |
   = help: Add return type annotation: `None`

praxis/backend/utils/plr_inspection.py:17:3: PLC0414 Import alias does not rename original package
   |
15 | # PyLabRobot Imports
16 | from pylabrobot.resources import (
17 |   Deck as Deck,
   |   ^^^^^^^^^^^^ PLC0414
18 | )
19 | from pylabrobot.resources import (
   |
   = help: Remove import alias

praxis/backend/utils/plr_inspection.py:20:3: PLC0414 Import alias does not rename original package
   |
18 | )
19 | from pylabrobot.resources import (
20 |   Resource as Resource,
   |   ^^^^^^^^^^^^^^^^^^^^ PLC0414
21 | )
22 | from pylabrobot.resources import (
   |
   = help: Remove import alias

praxis/backend/utils/plr_inspection.py:42:11: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `module`
   |
41 | def get_module_classes(
42 |   module: Any, parent_class: type[Any] | None = None, concrete_only: bool = False,
   |           ^^^ ANN401
43 | ) -> dict[str, type[Any]]:
44 |   """Get all classes from a module that are subclasses of parent_class.
   |

praxis/backend/utils/plr_inspection.py:42:55: FBT001 Boolean-typed positional argument in function definition
   |
41 | def get_module_classes(
42 |   module: Any, parent_class: type[Any] | None = None, concrete_only: bool = False,
   |                                                       ^^^^^^^^^^^^^ FBT001
43 | ) -> dict[str, type[Any]]:
44 |   """Get all classes from a module that are subclasses of parent_class.
   |

praxis/backend/utils/plr_inspection.py:42:55: FBT002 Boolean default positional argument in function definition
   |
41 | def get_module_classes(
42 |   module: Any, parent_class: type[Any] | None = None, concrete_only: bool = False,
   |                                                       ^^^^^^^^^^^^^ FBT002
43 | ) -> dict[str, type[Any]]:
44 |   """Get all classes from a module that are subclasses of parent_class.
   |

praxis/backend/utils/plr_inspection.py:66:13: B007 Loop control variable `importer` not used within loop body
   |
64 |       is_submodule_class = False
65 |       if hasattr(module, "__path__"):  # Check if module is a package
66 |         for importer, modname, ispkg in pkgutil.iter_modules(
   |             ^^^^^^^^ B007
67 |           module.__path__, module.__name__ + ".",
68 |         ):
   |
   = help: Rename unused `importer` to `_importer`

praxis/backend/utils/plr_inspection.py:66:32: B007 Loop control variable `ispkg` not used within loop body
   |
64 |       is_submodule_class = False
65 |       if hasattr(module, "__path__"):  # Check if module is a package
66 |         for importer, modname, ispkg in pkgutil.iter_modules(
   |                                ^^^^^ B007
67 |           module.__path__, module.__name__ + ".",
68 |         ):
   |
   = help: Rename unused `ispkg` to `_ispkg`

praxis/backend/utils/plr_inspection.py:82:21: FBT001 Boolean-typed positional argument in function definition
   |
81 | def get_constructor_params_with_defaults(
82 |   klass: type[Any], required_only: bool = False,
   |                     ^^^^^^^^^^^^^ FBT001
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

praxis/backend/utils/plr_inspection.py:82:21: FBT002 Boolean default positional argument in function definition
   |
81 | def get_constructor_params_with_defaults(
82 |   klass: type[Any], required_only: bool = False,
   |                     ^^^^^^^^^^^^^ FBT002
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

praxis/backend/utils/plr_inspection.py:99:10: PLR1714 Consider merging multiple comparisons: `name in ("self", "args", "kwargs")`. Use a `set` if the elements are hashable.
    |
 97 |     signature = inspect.signature(klass.__init__)
 98 |     for name, param in signature.parameters.items():
 99 |       if name == "self" or name == "args" or name == "kwargs":
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR1714
100 |         continue
101 |       if required_only and param.default is not inspect.Parameter.empty:
    |
    = help: Merge multiple comparisons

praxis/backend/utils/plr_inspection.py:104:10: BLE001 Do not catch blind exception: `Exception`
    |
102 |         continue
103 |       params[name] = param.default
104 |   except Exception as e:
    |          ^^^^^^^^^ BLE001
105 |     logger.error("Error inspecting constructor for %s: %s", get_class_fqn(klass), e)
106 |   return params
    |

praxis/backend/utils/plr_inspection.py:105:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
103 |       params[name] = param.default
104 |   except Exception as e:
105 |     logger.error("Error inspecting constructor for %s: %s", get_class_fqn(klass), e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
106 |   return params
    |
    = help: Replace with `exception`

praxis/backend/utils/plr_inspection.py:142:3: FBT001 Boolean-typed positional argument in function definition
    |
140 |   module_name: str,
141 |   parent_class: type[Any] | None,
142 |   concrete_only: bool,
    |   ^^^^^^^^^^^^^ FBT001
143 |   visited_modules: set[str],
144 | ) -> dict[str, type[Any]]:
    |

praxis/backend/utils/plr_inspection.py:165:9: B007 Loop control variable `klass_name` not used within loop body
    |
163 |     module = importlib.import_module(module_name)
164 |     classes_in_module = get_module_classes(module, parent_class, concrete_only)
165 |     for klass_name, klass in classes_in_module.items():
    |         ^^^^^^^^^^ B007
166 |       if klass.__module__.startswith(
167 |         module_name,
    |
    = help: Rename unused `klass_name` to `_klass_name`

praxis/backend/utils/plr_inspection.py:165:30: PERF102 When using only the values of a dict use the `values()` method
    |
163 |     module = importlib.import_module(module_name)
164 |     classes_in_module = get_module_classes(module, parent_class, concrete_only)
165 |     for klass_name, klass in classes_in_module.items():
    |                              ^^^^^^^^^^^^^^^^^^^^^^^ PERF102
166 |       if klass.__module__.startswith(
167 |         module_name,
    |
    = help: Replace `.items()` with `.values()`

praxis/backend/utils/plr_inspection.py:186:10: BLE001 Do not catch blind exception: `Exception`
    |
184 |   except ImportError as e:
185 |     logger.warning("Could not import module %s: %s", module_name, e)
186 |   except Exception as e:
    |          ^^^^^^^^^ BLE001
187 |     logger.error("Error processing module %s: %s", module_name, e)
188 |   return found_classes
    |

praxis/backend/utils/plr_inspection.py:187:5: TRY400 Use `logging.exception` instead of `logging.error`
    |
185 |     logger.warning("Could not import module %s: %s", module_name, e)
186 |   except Exception as e:
187 |     logger.error("Error processing module %s: %s", module_name, e)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
188 |   return found_classes
    |
    = help: Replace with `exception`

praxis/backend/utils/plr_inspection.py:194:3: FBT001 Boolean-typed positional argument in function definition
    |
192 |   base_module_names: str | list[str] = "pylabrobot",
193 |   parent_class: type[Any] | None = None,
194 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^ FBT001
195 | ) -> dict[str, type[Any]]:
196 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

praxis/backend/utils/plr_inspection.py:194:3: FBT002 Boolean default positional argument in function definition
    |
192 |   base_module_names: str | list[str] = "pylabrobot",
193 |   parent_class: type[Any] | None = None,
194 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^ FBT002
195 | ) -> dict[str, type[Any]]:
196 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

praxis/backend/utils/plr_inspection.py:222:3: FBT001 Boolean-typed positional argument in function definition
    |
221 | def get_resource_classes(
222 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
223 | ) -> dict[str, type[Resource]]:
224 |   """Return all resource classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:222:3: FBT002 Boolean default positional argument in function definition
    |
221 | def get_resource_classes(
222 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
223 | ) -> dict[str, type[Resource]]:
224 |   """Return all resource classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:225:28: PGH003 Use specific rule codes when ignoring type issues
    |
223 | ) -> dict[str, type[Resource]]:
224 |   """Return all resource classes from PyLabRobot modules."""
225 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
226 |     base_module_names=[
227 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:236:3: FBT001 Boolean-typed positional argument in function definition
    |
235 | def get_machine_classes(
236 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
237 | ) -> dict[str, type[Machine]]:
238 |   """Return all machine classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:236:3: FBT002 Boolean default positional argument in function definition
    |
235 | def get_machine_classes(
236 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
237 | ) -> dict[str, type[Machine]]:
238 |   """Return all machine classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:239:28: PGH003 Use specific rule codes when ignoring type issues
    |
237 | ) -> dict[str, type[Machine]]:
238 |   """Return all machine classes from PyLabRobot modules."""
239 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
240 |     base_module_names="pylabrobot.machines",
241 |     parent_class=Machine,
    |

praxis/backend/utils/plr_inspection.py:246:22: FBT001 Boolean-typed positional argument in function definition
    |
246 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^ FBT001
247 |   """Return all deck classes from PyLabRobot modules."""
248 |   all_decks = get_all_classes(  # type: ignore
    |

praxis/backend/utils/plr_inspection.py:246:22: FBT002 Boolean default positional argument in function definition
    |
246 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^ FBT002
247 |   """Return all deck classes from PyLabRobot modules."""
248 |   all_decks = get_all_classes(  # type: ignore
    |

praxis/backend/utils/plr_inspection.py:248:33: PGH003 Use specific rule codes when ignoring type issues
    |
246 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
247 |   """Return all deck classes from PyLabRobot modules."""
248 |   all_decks = get_all_classes(  # type: ignore
    |                                 ^^^^^^^^^^^^^^ PGH003
249 |     base_module_names=[
250 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:281:11: PERF403 Use a dictionary comprehension instead of a for-loop
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PERF403
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |

praxis/backend/utils/plr_inspection.py:281:54: PGH003 Use specific rule codes when ignoring type issues
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |                                                      ^^^^^^^^^^^^^^ PGH003
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |

praxis/backend/utils/plr_inspection.py:282:5: PERF203 `try`-`except` within a loop incurs performance overhead
    |
280 |           if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |             discovered_deck_classes[fqn] = deck_class  # type: ignore
282 |       except ImportError:
    |  _____^
283 | |       logger.warning("Package %s not found during deck discovery.", package_name)
    | |_________________________________________________________________________________^ PERF203
284 |       except Exception as e:
285 |         logger.error("Error discovering deck classes in package %s: %s", package_name, e)
    |

praxis/backend/utils/plr_inspection.py:284:12: BLE001 Do not catch blind exception: `Exception`
    |
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
284 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
285 |       logger.error("Error discovering deck classes in package %s: %s", package_name, e)
286 |   return discovered_deck_classes
    |

praxis/backend/utils/plr_inspection.py:285:7: TRY400 Use `logging.exception` instead of `logging.error`
    |
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
284 |     except Exception as e:
285 |       logger.error("Error discovering deck classes in package %s: %s", package_name, e)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
286 |   return discovered_deck_classes
    |
    = help: Replace with `exception`

praxis/backend/utils/plr_inspection.py:289:5: C901 `_get_accepted_categories_for_resource_holder` is too complex (11 > 10)
    |
289 | def _get_accepted_categories_for_resource_holder(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C901
290 |   holder: ResourceHolder, parent_carrier: Carrier | None = None,
291 | ) -> list[str]:
    |

praxis/backend/utils/plr_inspection.py:326:3: FBT001 Boolean-typed positional argument in function definition
    |
325 | def get_resource_holder_classes(
326 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
327 | ) -> dict[str, type[ResourceHolder]]:
328 |   """Return all resource holder and specific carrier classes.
    |

praxis/backend/utils/plr_inspection.py:326:3: FBT002 Boolean default positional argument in function definition
    |
325 | def get_resource_holder_classes(
326 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
327 | ) -> dict[str, type[ResourceHolder]]:
328 |   """Return all resource holder and specific carrier classes.
    |

praxis/backend/utils/plr_inspection.py:332:28: PGH003 Use specific rule codes when ignoring type issues
    |
330 |   Includes holders and specific carriers from PyLabRobot modules.
331 |   """
332 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
333 |     base_module_names=[
334 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:343:3: FBT001 Boolean-typed positional argument in function definition
    |
342 | def get_carrier_classes(
343 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
344 | ) -> dict[str, type[Carrier]]:
345 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

praxis/backend/utils/plr_inspection.py:343:3: FBT002 Boolean default positional argument in function definition
    |
342 | def get_carrier_classes(
343 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
344 | ) -> dict[str, type[Carrier]]:
345 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

praxis/backend/utils/plr_inspection.py:349:28: PGH003 Use specific rule codes when ignoring type issues
    |
347 |   Includes all carrier types from PyLabRobot modules.
348 |   """
349 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
350 |     base_module_names=[
351 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:360:3: FBT001 Boolean-typed positional argument in function definition
    |
359 | def get_plate_carrier_classes(
360 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
361 | ) -> dict[str, type[PlateCarrier]]:
362 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:360:3: FBT002 Boolean default positional argument in function definition
    |
359 | def get_plate_carrier_classes(
360 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
361 | ) -> dict[str, type[PlateCarrier]]:
362 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:363:28: PGH003 Use specific rule codes when ignoring type issues
    |
361 | ) -> dict[str, type[PlateCarrier]]:
362 |   """Return all plate carrier classes from PyLabRobot modules."""
363 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
364 |     base_module_names=[
365 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:374:3: FBT001 Boolean-typed positional argument in function definition
    |
373 | def get_tip_carrier_classes(
374 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
375 | ) -> dict[str, type[TipCarrier]]:
376 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:374:3: FBT002 Boolean default positional argument in function definition
    |
373 | def get_tip_carrier_classes(
374 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
375 | ) -> dict[str, type[TipCarrier]]:
376 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:377:28: PGH003 Use specific rule codes when ignoring type issues
    |
375 | ) -> dict[str, type[TipCarrier]]:
376 |   """Return all tip carrier classes from PyLabRobot modules."""
377 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
378 |     base_module_names=[
379 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:388:3: FBT001 Boolean-typed positional argument in function definition
    |
387 | def get_trough_carrier_classes(
388 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
389 | ) -> dict[str, type[TroughCarrier]]:
390 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:388:3: FBT002 Boolean default positional argument in function definition
    |
387 | def get_trough_carrier_classes(
388 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
389 | ) -> dict[str, type[TroughCarrier]]:
390 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:391:28: PGH003 Use specific rule codes when ignoring type issues
    |
389 | ) -> dict[str, type[TroughCarrier]]:
390 |   """Return all trough carrier classes from PyLabRobot modules."""
391 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^ PGH003
392 |     base_module_names=[
393 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:402:3: FBT001 Boolean-typed positional argument in function definition
    |
401 | def get_all_carrier_classes(
402 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
403 | ) -> dict[str, type[Carrier]]:
404 |   """Return all carrier classes.
    |

praxis/backend/utils/plr_inspection.py:402:3: FBT002 Boolean default positional argument in function definition
    |
401 | def get_all_carrier_classes(
402 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
403 | ) -> dict[str, type[Carrier]]:
404 |   """Return all carrier classes.
    |

praxis/backend/utils/plr_inspection.py:416:36: PGH003 Use specific rule codes when ignoring type issues
    |
415 |   """
416 |   all_carriers = get_all_classes(  # type: ignore
    |                                    ^^^^^^^^^^^^^^ PGH003
417 |     base_module_names=[
418 |       "pylabrobot.resources",
    |

praxis/backend/utils/plr_inspection.py:432:3: FBT001 Boolean-typed positional argument in function definition
    |
431 | def get_all_deck_and_carrier_classes(
432 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
433 | ) -> dict[str, type[Deck | Carrier]]:
434 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:432:3: FBT002 Boolean default positional argument in function definition
    |
431 | def get_all_deck_and_carrier_classes(
432 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
433 | ) -> dict[str, type[Deck | Carrier]]:
434 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:441:3: FBT001 Boolean-typed positional argument in function definition
    |
440 | def get_all_resource_classes(
441 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
442 | ) -> dict[str, type[Resource]]:
443 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:441:3: FBT002 Boolean default positional argument in function definition
    |
440 | def get_all_resource_classes(
441 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
442 | ) -> dict[str, type[Resource]]:
443 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:450:3: FBT001 Boolean-typed positional argument in function definition
    |
449 | def get_all_machine_and_deck_classes(
450 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
451 | ) -> dict[str, type[Machine | Deck]]:
452 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:450:3: FBT002 Boolean default positional argument in function definition
    |
449 | def get_all_machine_and_deck_classes(
450 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
451 | ) -> dict[str, type[Machine | Deck]]:
452 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

praxis/backend/utils/plr_inspection.py:461:3: FBT001 Boolean-typed positional argument in function definition
    |
459 |   base_module_names: str | list[str] = "pylabrobot",
460 |   parent_class: type[Any] | None = None,
461 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^ FBT001
462 | ) -> dict[str, type[Any]]:
463 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

praxis/backend/utils/plr_inspection.py:461:3: FBT002 Boolean default positional argument in function definition
    |
459 |   base_module_names: str | list[str] = "pylabrobot",
460 |   parent_class: type[Any] | None = None,
461 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^ FBT002
462 | ) -> dict[str, type[Any]]:
463 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

praxis/backend/utils/plr_inspection.py:503:3: FBT001 Boolean-typed positional argument in function definition
    |
502 | def get_all_resource_and_machine_classes(
503 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
504 | ) -> dict[str, type[Any]]:
505 |   """Return all resources and machine classes.
    |

praxis/backend/utils/plr_inspection.py:503:3: FBT002 Boolean default positional argument in function definition
    |
502 | def get_all_resource_and_machine_classes(
503 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
504 | ) -> dict[str, type[Any]]:
505 |   """Return all resources and machine classes.
    |

praxis/backend/utils/plr_inspection.py:515:3: FBT001 Boolean-typed positional argument in function definition
    |
514 | def get_deck_and_carrier_classes(
515 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
516 | ) -> dict[str, type[Any]]:
517 |   """Return all deck and carrier classes with enhanced inspection.
    |

praxis/backend/utils/plr_inspection.py:515:3: FBT002 Boolean default positional argument in function definition
    |
514 | def get_deck_and_carrier_classes(
515 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
516 | ) -> dict[str, type[Any]]:
517 |   """Return all deck and carrier classes with enhanced inspection.
    |

praxis/backend/utils/plr_inspection.py:537:3: FBT001 Boolean-typed positional argument in function definition
    |
536 | def get_all_resource_and_machine_classes_enhanced(
537 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT001
538 | ) -> dict[str, type[Any]]:
539 |   """Return all resources and machine classes with enhanced inspection.
    |

praxis/backend/utils/plr_inspection.py:537:3: FBT002 Boolean default positional argument in function definition
    |
536 | def get_all_resource_and_machine_classes_enhanced(
537 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^ FBT002
538 | ) -> dict[str, type[Any]]:
539 |   """Return all resources and machine classes with enhanced inspection.
    |

praxis/backend/utils/redis_lock.py:1:1: D100 Missing docstring in public module
praxis/backend/utils/redis_lock.py:8:5: ANN201 Missing return type annotation for public function `acquire_lock`
   |
 7 | @contextlib.contextmanager
 8 | def acquire_lock(
   |     ^^^^^^^^^^^^ ANN201
 9 |   redis_client: redis.Redis,
10 |   resource_name: str,
   |
   = help: Add return type annotation

praxis/backend/utils/redis_lock.py:45:5: T201 `print` found
   |
43 |     yield False
44 |   except Exception as e:
45 |     print(f"Error acquiring or releasing lock: {e}")
   |     ^^^^^ T201
46 |     raise
47 |   finally:
   |
   = help: Remove `print`

praxis/backend/utils/redis_lock.py:53:9: T201 `print` found
   |
51 |         redis_client.delete(lock_name)
52 |       except Exception as e:
53 |         print(f"Error releasing lock: {e}")
   |         ^^^^^ T201
54 |         raise
   |
   = help: Remove `print`

praxis/backend/utils/run_control.py:18:3: ERA001 Found commented-out code
   |
16 |   # Assuming settings.redis_host and settings.redis_port are available
17 |   # If settings.redis_url is directly available, that would be preferred:
18 |   # redis_url = settings.redis_url
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
19 |   redis_url = f"redis://{settings.redis_host}:{settings.redis_port}/0"
20 |   return redis.Redis.from_url(redis_url, decode_responses=True)
   |
   = help: Remove commented-out code

praxis/backend/utils/run_control.py:40:11: TRY003 Avoid specifying long messages outside the exception class
   |
38 |     """
39 |     if command not in ALLOWED_COMMANDS:
40 |       raise ValueError(
   |  ___________^
41 | |       f"Invalid command: {command}. Allowed commands are: {ALLOWED_COMMANDS}",
42 | |     )
   | |_____^ TRY003
43 |     try:
44 |       r = _get_redis_client()
   |

praxis/backend/utils/run_control.py:41:7: EM102 Exception must not use an f-string literal, assign to variable first
   |
39 |   if command not in ALLOWED_COMMANDS:
40 |     raise ValueError(
41 |       f"Invalid command: {command}. Allowed commands are: {ALLOWED_COMMANDS}",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
42 |     )
43 |   try:
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/run_control.py:47:5: TRY300 Consider moving this statement to an `else` block
   |
45 |     key = _get_command_key(run_accession_id)
46 |     await r.set(key, command, ex=ttl_seconds)
47 |     return True
   |     ^^^^^^^^^^^ TRY300
48 |   except RedisError as e:
49 |     # In a real application, use a proper logger
   |

praxis/backend/utils/run_control.py:50:5: T201 `print` found
   |
48 |   except RedisError as e:
49 |     # In a real application, use a proper logger
50 |     print(f"RedisError sending control command for run {run_accession_id}: {e}")
   |     ^^^^^ T201
51 |     return False
   |
   = help: Remove `print`

praxis/backend/utils/run_control.py:68:5: TRY300 Consider moving this statement to an `else` block
   |
66 |     key = _get_command_key(run_accession_id)
67 |     command = await r.get(key)
68 |     return command  # Returns None if key doesn't exist
   |     ^^^^^^^^^^^^^^ TRY300
69 |   except RedisError as e:
70 |     print(f"RedisError getting control command for run {run_accession_id}: {e}")
   |

praxis/backend/utils/run_control.py:68:12: RET504 Unnecessary assignment to `command` before `return` statement
   |
66 |     key = _get_command_key(run_accession_id)
67 |     command = await r.get(key)
68 |     return command  # Returns None if key doesn't exist
   |            ^^^^^^^ RET504
69 |   except RedisError as e:
70 |     print(f"RedisError getting control command for run {run_accession_id}: {e}")
   |
   = help: Remove unnecessary assignment

praxis/backend/utils/run_control.py:70:5: T201 `print` found
   |
68 |     return command  # Returns None if key doesn't exist
69 |   except RedisError as e:
70 |     print(f"RedisError getting control command for run {run_accession_id}: {e}")
   |     ^^^^^ T201
71 |     return None
   |
   = help: Remove `print`

praxis/backend/utils/run_control.py:88:5: TRY300 Consider moving this statement to an `else` block
   |
86 |     key = _get_command_key(run_accession_id)
87 |     deleted_count = await r.delete(key)
88 |     return deleted_count > 0
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
89 |   except RedisError as e:
90 |     print(f"RedisError clearing control command for run {run_accession_id}: {e}")
   |

praxis/backend/utils/run_control.py:90:5: T201 `print` found
   |
88 |     return deleted_count > 0
89 |   except RedisError as e:
90 |     print(f"RedisError clearing control command for run {run_accession_id}: {e}")
   |     ^^^^^ T201
91 |     return False
   |
   = help: Remove `print`

praxis/backend/utils/sanitation.py:1:1: D100 Missing docstring in public module
praxis/backend/utils/sanitation.py:10:11: D103 Missing docstring in public function
   |
10 | async def well_to_int(well: Well, plate: Plate) -> int:
   |           ^^^^^^^^^^^ D103
11 |   column, row = await parse_well_name(well)
12 |   return int((column * plate.num_items_y) + row)
   |

praxis/backend/utils/sanitation.py:15:5: ANN201 Missing return type annotation for public function `liquid_handler_setup_check`
   |
15 | def liquid_handler_setup_check(func):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |
   = help: Add return type annotation

praxis/backend/utils/sanitation.py:15:32: ANN001 Missing type annotation for function argument `func`
   |
15 | def liquid_handler_setup_check(func):
   |                                ^^^^ ANN001
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |

praxis/backend/utils/sanitation.py:16:3: D205 1 blank line required between summary line and description
   |
15 |   def liquid_handler_setup_check(func):
16 |     """A decorator function that checks if a liquid handler is set up before executing the decorated
   |  ___^
17 | |   function.
18 | | 
19 | |   Args:
20 | |     func: The function to be decorated.
21 | | 
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | | 
26 | |   Returns:
27 | |     The decorated function.
28 | | 
29 | |   """
   | |_____^ D205
30 |   
31 |     @wraps(func)
   |
   = help: Insert single blank line

praxis/backend/utils/sanitation.py:16:3: D401 First line of docstring should be in imperative mood: "A decorator function that checks if a liquid handler is set up before executing the decorated"
   |
15 |   def liquid_handler_setup_check(func):
16 |     """A decorator function that checks if a liquid handler is set up before executing the decorated
   |  ___^
17 | |   function.
18 | | 
19 | |   Args:
20 | |     func: The function to be decorated.
21 | | 
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | | 
26 | |   Returns:
27 | |     The decorated function.
28 | | 
29 | |   """
   | |_____^ D401
30 |   
31 |     @wraps(func)
   |

praxis/backend/utils/sanitation.py:32:13: ANN202 Missing return type annotation for private function `wrapper`
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |             ^^^^^^^ ANN202
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       raise ValueError("No liquid handler provided")
   |
   = help: Add return type annotation

praxis/backend/utils/sanitation.py:32:21: ANN002 Missing type annotation for `*args`
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                     ^^^^^ ANN002
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       raise ValueError("No liquid handler provided")
   |

praxis/backend/utils/sanitation.py:32:28: ANN003 Missing type annotation for `**kwargs`
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                            ^^^^^^^^ ANN003
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       raise ValueError("No liquid handler provided")
   |

praxis/backend/utils/sanitation.py:34:13: TRY003 Avoid specifying long messages outside the exception class
   |
32 |   async def wrapper(*args, **kwargs):
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       raise ValueError("No liquid handler provided")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
35 |     if args:
36 |       liquid_handler = args[0]
   |

praxis/backend/utils/sanitation.py:34:24: EM101 Exception must not use a string literal, assign to variable first
   |
32 |   async def wrapper(*args, **kwargs):
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       raise ValueError("No liquid handler provided")
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
35 |     if args:
36 |       liquid_handler = args[0]
   |
   = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:35:5: SIM108 Use ternary operator `liquid_handler = args[0] if args else kwargs["liquid_handler"]` instead of `if`-`else`-block
   |
33 |       if len(args) == 0 and "liquid_handler" not in kwargs:
34 |         raise ValueError("No liquid handler provided")
35 |       if args:
   |  _____^
36 | |       liquid_handler = args[0]
37 | |     else:
38 | |       liquid_handler = kwargs["liquid_handler"]
   | |_______________________________________________^ SIM108
39 |       if not liquid_handler.setup_finished:
40 |         raise RuntimeError("Liquid handler not set up")
   |
   = help: Replace `if`-`else`-block with `liquid_handler = args[0] if args else kwargs["liquid_handler"]`

praxis/backend/utils/sanitation.py:40:13: TRY003 Avoid specifying long messages outside the exception class
   |
38 |       liquid_handler = kwargs["liquid_handler"]
39 |     if not liquid_handler.setup_finished:
40 |       raise RuntimeError("Liquid handler not set up")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
41 |     return await func(*args, **kwargs)
   |

praxis/backend/utils/sanitation.py:40:26: EM101 Exception must not use a string literal, assign to variable first
   |
38 |       liquid_handler = kwargs["liquid_handler"]
39 |     if not liquid_handler.setup_finished:
40 |       raise RuntimeError("Liquid handler not set up")
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
41 |     return await func(*args, **kwargs)
   |
   = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:46:11: D417 Missing argument description in the docstring for `coerce_to_list`: `target_length`
   |
46 | async def coerce_to_list(items: list | tuple, target_length: int | None) -> list:
   |           ^^^^^^^^^^^^^^ D417
47 |   """Coerces the given items into a list.
   |

praxis/backend/utils/sanitation.py:62:14: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
60 |     if item is None:
61 |       new_items.append(None)
62 |     elif not isinstance(item, (list, tuple)):
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
63 |       new_items.append([item] * target_length)
64 |     elif len(item) == 1:
   |
   = help: Convert to `X | Y`

praxis/backend/utils/sanitation.py:69:13: TRY003 Avoid specifying long messages outside the exception class
   |
67 |         new_items.append(item)
68 |       else:
69 |         raise ValueError(
   |  _____________^
70 | |         f"Expected list of length {target_length} but got list of length \
71 | |           {len(item)}",
72 | |       )
   | |_______^ TRY003
73 |     return new_items
   |

praxis/backend/utils/sanitation.py:70:9: EM102 Exception must not use an f-string literal, assign to variable first
   |
68 |       else:
69 |         raise ValueError(
70 |           f"Expected list of length {target_length} but got list of length \
   |  _________^
71 | |           {len(item)}",
   | |______________________^ EM102
72 |         )
73 |     return new_items
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:87:11: TRY003 Avoid specifying long messages outside the exception class
   |
85 |     # if the val is a list, it must be of the correct length.
86 |     if len(val) != len(default):
87 |       raise ValueError(
   |  ___________^
88 | |       f"Value length must equal num operations ({len(default)}), but is {val}",
89 | |     )
   | |_____^ TRY003
90 |     # if the val is a list of the correct length, the values must be of the right type.
91 |     if not all(isinstance(v, t) for v in val):
   |

praxis/backend/utils/sanitation.py:88:7: EM102 Exception must not use an f-string literal, assign to variable first
   |
86 |   if len(val) != len(default):
87 |     raise ValueError(
88 |       f"Value length must equal num operations ({len(default)}), but is {val}",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
89 |     )
90 |   # if the val is a list of the correct length, the values must be of the right type.
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:92:11: TRY003 Avoid specifying long messages outside the exception class
   |
90 |   # if the val is a list of the correct length, the values must be of the right type.
91 |   if not all(isinstance(v, t) for v in val):
92 |     raise ValueError(f"Value must be a list of {t}, but is {val}")
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
93 |   # the value is ready to be used.
94 |   return val
   |

praxis/backend/utils/sanitation.py:92:22: EM102 Exception must not use an f-string literal, assign to variable first
   |
90 |   # if the val is a list of the correct length, the values must be of the right type.
91 |   if not all(isinstance(v, t) for v in val):
92 |     raise ValueError(f"Value must be a list of {t}, but is {val}")
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
93 |   # the value is ready to be used.
94 |   return val
   |
   = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:104:48: FBT001 Boolean-typed positional argument in function definition
    |
104 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^ FBT001
105 |   """Check the types of items in a list against a given list of types.
    |

praxis/backend/utils/sanitation.py:104:48: FBT002 Boolean default positional argument in function definition
    |
104 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^ FBT002
105 |   """Check the types of items in a list against a given list of types.
    |

praxis/backend/utils/sanitation.py:119:5: SIM102 Use a single `if` statement instead of nested `if` statements
    |
117 |     """
118 |     for item, item_type in zip(items, types, strict=False):
119 |       if in_list:
    |  _____^
120 | |       if not all(isinstance(i, item_type) for i in item):
    | |_________________________________________________________^ SIM102
121 |           raise ValueError(f"Expected {item_type} but got {type(item)}")
122 |       if not isinstance(item, item_type):
    |
    = help: Combine `if` statements using `and`

praxis/backend/utils/sanitation.py:121:15: TRY003 Avoid specifying long messages outside the exception class
    |
119 |     if in_list:
120 |       if not all(isinstance(i, item_type) for i in item):
121 |         raise ValueError(f"Expected {item_type} but got {type(item)}")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
122 |     if not isinstance(item, item_type):
123 |       raise ValueError(f"Expected {item_type} but got {type(item)}")
    |

praxis/backend/utils/sanitation.py:121:26: EM102 Exception must not use an f-string literal, assign to variable first
    |
119 |     if in_list:
120 |       if not all(isinstance(i, item_type) for i in item):
121 |         raise ValueError(f"Expected {item_type} but got {type(item)}")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
122 |     if not isinstance(item, item_type):
123 |       raise ValueError(f"Expected {item_type} but got {type(item)}")
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:123:7: TRY004 Prefer `TypeError` exception for invalid type
    |
121 |         raise ValueError(f"Expected {item_type} but got {type(item)}")
122 |     if not isinstance(item, item_type):
123 |       raise ValueError(f"Expected {item_type} but got {type(item)}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
    |

praxis/backend/utils/sanitation.py:123:13: TRY003 Avoid specifying long messages outside the exception class
    |
121 |         raise ValueError(f"Expected {item_type} but got {type(item)}")
122 |     if not isinstance(item, item_type):
123 |       raise ValueError(f"Expected {item_type} but got {type(item)}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
    |

praxis/backend/utils/sanitation.py:123:24: EM102 Exception must not use an f-string literal, assign to variable first
    |
121 |         raise ValueError(f"Expected {item_type} but got {type(item)}")
122 |     if not isinstance(item, item_type):
123 |       raise ValueError(f"Expected {item_type} but got {type(item)}")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:126:11: D417 Missing argument descriptions in the docstring for `check_list_length`: `coerce_length`, `target_length`
    |
126 | async def check_list_length(
    |           ^^^^^^^^^^^^^^^^^ D417
127 |   items: list[Any] | list[list[Any]],
128 |   coerce_length: bool = False,
    |

praxis/backend/utils/sanitation.py:128:3: FBT001 Boolean-typed positional argument in function definition
    |
126 | async def check_list_length(
127 |   items: list[Any] | list[list[Any]],
128 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^ FBT001
129 |   target_length: int | None = None,
130 | ) -> list[list[Any]]:
    |

praxis/backend/utils/sanitation.py:128:3: FBT002 Boolean default positional argument in function definition
    |
126 | async def check_list_length(
127 |   items: list[Any] | list[list[Any]],
128 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^ FBT002
129 |   target_length: int | None = None,
130 | ) -> list[list[Any]]:
    |

praxis/backend/utils/sanitation.py:147:3: SIM102 Use a single `if` statement instead of nested `if` statements
    |
145 |     if target_length is None:
146 |       length = len(items[0])
147 |     if not isinstance(items[0], list):
    |  ___^
148 | |     if len(items) != target_length:
    | |___________________________________^ SIM102
149 |         if len(items) == 1 and coerce_length:
150 |           assert target_length is not None, "Expected target length to be provided"
    |
    = help: Combine `if` statements using `and`

praxis/backend/utils/sanitation.py:150:9: S101 Use of `assert` detected
    |
148 |     if len(items) != target_length:
149 |       if len(items) == 1 and coerce_length:
150 |         assert target_length is not None, "Expected target length to be provided"
    |         ^^^^^^ S101
151 |         return items * target_length
152 |       raise ValueError(
    |

praxis/backend/utils/sanitation.py:152:13: TRY003 Avoid specifying long messages outside the exception class
    |
150 |           assert target_length is not None, "Expected target length to be provided"
151 |           return items * target_length
152 |         raise ValueError(
    |  _____________^
153 | |         f"Expected list of length {length} but got list of length {len(items)}",
154 | |       )
    | |_______^ TRY003
155 |     new_items = []
156 |     for item in items:
    |

praxis/backend/utils/sanitation.py:153:9: EM102 Exception must not use an f-string literal, assign to variable first
    |
151 |         return items * target_length
152 |       raise ValueError(
153 |         f"Expected list of length {length} but got list of length {len(items)}",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
154 |       )
155 |   new_items = []
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:158:7: TRY004 Prefer `TypeError` exception for invalid type
    |
156 |   for item in items:
157 |     if not isinstance(item, list):
158 |       raise ValueError(f"Expected list but got {type(item)}")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY004
159 |     if len(item) != target_length:
160 |       if len(item) == 1 and coerce_length:
    |

praxis/backend/utils/sanitation.py:158:13: TRY003 Avoid specifying long messages outside the exception class
    |
156 |   for item in items:
157 |     if not isinstance(item, list):
158 |       raise ValueError(f"Expected list but got {type(item)}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
159 |     if len(item) != target_length:
160 |       if len(item) == 1 and coerce_length:
    |

praxis/backend/utils/sanitation.py:158:24: EM102 Exception must not use an f-string literal, assign to variable first
    |
156 |   for item in items:
157 |     if not isinstance(item, list):
158 |       raise ValueError(f"Expected list but got {type(item)}")
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
159 |     if len(item) != target_length:
160 |       if len(item) == 1 and coerce_length:
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:161:9: S101 Use of `assert` detected
    |
159 |     if len(item) != target_length:
160 |       if len(item) == 1 and coerce_length:
161 |         assert target_length is not None, (
    |         ^^^^^^ S101
162 |           "Expected target length to be provided"
163 |         )  # mypy assert
    |

praxis/backend/utils/sanitation.py:166:15: TRY003 Avoid specifying long messages outside the exception class
    |
164 |           new_items.append(item * target_length)
165 |         else:
166 |           raise ValueError(
    |  _______________^
167 | |           f"Expected list of length {length} but got list of length {len(item)}",
168 | |         )
    | |_________^ TRY003
169 |     if all(len(item) == target_length for item in items):
170 |       return items
    |

praxis/backend/utils/sanitation.py:167:11: EM102 Exception must not use an f-string literal, assign to variable first
    |
165 |       else:
166 |         raise ValueError(
167 |           f"Expected list of length {length} but got list of length {len(item)}",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
168 |         )
169 |   if all(len(item) == target_length for item in items):
    |
    = help: Assign to variable; remove f-string literal

praxis/backend/utils/sanitation.py:174:11: D417 Missing argument description in the docstring for `parse_well_name`: `well`
    |
174 | async def parse_well_name(well: Well) -> tuple:
    |           ^^^^^^^^^^^^^^^ D417
175 |   """Parse the name of a well into a tuple of the row and column.
    |

praxis/backend/utils/sanitation.py:190:11: D417 Missing argument descriptions in the docstring for `parse_well_str_accession_id`: `plate`, `well`
    |
190 | async def parse_well_str_accession_id(well: str, plate: Plate) -> list[Well]:
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D417
191 |   """Parse the name of a well into a tuple of the row and column.
    |

praxis/backend/utils/sanitation.py:203:11: C901 `tip_mapping` is too complex (12 > 10)
    |
203 | async def tip_mapping(
    |           ^^^^^^^^^^^ C901
204 |   tips: TipRack | list[TipSpot],
205 |   sources: list[Well],
    |

praxis/backend/utils/sanitation.py:203:11: PLR0913 Too many arguments in function definition (6 > 5)
    |
203 | async def tip_mapping(
    |           ^^^^^^^^^^^ PLR0913
204 |   tips: TipRack | list[TipSpot],
205 |   sources: list[Well],
    |

praxis/backend/utils/sanitation.py:203:11: D417 Missing argument descriptions in the docstring for `tip_mapping`: `map_tips`, `source_plate`, `target_plate`
    |
203 | async def tip_mapping(
    |           ^^^^^^^^^^^ D417
204 |   tips: TipRack | list[TipSpot],
205 |   sources: list[Well],
    |

praxis/backend/utils/sanitation.py:207:3: ARG001 Unused function argument: `target_plate`
    |
205 |   sources: list[Well],
206 |   source_plate: Plate,
207 |   target_plate: Plate | None = None,
    |   ^^^^^^^^^^^^ ARG001
208 |   targets: list[Well] | None = None,
209 |   map_tips: Literal["source", "target"] | None = None,
    |

praxis/backend/utils/sanitation.py:211:3: D205 1 blank line required between summary line and description
    |
209 |     map_tips: Literal["source", "target"] | None = None,
210 |   ) -> list[TipSpot]:
211 |     """Check if tips can be mapped between either source or destination containers based on if they
    |  ___^
212 | |   are wells, and that the number of tips is sufficient for the number of sources and targets.
213 | | 
214 | |   Args:
215 | |     tips (TipRack | list[TipSpot]): The list of tips to be mapped.
216 | |     sources (list[Well]): The list of source containers.
217 | |     targets (list[Well]): The list of destination containers.
218 | | 
219 | |   Raises:
220 | |     ValueError: If the tips cannot be mapped between either the source and target containers.
221 | |     NotImplementedError: If multiple tip racks are used to map between source or target containers.
222 | |     ValueError: If the tip rack does not have a tip at the specified location.
223 | |     ValueError: If the type of the tip is not a list of Tip objects or a single TipRack.
224 | |     ValueError: If the value of map_tips is not "source" or "target".
225 | |     ValueError: If the number of tips is insufficient for the number of sources or targets.
226 | | 
227 | |   Returns:
228 | |     tips: The list of tips, either from the input or from mapping between source, target, and
229 | |     tip rack.
230 | | 
231 | |   """
    | |_____^ D205
232 |     if isinstance(tips, list):
233 |       if all(isinstance(tip, TipSpot) for tip in tips):
    |
    = help: Insert single blank line

praxis/backend/utils/sanitation.py:235:11: TRY003 Avoid specifying long messages outside the exception class
    |
233 |       if all(isinstance(tip, TipSpot) for tip in tips):
234 |         return [tip for tip in tips if isinstance(tip, TipSpot)]  # mypy compatible return
235 |       raise ValueError(
    |  ___________^
236 | |       "Invalid type for tip. Must be a list of TipSpot objects or TipRack.",
237 | |     )
    | |_____^ TRY003
238 |     if map_tips is None:
239 |       map_tips = "source"
    |

praxis/backend/utils/sanitation.py:236:7: EM101 Exception must not use a string literal, assign to variable first
    |
234 |       return [tip for tip in tips if isinstance(tip, TipSpot)]  # mypy compatible return
235 |     raise ValueError(
236 |       "Invalid type for tip. Must be a list of TipSpot objects or TipRack.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
237 |     )
238 |   if map_tips is None:
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:241:11: TRY003 Avoid specifying long messages outside the exception class
    |
239 |     map_tips = "source"
240 |   if map_tips not in ["source", "target"]:
241 |     raise ValueError("Invalid value for map_tips. Must be either 'source' or 'target'.")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
242 |   if targets is None and map_tips == "target":
243 |     warnings.warn(
    |

praxis/backend/utils/sanitation.py:241:22: EM101 Exception must not use a string literal, assign to variable first
    |
239 |     map_tips = "source"
240 |   if map_tips not in ["source", "target"]:
241 |     raise ValueError("Invalid value for map_tips. Must be either 'source' or 'target'.")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
242 |   if targets is None and map_tips == "target":
243 |     warnings.warn(
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:243:5: B028 No explicit `stacklevel` keyword argument found
    |
241 |     raise ValueError("Invalid value for map_tips. Must be either 'source' or 'target'.")
242 |   if targets is None and map_tips == "target":
243 |     warnings.warn(
    |     ^^^^^^^^^^^^^ B028
244 |       "No target containers provided, mapping tips to source containers."
245 |       "Please set map_tips to 'source' to map to source containers.",
    |

praxis/backend/utils/sanitation.py:249:3: S101 Use of `assert` detected
    |
247 |     targets = sources
248 |   map_onto = sources if map_tips == "source" else targets
249 |   assert map_onto is not None, "Expected map_onto to be provided"  # mypy assert
    |   ^^^^^^ S101
250 |   if isinstance(tips, TipRack):
251 |     tip_number = tips.num_items
    |

praxis/backend/utils/sanitation.py:253:5: TRY004 Prefer `TypeError` exception for invalid type
    |
251 |       tip_number = tips.num_items
252 |     else:
253 |       raise ValueError(
    |  _____^
254 | |       "Invalid type for tip. Must be a list of TipSpot objects or single TipRack.",
255 | |     )
    | |_____^ TRY004
256 |     if tip_number < len(map_onto):
257 |       raise ValueError(
    |

praxis/backend/utils/sanitation.py:253:11: TRY003 Avoid specifying long messages outside the exception class
    |
251 |       tip_number = tips.num_items
252 |     else:
253 |       raise ValueError(
    |  ___________^
254 | |       "Invalid type for tip. Must be a list of TipSpot objects or single TipRack.",
255 | |     )
    | |_____^ TRY003
256 |     if tip_number < len(map_onto):
257 |       raise ValueError(
    |

praxis/backend/utils/sanitation.py:254:7: EM101 Exception must not use a string literal, assign to variable first
    |
252 |   else:
253 |     raise ValueError(
254 |       "Invalid type for tip. Must be a list of TipSpot objects or single TipRack.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
255 |     )
256 |   if tip_number < len(map_onto):
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:257:11: TRY003 Avoid specifying long messages outside the exception class
    |
255 |       )
256 |     if tip_number < len(map_onto):
257 |       raise ValueError(
    |  ___________^
258 | |       "Insufficient number of tips for the number of sources or targets.",
259 | |     )
    | |_____^ TRY003
260 |     if isinstance(tips, TipRack):
261 |       output_tips = []
    |

praxis/backend/utils/sanitation.py:258:7: EM101 Exception must not use a string literal, assign to variable first
    |
256 |   if tip_number < len(map_onto):
257 |     raise ValueError(
258 |       "Insufficient number of tips for the number of sources or targets.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
259 |     )
260 |   if isinstance(tips, TipRack):
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:263:13: TRY003 Avoid specifying long messages outside the exception class
    |
261 |       output_tips = []
262 |       if not all(isinstance(item, Well) for item in map_onto):
263 |         raise ValueError(
    |  _____________^
264 | |         "Cannot map between source or target containers and tip rack. Specify \
265 | |         tips as list[TipSpot].",
266 | |       )
    | |_______^ TRY003
267 |       for well in map_onto:
268 |         assert isinstance(well, Well), "Expected Well object"  # mypy compatible assert
    |

praxis/backend/utils/sanitation.py:264:9: EM101 Exception must not use a string literal, assign to variable first
    |
262 |       if not all(isinstance(item, Well) for item in map_onto):
263 |         raise ValueError(
264 |           "Cannot map between source or target containers and tip rack. Specify \
    |  _________^
265 | |         tips as list[TipSpot].",
    | |_______________________________^ EM101
266 |         )
267 |       for well in map_onto:
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:268:7: S101 Use of `assert` detected
    |
266 |       )
267 |     for well in map_onto:
268 |       assert isinstance(well, Well), "Expected Well object"  # mypy compatible assert
    |       ^^^^^^ S101
269 |       well_number = await well_to_int(well, source_plate)
270 |       if not tips[well_number][0].has_tip():
    |

praxis/backend/utils/sanitation.py:271:15: TRY003 Avoid specifying long messages outside the exception class
    |
269 |       well_number = await well_to_int(well, source_plate)
270 |       if not tips[well_number][0].has_tip():
271 |         raise ValueError("Tip rack does not have tip at specified location.")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
272 |       output_tips.append(tips[well_number][0])
273 |   return output_tips
    |

praxis/backend/utils/sanitation.py:271:26: EM101 Exception must not use a string literal, assign to variable first
    |
269 |       well_number = await well_to_int(well, source_plate)
270 |       if not tips[well_number][0].has_tip():
271 |         raise ValueError("Tip rack does not have tip at specified location.")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
272 |       output_tips.append(tips[well_number][0])
273 |   return output_tips
    |
    = help: Assign to variable; remove string literal

praxis/backend/utils/sanitation.py:276:43: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `key`
    |
276 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                           ^^^ ANN401
277 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
278 |     the key matches the given key and the value matches the given value.
    |

praxis/backend/utils/sanitation.py:276:55: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
276 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                                       ^^^ ANN401
277 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
278 |     the key matches the given key and the value matches the given value.
    |

praxis/backend/utils/sanitation.py:277:3: D205 1 blank line required between summary line and description
    |
276 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
277 |     """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
    |  ___^
278 | |     the key matches the given key and the value matches the given value.
279 | | 
280 | |   Args:
281 | |     nested_dict (dict): The nested dictionary to be sliced.
282 | |     key (Any): The key to be matched.
283 | |     value (Any): The value to be matched.
284 | | 
285 | |   Returns:
286 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
287 | | 
288 | |   """
    | |_____^ D205
289 |     new_dict = {}
290 |     for k, v in nested_dict.items():
    |
    = help: Insert single blank line

praxis/backend/utils/sanitation.py:277:3: D401 First line of docstring should be in imperative mood: "Returns a new dictionary containing only the key-value pairs from the nested dictionary where \"
    |
276 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
277 |     """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
    |  ___^
278 | |     the key matches the given key and the value matches the given value.
279 | | 
280 | |   Args:
281 | |     nested_dict (dict): The nested dictionary to be sliced.
282 | |     key (Any): The key to be matched.
283 | |     value (Any): The value to be matched.
284 | | 
285 | |   Returns:
286 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
287 | | 
288 | |   """
    | |_____^ D401
289 |     new_dict = {}
290 |     for k, v in nested_dict.items():
    |

praxis/backend/utils/type_inspection.py:10:38: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `obj_type`
   |
10 | def is_pylabrobot_resource(obj_type: Any) -> bool:
   |                                      ^^^ ANN401
11 |   """Check if the given type is a Pylabrobot Resource or Union of Resources."""
12 |   if obj_type is inspect.Parameter.empty:
   |

praxis/backend/utils/type_inspection.py:26:30: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
   |
26 | def fqn_from_hint(type_hint: Any) -> str:
   |                              ^^^ ANN401
27 |   """Get the fully qualified name of a type hint.
   |

praxis/backend/utils/type_inspection.py:48:7: SIM108 Use ternary operator `actual_type = resource_types[0] if resource_types else non_none_args[0]` instead of `if`-`else`-block
   |
46 |         # This is a heuristic. A more robust solution might require more context.
47 |         resource_types = [t for t in non_none_args if is_pylabrobot_resource(t)]
48 |         if resource_types:
   |  _______^
49 | |         actual_type = resource_types[0]
50 | |       else:
51 | |         actual_type = non_none_args[0]  # Fallback to the first type
   | |______________________________________^ SIM108
52 |       else:  # Only NoneType in Union
53 |         return "None"
   |
   = help: Replace `if`-`else`-block with `actual_type = resource_types[0] if resource_types else non_none_args[0]`

praxis/backend/utils/type_inspection.py:58:7: PIE810 Call `startswith` once with a `tuple`
   |
56 |       module = getattr(actual_type, "__module__", "")
57 |       if isinstance(module, str) and (
58 |         module.startswith("praxis.")
   |  _______^
59 | |       or module.startswith("pylabrobot.")
60 | |       or module == "builtins"
   | |_____________________________^ PIE810
61 |       ):
62 |         return (
   |
   = help: Merge into a single `startswith` call

praxis/backend/utils/type_inspection.py:71:36: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
   |
71 | def serialize_type_hint(type_hint: Any) -> str:
   |                                    ^^^ ANN401
72 |   """Serialize a type hint to a string representation."""
73 |   if type_hint == inspect.Parameter.empty:
   |

pyproject.toml:1:1: RUF200 Failed to parse pyproject.toml: missing field `name`
  |
1 | / [project]
2 | | requires-python = ">=3.10"
  | |__________________________^ RUF200
  |

setup.py:3:46: PGH003 Use specific rule codes when ignoring type issues
  |
1 | """Setup script for Praxis, a hardware agnostic platform for managing lab automation."""
2 | 
3 | from setuptools import find_packages, setup  # type: ignore
  |                                              ^^^^^^^^^^^^^^ PGH003
4 | 
5 | from .__version__ import __version__
  |

setup.py:7:6: PTH123 `open()` should be replaced by `Path.open()`
  |
5 | from .__version__ import __version__
6 | 
7 | with open("README.md", encoding="utf-8") as f:
  |      ^^^^ PTH123
8 |   long_description = f.read()
  |

tests/api/assets_api_tests.py:1:1: INP001 File `tests/api/assets_api_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/assets_api_tests.py:1:1: D100 Missing docstring in public module
tests/api/assets_api_tests.py:30:7: D101 Missing docstring in public class
   |
29 | # --- Test Class for Resource  Inventory API Endpoints ---
30 | class TestResourceInventoryAPI:
   |       ^^^^^^^^^^^^^^^^^^^^^^^^ D101
31 |   MOCK_INSTANCE_ID = 123
32 |   MOCK_USER_ID = "test_user_api"
   |

tests/api/assets_api_tests.py:35:7: ANN201 Missing return type annotation for public function `patch_dependencies`
   |
34 |   @pytest.fixture(autouse=True)
35 |   def patch_dependencies(self, monkeypatch):
   |       ^^^^^^^^^^^^^^^^^^ ANN201
36 |     # Mock the get_db dependency to avoid actual DB calls
37 |     self.mock_db_session = MagicMock()
   |
   = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:35:7: D102 Missing docstring in public method
   |
34 |   @pytest.fixture(autouse=True)
35 |   def patch_dependencies(self, monkeypatch):
   |       ^^^^^^^^^^^^^^^^^^ D102
36 |     # Mock the get_db dependency to avoid actual DB calls
37 |     self.mock_db_session = MagicMock()
   |

tests/api/assets_api_tests.py:35:32: ANN001 Missing type annotation for function argument `monkeypatch`
   |
34 |   @pytest.fixture(autouse=True)
35 |   def patch_dependencies(self, monkeypatch):
   |                                ^^^^^^^^^^^ ANN001
36 |     # Mock the get_db dependency to avoid actual DB calls
37 |     self.mock_db_session = MagicMock()
   |

tests/api/assets_api_tests.py:54:7: ANN201 Missing return type annotation for public function `test_get_resource_instance_inventory_success`
   |
52 |     )
53 | 
54 |   def test_get_resource_instance_inventory_success(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
55 |     mock_orm = MagicMock(spec=ResourceOrm)
56 |     inventory_dict = {
   |
   = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:54:7: D102 Missing docstring in public method
   |
52 |     )
53 | 
54 |   def test_get_resource_instance_inventory_success(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
55 |     mock_orm = MagicMock(spec=ResourceOrm)
56 |     inventory_dict = {
   |

tests/api/assets_api_tests.py:76:5: S101 Use of `assert` detected
   |
74 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
75 | 
76 |     assert response.status_code == 200
   |     ^^^^^^ S101
77 |     self.mock_get_resource.assert_called_once_with(
78 |       self.mock_db_session,
   |

tests/api/assets_api_tests.py:76:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
74 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
75 | 
76 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
77 |     self.mock_get_resource.assert_called_once_with(
78 |       self.mock_db_session,
   |

tests/api/assets_api_tests.py:87:5: S101 Use of `assert` detected
   |
85 |     ).model_dump()  # Pydantic v2
86 |     # For Pydantic v1: expected_data = ResourceInventoryDataOut(**inventory_dict).dict()
87 |     assert response.json() == expected_data
   |     ^^^^^^ S101
88 | 
89 |   def test_get_resource_instance_inventory_not_found(self):
   |

tests/api/assets_api_tests.py:89:7: ANN201 Missing return type annotation for public function `test_get_resource_instance_inventory_not_found`
   |
87 |     assert response.json() == expected_data
88 | 
89 |   def test_get_resource_instance_inventory_not_found(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
90 |     self.mock_get_resource.return_value = None
91 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
   |
   = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:89:7: D102 Missing docstring in public method
   |
87 |     assert response.json() == expected_data
88 | 
89 |   def test_get_resource_instance_inventory_not_found(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
90 |     self.mock_get_resource.return_value = None
91 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
   |

tests/api/assets_api_tests.py:92:5: S101 Use of `assert` detected
   |
90 |     self.mock_get_resource.return_value = None
91 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
92 |     assert response.status_code == 404
   |     ^^^^^^ S101
93 |     self.mock_get_resource.assert_called_once_with(
94 |       self.mock_db_session,
   |

tests/api/assets_api_tests.py:92:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
90 |     self.mock_get_resource.return_value = None
91 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
92 |     assert response.status_code == 404
   |                                    ^^^ PLR2004
93 |     self.mock_get_resource.assert_called_once_with(
94 |       self.mock_db_session,
   |

tests/api/assets_api_tests.py:98:7: ANN201 Missing return type annotation for public function `test_get_resource_instance_inventory_empty`
    |
 96 |     )
 97 | 
 98 |   def test_get_resource_instance_inventory_empty(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 99 |     mock_orm = MagicMock(spec=ResourceOrm)
100 |     mock_orm.properties_json = None  # Or {}
    |
    = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:98:7: D102 Missing docstring in public method
    |
 96 |     )
 97 | 
 98 |   def test_get_resource_instance_inventory_empty(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
 99 |     mock_orm = MagicMock(spec=ResourceOrm)
100 |     mock_orm.properties_json = None  # Or {}
    |

tests/api/assets_api_tests.py:104:5: S101 Use of `assert` detected
    |
103 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
104 |     assert response.status_code == 200
    |     ^^^^^^ S101
105 |     # Expecting ResourceInventoryDataOut default values (all None)
106 |     expected_empty_data = ResourceInventoryDataOut().model_dump()  # Pydantic v2
    |

tests/api/assets_api_tests.py:104:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
103 |     response = client.get(f"/resource/{self.MOCK_INSTANCE_ID}/inventory")
104 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
105 |     # Expecting ResourceInventoryDataOut default values (all None)
106 |     expected_empty_data = ResourceInventoryDataOut().model_dump()  # Pydantic v2
    |

tests/api/assets_api_tests.py:108:5: S101 Use of `assert` detected
    |
106 |     expected_empty_data = ResourceInventoryDataOut().model_dump()  # Pydantic v2
107 |     # For Pydantic v1: expected_empty_data = ResourceInventoryDataOut().dict()
108 |     assert response.json() == expected_empty_data
    |     ^^^^^^ S101
109 |     self.mock_get_resource.assert_called_once_with(
110 |       self.mock_db_session,
    |

tests/api/assets_api_tests.py:114:7: ANN201 Missing return type annotation for public function `test_update_resource_instance_inventory_success`
    |
112 |     )
113 | 
114 |   def test_update_resource_instance_inventory_success(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
115 |     mock_orm_initial = MagicMock(spec=ResourceOrm)
116 |     mock_orm_initial.accession_id = self.MOCK_INSTANCE_ID
    |
    = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:114:7: D102 Missing docstring in public method
    |
112 |     )
113 | 
114 |   def test_update_resource_instance_inventory_success(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
115 |     mock_orm_initial = MagicMock(spec=ResourceOrm)
116 |     mock_orm_initial.accession_id = self.MOCK_INSTANCE_ID
    |

tests/api/assets_api_tests.py:158:5: S101 Use of `assert` detected
    |
156 |       )
157 | 
158 |     assert response.status_code == 200
    |     ^^^^^^ S101
159 |     self.mock_get_resource.assert_called_once_with(
160 |       self.mock_db_session,
    |

tests/api/assets_api_tests.py:158:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
156 |       )
157 | 
158 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
159 |     self.mock_get_resource.assert_called_once_with(
160 |       self.mock_db_session,
    |

tests/api/assets_api_tests.py:181:5: S101 Use of `assert` detected
    |
179 |     ).model_dump()  # Pydantic v2
180 |     # For Pydantic v1: expected_response_data = ResourceInventoryDataOut(**final_properties_from_service).dict()
181 |     assert response.json() == expected_response_data
    |     ^^^^^^ S101
182 | 
183 |   def test_update_resource_instance_inventory_not_found(self):
    |

tests/api/assets_api_tests.py:183:7: ANN201 Missing return type annotation for public function `test_update_resource_instance_inventory_not_found`
    |
181 |     assert response.json() == expected_response_data
182 | 
183 |   def test_update_resource_instance_inventory_not_found(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |     self.mock_get_resource.return_value = None
185 |     request_payload_dict = {
    |
    = help: Add return type annotation: `None`

tests/api/assets_api_tests.py:183:7: D102 Missing docstring in public method
    |
181 |     assert response.json() == expected_response_data
182 | 
183 |   def test_update_resource_instance_inventory_not_found(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
184 |     self.mock_get_resource.return_value = None
185 |     request_payload_dict = {
    |

tests/api/assets_api_tests.py:193:5: S101 Use of `assert` detected
    |
191 |       json=request_payload_dict,
192 |     )
193 |     assert response.status_code == 404
    |     ^^^^^^ S101
194 |     self.mock_get_resource.assert_called_once_with(
195 |       self.mock_db_session,
    |

tests/api/assets_api_tests.py:193:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
191 |       json=request_payload_dict,
192 |     )
193 |     assert response.status_code == 404
    |                                    ^^^ PLR2004
194 |     self.mock_get_resource.assert_called_once_with(
195 |       self.mock_db_session,
    |

tests/api/conftest.py:1:1: INP001 File `tests/api/conftest.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/conftest.py:1:1: D100 Missing docstring in public module
tests/api/conftest.py:12:5: ANN201 Missing return type annotation for public function `setup_test_database_session`
   |
11 | @pytest.fixture(scope="session", autouse=True)
12 | def setup_test_database_session():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
13 |     """Create test tables once per session."""
14 |     create_tables_if_not_exist()
   |
   = help: Add return type annotation: `None`

tests/api/conftest.py:15:5: ERA001 Found commented-out code
   |
13 |     """Create test tables once per session."""
14 |     create_tables_if_not_exist()
15 |     # Base.metadata.drop_all(bind=engine) # Uncomment if you want to drop tables after all tests
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
16 | 
17 | @pytest.fixture(scope="function")
   |
   = help: Remove commented-out code

tests/api/conftest.py:17:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
15 |     # Base.metadata.drop_all(bind=engine) # Uncomment if you want to drop tables after all tests
16 | 
17 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
18 | def db_session() -> Generator[Session, None, None]:
19 |     """Provides a test database session, rolling back changes after each test."""
   |
   = help: Remove implied `scope` argument

tests/api/conftest.py:19:5: D401 First line of docstring should be in imperative mood: "Provides a test database session, rolling back changes after each test."
   |
17 | @pytest.fixture(scope="function")
18 | def db_session() -> Generator[Session, None, None]:
19 |     """Provides a test database session, rolling back changes after each test."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
20 |     connection = engine.connect()
21 |     transaction = connection.begin()
   |

tests/api/conftest.py:30:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
   |
28 |         connection.close()
29 | 
30 | @pytest.fixture(scope="function")
   |                 ^^^^^^^^^^^^^^^^ PT003
31 | def client(db_session: Session) -> Generator[TestClient, None, None]:
32 |     """Provides a TestClient instance for FastAPI, with DB session override.
   |
   = help: Remove implied `scope` argument

tests/api/conftest.py:32:5: D200 One-line docstring should fit on one line
   |
30 |   @pytest.fixture(scope="function")
31 |   def client(db_session: Session) -> Generator[TestClient, None, None]:
32 |       """Provides a TestClient instance for FastAPI, with DB session override.
   |  _____^
33 | |     """
   | |_______^ D200
34 |       from praxis.backend.api.dependencies import get_db
   |
   = help: Reformat to one line

tests/api/conftest.py:32:5: D401 First line of docstring should be in imperative mood: "Provides a TestClient instance for FastAPI, with DB session override."
   |
30 |   @pytest.fixture(scope="function")
31 |   def client(db_session: Session) -> Generator[TestClient, None, None]:
32 |       """Provides a TestClient instance for FastAPI, with DB session override.
   |  _____^
33 | |     """
   | |_______^ D401
34 |       from praxis.backend.api.dependencies import get_db
   |

tests/api/decks_api_tests.py:1:1: INP001 File `tests/api/decks_api_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/decks_api_tests.py:1:1: D100 Missing docstring in public module
tests/api/decks_api_tests.py:31:5: ANN201 Missing return type annotation for public function `test_deck_info_model`
   |
29 | # --- Pydantic Model Unit Tests ---
30 | 
31 | def test_deck_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
32 |     data = {
33 |         "id": 1,
   |
   = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:31:5: D103 Missing docstring in public function
   |
29 | # --- Pydantic Model Unit Tests ---
30 | 
31 | def test_deck_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^ D103
32 |     data = {
33 |         "id": 1,
   |

tests/api/decks_api_tests.py:39:5: S101 Use of `assert` detected
   |
37 |     }
38 |     deck_info = DeckInfo.model_validate(data)
39 |     assert deck_info.accession_id == data["id"]
   |     ^^^^^^ S101
40 |     assert deck_info.name == data["name"]
41 |     assert deck_info.model_dump()["current_status"] == "ONLINE"
   |

tests/api/decks_api_tests.py:40:5: S101 Use of `assert` detected
   |
38 |     deck_info = DeckInfo.model_validate(data)
39 |     assert deck_info.accession_id == data["id"]
40 |     assert deck_info.name == data["name"]
   |     ^^^^^^ S101
41 |     assert deck_info.model_dump()["current_status"] == "ONLINE"
   |

tests/api/decks_api_tests.py:41:5: S101 Use of `assert` detected
   |
39 |     assert deck_info.accession_id == data["id"]
40 |     assert deck_info.name == data["name"]
41 |     assert deck_info.model_dump()["current_status"] == "ONLINE"
   |     ^^^^^^ S101
42 | 
43 | def test_resource_info_model():
   |

tests/api/decks_api_tests.py:43:5: ANN201 Missing return type annotation for public function `test_resource_info_model`
   |
41 |     assert deck_info.model_dump()["current_status"] == "ONLINE"
42 | 
43 | def test_resource_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
44 |     data = {
45 |         "resource_instance_accession_id": 10,
   |
   = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:43:5: D103 Missing docstring in public function
   |
41 |     assert deck_info.model_dump()["current_status"] == "ONLINE"
42 | 
43 | def test_resource_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
44 |     data = {
45 |         "resource_instance_accession_id": 10,
   |

tests/api/decks_api_tests.py:58:5: S101 Use of `assert` detected
   |
56 |     }
57 |     resource_info = ResourceInfo.model_validate(data)
58 |     assert resource_info.resource_instance_accession_id == data["resource_instance_accession_id"]
   |     ^^^^^^ S101
59 |     assert resource_info.model_dump()["category"] == "PLATE"
   |

tests/api/decks_api_tests.py:59:5: S101 Use of `assert` detected
   |
57 |     resource_info = ResourceInfo.model_validate(data)
58 |     assert resource_info.resource_instance_accession_id == data["resource_instance_accession_id"]
59 |     assert resource_info.model_dump()["category"] == "PLATE"
   |     ^^^^^^ S101
60 | 
61 | def test_position_info_model():
   |

tests/api/decks_api_tests.py:61:5: ANN201 Missing return type annotation for public function `test_position_info_model`
   |
59 |     assert resource_info.model_dump()["category"] == "PLATE"
60 | 
61 | def test_position_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
62 |     resource_data = {
63 |         "resource_instance_accession_id": 10, "name": "Reagent Plate 1",
   |
   = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:61:5: D103 Missing docstring in public function
   |
59 |     assert resource_info.model_dump()["category"] == "PLATE"
60 | 
61 | def test_position_info_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ D103
62 |     resource_data = {
63 |         "resource_instance_accession_id": 10, "name": "Reagent Plate 1",
   |

tests/api/decks_api_tests.py:74:5: S101 Use of `assert` detected
   |
72 |     }
73 |     position_info = PositionInfo.model_validate(data)
74 |     assert position_info.name == data["name"]
   |     ^^^^^^ S101
75 |     assert position_info.resource is not None
76 |     assert position_info.resource.resource_instance_accession_id == resource_data["resource_instance_accession_id"]
   |

tests/api/decks_api_tests.py:75:5: S101 Use of `assert` detected
   |
73 |     position_info = PositionInfo.model_validate(data)
74 |     assert position_info.name == data["name"]
75 |     assert position_info.resource is not None
   |     ^^^^^^ S101
76 |     assert position_info.resource.resource_instance_accession_id == resource_data["resource_instance_accession_id"]
77 |     assert position_info.model_dump()["resource"]["name"] == "Reagent Plate 1"
   |

tests/api/decks_api_tests.py:76:5: S101 Use of `assert` detected
   |
74 |     assert position_info.name == data["name"]
75 |     assert position_info.resource is not None
76 |     assert position_info.resource.resource_instance_accession_id == resource_data["resource_instance_accession_id"]
   |     ^^^^^^ S101
77 |     assert position_info.model_dump()["resource"]["name"] == "Reagent Plate 1"
   |

tests/api/decks_api_tests.py:77:5: S101 Use of `assert` detected
   |
75 |     assert position_info.resource is not None
76 |     assert position_info.resource.resource_instance_accession_id == resource_data["resource_instance_accession_id"]
77 |     assert position_info.model_dump()["resource"]["name"] == "Reagent Plate 1"
   |     ^^^^^^ S101
78 | 
79 | def test_deck_state_response_model():
   |

tests/api/decks_api_tests.py:79:5: ANN201 Missing return type annotation for public function `test_deck_state_response_model`
   |
77 |     assert position_info.model_dump()["resource"]["name"] == "Reagent Plate 1"
78 | 
79 | def test_deck_state_response_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
80 |     position_data = {"name": "A1", "resource": None}
81 |     data = {
   |
   = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:79:5: D103 Missing docstring in public function
   |
77 |     assert position_info.model_dump()["resource"]["name"] == "Reagent Plate 1"
78 | 
79 | def test_deck_state_response_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
80 |     position_data = {"name": "A1", "resource": None}
81 |     data = {
   |

tests/api/decks_api_tests.py:91:5: S101 Use of `assert` detected
   |
89 |     }
90 |     deck_state = DeckStateResponse.model_validate(data)
91 |     assert deck_state.deck_accession_id == data["deck_accession_id"]
   |     ^^^^^^ S101
92 |     assert len(deck_state.positions) == 1
93 |     assert deck_state.positions[0].name == position_data["name"]
   |

tests/api/decks_api_tests.py:92:5: S101 Use of `assert` detected
   |
90 |     deck_state = DeckStateResponse.model_validate(data)
91 |     assert deck_state.deck_accession_id == data["deck_accession_id"]
92 |     assert len(deck_state.positions) == 1
   |     ^^^^^^ S101
93 |     assert deck_state.positions[0].name == position_data["name"]
94 |     assert deck_state.model_dump()["positions"][0]["resource"] is None
   |

tests/api/decks_api_tests.py:93:5: S101 Use of `assert` detected
   |
91 |     assert deck_state.deck_accession_id == data["deck_accession_id"]
92 |     assert len(deck_state.positions) == 1
93 |     assert deck_state.positions[0].name == position_data["name"]
   |     ^^^^^^ S101
94 |     assert deck_state.model_dump()["positions"][0]["resource"] is None
   |

tests/api/decks_api_tests.py:94:5: S101 Use of `assert` detected
   |
92 |     assert len(deck_state.positions) == 1
93 |     assert deck_state.positions[0].name == position_data["name"]
94 |     assert deck_state.model_dump()["positions"][0]["resource"] is None
   |     ^^^^^^ S101
95 | 
96 | def test_deck_update_message_model():
   |

tests/api/decks_api_tests.py:96:5: ANN201 Missing return type annotation for public function `test_deck_update_message_model`
   |
94 |     assert deck_state.model_dump()["positions"][0]["resource"] is None
95 | 
96 | def test_deck_update_message_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
97 |     resource_data = {
98 |         "resource_instance_accession_id": 10, "name": "Tip Box",
   |
   = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:96:5: D103 Missing docstring in public function
   |
94 |     assert deck_state.model_dump()["positions"][0]["resource"] is None
95 | 
96 | def test_deck_update_message_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
97 |     resource_data = {
98 |         "resource_instance_accession_id": 10, "name": "Tip Box",
   |

tests/api/decks_api_tests.py:109:5: S101 Use of `assert` detected
    |
107 |     }
108 |     deck_update = DeckUpdateMessage.model_validate(data)
109 |     assert deck_update.deck_accession_id == data["deck_accession_id"]
    |     ^^^^^^ S101
110 |     assert deck_update.update_type == data["update_type"]
111 |     assert deck_update.resource_info is not None
    |

tests/api/decks_api_tests.py:110:5: S101 Use of `assert` detected
    |
108 |     deck_update = DeckUpdateMessage.model_validate(data)
109 |     assert deck_update.deck_accession_id == data["deck_accession_id"]
110 |     assert deck_update.update_type == data["update_type"]
    |     ^^^^^^ S101
111 |     assert deck_update.resource_info is not None
112 |     assert deck_update.resource_info.category == "TIP_RACK" # Check enum-like string
    |

tests/api/decks_api_tests.py:111:5: S101 Use of `assert` detected
    |
109 |     assert deck_update.deck_accession_id == data["deck_accession_id"]
110 |     assert deck_update.update_type == data["update_type"]
111 |     assert deck_update.resource_info is not None
    |     ^^^^^^ S101
112 |     assert deck_update.resource_info.category == "TIP_RACK" # Check enum-like string
113 |     assert deck_update.model_dump()["timestamp"] is not None # Check timestamp is generated
    |

tests/api/decks_api_tests.py:112:5: S101 Use of `assert` detected
    |
110 |     assert deck_update.update_type == data["update_type"]
111 |     assert deck_update.resource_info is not None
112 |     assert deck_update.resource_info.category == "TIP_RACK" # Check enum-like string
    |     ^^^^^^ S101
113 |     assert deck_update.model_dump()["timestamp"] is not None # Check timestamp is generated
    |

tests/api/decks_api_tests.py:113:5: S101 Use of `assert` detected
    |
111 |     assert deck_update.resource_info is not None
112 |     assert deck_update.resource_info.category == "TIP_RACK" # Check enum-like string
113 |     assert deck_update.model_dump()["timestamp"] is not None # Check timestamp is generated
    |     ^^^^^^ S101
114 | 
115 |     # Test with explicit timestamp
    |

tests/api/decks_api_tests.py:119:5: S101 Use of `assert` detected
    |
117 |     data_with_ts = {**data, "timestamp": ts}
118 |     deck_update_ts = DeckUpdateMessage.model_validate(data_with_ts)
119 |     assert deck_update_ts.timestamp == ts
    |     ^^^^^^ S101
    |

tests/api/decks_api_tests.py:125:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
    |
125 | @pytest.fixture(scope="function")
    |                 ^^^^^^^^^^^^^^^^ PT003
126 | def setup_basic_machines(db_session: Session) -> None:
127 |     """Sets up a basic DECK machine and a NON-DECK machine."""
    |
    = help: Remove implied `scope` argument

tests/api/decks_api_tests.py:127:5: D401 First line of docstring should be in imperative mood: "Sets up a basic DECK machine and a NON-DECK machine."
    |
125 | @pytest.fixture(scope="function")
126 | def setup_basic_machines(db_session: Session) -> None:
127 |     """Sets up a basic DECK machine and a NON-DECK machine."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
128 |     deck_machine = ManagedDeviceOrm(
129 |         id=VALID_DECK_ID,
    |

tests/api/decks_api_tests.py:147:5: ANN201 Missing return type annotation for public function `test_list_available_decks_empty`
    |
145 | # --- HTTP Endpoint Tests ---
146 | 
147 | def test_list_available_decks_empty(client: TestClient, db_session: Session):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
148 |     """Test GET /api/workcell/decks when no decks are present."""
149 |     response = client.get("/api/workcell/decks")
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:147:57: ARG001 Unused function argument: `db_session`
    |
145 | # --- HTTP Endpoint Tests ---
146 | 
147 | def test_list_available_decks_empty(client: TestClient, db_session: Session):
    |                                                         ^^^^^^^^^^ ARG001
148 |     """Test GET /api/workcell/decks when no decks are present."""
149 |     response = client.get("/api/workcell/decks")
    |

tests/api/decks_api_tests.py:150:5: S101 Use of `assert` detected
    |
148 |     """Test GET /api/workcell/decks when no decks are present."""
149 |     response = client.get("/api/workcell/decks")
150 |     assert response.status_code == 200
    |     ^^^^^^ S101
151 |     assert response.json() == []
    |

tests/api/decks_api_tests.py:150:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
148 |     """Test GET /api/workcell/decks when no decks are present."""
149 |     response = client.get("/api/workcell/decks")
150 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
151 |     assert response.json() == []
    |

tests/api/decks_api_tests.py:151:5: S101 Use of `assert` detected
    |
149 |     response = client.get("/api/workcell/decks")
150 |     assert response.status_code == 200
151 |     assert response.json() == []
    |     ^^^^^^ S101
152 | 
153 | def test_list_available_decks_with_data(client: TestClient, db_session: Session, setup_basic_machines: None):
    |

tests/api/decks_api_tests.py:153:5: ANN201 Missing return type annotation for public function `test_list_available_decks_with_data`
    |
151 |     assert response.json() == []
152 | 
153 | def test_list_available_decks_with_data(client: TestClient, db_session: Session, setup_basic_machines: None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
154 |     """Test GET /api/workcell/decks with a DECK and a NON-DECK machine."""
155 |     response = client.get("/api/workcell/decks")
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:153:61: ARG001 Unused function argument: `db_session`
    |
151 |     assert response.json() == []
152 | 
153 | def test_list_available_decks_with_data(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                             ^^^^^^^^^^ ARG001
154 |     """Test GET /api/workcell/decks with a DECK and a NON-DECK machine."""
155 |     response = client.get("/api/workcell/decks")
    |

tests/api/decks_api_tests.py:153:82: ARG001 Unused function argument: `setup_basic_machines`
    |
151 |     assert response.json() == []
152 | 
153 | def test_list_available_decks_with_data(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                                                  ^^^^^^^^^^^^^^^^^^^^ ARG001
154 |     """Test GET /api/workcell/decks with a DECK and a NON-DECK machine."""
155 |     response = client.get("/api/workcell/decks")
    |

tests/api/decks_api_tests.py:156:5: S101 Use of `assert` detected
    |
154 |     """Test GET /api/workcell/decks with a DECK and a NON-DECK machine."""
155 |     response = client.get("/api/workcell/decks")
156 |     assert response.status_code == 200
    |     ^^^^^^ S101
157 |     data = response.json()
158 |     assert isinstance(data, list)
    |

tests/api/decks_api_tests.py:156:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
154 |     """Test GET /api/workcell/decks with a DECK and a NON-DECK machine."""
155 |     response = client.get("/api/workcell/decks")
156 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
157 |     data = response.json()
158 |     assert isinstance(data, list)
    |

tests/api/decks_api_tests.py:158:5: S101 Use of `assert` detected
    |
156 |     assert response.status_code == 200
157 |     data = response.json()
158 |     assert isinstance(data, list)
    |     ^^^^^^ S101
159 |     assert len(data) == 1 # Should only return the DECK machine
    |

tests/api/decks_api_tests.py:159:5: S101 Use of `assert` detected
    |
157 |     data = response.json()
158 |     assert isinstance(data, list)
159 |     assert len(data) == 1 # Should only return the DECK machine
    |     ^^^^^^ S101
160 | 
161 |     deck_info = data[0]
    |

tests/api/decks_api_tests.py:162:5: S101 Use of `assert` detected
    |
161 |     deck_info = data[0]
162 |     assert deck_info["id"] == VALID_DECK_ID
    |     ^^^^^^ S101
163 |     assert deck_info["name"] == "Test Deck 1"
164 |     assert deck_info["fqn"] == "pylabrobot.resources.Deck"
    |

tests/api/decks_api_tests.py:163:5: S101 Use of `assert` detected
    |
161 |     deck_info = data[0]
162 |     assert deck_info["id"] == VALID_DECK_ID
163 |     assert deck_info["name"] == "Test Deck 1"
    |     ^^^^^^ S101
164 |     assert deck_info["fqn"] == "pylabrobot.resources.Deck"
165 |     assert deck_info["current_status"] == "ONLINE" # Enum .name or .value
    |

tests/api/decks_api_tests.py:164:5: S101 Use of `assert` detected
    |
162 |     assert deck_info["id"] == VALID_DECK_ID
163 |     assert deck_info["name"] == "Test Deck 1"
164 |     assert deck_info["fqn"] == "pylabrobot.resources.Deck"
    |     ^^^^^^ S101
165 |     assert deck_info["current_status"] == "ONLINE" # Enum .name or .value
    |

tests/api/decks_api_tests.py:165:5: S101 Use of `assert` detected
    |
163 |     assert deck_info["name"] == "Test Deck 1"
164 |     assert deck_info["fqn"] == "pylabrobot.resources.Deck"
165 |     assert deck_info["current_status"] == "ONLINE" # Enum .name or .value
    |     ^^^^^^ S101
166 | 
167 | def test_get_specific_deck_state_not_found(client: TestClient, db_session: Session):
    |

tests/api/decks_api_tests.py:167:5: ANN201 Missing return type annotation for public function `test_get_specific_deck_state_not_found`
    |
165 |     assert deck_info["current_status"] == "ONLINE" # Enum .name or .value
166 | 
167 | def test_get_specific_deck_state_not_found(client: TestClient, db_session: Session):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
168 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a non-existent deck."""
169 |     response = client.get(f"/api/workcell/decks/{INVALID_DEVICE_ID}/state")
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:167:64: ARG001 Unused function argument: `db_session`
    |
165 |     assert deck_info["current_status"] == "ONLINE" # Enum .name or .value
166 | 
167 | def test_get_specific_deck_state_not_found(client: TestClient, db_session: Session):
    |                                                                ^^^^^^^^^^ ARG001
168 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a non-existent deck."""
169 |     response = client.get(f"/api/workcell/decks/{INVALID_DEVICE_ID}/state")
    |

tests/api/decks_api_tests.py:170:5: S101 Use of `assert` detected
    |
168 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a non-existent deck."""
169 |     response = client.get(f"/api/workcell/decks/{INVALID_DEVICE_ID}/state")
170 |     assert response.status_code == 404 # Assuming WorkcellRuntimeError leads to 404 for not found
    |     ^^^^^^ S101
171 |     assert "not found" in response.json()["detail"].lower()
    |

tests/api/decks_api_tests.py:170:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
168 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a non-existent deck."""
169 |     response = client.get(f"/api/workcell/decks/{INVALID_DEVICE_ID}/state")
170 |     assert response.status_code == 404 # Assuming WorkcellRuntimeError leads to 404 for not found
    |                                    ^^^ PLR2004
171 |     assert "not found" in response.json()["detail"].lower()
    |

tests/api/decks_api_tests.py:171:5: S101 Use of `assert` detected
    |
169 |     response = client.get(f"/api/workcell/decks/{INVALID_DEVICE_ID}/state")
170 |     assert response.status_code == 404 # Assuming WorkcellRuntimeError leads to 404 for not found
171 |     assert "not found" in response.json()["detail"].lower()
    |     ^^^^^^ S101
    |

tests/api/decks_api_tests.py:174:5: ANN201 Missing return type annotation for public function `test_get_specific_deck_state_not_a_deck`
    |
174 | def test_get_specific_deck_state_not_a_deck(client: TestClient, db_session: Session, setup_basic_machines: None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
175 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a machine that is not a DECK."""
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:174:65: ARG001 Unused function argument: `db_session`
    |
174 | def test_get_specific_deck_state_not_a_deck(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                                 ^^^^^^^^^^ ARG001
175 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a machine that is not a DECK."""
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
    |

tests/api/decks_api_tests.py:174:86: ARG001 Unused function argument: `setup_basic_machines`
    |
174 | def test_get_specific_deck_state_not_a_deck(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                                                      ^^^^^^^^^^^^^^^^^^^^ ARG001
175 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a machine that is not a DECK."""
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
    |

tests/api/decks_api_tests.py:177:5: S101 Use of `assert` detected
    |
175 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a machine that is not a DECK."""
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
177 |     assert response.status_code == 404 # As per current error handling
    |     ^^^^^^ S101
178 |     assert "not categorized as a deck" in response.json()["detail"].lower()
    |

tests/api/decks_api_tests.py:177:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
175 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a machine that is not a DECK."""
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
177 |     assert response.status_code == 404 # As per current error handling
    |                                    ^^^ PLR2004
178 |     assert "not categorized as a deck" in response.json()["detail"].lower()
    |

tests/api/decks_api_tests.py:178:5: S101 Use of `assert` detected
    |
176 |     response = client.get(f"/api/workcell/decks/{VALID_NON_DECK_ID}/state")
177 |     assert response.status_code == 404 # As per current error handling
178 |     assert "not categorized as a deck" in response.json()["detail"].lower()
    |     ^^^^^^ S101
    |

tests/api/decks_api_tests.py:181:17: PT003 `scope='function'` is implied in `@pytest.fixture()`
    |
181 | @pytest.fixture(scope="function")
    |                 ^^^^^^^^^^^^^^^^ PT003
182 | def setup_deck_with_resource(db_session: Session, setup_basic_machines: None) -> None:
183 |     """Fixture to set up a deck with some resource on it."""
    |
    = help: Remove implied `scope` argument

tests/api/decks_api_tests.py:182:51: ARG001 Unused function argument: `setup_basic_machines`
    |
181 | @pytest.fixture(scope="function")
182 | def setup_deck_with_resource(db_session: Session, setup_basic_machines: None) -> None:
    |                                                   ^^^^^^^^^^^^^^^^^^^^ ARG001
183 |     """Fixture to set up a deck with some resource on it."""
184 |     # Resource Definition
    |

tests/api/decks_api_tests.py:233:5: ANN201 Missing return type annotation for public function `test_get_specific_deck_state_with_resource`
    |
233 | def test_get_specific_deck_state_with_resource(client: TestClient, db_session: Session, setup_deck_with_resource: None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
234 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a deck with resource."""
235 |     response = client.get(f"/api/workcell/decks/{VALID_DECK_ID}/state")
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:233:68: ARG001 Unused function argument: `db_session`
    |
233 | def test_get_specific_deck_state_with_resource(client: TestClient, db_session: Session, setup_deck_with_resource: None):
    |                                                                    ^^^^^^^^^^ ARG001
234 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a deck with resource."""
235 |     response = client.get(f"/api/workcell/decks/{VALID_DECK_ID}/state")
    |

tests/api/decks_api_tests.py:233:89: ARG001 Unused function argument: `setup_deck_with_resource`
    |
233 | def test_get_specific_deck_state_with_resource(client: TestClient, db_session: Session, setup_deck_with_resource: None):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ ARG001
234 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a deck with resource."""
235 |     response = client.get(f"/api/workcell/decks/{VALID_DECK_ID}/state")
    |

tests/api/decks_api_tests.py:236:5: S101 Use of `assert` detected
    |
234 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a deck with resource."""
235 |     response = client.get(f"/api/workcell/decks/{VALID_DECK_ID}/state")
236 |     assert response.status_code == 200
    |     ^^^^^^ S101
237 |     data = response.json()
    |

tests/api/decks_api_tests.py:236:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
234 |     """Test GET /api/workcell/decks/{deck_accession_id}/state for a deck with resource."""
235 |     response = client.get(f"/api/workcell/decks/{VALID_DECK_ID}/state")
236 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
237 |     data = response.json()
    |

tests/api/decks_api_tests.py:239:5: S101 Use of `assert` detected
    |
237 |     data = response.json()
238 | 
239 |     assert data["deck_accession_id"] == VALID_DECK_ID
    |     ^^^^^^ S101
240 |     assert data["name"] == "Test Deck 1"
241 |     assert data["fqn"] == "pylabrobot.resources.Deck"
    |

tests/api/decks_api_tests.py:240:5: S101 Use of `assert` detected
    |
239 |     assert data["deck_accession_id"] == VALID_DECK_ID
240 |     assert data["name"] == "Test Deck 1"
    |     ^^^^^^ S101
241 |     assert data["fqn"] == "pylabrobot.resources.Deck"
242 |     # Placeholder dimensions might be None or specific values if set in WorkcellRuntime
    |

tests/api/decks_api_tests.py:241:5: S101 Use of `assert` detected
    |
239 |     assert data["deck_accession_id"] == VALID_DECK_ID
240 |     assert data["name"] == "Test Deck 1"
241 |     assert data["fqn"] == "pylabrobot.resources.Deck"
    |     ^^^^^^ S101
242 |     # Placeholder dimensions might be None or specific values if set in WorkcellRuntime
243 |     assert "size_x_mm" in data
    |

tests/api/decks_api_tests.py:243:5: S101 Use of `assert` detected
    |
241 |     assert data["fqn"] == "pylabrobot.resources.Deck"
242 |     # Placeholder dimensions might be None or specific values if set in WorkcellRuntime
243 |     assert "size_x_mm" in data
    |     ^^^^^^ S101
244 |     assert "positions" in data
    |

tests/api/decks_api_tests.py:244:5: S101 Use of `assert` detected
    |
242 |     # Placeholder dimensions might be None or specific values if set in WorkcellRuntime
243 |     assert "size_x_mm" in data
244 |     assert "positions" in data
    |     ^^^^^^ S101
245 | 
246 |     positions_with_resource = {
    |

tests/api/decks_api_tests.py:251:5: S101 Use of `assert` detected
    |
249 |         if position["resource"]
250 |     }
251 |     assert len(positions_with_resource) == 2 # PlateOnDeck and TipsOnDeck
    |     ^^^^^^ S101
252 | 
253 |     # Check PlateOnDeck in A1
    |

tests/api/decks_api_tests.py:251:44: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
249 |         if position["resource"]
250 |     }
251 |     assert len(positions_with_resource) == 2 # PlateOnDeck and TipsOnDeck
    |                                            ^ PLR2004
252 | 
253 |     # Check PlateOnDeck in A1
    |

tests/api/decks_api_tests.py:254:5: S101 Use of `assert` detected
    |
253 |     # Check PlateOnDeck in A1
254 |     assert "A1" in positions_with_resource
    |     ^^^^^^ S101
255 |     plate_info = positions_with_resource["A1"]
256 |     assert plate_info["name"] == "PlateOnDeck"
    |

tests/api/decks_api_tests.py:256:5: S101 Use of `assert` detected
    |
254 |     assert "A1" in positions_with_resource
255 |     plate_info = positions_with_resource["A1"]
256 |     assert plate_info["name"] == "PlateOnDeck"
    |     ^^^^^^ S101
257 |     assert plate_info["category"] == "PLATE"
258 |     assert plate_info["properties_json"] == {"sample_type": "plasma"}
    |

tests/api/decks_api_tests.py:257:5: S101 Use of `assert` detected
    |
255 |     plate_info = positions_with_resource["A1"]
256 |     assert plate_info["name"] == "PlateOnDeck"
257 |     assert plate_info["category"] == "PLATE"
    |     ^^^^^^ S101
258 |     assert plate_info["properties_json"] == {"sample_type": "plasma"}
    |

tests/api/decks_api_tests.py:258:5: S101 Use of `assert` detected
    |
256 |     assert plate_info["name"] == "PlateOnDeck"
257 |     assert plate_info["category"] == "PLATE"
258 |     assert plate_info["properties_json"] == {"sample_type": "plasma"}
    |     ^^^^^^ S101
259 | 
260 |     # Check TipsOnDeck in B2
    |

tests/api/decks_api_tests.py:261:5: S101 Use of `assert` detected
    |
260 |     # Check TipsOnDeck in B2
261 |     assert "B2" in positions_with_resource
    |     ^^^^^^ S101
262 |     tip_rack_info = positions_with_resource["B2"]
263 |     assert tip_rack_info["name"] == "TipsOnDeck"
    |

tests/api/decks_api_tests.py:263:5: S101 Use of `assert` detected
    |
261 |     assert "B2" in positions_with_resource
262 |     tip_rack_info = positions_with_resource["B2"]
263 |     assert tip_rack_info["name"] == "TipsOnDeck"
    |     ^^^^^^ S101
264 |     assert tip_rack_info["category"] == "TIP_RACK"
    |

tests/api/decks_api_tests.py:264:5: S101 Use of `assert` detected
    |
262 |     tip_rack_info = positions_with_resource["B2"]
263 |     assert tip_rack_info["name"] == "TipsOnDeck"
264 |     assert tip_rack_info["category"] == "TIP_RACK"
    |     ^^^^^^ S101
265 | 
266 |     # Ensure no other resource is reported for this deck
    |

tests/api/decks_api_tests.py:268:5: S101 Use of `assert` detected
    |
266 |     # Ensure no other resource is reported for this deck
267 |     all_resource_names_on_deck = [lw["name"] for lw in positions_with_resource.values()]
268 |     assert "PlateInStorage" not in all_resource_names_on_deck
    |     ^^^^^^ S101
269 | 
270 |     # TODO: Add checks for empty positions if get_deck_state_representation is updated to include them.
    |

tests/api/decks_api_tests.py:270:7: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
268 |     assert "PlateInStorage" not in all_resource_names_on_deck
269 | 
270 |     # TODO: Add checks for empty positions if get_deck_state_representation is updated to include them.
    |       ^^^^ TD002
271 | 
272 | # --- WebSocket Endpoint Tests ---
    |

tests/api/decks_api_tests.py:270:7: TD003 Missing issue link on the line following this TODO
    |
268 |     assert "PlateInStorage" not in all_resource_names_on_deck
269 | 
270 |     # TODO: Add checks for empty positions if get_deck_state_representation is updated to include them.
    |       ^^^^ TD003
271 | 
272 | # --- WebSocket Endpoint Tests ---
    |

tests/api/decks_api_tests.py:270:7: FIX002 Line contains TODO, consider resolving the issue
    |
268 |     assert "PlateInStorage" not in all_resource_names_on_deck
269 | 
270 |     # TODO: Add checks for empty positions if get_deck_state_representation is updated to include them.
    |       ^^^^ FIX002
271 | 
272 | # --- WebSocket Endpoint Tests ---
    |

tests/api/decks_api_tests.py:274:5: ANN201 Missing return type annotation for public function `test_websocket_deck_updates_connection_and_broadcast`
    |
272 | # --- WebSocket Endpoint Tests ---
273 | 
274 | def test_websocket_deck_updates_connection_and_broadcast(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
275 |     client: TestClient, db_session: Session, setup_basic_machines: None,
276 | ):
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:275:25: ARG001 Unused function argument: `db_session`
    |
274 | def test_websocket_deck_updates_connection_and_broadcast(
275 |     client: TestClient, db_session: Session, setup_basic_machines: None,
    |                         ^^^^^^^^^^ ARG001
276 | ):
277 |     """Test WebSocket connection and message broadcast."""
    |

tests/api/decks_api_tests.py:275:46: ARG001 Unused function argument: `setup_basic_machines`
    |
274 | def test_websocket_deck_updates_connection_and_broadcast(
275 |     client: TestClient, db_session: Session, setup_basic_machines: None,
    |                                              ^^^^^^^^^^^^^^^^^^^^ ARG001
276 | ):
277 |     """Test WebSocket connection and message broadcast."""
    |

tests/api/decks_api_tests.py:286:9: S101 Use of `assert` detected
    |
284 |         }
285 |         response = client.post(f"/ws/test_broadcast/{VALID_DECK_ID}", json=test_message_payload) # Send JSON payload
286 |         assert response.status_code == 200 # Assuming POST request for test broadcast
    |         ^^^^^^ S101
287 | 
288 |         # Receive the message from WebSocket
    |

tests/api/decks_api_tests.py:286:40: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
284 |         }
285 |         response = client.post(f"/ws/test_broadcast/{VALID_DECK_ID}", json=test_message_payload) # Send JSON payload
286 |         assert response.status_code == 200 # Assuming POST request for test broadcast
    |                                        ^^^ PLR2004
287 | 
288 |         # Receive the message from WebSocket
    |

tests/api/decks_api_tests.py:292:9: S101 Use of `assert` detected
    |
290 |         message_data = json.loads(message_str)
291 | 
292 |         assert message_data["deck_accession_id"] == VALID_DECK_ID
    |         ^^^^^^ S101
293 |         # The test_broadcast endpoint sends a DeckUpdateMessage.
294 |         # The message_type in the POST request to test_broadcast is used to construct this.
    |

tests/api/decks_api_tests.py:295:9: S101 Use of `assert` detected
    |
293 |         # The test_broadcast endpoint sends a DeckUpdateMessage.
294 |         # The message_type in the POST request to test_broadcast is used to construct this.
295 |         assert message_data["update_type"] == test_message_payload["message_type"]
    |         ^^^^^^ S101
296 |         assert message_data["position_name"] == test_message_payload["position_name"]
    |

tests/api/decks_api_tests.py:296:9: S101 Use of `assert` detected
    |
294 |         # The message_type in the POST request to test_broadcast is used to construct this.
295 |         assert message_data["update_type"] == test_message_payload["message_type"]
296 |         assert message_data["position_name"] == test_message_payload["position_name"]
    |         ^^^^^^ S101
297 | 
298 |         assert message_data["resource_info"] is not None
    |

tests/api/decks_api_tests.py:298:9: S101 Use of `assert` detected
    |
296 |         assert message_data["position_name"] == test_message_payload["position_name"]
297 | 
298 |         assert message_data["resource_info"] is not None
    |         ^^^^^^ S101
299 |         assert message_data["resource_info"]["name"] == test_message_payload["resource_name"]
300 |         assert "timestamp" in message_data
    |

tests/api/decks_api_tests.py:299:9: S101 Use of `assert` detected
    |
298 |         assert message_data["resource_info"] is not None
299 |         assert message_data["resource_info"]["name"] == test_message_payload["resource_name"]
    |         ^^^^^^ S101
300 |         assert "timestamp" in message_data
    |

tests/api/decks_api_tests.py:300:9: S101 Use of `assert` detected
    |
298 |         assert message_data["resource_info"] is not None
299 |         assert message_data["resource_info"]["name"] == test_message_payload["resource_name"]
300 |         assert "timestamp" in message_data
    |         ^^^^^^ S101
301 | 
302 |         websocket.close()
    |

tests/api/decks_api_tests.py:305:5: ANN201 Missing return type annotation for public function `test_websocket_deck_updates_connection_to_invalid_deck`
    |
305 | def test_websocket_deck_updates_connection_to_invalid_deck(client: TestClient, db_session: Session):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
306 |     """Test WebSocket connection attempt to an invalid deck_accession_id."""
307 |     with pytest.raises(Exception) as exc_info: # Catching generic Exception as TestClient might wrap WebSocketDisconnect
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:305:80: ARG001 Unused function argument: `db_session`
    |
305 | def test_websocket_deck_updates_connection_to_invalid_deck(client: TestClient, db_session: Session):
    |                                                                                ^^^^^^^^^^ ARG001
306 |     """Test WebSocket connection attempt to an invalid deck_accession_id."""
307 |     with pytest.raises(Exception) as exc_info: # Catching generic Exception as TestClient might wrap WebSocketDisconnect
    |

tests/api/decks_api_tests.py:307:5: PT012 `pytest.raises()` block should contain a single simple statement
    |
305 |   def test_websocket_deck_updates_connection_to_invalid_deck(client: TestClient, db_session: Session):
306 |       """Test WebSocket connection attempt to an invalid deck_accession_id."""
307 |       with pytest.raises(Exception) as exc_info: # Catching generic Exception as TestClient might wrap WebSocketDisconnect
    |  _____^
308 | |         with client.websocket_connect(f"/ws/decks/{INVALID_DEVICE_ID}/updates") as websocket:
309 | |             # We expect this connection to fail and be closed by the server.
310 | |             # Depending on how TestClient handles server-side close, this might raise.
311 | |             # If it doesn't raise immediately, try receiving:
312 | |             try:
313 | |                 _ = websocket.receive_text(timeout=1) # timeout to prevent hanging if no close frame
314 | |             except Exception: # WebSocketTimeoutError or similar
315 | |                  pass # Expected if server just closes without sending a close frame client expects
    | |_____________________^ PT012
316 |   
317 |       # The exact exception and how to check the close code (1008) can be tricky with TestClient.
    |

tests/api/decks_api_tests.py:307:5: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
305 |   def test_websocket_deck_updates_connection_to_invalid_deck(client: TestClient, db_session: Session):
306 |       """Test WebSocket connection attempt to an invalid deck_accession_id."""
307 |       with pytest.raises(Exception) as exc_info: # Catching generic Exception as TestClient might wrap WebSocketDisconnect
    |  _____^
308 | |         with client.websocket_connect(f"/ws/decks/{INVALID_DEVICE_ID}/updates") as websocket:
    | |_____________________________________________________________________________________________^ SIM117
309 |               # We expect this connection to fail and be closed by the server.
310 |               # Depending on how TestClient handles server-side close, this might raise.
    |
    = help: Combine `with` statements

tests/api/decks_api_tests.py:307:24: PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
    |
305 | def test_websocket_deck_updates_connection_to_invalid_deck(client: TestClient, db_session: Session):
306 |     """Test WebSocket connection attempt to an invalid deck_accession_id."""
307 |     with pytest.raises(Exception) as exc_info: # Catching generic Exception as TestClient might wrap WebSocketDisconnect
    |                        ^^^^^^^^^ PT011
308 |         with client.websocket_connect(f"/ws/decks/{INVALID_DEVICE_ID}/updates") as websocket:
309 |             # We expect this connection to fail and be closed by the server.
    |

tests/api/decks_api_tests.py:312:13: SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
    |
310 |               # Depending on how TestClient handles server-side close, this might raise.
311 |               # If it doesn't raise immediately, try receiving:
312 |               try:
    |  _____________^
313 | |                 _ = websocket.receive_text(timeout=1) # timeout to prevent hanging if no close frame
314 | |             except Exception: # WebSocketTimeoutError or similar
315 | |                  pass # Expected if server just closes without sending a close frame client expects
    | |_____________________^ SIM105
316 |   
317 |       # The exact exception and how to check the close code (1008) can be tricky with TestClient.
    |
    = help: Replace with `contextlib.suppress(Exception)`

tests/api/decks_api_tests.py:314:13: S110 `try`-`except`-`pass` detected, consider logging the exception
    |
312 |               try:
313 |                   _ = websocket.receive_text(timeout=1) # timeout to prevent hanging if no close frame
314 |               except Exception: # WebSocketTimeoutError or similar
    |  _____________^
315 | |                  pass # Expected if server just closes without sending a close frame client expects
    | |_____________________^ S110
316 |   
317 |       # The exact exception and how to check the close code (1008) can be tricky with TestClient.
    |

tests/api/decks_api_tests.py:314:20: BLE001 Do not catch blind exception: `Exception`
    |
312 |             try:
313 |                 _ = websocket.receive_text(timeout=1) # timeout to prevent hanging if no close frame
314 |             except Exception: # WebSocketTimeoutError or similar
    |                    ^^^^^^^^^ BLE001
315 |                  pass # Expected if server just closes without sending a close frame client expects
    |

tests/api/decks_api_tests.py:322:5: S101 Use of `assert` detected
    |
320 |     # For now, we assert that an exception occurs, implying the connection was not maintained.
321 |     # A more direct way to test close codes might require lower-level WebSocket client testing.
322 |     assert exc_info is not None
    |     ^^^^^^ S101
323 |     # If we could access the close event details, we'd check:
324 |     # assert exc_info.value.code == 1008 # For WebSocketDisconnect exception if it holds the code
    |

tests/api/decks_api_tests.py:324:5: ERA001 Found commented-out code
    |
322 |     assert exc_info is not None
323 |     # If we could access the close event details, we'd check:
324 |     # assert exc_info.value.code == 1008 # For WebSocketDisconnect exception if it holds the code
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
325 | 
326 | def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
    |
    = help: Remove commented-out code

tests/api/decks_api_tests.py:326:5: ANN201 Missing return type annotation for public function `test_websocket_connection_to_non_deck_machine`
    |
324 |     # assert exc_info.value.code == 1008 # For WebSocketDisconnect exception if it holds the code
325 | 
326 | def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
327 |     """Test WebSocket connection attempt to a machine that is not a DECK."""
328 |     with pytest.raises(Exception) as exc_info:
    |
    = help: Add return type annotation: `None`

tests/api/decks_api_tests.py:326:71: ARG001 Unused function argument: `db_session`
    |
324 |     # assert exc_info.value.code == 1008 # For WebSocketDisconnect exception if it holds the code
325 | 
326 | def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                                       ^^^^^^^^^^ ARG001
327 |     """Test WebSocket connection attempt to a machine that is not a DECK."""
328 |     with pytest.raises(Exception) as exc_info:
    |

tests/api/decks_api_tests.py:326:92: ARG001 Unused function argument: `setup_basic_machines`
    |
324 |     # assert exc_info.value.code == 1008 # For WebSocketDisconnect exception if it holds the code
325 | 
326 | def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
    |                                                                                            ^^^^^^^^^^^^^^^^^^^^ ARG001
327 |     """Test WebSocket connection attempt to a machine that is not a DECK."""
328 |     with pytest.raises(Exception) as exc_info:
    |

tests/api/decks_api_tests.py:328:5: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
326 |   def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
327 |       """Test WebSocket connection attempt to a machine that is not a DECK."""
328 |       with pytest.raises(Exception) as exc_info:
    |  _____^
329 | |         with client.websocket_connect(f"/ws/decks/{VALID_NON_DECK_ID}/updates"):
    | |________________________________________________________________________________^ SIM117
330 |               pass # Expect connection to be refused/closed
331 |       assert exc_info is not None
    |
    = help: Combine `with` statements

tests/api/decks_api_tests.py:328:24: PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
    |
326 | def test_websocket_connection_to_non_deck_machine(client: TestClient, db_session: Session, setup_basic_machines: None):
327 |     """Test WebSocket connection attempt to a machine that is not a DECK."""
328 |     with pytest.raises(Exception) as exc_info:
    |                        ^^^^^^^^^ PT011
329 |         with client.websocket_connect(f"/ws/decks/{VALID_NON_DECK_ID}/updates"):
330 |             pass # Expect connection to be refused/closed
    |

tests/api/decks_api_tests.py:331:5: S101 Use of `assert` detected
    |
329 |         with client.websocket_connect(f"/ws/decks/{VALID_NON_DECK_ID}/updates"):
330 |             pass # Expect connection to be refused/closed
331 |     assert exc_info is not None
    |     ^^^^^^ S101
    |

tests/api/decks_api_tests.py:334:3: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
334 | # TODO: Add more tests, e.g. multiple clients for the same deck,
    |   ^^^^ TD002
335 | #       clients for different decks, graceful disconnect from server side if possible to simulate.
    |

tests/api/decks_api_tests.py:334:3: TD003 Missing issue link on the line following this TODO
    |
334 | # TODO: Add more tests, e.g. multiple clients for the same deck,
    |   ^^^^ TD003
335 | #       clients for different decks, graceful disconnect from server side if possible to simulate.
    |

tests/api/decks_api_tests.py:334:3: FIX002 Line contains TODO, consider resolving the issue
    |
334 | # TODO: Add more tests, e.g. multiple clients for the same deck,
    |   ^^^^ FIX002
335 | #       clients for different decks, graceful disconnect from server side if possible to simulate.
    |

tests/api/protocols_tests.py:1:1: INP001 File `tests/api/protocols_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/protocols_tests.py:1:1: D100 Missing docstring in public module
tests/api/protocols_tests.py:23:7: D101 Missing docstring in public class
   |
23 | class TestProtocolCommandsAPI:
   |       ^^^^^^^^^^^^^^^^^^^^^^^ D101
24 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
25 |   def test_send_pause_command_success(self, mock_send_control_command_redis):
   |

tests/api/protocols_tests.py:25:7: ANN201 Missing return type annotation for public function `test_send_pause_command_success`
   |
23 | class TestProtocolCommandsAPI:
24 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
25 |   def test_send_pause_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
26 |     mock_send_control_command_redis.return_value = True
27 |     response = client.post(
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:25:7: D102 Missing docstring in public method
   |
23 | class TestProtocolCommandsAPI:
24 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
25 |   def test_send_pause_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
26 |     mock_send_control_command_redis.return_value = True
27 |     response = client.post(
   |

tests/api/protocols_tests.py:25:45: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
23 | class TestProtocolCommandsAPI:
24 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
25 |   def test_send_pause_command_success(self, mock_send_control_command_redis):
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
26 |     mock_send_control_command_redis.return_value = True
27 |     response = client.post(
   |

tests/api/protocols_tests.py:30:5: S101 Use of `assert` detected
   |
28 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": "PAUSE"},
29 |     )
30 |     assert response.status_code == status.HTTP_200_OK
   |     ^^^^^^ S101
31 |     assert response.json() == {
32 |       "message": f"Command 'PAUSE' sent to run '{TEST_RUN_GUID}'",
   |

tests/api/protocols_tests.py:31:5: S101 Use of `assert` detected
   |
29 |     )
30 |     assert response.status_code == status.HTTP_200_OK
31 |     assert response.json() == {
   |     ^^^^^^ S101
32 |       "message": f"Command 'PAUSE' sent to run '{TEST_RUN_GUID}'",
33 |     }
   |

tests/api/protocols_tests.py:37:7: ANN201 Missing return type annotation for public function `test_send_resume_command_success`
   |
36 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
37 |   def test_send_resume_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
38 |     mock_send_control_command_redis.return_value = True
39 |     response = client.post(
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:37:7: D102 Missing docstring in public method
   |
36 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
37 |   def test_send_resume_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
38 |     mock_send_control_command_redis.return_value = True
39 |     response = client.post(
   |

tests/api/protocols_tests.py:37:46: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
36 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
37 |   def test_send_resume_command_success(self, mock_send_control_command_redis):
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
38 |     mock_send_control_command_redis.return_value = True
39 |     response = client.post(
   |

tests/api/protocols_tests.py:42:5: S101 Use of `assert` detected
   |
40 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": "RESUME"},
41 |     )
42 |     assert response.status_code == status.HTTP_200_OK
   |     ^^^^^^ S101
43 |     assert response.json() == {
44 |       "message": f"Command 'RESUME' sent to run '{TEST_RUN_GUID}'",
   |

tests/api/protocols_tests.py:43:5: S101 Use of `assert` detected
   |
41 |     )
42 |     assert response.status_code == status.HTTP_200_OK
43 |     assert response.json() == {
   |     ^^^^^^ S101
44 |       "message": f"Command 'RESUME' sent to run '{TEST_RUN_GUID}'",
45 |     }
   |

tests/api/protocols_tests.py:49:7: ANN201 Missing return type annotation for public function `test_send_cancel_command_success`
   |
48 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
49 |   def test_send_cancel_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
50 |     mock_send_control_command_redis.return_value = True
51 |     response = client.post(
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:49:7: D102 Missing docstring in public method
   |
48 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
49 |   def test_send_cancel_command_success(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
50 |     mock_send_control_command_redis.return_value = True
51 |     response = client.post(
   |

tests/api/protocols_tests.py:49:46: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
48 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
49 |   def test_send_cancel_command_success(self, mock_send_control_command_redis):
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
50 |     mock_send_control_command_redis.return_value = True
51 |     response = client.post(
   |

tests/api/protocols_tests.py:54:5: S101 Use of `assert` detected
   |
52 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": "CANCEL"},
53 |     )
54 |     assert response.status_code == status.HTTP_200_OK
   |     ^^^^^^ S101
55 |     assert response.json() == {
56 |       "message": f"Command 'CANCEL' sent to run '{TEST_RUN_GUID}'",
   |

tests/api/protocols_tests.py:55:5: S101 Use of `assert` detected
   |
53 |     )
54 |     assert response.status_code == status.HTTP_200_OK
55 |     assert response.json() == {
   |     ^^^^^^ S101
56 |       "message": f"Command 'CANCEL' sent to run '{TEST_RUN_GUID}'",
57 |     }
   |

tests/api/protocols_tests.py:61:7: ANN201 Missing return type annotation for public function `test_send_invalid_command`
   |
60 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
61 |   def test_send_invalid_command(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
62 |     invalid_command = "INVALID_COMMAND"
63 |     response = client.post(
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:61:7: D102 Missing docstring in public method
   |
60 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
61 |   def test_send_invalid_command(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
62 |     invalid_command = "INVALID_COMMAND"
63 |     response = client.post(
   |

tests/api/protocols_tests.py:61:39: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
60 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
61 |   def test_send_invalid_command(self, mock_send_control_command_redis):
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
62 |     invalid_command = "INVALID_COMMAND"
63 |     response = client.post(
   |

tests/api/protocols_tests.py:66:5: S101 Use of `assert` detected
   |
64 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": invalid_command},
65 |     )
66 |     assert response.status_code == status.HTTP_400_BAD_REQUEST
   |     ^^^^^^ S101
67 |     assert "detail" in response.json()
68 |     assert f"Invalid command: {invalid_command}" in response.json()["detail"]
   |

tests/api/protocols_tests.py:67:5: S101 Use of `assert` detected
   |
65 |     )
66 |     assert response.status_code == status.HTTP_400_BAD_REQUEST
67 |     assert "detail" in response.json()
   |     ^^^^^^ S101
68 |     assert f"Invalid command: {invalid_command}" in response.json()["detail"]
69 |     assert f"Allowed commands are: {ALLOWED_COMMANDS}" in response.json()["detail"]
   |

tests/api/protocols_tests.py:68:5: S101 Use of `assert` detected
   |
66 |     assert response.status_code == status.HTTP_400_BAD_REQUEST
67 |     assert "detail" in response.json()
68 |     assert f"Invalid command: {invalid_command}" in response.json()["detail"]
   |     ^^^^^^ S101
69 |     assert f"Allowed commands are: {ALLOWED_COMMANDS}" in response.json()["detail"]
70 |     mock_send_control_command_redis.assert_not_called()
   |

tests/api/protocols_tests.py:69:5: S101 Use of `assert` detected
   |
67 |     assert "detail" in response.json()
68 |     assert f"Invalid command: {invalid_command}" in response.json()["detail"]
69 |     assert f"Allowed commands are: {ALLOWED_COMMANDS}" in response.json()["detail"]
   |     ^^^^^^ S101
70 |     mock_send_control_command_redis.assert_not_called()
   |

tests/api/protocols_tests.py:73:7: ANN201 Missing return type annotation for public function `test_send_command_redis_error`
   |
72 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
73 |   def test_send_command_redis_error(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |     mock_send_control_command_redis.side_effect = redis.exceptions.RedisError(
75 |       "Test Redis Error",
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:73:7: D102 Missing docstring in public method
   |
72 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
73 |   def test_send_command_redis_error(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
74 |     mock_send_control_command_redis.side_effect = redis.exceptions.RedisError(
75 |       "Test Redis Error",
   |

tests/api/protocols_tests.py:73:43: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
72 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
73 |   def test_send_command_redis_error(self, mock_send_control_command_redis):
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
74 |     mock_send_control_command_redis.side_effect = redis.exceptions.RedisError(
75 |       "Test Redis Error",
   |

tests/api/protocols_tests.py:80:5: S101 Use of `assert` detected
   |
78 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": "PAUSE"},
79 |     )
80 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
   |     ^^^^^^ S101
81 |     assert "detail" in response.json()
82 |     assert (
   |

tests/api/protocols_tests.py:81:5: S101 Use of `assert` detected
   |
79 |     )
80 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
81 |     assert "detail" in response.json()
   |     ^^^^^^ S101
82 |     assert (
83 |       "An unexpected error occurred while sending command" in response.json()["detail"]
   |

tests/api/protocols_tests.py:82:5: S101 Use of `assert` detected
   |
80 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
81 |     assert "detail" in response.json()
82 |     assert (
   |     ^^^^^^ S101
83 |       "An unexpected error occurred while sending command" in response.json()["detail"]
84 |     )
   |

tests/api/protocols_tests.py:88:7: ANN201 Missing return type annotation for public function `test_send_command_failure_from_redis_false`
   |
87 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
88 |   def test_send_command_failure_from_redis_false(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
89 |     mock_send_control_command_redis.return_value = (
90 |       False  # Simulate Redis command sending failure
   |
   = help: Add return type annotation: `None`

tests/api/protocols_tests.py:88:7: D102 Missing docstring in public method
   |
87 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
88 |   def test_send_command_failure_from_redis_false(self, mock_send_control_command_redis):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
89 |     mock_send_control_command_redis.return_value = (
90 |       False  # Simulate Redis command sending failure
   |

tests/api/protocols_tests.py:88:56: ANN001 Missing type annotation for function argument `mock_send_control_command_redis`
   |
87 |   @patch("praxis.backend.api.protocols.send_control_command_to_redis")
88 |   def test_send_command_failure_from_redis_false(self, mock_send_control_command_redis):
   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
89 |     mock_send_control_command_redis.return_value = (
90 |       False  # Simulate Redis command sending failure
   |

tests/api/protocols_tests.py:95:5: S101 Use of `assert` detected
   |
93 |       f"/api/protocols/{TEST_RUN_GUID}/command", params={"command": "PAUSE"},
94 |     )
95 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
   |     ^^^^^^ S101
96 |     assert "detail" in response.json()
97 |     assert (
   |

tests/api/protocols_tests.py:96:5: S101 Use of `assert` detected
   |
94 |     )
95 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
96 |     assert "detail" in response.json()
   |     ^^^^^^ S101
97 |     assert (
98 |       f"Failed to send command to run '{TEST_RUN_GUID}' using Redis."
   |

tests/api/protocols_tests.py:97:5: S101 Use of `assert` detected
   |
95 |     assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
96 |     assert "detail" in response.json()
97 |     assert (
   |     ^^^^^^ S101
98 |       f"Failed to send command to run '{TEST_RUN_GUID}' using Redis."
99 |       in response.json()["detail"]
   |

tests/api/test_decks.py:1:1: INP001 File `tests/api/test_decks.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_decks.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/decks.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_decks.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/decks.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_decks.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/decks.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_decks.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_decks.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_decks.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_decks.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_decks.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_dependencies.py:1:1: INP001 File `tests/api/test_dependencies.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_dependencies.py:1:1: D100 Missing docstring in public module
tests/api/test_function_data_outputs.py:1:1: INP001 File `tests/api/test_function_data_outputs.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_function_data_outputs.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/function_data_outputs.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_function_data_outputs.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/function_data_outputs.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_function_data_outputs.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/function_data_outputs.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_function_data_outputs.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_function_data_outputs.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_function_data_outputs.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_function_data_outputs.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_function_data_outputs.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_global_dependencies.py:1:1: INP001 File `tests/api/test_global_dependencies.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_global_dependencies.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/global_dependencies.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_global_dependencies.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/global_dependencies.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_global_dependencies.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/global_dependencies.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_global_dependencies.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_global_dependencies.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_global_dependencies.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_global_dependencies.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_global_dependencies.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_machines.py:1:1: INP001 File `tests/api/test_machines.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_machines.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/machines.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_machines.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/machines.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_machines.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/machines.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_machines.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_machines.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_machines.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_machines.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_machines.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_protocols.py:1:1: INP001 File `tests/api/test_protocols.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_protocols.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/protocols.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_protocols.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/protocols.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_protocols.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/protocols.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_protocols.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_protocols.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_protocols.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_protocols.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_protocols.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_resources.py:1:1: INP001 File `tests/api/test_resources.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_resources.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/resources.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_resources.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/resources.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_resources.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/resources.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_resources.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_resources.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_resources.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_resources.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_resources.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/test_scheduler_api.py:1:1: INP001 File `tests/api/test_scheduler_api.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/test_scheduler_api.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/api/scheduler_api.py
2 | | """
  | |___^ D200
3 |   from fastapi.testclient import TestClient
  |
  = help: Reformat to one line

tests/api/test_scheduler_api.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/api/scheduler_api.py
2 | | """
  | |___^ D400
3 |   from fastapi.testclient import TestClient
  |
  = help: Add period

tests/api/test_scheduler_api.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/api/scheduler_api.py
2 | | """
  | |___^ D415
3 |   from fastapi.testclient import TestClient
  |
  = help: Add closing punctuation

tests/api/test_scheduler_api.py:9:5: ANN201 Missing return type annotation for public function `test_read_main`
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ ANN201
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |
   = help: Add return type annotation: `None`

tests/api/test_scheduler_api.py:9:5: D103 Missing docstring in public function
   |
 7 | client = TestClient(router)
 8 | 
 9 | def test_read_main():
   |     ^^^^^^^^^^^^^^ D103
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |

tests/api/test_scheduler_api.py:11:5: S101 Use of `assert` detected
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |     ^^^^^^ S101
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_scheduler_api.py:11:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
 9 | def test_read_main():
10 |     response = client.get("/")
11 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
12 |     assert response.json() == {"msg": "Hello World"}
   |

tests/api/test_scheduler_api.py:12:5: S101 Use of `assert` detected
   |
10 |     response = client.get("/")
11 |     assert response.status_code == 200
12 |     assert response.json() == {"msg": "Hello World"}
   |     ^^^^^^ S101
   |

tests/api/workcell_api_tests.py:1:1: INP001 File `tests/api/workcell_api_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/api/workcell_api_tests.py:1:1: D100 Missing docstring in public module
tests/api/workcell_api_tests.py:12:5: ANN201 Missing return type annotation for public function `test_create_workcell`
   |
10 | # --- CRUD Endpoint Tests ---
11 | 
12 | def test_create_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
13 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
14 |     response = client.post("/api/workcell/", json=workcell_data)
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:12:5: D103 Missing docstring in public function
   |
10 | # --- CRUD Endpoint Tests ---
11 | 
12 | def test_create_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ D103
13 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
14 |     response = client.post("/api/workcell/", json=workcell_data)
   |

tests/api/workcell_api_tests.py:12:46: ARG001 Unused function argument: `db_session`
   |
10 | # --- CRUD Endpoint Tests ---
11 | 
12 | def test_create_workcell(client: TestClient, db_session: Session):
   |                                              ^^^^^^^^^^ ARG001
13 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
14 |     response = client.post("/api/workcell/", json=workcell_data)
   |

tests/api/workcell_api_tests.py:15:5: S101 Use of `assert` detected
   |
13 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
14 |     response = client.post("/api/workcell/", json=workcell_data)
15 |     assert response.status_code == 201
   |     ^^^^^^ S101
16 |     data = response.json()
17 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:15:36: PLR2004 Magic value used in comparison, consider replacing `201` with a constant variable
   |
13 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
14 |     response = client.post("/api/workcell/", json=workcell_data)
15 |     assert response.status_code == 201
   |                                    ^^^ PLR2004
16 |     data = response.json()
17 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:17:5: S101 Use of `assert` detected
   |
15 |     assert response.status_code == 201
16 |     data = response.json()
17 |     assert data["name"] == VALID_WORKCELL_NAME
   |     ^^^^^^ S101
18 |     assert "accession_id" in data
   |

tests/api/workcell_api_tests.py:18:5: S101 Use of `assert` detected
   |
16 |     data = response.json()
17 |     assert data["name"] == VALID_WORKCELL_NAME
18 |     assert "accession_id" in data
   |     ^^^^^^ S101
19 | 
20 |     # Test creating with existing name (should fail)
   |

tests/api/workcell_api_tests.py:22:5: S101 Use of `assert` detected
   |
20 |     # Test creating with existing name (should fail)
21 |     response = client.post("/api/workcell/", json=workcell_data)
22 |     assert response.status_code == 400
   |     ^^^^^^ S101
23 | 
24 | def test_get_workcell_by_id(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:22:36: PLR2004 Magic value used in comparison, consider replacing `400` with a constant variable
   |
20 |     # Test creating with existing name (should fail)
21 |     response = client.post("/api/workcell/", json=workcell_data)
22 |     assert response.status_code == 400
   |                                    ^^^ PLR2004
23 | 
24 | def test_get_workcell_by_id(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:24:5: ANN201 Missing return type annotation for public function `test_get_workcell_by_id`
   |
22 |     assert response.status_code == 400
23 | 
24 | def test_get_workcell_by_id(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
25 |     # Create a workcell first
26 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:24:5: D103 Missing docstring in public function
   |
22 |     assert response.status_code == 400
23 | 
24 | def test_get_workcell_by_id(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^ D103
25 |     # Create a workcell first
26 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:24:49: ARG001 Unused function argument: `db_session`
   |
22 |     assert response.status_code == 400
23 | 
24 | def test_get_workcell_by_id(client: TestClient, db_session: Session):
   |                                                 ^^^^^^^^^^ ARG001
25 |     # Create a workcell first
26 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:31:5: S101 Use of `assert` detected
   |
30 |     response = client.get(f"/api/workcell/{created_workcell_id}")
31 |     assert response.status_code == 200
   |     ^^^^^^ S101
32 |     data = response.json()
33 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:31:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
30 |     response = client.get(f"/api/workcell/{created_workcell_id}")
31 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
32 |     data = response.json()
33 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:33:5: S101 Use of `assert` detected
   |
31 |     assert response.status_code == 200
32 |     data = response.json()
33 |     assert data["name"] == VALID_WORKCELL_NAME
   |     ^^^^^^ S101
34 |     assert data["accession_id"] == created_workcell_id
   |

tests/api/workcell_api_tests.py:34:5: S101 Use of `assert` detected
   |
32 |     data = response.json()
33 |     assert data["name"] == VALID_WORKCELL_NAME
34 |     assert data["accession_id"] == created_workcell_id
   |     ^^^^^^ S101
35 | 
36 | def test_get_workcell_by_name(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:36:5: ANN201 Missing return type annotation for public function `test_get_workcell_by_name`
   |
34 |     assert data["accession_id"] == created_workcell_id
35 | 
36 | def test_get_workcell_by_name(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     # Create a workcell first
38 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:36:5: D103 Missing docstring in public function
   |
34 |     assert data["accession_id"] == created_workcell_id
35 | 
36 | def test_get_workcell_by_name(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ D103
37 |     # Create a workcell first
38 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:36:51: ARG001 Unused function argument: `db_session`
   |
34 |     assert data["accession_id"] == created_workcell_id
35 | 
36 | def test_get_workcell_by_name(client: TestClient, db_session: Session):
   |                                                   ^^^^^^^^^^ ARG001
37 |     # Create a workcell first
38 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:42:5: S101 Use of `assert` detected
   |
41 |     response = client.get(f"/api/workcell/{VALID_WORKCELL_NAME}")
42 |     assert response.status_code == 200
   |     ^^^^^^ S101
43 |     data = response.json()
44 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:42:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
41 |     response = client.get(f"/api/workcell/{VALID_WORKCELL_NAME}")
42 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
43 |     data = response.json()
44 |     assert data["name"] == VALID_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:44:5: S101 Use of `assert` detected
   |
42 |     assert response.status_code == 200
43 |     data = response.json()
44 |     assert data["name"] == VALID_WORKCELL_NAME
   |     ^^^^^^ S101
45 | 
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:46:5: ANN201 Missing return type annotation for public function `test_get_non_existent_workcell`
   |
44 |     assert data["name"] == VALID_WORKCELL_NAME
45 | 
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
47 |     response = client.get(f"/api/workcell/{INVALID_WORKCELL_ID}")
48 |     assert response.status_code == 404
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:46:5: D103 Missing docstring in public function
   |
44 |     assert data["name"] == VALID_WORKCELL_NAME
45 | 
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
47 |     response = client.get(f"/api/workcell/{INVALID_WORKCELL_ID}")
48 |     assert response.status_code == 404
   |

tests/api/workcell_api_tests.py:46:56: ARG001 Unused function argument: `db_session`
   |
44 |     assert data["name"] == VALID_WORKCELL_NAME
45 | 
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
   |                                                        ^^^^^^^^^^ ARG001
47 |     response = client.get(f"/api/workcell/{INVALID_WORKCELL_ID}")
48 |     assert response.status_code == 404
   |

tests/api/workcell_api_tests.py:48:5: S101 Use of `assert` detected
   |
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
47 |     response = client.get(f"/api/workcell/{INVALID_WORKCELL_ID}")
48 |     assert response.status_code == 404
   |     ^^^^^^ S101
49 | 
50 | def test_list_workcells(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:48:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
46 | def test_get_non_existent_workcell(client: TestClient, db_session: Session):
47 |     response = client.get(f"/api/workcell/{INVALID_WORKCELL_ID}")
48 |     assert response.status_code == 404
   |                                    ^^^ PLR2004
49 | 
50 | def test_list_workcells(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:50:5: ANN201 Missing return type annotation for public function `test_list_workcells`
   |
48 |     assert response.status_code == 404
49 | 
50 | def test_list_workcells(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
51 |     # Create a few workcells
52 |     client.post("/api/workcell/", json={"name": "Workcell 1"})
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:50:5: D103 Missing docstring in public function
   |
48 |     assert response.status_code == 404
49 | 
50 | def test_list_workcells(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^ D103
51 |     # Create a few workcells
52 |     client.post("/api/workcell/", json={"name": "Workcell 1"})
   |

tests/api/workcell_api_tests.py:50:45: ARG001 Unused function argument: `db_session`
   |
48 |     assert response.status_code == 404
49 | 
50 | def test_list_workcells(client: TestClient, db_session: Session):
   |                                             ^^^^^^^^^^ ARG001
51 |     # Create a few workcells
52 |     client.post("/api/workcell/", json={"name": "Workcell 1"})
   |

tests/api/workcell_api_tests.py:56:5: S101 Use of `assert` detected
   |
55 |     response = client.get("/api/workcell/")
56 |     assert response.status_code == 200
   |     ^^^^^^ S101
57 |     data = response.json()
58 |     assert isinstance(data, list)
   |

tests/api/workcell_api_tests.py:56:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
55 |     response = client.get("/api/workcell/")
56 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
57 |     data = response.json()
58 |     assert isinstance(data, list)
   |

tests/api/workcell_api_tests.py:58:5: S101 Use of `assert` detected
   |
56 |     assert response.status_code == 200
57 |     data = response.json()
58 |     assert isinstance(data, list)
   |     ^^^^^^ S101
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
   |

tests/api/workcell_api_tests.py:59:5: S101 Use of `assert` detected
   |
57 |     data = response.json()
58 |     assert isinstance(data, list)
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
   |     ^^^^^^ S101
60 | 
61 | def test_update_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:59:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
57 |     data = response.json()
58 |     assert isinstance(data, list)
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
   |                         ^ PLR2004
60 | 
61 | def test_update_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:61:5: ANN201 Missing return type annotation for public function `test_update_workcell`
   |
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
60 | 
61 | def test_update_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
62 |     # Create a workcell first
63 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:61:5: D103 Missing docstring in public function
   |
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
60 | 
61 | def test_update_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ D103
62 |     # Create a workcell first
63 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:61:46: ARG001 Unused function argument: `db_session`
   |
59 |     assert len(data) >= 2 # May have other workcells from other tests if not properly isolated
60 | 
61 | def test_update_workcell(client: TestClient, db_session: Session):
   |                                              ^^^^^^^^^^ ARG001
62 |     # Create a workcell first
63 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:69:5: S101 Use of `assert` detected
   |
67 |     update_data = {"name": UPDATED_WORKCELL_NAME, "description": "Updated description"}
68 |     response = client.put(f"/api/workcell/{created_workcell_id}", json=update_data)
69 |     assert response.status_code == 200
   |     ^^^^^^ S101
70 |     data = response.json()
71 |     assert data["name"] == UPDATED_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:69:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
67 |     update_data = {"name": UPDATED_WORKCELL_NAME, "description": "Updated description"}
68 |     response = client.put(f"/api/workcell/{created_workcell_id}", json=update_data)
69 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
70 |     data = response.json()
71 |     assert data["name"] == UPDATED_WORKCELL_NAME
   |

tests/api/workcell_api_tests.py:71:5: S101 Use of `assert` detected
   |
69 |     assert response.status_code == 200
70 |     data = response.json()
71 |     assert data["name"] == UPDATED_WORKCELL_NAME
   |     ^^^^^^ S101
72 |     assert data["description"] == "Updated description"
   |

tests/api/workcell_api_tests.py:72:5: S101 Use of `assert` detected
   |
70 |     data = response.json()
71 |     assert data["name"] == UPDATED_WORKCELL_NAME
72 |     assert data["description"] == "Updated description"
   |     ^^^^^^ S101
73 | 
74 | def test_update_non_existent_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:74:5: ANN201 Missing return type annotation for public function `test_update_non_existent_workcell`
   |
72 |     assert data["description"] == "Updated description"
73 | 
74 | def test_update_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
75 |     update_data = {"name": UPDATED_WORKCELL_NAME}
76 |     response = client.put(f"/api/workcell/{INVALID_WORKCELL_ID}", json=update_data)
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:74:5: D103 Missing docstring in public function
   |
72 |     assert data["description"] == "Updated description"
73 | 
74 | def test_update_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
75 |     update_data = {"name": UPDATED_WORKCELL_NAME}
76 |     response = client.put(f"/api/workcell/{INVALID_WORKCELL_ID}", json=update_data)
   |

tests/api/workcell_api_tests.py:74:59: ARG001 Unused function argument: `db_session`
   |
72 |     assert data["description"] == "Updated description"
73 | 
74 | def test_update_non_existent_workcell(client: TestClient, db_session: Session):
   |                                                           ^^^^^^^^^^ ARG001
75 |     update_data = {"name": UPDATED_WORKCELL_NAME}
76 |     response = client.put(f"/api/workcell/{INVALID_WORKCELL_ID}", json=update_data)
   |

tests/api/workcell_api_tests.py:77:5: S101 Use of `assert` detected
   |
75 |     update_data = {"name": UPDATED_WORKCELL_NAME}
76 |     response = client.put(f"/api/workcell/{INVALID_WORKCELL_ID}", json=update_data)
77 |     assert response.status_code == 404
   |     ^^^^^^ S101
78 | 
79 | def test_delete_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:77:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
75 |     update_data = {"name": UPDATED_WORKCELL_NAME}
76 |     response = client.put(f"/api/workcell/{INVALID_WORKCELL_ID}", json=update_data)
77 |     assert response.status_code == 404
   |                                    ^^^ PLR2004
78 | 
79 | def test_delete_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:79:5: ANN201 Missing return type annotation for public function `test_delete_workcell`
   |
77 |     assert response.status_code == 404
78 | 
79 | def test_delete_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
80 |     # Create a workcell first
81 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:79:5: D103 Missing docstring in public function
   |
77 |     assert response.status_code == 404
78 | 
79 | def test_delete_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^ D103
80 |     # Create a workcell first
81 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:79:46: ARG001 Unused function argument: `db_session`
   |
77 |     assert response.status_code == 404
78 | 
79 | def test_delete_workcell(client: TestClient, db_session: Session):
   |                                              ^^^^^^^^^^ ARG001
80 |     # Create a workcell first
81 |     workcell_data = {"name": VALID_WORKCELL_NAME, "description": "A test workcell"}
   |

tests/api/workcell_api_tests.py:86:5: S101 Use of `assert` detected
   |
85 |     response = client.delete(f"/api/workcell/{created_workcell_id}")
86 |     assert response.status_code == 204
   |     ^^^^^^ S101
87 | 
88 |     # Verify it's deleted
   |

tests/api/workcell_api_tests.py:86:36: PLR2004 Magic value used in comparison, consider replacing `204` with a constant variable
   |
85 |     response = client.delete(f"/api/workcell/{created_workcell_id}")
86 |     assert response.status_code == 204
   |                                    ^^^ PLR2004
87 | 
88 |     # Verify it's deleted
   |

tests/api/workcell_api_tests.py:90:5: S101 Use of `assert` detected
   |
88 |     # Verify it's deleted
89 |     response = client.get(f"/api/workcell/{created_workcell_id}")
90 |     assert response.status_code == 404
   |     ^^^^^^ S101
91 | 
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:90:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
88 |     # Verify it's deleted
89 |     response = client.get(f"/api/workcell/{created_workcell_id}")
90 |     assert response.status_code == 404
   |                                    ^^^ PLR2004
91 | 
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
   |

tests/api/workcell_api_tests.py:92:5: ANN201 Missing return type annotation for public function `test_delete_non_existent_workcell`
   |
90 |     assert response.status_code == 404
91 | 
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
93 |     response = client.delete(f"/api/workcell/{INVALID_WORKCELL_ID}")
94 |     assert response.status_code == 404
   |
   = help: Add return type annotation: `None`

tests/api/workcell_api_tests.py:92:5: D103 Missing docstring in public function
   |
90 |     assert response.status_code == 404
91 | 
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
93 |     response = client.delete(f"/api/workcell/{INVALID_WORKCELL_ID}")
94 |     assert response.status_code == 404
   |

tests/api/workcell_api_tests.py:92:59: ARG001 Unused function argument: `db_session`
   |
90 |     assert response.status_code == 404
91 | 
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
   |                                                           ^^^^^^^^^^ ARG001
93 |     response = client.delete(f"/api/workcell/{INVALID_WORKCELL_ID}")
94 |     assert response.status_code == 404
   |

tests/api/workcell_api_tests.py:94:5: S101 Use of `assert` detected
   |
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
93 |     response = client.delete(f"/api/workcell/{INVALID_WORKCELL_ID}")
94 |     assert response.status_code == 404
   |     ^^^^^^ S101
   |

tests/api/workcell_api_tests.py:94:36: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
92 | def test_delete_non_existent_workcell(client: TestClient, db_session: Session):
93 |     response = client.delete(f"/api/workcell/{INVALID_WORKCELL_ID}")
94 |     assert response.status_code == 404
   |                                    ^^^ PLR2004
   |

tests/asset_manager_tests.py:1:1: INP001 File `tests/asset_manager_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/asset_manager_tests.py:1:15: PGH003 Use specific rule codes when ignoring type issues
  |
1 | import pytest # type: ignore
  |               ^^^^^^^^^^^^^^ PGH003
2 | from unittest.mock import MagicMock, patch, call, ANY
3 | from typing import List, Optional, Any, Dict, Type
  |

tests/asset_manager_tests.py:20:31: COM812 Trailing comma missing
   |
18 | from praxis.backend.database_models.asset_management_orm import (
19 |     ManagedDeviceStatusEnum, ResourceStatusEnum, PraxisDeviceCategoryEnum, ResourceCategoryEnum,
20 |     DeckLayoutOrm, DeckSlotOrm # ADDED for DeckLoading tests
   |                                COM812
21 | )
22 | from praxis.protocol_core.definitions import Deck as ProtocolDeck # ADDED for DeckLoading tests
   |
   = help: Add trailing comma

tests/asset_manager_tests.py:212:38: COM812 Trailing comma missing
    |
210 |         data.update({
211 |             "size_x": self.size_x, "size_y": self.size_y, "size_z": self.size_z,
212 |             "capacity": self.capacity
    |                                       COM812
213 |         })
214 |         return data
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:233:65: COM812 Trailing comma missing
    |
231 |         data.update({
232 |             "num_items": self.num_items,
233 |             "wells_data": [{"name": w.name} for w in self.wells] # Simulate serialized well data
    |                                                                  COM812
234 |         })
235 |         return data
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:259:9: ERA001 Found commented-out code
    |
258 |     def __init__(self, name: str, **kwargs: Any):
259 |         # super().__init__(name, **kwargs) # Don't call super if init itself fails
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
260 |         self.__class__.__module__ = "pylabrobot.resources.mock_fails"
261 |         self.__class__.__name__ = "MockResourceInstantiationFails"
    |
    = help: Remove commented-out code

tests/asset_manager_tests.py:270:121: E501 Line too long (131 > 120)
    |
269 | # Helper function for mocking module discovery
270 | def setup_mock_modules(mock_walk_packages_target, mock_import_module_target, mock_getmembers_target, resource_classes_to_discover):
    |                                                                                                                         ^^^^^^^^^^^ E501
271 |     """
272 |     Configures mocks for pkgutil.walk_packages, importlib.import_module, and inspect.getmembers
    |

tests/asset_manager_tests.py:308:13: ERA001 Found commented-out code
    |
306 |         # Fallback for other imports if AssetManager tries to import something else from pylabrobot.resources
307 |         if name_import.startswith("pylabrobot.resources"):
308 |             # print(f"DEBUG_IMPORT_HELPER: Mock importing {name_import} as new MagicMock")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
309 |             return MagicMock(__name__=name_import) # Return a generic mock for other PLR modules
310 |         raise ImportError(f"No mock for module {name_import} in setup_mock_modules")
    |
    = help: Remove commented-out code

tests/asset_manager_tests.py:317:13: ERA001 Found commented-out code
    |
315 |         module_name_lookup = getattr(module_obj, '__name__', None)
316 |         if module_name_lookup in discovered_modules_info:
317 |             # print(f"DEBUG_GETMEMBERS_HELPER: Returning members for {module_name_lookup}: {discovered_modules_info[module_name_lookup][1]}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
318 |             # Filter by predicate if provided, as inspect.getmembers does
319 |             if predicate:
    |
    = help: Remove commented-out code

tests/asset_manager_tests.py:317:121: E501 Line too long (141 > 120)
    |
315 |         module_name_lookup = getattr(module_obj, '__name__', None)
316 |         if module_name_lookup in discovered_modules_info:
317 |             # print(f"DEBUG_GETMEMBERS_HELPER: Returning members for {module_name_lookup}: {discovered_modules_info[module_name_lookup][1]}")
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
318 |             # Filter by predicate if provided, as inspect.getmembers does
319 |             if predicate:
    |

tests/asset_manager_tests.py:320:121: E501 Line too long (127 > 120)
    |
318 |             # Filter by predicate if provided, as inspect.getmembers does
319 |             if predicate:
320 |                 return [(name, member) for name, member in discovered_modules_info[module_name_lookup][1] if predicate(member)]
    |                                                                                                                         ^^^^^^^ E501
321 |             return discovered_modules_info[module_name_lookup][1]
322 |         # print(f"DEBUG_GETMEMBERS_HELPER: No members for {module_name_lookup}")
    |

tests/asset_manager_tests.py:322:9: ERA001 Found commented-out code
    |
320 |                 return [(name, member) for name, member in discovered_modules_info[module_name_lookup][1] if predicate(member)]
321 |             return discovered_modules_info[module_name_lookup][1]
322 |         # print(f"DEBUG_GETMEMBERS_HELPER: No members for {module_name_lookup}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
323 |         return []
324 |     mock_getmembers_target.side_effect = getmembers_side_effect
    |
    = help: Remove commented-out code

tests/asset_manager_tests.py:359:121: E501 Line too long (135 > 120)
    |
357 | class TestAssetManagerAcquireDevice:
358 | 
359 |     def test_acquire_machine_success(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock):
    |                                                                                                                         ^^^^^^^^^^^^^^^ E501
360 |         mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1", fqn="SomeDeviceClass")
361 |         mock_ads_service.list_managed_machines.return_value = [mock_machine_orm]
    |

tests/asset_manager_tests.py:362:121: E501 Line too long (124 > 120)
    |
360 |         mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1", fqn="SomeDeviceClass")
361 |         mock_ads_service.list_managed_machines.return_value = [mock_machine_orm]
362 |         updated_mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1", current_status=ManagedDeviceStatusEnum.IN_USE)
    |                                                                                                                         ^^^^ E501
363 |         mock_ads_service.update_managed_machine_status.return_value = updated_mock_machine_orm
    |

tests/asset_manager_tests.py:368:45: COM812 Trailing comma missing
    |
366 |             protocol_run_accession_id="run123",
367 |             requested_asset_name_in_protocol="dev_in_proto",
368 |             fqn_constraint="SomeDeviceClass"
    |                                              COM812
369 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:374:54: COM812 Trailing comma missing
    |
372 |             asset_manager.db,
373 |             status=ManagedDeviceStatusEnum.AVAILABLE,
374 |             pylabrobot_class_filter="SomeDeviceClass"
    |                                                       COM812
375 |         )
376 |         mock_workcell_runtime.initialize_machine_backend.assert_called_once_with(mock_machine_orm)
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:380:50: COM812 Trailing comma missing
    |
378 |             asset_manager.db, 1, ManagedDeviceStatusEnum.IN_USE,
379 |             current_protocol_run_accession_id="run123",
380 |             status_details="In use by run run123"
    |                                                   COM812
381 |         )
382 |         assert live_machine is mock_workcell_runtime.initialize_machine_backend.return_value
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:388:121: E501 Line too long (141 > 120)
    |
386 |     def test_acquire_machine_no_machine_found(self, asset_manager: AssetManager, mock_ads_service: MagicMock):
387 |         mock_ads_service.list_managed_machines.return_value = []
388 |         with pytest.raises(AssetAcquisitionError, match="No machine found matching type constraint 'SomeDeviceClass' and status AVAILABLE."):
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^ E501
389 |             asset_manager.acquire_machine("run123", "dev", "SomeDeviceClass")
    |

tests/asset_manager_tests.py:391:121: E501 Line too long (146 > 120)
    |
389 |             asset_manager.acquire_machine("run123", "dev", "SomeDeviceClass")
390 | 
391 |     def test_acquire_machine_backend_init_fails(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock):
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
392 |         mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1")
393 |         mock_ads_service.list_managed_machines.return_value = [mock_machine_orm]
    |

tests/asset_manager_tests.py:399:121: E501 Line too long (161 > 120)
    |
397 |             asset_manager.acquire_machine("run123", "dev", "SomeDeviceClass")
398 | 
399 |     def test_acquire_machine_db_status_update_fails_after_init(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock):
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
400 |         mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1")
401 |         mock_ads_service.list_managed_machines.return_value = [mock_machine_orm]
    |

tests/asset_manager_tests.py:404:121: E501 Line too long (148 > 120)
    |
402 |         mock_ads_service.update_managed_machine_status.return_value = None
403 | 
404 |         with pytest.raises(AssetAcquisitionError, match="CRITICAL: Device 'Device1' backend is live, but FAILED to update its DB status to IN_USE"):
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
405 |             asset_manager.acquire_machine("run123", "dev", "SomeDeviceClass")
    |

tests/asset_manager_tests.py:418:71: COM812 Trailing comma missing
    |
416 |     def test_acquire_resource_success_from_storage(
417 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
418 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
    |                                                                        COM812
419 |     ):
420 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="some_plate_def_name")
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:420:60: SyntaxError: Duplicate keyword argument "name"
    |
418 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
419 |     ):
420 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="some_plate_def_name")
    |                                                            ^
421 |         mock_ads_service.read_resources.side_effect = [
422 |             [],
    |

tests/asset_manager_tests.py:423:26: COM812 Trailing comma missing
    |
421 |         mock_ads_service.read_resources.side_effect = [
422 |             [],
423 |             [mock_lw_orm]
    |                           COM812
424 |         ]
425 |         mock_ads_service.get_resource_definition.return_value = mock_resource_def
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:432:50: COM812 Trailing comma missing
    |
430 |             protocol_run_accession_id="run123",
431 |             requested_asset_name_in_protocol="lw_in_proto",
432 |             name_constraint="some_plate_def_name"
    |                                                   COM812
433 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:438:71: COM812 Trailing comma missing
    |
436 |         mock_workcell_runtime.create_or_get_resource_plr_object.assert_called_once_with(
437 |             resource_orm=mock_lw_orm,
438 |             resource_definition_fqn="pylabrobot.resources.plate.Plate"
    |                                                                        COM812
439 |         )
440 |         mock_ads_service.update_resource_instance_location_and_status.assert_called_with(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:444:50: COM812 Trailing comma missing
    |
442 |             new_status=ResourceStatusEnum.IN_USE,
443 |             current_protocol_run_accession_id="run123",
444 |             status_details="In use by run run123"
    |                                                   COM812
445 |         )
446 |         assert live_resource is mock_workcell_runtime.create_or_get_resource_plr_object.return_value
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:452:71: COM812 Trailing comma missing
    |
450 |     def test_acquire_resource_with_deck_assignment(
451 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
452 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
    |                                                                        COM812
453 |     ):
454 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="some_plate_def_name")
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:454:60: SyntaxError: Duplicate keyword argument "name"
    |
452 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
453 |     ):
454 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="some_plate_def_name")
    |                                                            ^
455 |         mock_deck_orm = ManagedDeviceOrmMock(id=10, name="MainDeck")
    |

tests/asset_manager_tests.py:467:54: COM812 Trailing comma missing
    |
465 |             requested_asset_name_in_protocol="plate_on_deck",
466 |             name_constraint="some_plate_def_name",
467 |             location_constraints=location_constraints
    |                                                       COM812
468 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:471:107: COM812 Trailing comma missing
    |
470 |         mock_ads_service.list_managed_machines.assert_called_once_with(
471 |             asset_manager.db, name_filter="MainDeck", praxis_category_filter=PraxisDeviceCategoryEnum.DECK
    |                                                                                                            COM812
472 |         )
473 |         mock_workcell_runtime.assign_resource_to_deck_slot.assert_called_once_with(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:477:63: COM812 Trailing comma missing
    |
475 |             slot_name="A1",
476 |             resource_plr_object=mock_workcell_runtime.create_or_get_resource_plr_object.return_value,
477 |             resource_orm_accession_id=mock_lw_orm.accession_id
    |                                                                COM812
478 |         )
479 |         mock_ads_service.update_resource_instance_location_and_status.assert_called_with(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:483:50: COM812 Trailing comma missing
    |
481 |             new_status=ResourceStatusEnum.IN_USE,
482 |             current_protocol_run_accession_id="run123",
483 |             status_details="In use by run run123"
    |                                                   COM812
484 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:491:121: E501 Line too long (123 > 120)
    |
489 |         mock_ads_service.get_resource_definition.return_value = None
490 | 
491 |         with pytest.raises(AssetAcquisitionError, match="Python FQN not found for resource definition 'unknown_def_name'"):
    |                                                                                                                         ^^^ E501
492 |             asset_manager.acquire_resource("run123", "lw", "unknown_def_name")
    |

tests/asset_manager_tests.py:497:31: COM812 Trailing comma missing
    |
495 |             db=asset_manager.db, resource_instance_accession_id=mock_lw_orm.accession_id,
496 |             new_status=ResourceStatusEnum.ERROR,
497 |             status_details=ANY
    |                                COM812
498 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:502:71: COM812 Trailing comma missing
    |
500 |     def test_acquire_resource_plr_object_creation_fails(
501 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
502 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
    |                                                                        COM812
503 |     ):
504 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="def")
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:504:60: SyntaxError: Duplicate keyword argument "name"
    |
502 |         mock_workcell_runtime: MagicMock, mock_resource_def: MagicMock
503 |     ):
504 |         mock_lw_orm = ResourceOrmMock(id=1, name="Plate1", name="def")
    |                                                            ^
505 |         mock_ads_service.read_resources.return_value = [mock_lw_orm]
506 |         mock_ads_service.get_resource_definition.return_value = mock_resource_def
    |

tests/asset_manager_tests.py:514:121: E501 Line too long (127 > 120)
    |
512 | class TestAssetManagerRelease:
513 | 
514 |     def test_release_machine(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock):
    |                                                                                                                         ^^^^^^^ E501
515 |         mock_machine_after_shutdown = ManagedDeviceOrmMock(id=1, current_status=ManagedDeviceStatusEnum.OFFLINE)
516 |         mock_ads_service.get_managed_machine.return_value = mock_machine_after_shutdown
    |

tests/asset_manager_tests.py:524:87: COM812 Trailing comma missing
    |
522 |         mock_ads_service.update_managed_machine_status.assert_called_with(
523 |             asset_manager.db, 1, ManagedDeviceStatusEnum.AVAILABLE,
524 |             status_details="Released from run", current_protocol_run_accession_id=None
    |                                                                                        COM812
525 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:528:105: COM812 Trailing comma missing
    |
527 |     def test_release_resource_no_deck_clear(
528 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock
    |                                                                                                          COM812
529 |     ):
530 |         asset_manager.release_resource(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:533:46: COM812 Trailing comma missing
    |
531 |             resource_orm_accession_id=1,
532 |             final_status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
533 |             status_details="Stored after run"
    |                                               COM812
534 |         )
535 |         mock_workcell_runtime.clear_deck_slot.assert_not_called()
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:543:46: COM812 Trailing comma missing
    |
541 |             current_deck_slot_name=None,
542 |             current_protocol_run_accession_id=None,
543 |             status_details="Stored after run"
    |                                               COM812
544 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:547:105: COM812 Trailing comma missing
    |
546 |     def test_release_resource_with_deck_clear(
547 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock
    |                                                                                                          COM812
548 |     ):
549 |         asset_manager.release_resource(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:554:58: COM812 Trailing comma missing
    |
552 |             clear_from_deck_machine_accession_id=10,
553 |             clear_from_slot_name="A1",
554 |             status_details="Cleared from deck and stored"
    |                                                           COM812
555 |         )
556 |         mock_workcell_runtime.clear_deck_slot.assert_called_once_with(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:557:90: COM812 Trailing comma missing
    |
555 |         )
556 |         mock_workcell_runtime.clear_deck_slot.assert_called_once_with(
557 |             deck_machine_orm_accession_id=10, slot_name="A1", resource_orm_accession_id=1
    |                                                                                           COM812
558 |         )
559 |         mock_ads_service.update_resource_instance_location_and_status.assert_called_once_with(
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:566:58: COM812 Trailing comma missing
    |
564 |             current_deck_slot_name=None,
565 |             current_protocol_run_accession_id=None,
566 |             status_details="Cleared from deck and stored"
    |                                                           COM812
567 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:590:121: E501 Line too long (127 > 120)
    |
588 |         monkeypatch.setattr("praxis.backend.core.asset_manager.pkgutil.walk_packages", self.mock_walk_packages_target)
589 |         monkeypatch.setattr("praxis.backend.core.asset_manager.importlib.import_module", self.mock_import_module_target)
590 |         monkeypatch.setattr("praxis.backend.core.asset_manager.inspect.getmembers", self.mock_getmembers_target) # Patched here
    |                                                                                                                         ^^^^^^^ E501
591 | 
592 |         monkeypatch.setattr("praxis.backend.core.asset_manager.inspect.isabstract", self.mock_isabstract_inspect)
    |

tests/asset_manager_tests.py:596:121: E501 Line too long (130 > 120)
    |
594 |         monkeypatch.setattr("praxis.backend.core.asset_manager.issubclass", self.mock_issubclass_inspect)
595 |         # Patch for the constructor param utility
596 |         monkeypatch.setattr("praxis.backend.core.asset_manager.get_resource_constructor_params", self.mock_get_constructor_params)
    |                                                                                                                         ^^^^^^^^^^ E501
    |

tests/asset_manager_tests.py:624:41: E701 Multiple statements on one line (colon)
    |
623 |         def _mock_issubclass(obj, base):
624 |             if not isinstance(obj, type): return False
    |                                         ^ E701
625 |             if not inspect.isclass(base): return False
626 |             return issubclass(obj, base)
    |

tests/asset_manager_tests.py:625:41: E701 Multiple statements on one line (colon)
    |
623 |         def _mock_issubclass(obj, base):
624 |             if not isinstance(obj, type): return False
625 |             if not inspect.isclass(base): return False
    |                                         ^ E701
626 |             return issubclass(obj, base)
627 |         self.mock_issubclass_inspect.side_effect = _mock_issubclass
    |

tests/asset_manager_tests.py:632:121: E501 Line too long (149 > 120)
    |
630 |         class MockSimplePlateDef(MockPlrPlate):
631 |             resource_type = "simple_plate_type_inst"
632 |             def __init__(self, name: str, model: Optional[str] = "TestModel123", size_x: Optional[float] = 120.0, capacity: Optional[float] = 100.0):
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
633 |                 super().__init__(name, model=model, size_x=size_x, capacity=capacity)
634 |                 self.model = model
    |

tests/asset_manager_tests.py:657:121: E501 Line too long (144 > 120)
    |
655 |         self.mock_ads_service.get_resource_definition.return_value = None
656 | 
657 |         added, updated = asset_manager.sync_pylabrobot_definitions(plr_resources_package=MagicMock(__path__=['dummy'], __name__='mock_plr_pkg'))
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
658 | 
659 |         assert added == 1
    |

tests/asset_manager_tests.py:671:121: E501 Line too long (147 > 120)
    |
669 |         assert call_args['size_x_mm'] == 120.0
670 |         assert call_args['nominal_volume_ul'] == 100.0
671 |         assert call_args['plr_definition_details_json'] == {"custom_field": "value", "name": ANY, "model": "TestModel123", "category_str": "plate"}
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
672 |         assert call_args['is_consumable'] is True
673 |         assert "MockSimplePlateToSync" in call_args['description']
    |

tests/asset_manager_tests.py:697:102: COM812 Trailing comma missing
    |
695 |             'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty},
696 |             'backend': {'type': 'SomeBackendClass', 'required': True, 'default': inspect.Parameter.empty},
697 |             'another_required': {'type': 'int', 'required': True, 'default': inspect.Parameter.empty}
    |                                                                                                       COM812
698 |         }
699 |         self.mock_ads_service.get_resource_definition.return_value = None
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:701:121: E501 Line too long (144 > 120)
    |
699 |         self.mock_ads_service.get_resource_definition.return_value = None
700 | 
701 |         added, updated = asset_manager.sync_pylabrobot_definitions(plr_resources_package=MagicMock(__path__=['dummy'], __name__='mock_plr_pkg'))
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
702 | 
703 |         assert added == 1
    |

tests/asset_manager_tests.py:716:121: E501 Line too long (142 > 120)
    |
714 |         assert call_args['nominal_volume_ul'] is None
715 |         assert call_args['plr_definition_details_json'] is None
716 |         assert "Skipping instantiation for mock_module.complex.MockComplexResource due to complex required parameter 'backend'" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^ E501
717 | 
718 |     def test_sync_instantiation_failure_fallback_to_class_data(self, asset_manager: AssetManager, caplog):
    |

tests/asset_manager_tests.py:737:90: COM812 Trailing comma missing
    |
735 |         self.mock_isabstract_inspect.return_value = False
736 |         self.mock_get_constructor_params.return_value = {
737 |             'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty}
    |                                                                                           COM812
738 |         }
739 |         self.mock_ads_service.get_resource_definition.return_value = None
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:741:121: E501 Line too long (144 > 120)
    |
739 |         self.mock_ads_service.get_resource_definition.return_value = None
740 | 
741 |         added, updated = asset_manager.sync_pylabrobot_definitions(plr_resources_package=MagicMock(__path__=['dummy'], __name__='mock_plr_pkg'))
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
742 | 
743 |         assert added == 1
    |

tests/asset_manager_tests.py:756:121: E501 Line too long (157 > 120)
    |
754 |         assert call_args['nominal_volume_ul'] is None
755 |         assert call_args['plr_definition_details_json'] is None
756 |         assert "WARNING: Instantiation of mock_module.failing.MockFailingResource failed even with smart defaults: Test instantiation failure" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
757 | 
758 |     def test_sync_filters_excluded_classes(self, asset_manager: AssetManager, monkeypatch):
    |

tests/asset_manager_tests.py:795:46: COM812 Trailing comma missing
    |
793 |         self.mock_walk_packages.return_value = [
794 |             (None, 'mock_module.excluded', False),
795 |             (None, 'mock_module.kept', False)
    |                                               COM812
796 |         ]
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:799:46: E701 Multiple statements on one line (colon)
    |
798 |         def import_module_side_effect(name):
799 |             if name == 'mock_module.excluded': return mock_module_excluded
    |                                              ^ E701
800 |             if name == 'mock_module.kept': return mock_module_kept
801 |             raise ImportError
    |

tests/asset_manager_tests.py:800:42: E701 Multiple statements on one line (colon)
    |
798 |         def import_module_side_effect(name):
799 |             if name == 'mock_module.excluded': return mock_module_excluded
800 |             if name == 'mock_module.kept': return mock_module_kept
    |                                          ^ E701
801 |             raise ImportError
802 |         self.mock_import_module.side_effect = import_module_side_effect
    |

tests/asset_manager_tests.py:812:49: COM812 Trailing comma missing
    |
810 |                     ('MockExcludedByBase', MockExcludedByBase),
811 |                     ('MockAbstractResource', MockAbstractResource),
812 |                     ('NonResource', NonResource)
    |                                                  COM812
813 |                 ]
814 |             if module_obj == mock_module_kept:
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:822:121: E501 Line too long (122 > 120)
    |
821 |         self.mock_get_constructor_params.side_effect = lambda cls: \
822 |             {'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty}} if cls == KeptResource else {}
    |                                                                                                                         ^^ E501
823 | 
824 |         self.mock_ads_service.get_resource_definition.return_value = None
    |

tests/asset_manager_tests.py:826:121: E501 Line too long (144 > 120)
    |
824 |         self.mock_ads_service.get_resource_definition.return_value = None
825 | 
826 |         added, updated = asset_manager.sync_pylabrobot_definitions(plr_resources_package=MagicMock(__path__=['dummy'], __name__='mock_plr_pkg'))
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ E501
827 | 
828 |         asset_manager.EXCLUDED_CLASS_NAMES = original_excluded_names
    |

tests/asset_manager_tests.py:845:55: COM812 Trailing comma missing
    |
843 |             self.mock_import_module_target,
844 |             self.mock_getmembers_target,
845 |             [MockResourceSimple, MockResourceItemized]
    |                                                        COM812
846 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:854:79: COM812 Trailing comma missing
    |
852 |         itemized_params = {
853 |             'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty},
854 |             'num_items_init': {'type': 'int', 'required': False, 'default': 5}
    |                                                                                COM812
855 |         }
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:858:41: E701 Multiple statements on one line (colon)
    |
857 |         def get_constructor_params_side_effect(cls):
858 |             if cls == MockResourceSimple: return simple_params
    |                                         ^ E701
859 |             if cls == MockResourceItemized: return itemized_params
860 |             return {}
    |

tests/asset_manager_tests.py:859:43: E701 Multiple statements on one line (colon)
    |
857 |         def get_constructor_params_side_effect(cls):
858 |             if cls == MockResourceSimple: return simple_params
859 |             if cls == MockResourceItemized: return itemized_params
    |                                           ^ E701
860 |             return {}
861 |         self.mock_get_constructor_params.side_effect = get_constructor_params_side_effect
    |

tests/asset_manager_tests.py:878:121: E501 Line too long (134 > 120)
    |
876 |         assert args_simple['name'] == 'simple_resource' # From class attribute
877 |         assert args_simple['resource_type'] == 'SimpleModel' # From class attribute, instance uses it
878 |         assert args_simple['category'] == ResourceCategoryEnum.OTHER # Default from MockBaseResource via _get_category_from_plr_object
    |                                                                                                                         ^^^^^^^^^^^^^^ E501
879 |         assert args_simple['model'] == 'SimpleModel'
880 |         assert args_simple['size_x_mm'] == 10.0
    |

tests/asset_manager_tests.py:904:45: COM812 Trailing comma missing
    |
902 |             self.mock_import_module_target,
903 |             self.mock_getmembers_target,
904 |             [MockResourceComplexConstructor]
    |                                              COM812
905 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:910:77: COM812 Trailing comma missing
    |
908 |             'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty},
909 |             'required_object': {'type': 'SomeNonSimpleType', 'required': True, 'default': inspect.Parameter.empty},
910 |             'optional_int': {'type': 'int', 'required': False, 'default': 0}
    |                                                                              COM812
911 |         }
912 |         self.mock_ads_service.get_resource_definition.return_value = None
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:924:121: E501 Line too long (129 > 120)
    |
922 |         assert args_complex['resource_type'] == 'ComplexModel' # From class
923 |         assert args_complex['model'] == 'ComplexModel' # From class attribute, as instance not created
924 |         assert args_complex['nominal_volume_ul'] is None # class_volume not automatically picked up by _extract_volume from class
    |                                                                                                                         ^^^^^^^^^ E501
925 |         # Ensure details_json does not contain instance-specific data if temp_instance was None
926 |         details_complex = args_complex['plr_definition_details_json']
    |

tests/asset_manager_tests.py:932:121: E501 Line too long (218 > 120)
    |
930 |         assert "praxis_extracted_ordering" not in details_complex
931 | 
932 |         assert "INFO: AM_SYNC: Skipping instantiation for pylabrobot.resources.mock_complex.MockResourceComplexConstructor due to complex required parameter 'required_object' of type 'SomeNonSimpleType'" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
933 |         assert "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_complex.MockResourceComplexConstructor without a temporary instance" in caplog.text
    |

tests/asset_manager_tests.py:933:121: E501 Line too long (171 > 120)
    |
932 |         assert "INFO: AM_SYNC: Skipping instantiation for pylabrobot.resources.mock_complex.MockResourceComplexConstructor due to complex required parameter 'required_object' of type 'SomeNonSimpleType'" in caplog.text
933 |         assert "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_complex.MockResourceComplexConstructor without a temporary instance" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

tests/asset_manager_tests.py:941:45: COM812 Trailing comma missing
    |
939 |             self.mock_import_module_target,
940 |             self.mock_getmembers_target,
941 |             [MockResourceInstantiationFails]
    |                                              COM812
942 |         )
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:945:90: COM812 Trailing comma missing
    |
944 |         self.mock_get_constructor_params.return_value = {
945 |             'name': {'type': 'str', 'required': True, 'default': inspect.Parameter.empty}
    |                                                                                           COM812
946 |         }
947 |         self.mock_ads_service.get_resource_definition.return_value = None
    |
    = help: Add trailing comma

tests/asset_manager_tests.py:962:121: E501 Line too long (200 > 120)
    |
960 |         assert args_fail['size_x_mm'] is None
961 | 
962 |         assert "WARNING: AM_SYNC: Instantiation of pylabrobot.resources.mock_fails.MockResourceInstantiationFails failed even with smart defaults: ValueError('Cannot instantiate this')" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
963 |         assert "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_fails.MockResourceInstantiationFails without a temporary instance" in caplog.text
    |

tests/asset_manager_tests.py:963:121: E501 Line too long (169 > 120)
    |
962 |         assert "WARNING: AM_SYNC: Instantiation of pylabrobot.resources.mock_fails.MockResourceInstantiationFails failed even with smart defaults: ValueError('Cannot instantiate this')" in caplog.text
963 |         assert "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_fails.MockResourceInstantiationFails without a temporary instance" in caplog.text
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
    |

tests/asset_manager_tests.py:973:9: ERA001 Found commented-out code
    |
971 |         deck_layout.accession_id = 1
972 |         deck_layout.name = "TestDeckLayout"
973 |         # deck_layout.managing_machine_accession_id = 50 # Assuming a link if needed, or handled by name+category
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
974 |         return deck_layout
    |
    = help: Remove commented-out code

tests/asset_manager_tests.py:1019:121: E501 Line too long (122 > 120)
     |
1017 |             asset_manager.apply_deck_instance("NonExistentLayout", "run123")
1018 | 
1019 |     def test_deck_machine_not_found(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_deck_layout_orm):
     |                                                                                                                         ^^ E501
1020 |         mock_ads_service.get_deck_layout_by_name.return_value = mock_deck_layout_orm
1021 |         mock_ads_service.list_managed_machines.return_value = [] # No deck found
     |

tests/asset_manager_tests.py:1022:121: E501 Line too long (127 > 120)
     |
1020 |         mock_ads_service.get_deck_layout_by_name.return_value = mock_deck_layout_orm
1021 |         mock_ads_service.list_managed_machines.return_value = [] # No deck found
1022 |         with pytest.raises(AssetAcquisitionError, match="No ManagedDevice found for deck 'TestDeckLayout' with category DECK"):
     |                                                                                                                         ^^^^^^^ E501
1023 |             asset_manager.apply_deck_instance("TestDeckLayout", "run123")
1024 |         mock_ads_service.list_managed_machines.assert_called_once_with(
     |

tests/asset_manager_tests.py:1027:65: COM812 Trailing comma missing
     |
1025 |             asset_manager.db,
1026 |             name_filter="TestDeckLayout",
1027 |             praxis_category_filter=PraxisDeviceCategoryEnum.DECK
     |                                                                  COM812
1028 |         )
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1032:86: COM812 Trailing comma missing
     |
1030 |     def test_deck_machine_init_fails(
1031 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
1032 |         mock_deck_layout_orm, mock_deck_machine_orm, mock_workcell_runtime: MagicMock
     |                                                                                       COM812
1033 |     ):
1034 |         mock_ads_service.get_deck_layout_by_name.return_value = mock_deck_layout_orm
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1044:86: COM812 Trailing comma missing
     |
1042 |     def test_successful_deck_config_no_resource(
1043 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
1044 |         mock_deck_layout_orm, mock_deck_machine_orm, mock_workcell_runtime: MagicMock
     |                                                                                       COM812
1045 |     ):
1046 |         mock_ads_service.get_deck_layout_by_name.return_value = mock_deck_layout_orm
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1058:72: COM812 Trailing comma missing
     |
1056 |             asset_manager.db, mock_deck_machine_orm.accession_id, ManagedDeviceStatusEnum.IN_USE,
1057 |             current_protocol_run_accession_id="run123",
1058 |             status_details="Deck 'TestDeckLayout' in use by run run123"
     |                                                                         COM812
1059 |         )
1060 |         mock_workcell_runtime.assign_resource_to_deck_slot.assert_not_called()
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1065:91: COM812 Trailing comma missing
     |
1063 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
1064 |         mock_deck_layout_orm, mock_deck_machine_orm, mock_slot_orm,
1065 |         mock_resource_orm, mock_resource_def_catalog_orm, mock_workcell_runtime: MagicMock
     |                                                                                            COM812
1066 |     ):
1067 |         mock_ads_service.get_deck_layout_by_name.return_value = mock_deck_layout_orm
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1084:70: COM812 Trailing comma missing
     |
1082 |         mock_workcell_runtime.create_or_get_resource_plr_object.assert_called_once_with(
1083 |             resource_orm=mock_resource_orm,
1084 |             resource_definition_fqn=mock_resource_def_catalog_orm.fqn
     |                                                                       COM812
1085 |         )
1086 |         mock_workcell_runtime.assign_resource_to_deck_slot.assert_called_once_with(
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1090:69: COM812 Trailing comma missing
     |
1088 |             slot_name=mock_slot_orm.slot_name,
1089 |             resource_plr_object=live_plr_resource_obj,
1090 |             resource_orm_accession_id=mock_resource_orm.accession_id
     |                                                                      COM812
1091 |         )
1092 |         mock_ads_service.update_resource_instance_location_and_status.assert_called_once_with(
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1100:116: COM812 Trailing comma missing
     |
1098 |             current_deck_slot_name=mock_slot_orm.slot_name,
1099 |             deck_slot_orm_accession_id=mock_slot_orm.accession_id,
1100 |             status_details=f"On deck '{mock_deck_layout_orm.name}' slot '{mock_slot_orm.slot_name}' for run run123"
     |                                                                                                                     COM812
1101 |         )
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1106:60: COM812 Trailing comma missing
     |
1104 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
1105 |         mock_deck_layout_orm, mock_deck_machine_orm, mock_slot_orm,
1106 |         mock_resource_orm, mock_workcell_runtime: MagicMock
     |                                                             COM812
1107 |     ):
1108 |         mock_resource_orm.current_status = ResourceStatusEnum.IN_USE # Not available
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1123:91: COM812 Trailing comma missing
     |
1121 |         self, asset_manager: AssetManager, mock_ads_service: MagicMock,
1122 |         mock_deck_layout_orm, mock_deck_machine_orm, mock_slot_orm,
1123 |         mock_resource_orm, mock_resource_def_catalog_orm, mock_workcell_runtime: MagicMock
     |                                                                                            COM812
1124 |     ):
1125 |         mock_resource_def_catalog_orm.fqn = None # FQN missing
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1140:121: E501 Line too long (162 > 120)
     |
1138 | class TestAssetManagerLogging:
1139 | 
1140 |     def test_acquire_resource_logs_property_constraints(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock, caplog):
     |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1141 |         # Setup for a successful resource acquisition to reach the logging point
1142 |         mock_lw_orm = ResourceOrmMock(id=1, name="PlateLogTest", name="log_plate_def")
     |

tests/asset_manager_tests.py:1142:66: SyntaxError: Duplicate keyword argument "name"
     |
1140 |     def test_acquire_resource_logs_property_constraints(self, asset_manager: AssetManager, mock_ads_service: MagicMock, mock_workcell_runtime: MagicMock, caplog):
1141 |         # Setup for a successful resource acquisition to reach the logging point
1142 |         mock_lw_orm = ResourceOrmMock(id=1, name="PlateLogTest", name="log_plate_def")
     |                                                                  ^
1143 |         mock_resource_def = ResourceDefinitionOrmMock()
1144 |         mock_resource_def.fqn = "pylabrobot.resources.plate.Plate" # Valid FQN
     |

tests/asset_manager_tests.py:1163:44: COM812 Trailing comma missing
     |
1161 |             asset_manager.acquire_asset(
1162 |                 protocol_run_accession_id="log_run_123",
1163 |                 asset_requirement=asset_req
     |                                             COM812
1164 |             )
1165 |         except AssetAcquisitionError: # Catch if something else fails, to still check logs
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1168:121: E501 Line too long (158 > 120)
     |
1166 |             pass
1167 | 
1168 |         assert f"INFO: AM_ACQUIRE: Resource acquisition for 'test_plate_for_log' includes property_constraints: {property_constraints_payload}" in caplog.text
     |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1169 | 
1170 |     def test_release_resource_logs_properties_update(self, asset_manager: AssetManager, mock_ads_service: MagicMock, caplog):
     |

tests/asset_manager_tests.py:1170:121: E501 Line too long (125 > 120)
     |
1168 |         assert f"INFO: AM_ACQUIRE: Resource acquisition for 'test_plate_for_log' includes property_constraints: {property_constraints_payload}" in caplog.text
1169 | 
1170 |     def test_release_resource_logs_properties_update(self, asset_manager: AssetManager, mock_ads_service: MagicMock, caplog):
     |                                                                                                                         ^^^^^ E501
1171 |         # Setup for release_resource
1172 |         final_props_update = {"content_state": "empty", "cleaned": True}
     |

tests/asset_manager_tests.py:1184:66: COM812 Trailing comma missing
     |
1182 |             final_status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
1183 |             final_properties_json_update=final_props_update,
1184 |             status_details="Logging properties update on release"
     |                                                                   COM812
1185 |         )
     |
     = help: Add trailing comma

tests/asset_manager_tests.py:1187:121: E501 Line too long (147 > 120)
     |
1185 |         )
1186 | 
1187 |         assert f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: {final_props_update}" in caplog.text
     |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
1188 | ```
     |

tests/asset_manager_tests.py:1188:1: SyntaxError: Got unexpected token `
     |
1187 |         assert f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: {final_props_update}" in caplog.text
1188 | ```
     | ^
     |

tests/asset_manager_tests.py:1188:2: SyntaxError: Got unexpected token `
     |
1187 |         assert f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: {final_props_update}" in caplog.text
1188 | ```
     |  ^
     |

tests/asset_manager_tests.py:1188:3: SyntaxError: Got unexpected token `
     |
1187 |         assert f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: {final_props_update}" in caplog.text
1188 | ```
     |   ^
     |

tests/asset_manager_tests.py:1188:4: SyntaxError: Expected a statement
     |
1187 |         assert f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: {final_props_update}" in caplog.text
1188 | ```
     |    ^
     |

tests/core/conftest.py:1:1: INP001 File `tests/core/conftest.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/conftest.py:46:19: ANN001 Missing type annotation for function argument `mock_db_session`
   |
45 | @pytest.fixture
46 | def asset_manager(mock_db_session, mock_workcell_runtime) -> AssetManager:
   |                   ^^^^^^^^^^^^^^^ ANN001
47 |   """Provide an AssetManager instance with mocked dependencies."""
48 |   return AssetManager(
   |

tests/core/conftest.py:46:36: ANN001 Missing type annotation for function argument `mock_workcell_runtime`
   |
45 | @pytest.fixture
46 | def asset_manager(mock_db_session, mock_workcell_runtime) -> AssetManager:
   |                                    ^^^^^^^^^^^^^^^^^^^^^ ANN001
47 |   """Provide an AssetManager instance with mocked dependencies."""
48 |   return AssetManager(
   |

tests/core/conftest.py:55:5: ANN201 Missing return type annotation for public function `machine_orm_factory`
   |
54 | @pytest.fixture
55 | def machine_orm_factory():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
56 |   """Create MachineOrm instances for testing."""
   |
   = help: Add return type annotation

tests/core/conftest.py:58:7: ANN202 Missing return type annotation for private function `_factory`
   |
56 |   """Create MachineOrm instances for testing."""
57 | 
58 |   def _factory(**kwargs):
   |       ^^^^^^^^ ANN202
59 |     defaults = {
60 |       "accession_id": TEST_MACHINE_ID,
   |
   = help: Add return type annotation

tests/core/conftest.py:58:16: ANN003 Missing type annotation for `**kwargs`
   |
56 |   """Create MachineOrm instances for testing."""
57 | 
58 |   def _factory(**kwargs):
   |                ^^^^^^^^ ANN003
59 |     defaults = {
60 |       "accession_id": TEST_MACHINE_ID,
   |

tests/core/conftest.py:73:5: ANN201 Missing return type annotation for public function `resource_definition_factory`
   |
72 | @pytest.fixture
73 | def resource_definition_factory():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |   """Create ResourceDefinitionOrm instances."""
   |
   = help: Add return type annotation

tests/core/conftest.py:76:7: ANN202 Missing return type annotation for private function `_factory`
   |
74 |   """Create ResourceDefinitionOrm instances."""
75 | 
76 |   def _factory(**kwargs):
   |       ^^^^^^^^ ANN202
77 |     defaults = {
78 |       "name": "cos_96_wellplate_100ul",
   |
   = help: Add return type annotation

tests/core/conftest.py:76:16: ANN003 Missing type annotation for `**kwargs`
   |
74 |   """Create ResourceDefinitionOrm instances."""
75 | 
76 |   def _factory(**kwargs):
   |                ^^^^^^^^ ANN003
77 |     defaults = {
78 |       "name": "cos_96_wellplate_100ul",
   |

tests/core/conftest.py:95:5: ANN201 Missing return type annotation for public function `resource_instance_factory`
   |
94 | @pytest.fixture
95 | def resource_instance_factory():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
96 |   """Create ResourceOrm instances."""
   |
   = help: Add return type annotation

tests/core/conftest.py:98:7: ANN202 Missing return type annotation for private function `_factory`
    |
 96 |   """Create ResourceOrm instances."""
 97 | 
 98 |   def _factory(**kwargs):
    |       ^^^^^^^^ ANN202
 99 |     defaults = {
100 |       "accession_id": TEST_RESOURCE_ID,
    |
    = help: Add return type annotation

tests/core/conftest.py:98:16: ANN003 Missing type annotation for `**kwargs`
    |
 96 |   """Create ResourceOrm instances."""
 97 | 
 98 |   def _factory(**kwargs):
    |                ^^^^^^^^ ANN003
 99 |     defaults = {
100 |       "accession_id": TEST_RESOURCE_ID,
    |

tests/core/test_asset_lock_manager.py:1:1: INP001 File `tests/core/test_asset_lock_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_asset_lock_manager.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/core/asset_lock_manager.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/core/test_asset_lock_manager.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/core/asset_lock_manager.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/core/test_asset_lock_manager.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/core/asset_lock_manager.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/core/test_asset_lock_manager.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/core/test_asset_lock_manager.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/core/test_asset_lock_manager.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/core/test_asset_manager.py:1:1: INP001 File `tests/core/test_asset_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_asset_manager.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/core/asset_manager.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/core/test_asset_manager.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/core/asset_manager.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/core/test_asset_manager.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/core/asset_manager.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/core/test_asset_manager.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/core/test_asset_manager.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/core/test_asset_manager.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/core/test_celery.py:1:1: INP001 File `tests/core/test_celery.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_celery.py:8:5: ANN201 Missing return type annotation for public function `test_celery_app_instance`
   |
 8 | def test_celery_app_instance():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 9 |   """Test that the celery_app is a correctly configured Celery instance."""
10 |   # Assert: Check that the app is an instance of Celery
   |
   = help: Add return type annotation: `None`

tests/core/test_celery.py:11:3: S101 Use of `assert` detected
   |
 9 |   """Test that the celery_app is a correctly configured Celery instance."""
10 |   # Assert: Check that the app is an instance of Celery
11 |   assert isinstance(celery_app, Celery)
   |   ^^^^^^ S101
12 | 
13 |   # Assert: Check key configuration values
   |

tests/core/test_celery.py:14:3: S101 Use of `assert` detected
   |
13 |   # Assert: Check key configuration values
14 |   assert celery_app.main == "praxis_protocol_execution"
   |   ^^^^^^ S101
15 |   assert "redis://localhost:6379/0" in celery_app.conf.broker_url
16 |   assert "redis://localhost:6379/0" in celery_app.conf.result_backend
   |

tests/core/test_celery.py:15:3: S101 Use of `assert` detected
   |
13 |   # Assert: Check key configuration values
14 |   assert celery_app.main == "praxis_protocol_execution"
15 |   assert "redis://localhost:6379/0" in celery_app.conf.broker_url
   |   ^^^^^^ S101
16 |   assert "redis://localhost:6379/0" in celery_app.conf.result_backend
   |

tests/core/test_celery.py:16:3: S101 Use of `assert` detected
   |
14 |   assert celery_app.main == "praxis_protocol_execution"
15 |   assert "redis://localhost:6379/0" in celery_app.conf.broker_url
16 |   assert "redis://localhost:6379/0" in celery_app.conf.result_backend
   |   ^^^^^^ S101
17 | 
18 |   # Assert: Check important performance and reliability settings
   |

tests/core/test_celery.py:19:3: S101 Use of `assert` detected
   |
18 |   # Assert: Check important performance and reliability settings
19 |   assert celery_app.conf.task_serializer == "json"
   |   ^^^^^^ S101
20 |   assert celery_app.conf.worker_prefetch_multiplier == 1
21 |   assert celery_app.conf.task_acks_late is True
   |

tests/core/test_celery.py:20:3: S101 Use of `assert` detected
   |
18 |   # Assert: Check important performance and reliability settings
19 |   assert celery_app.conf.task_serializer == "json"
20 |   assert celery_app.conf.worker_prefetch_multiplier == 1
   |   ^^^^^^ S101
21 |   assert celery_app.conf.task_acks_late is True
   |

tests/core/test_celery.py:21:3: S101 Use of `assert` detected
   |
19 |   assert celery_app.conf.task_serializer == "json"
20 |   assert celery_app.conf.worker_prefetch_multiplier == 1
21 |   assert celery_app.conf.task_acks_late is True
   |   ^^^^^^ S101
22 | 
23 |   # Assert: Ensure the task module is included for discovery
   |

tests/core/test_celery.py:24:3: S101 Use of `assert` detected
   |
23 |   # Assert: Ensure the task module is included for discovery
24 |   assert "praxis.backend.core.celery_tasks" in celery_app.conf.include
   |   ^^^^^^ S101
   |

tests/core/test_celery_tasks.py:1:1: INP001 File `tests/core/test_celery_tasks.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_celery_tasks.py:8:27: TCH002 Move third-party import `celery.result.EagerResult` into a type-checking block
   |
 7 | import pytest
 8 | from celery.result import EagerResult
   |                           ^^^^^^^^^^^ TCH002
 9 | 
10 | from praxis.backend.core.celery_tasks import (
   |
   = help: Move into type-checking block

tests/core/test_celery_tasks.py:26:5: ANN201 Missing return type annotation for public function `mock_orchestrator`
   |
25 | @pytest.fixture
26 | def mock_orchestrator():
   |     ^^^^^^^^^^^^^^^^^ ANN201
27 |   """Provides a mock Orchestrator."""
28 |   orc = AsyncMock()
   |
   = help: Add return type annotation

tests/core/test_celery_tasks.py:27:3: D401 First line of docstring should be in imperative mood: "Provides a mock Orchestrator."
   |
25 | @pytest.fixture
26 | def mock_orchestrator():
27 |   """Provides a mock Orchestrator."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
28 |   orc = AsyncMock()
29 |   orc.execute_existing_protocol_run = AsyncMock(
   |

tests/core/test_celery_tasks.py:36:5: ANN201 Missing return type annotation for public function `mock_db_session_factory`
   |
35 | @pytest.fixture
36 | def mock_db_session_factory():
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |   """Provides a mock async session factory."""
38 |   factory = MagicMock()
   |
   = help: Add return type annotation

tests/core/test_celery_tasks.py:37:3: D401 First line of docstring should be in imperative mood: "Provides a mock async session factory."
   |
35 | @pytest.fixture
36 | def mock_db_session_factory():
37 |   """Provides a mock async session factory."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
38 |   factory = MagicMock()
39 |   # The factory returns an async context manager which in turn returns a mock session
   |

tests/core/test_celery_tasks.py:46:5: ANN201 Missing return type annotation for public function `execution_context`
   |
45 | @pytest.fixture
46 | def execution_context(mock_orchestrator, mock_db_session_factory):
   |     ^^^^^^^^^^^^^^^^^ ANN201
47 |   """Provides a mock ProtocolExecutionContext."""
48 |   return ProtocolExecutionContext(
   |
   = help: Add return type annotation

tests/core/test_celery_tasks.py:46:23: ANN001 Missing type annotation for function argument `mock_orchestrator`
   |
45 | @pytest.fixture
46 | def execution_context(mock_orchestrator, mock_db_session_factory):
   |                       ^^^^^^^^^^^^^^^^^ ANN001
47 |   """Provides a mock ProtocolExecutionContext."""
48 |   return ProtocolExecutionContext(
   |

tests/core/test_celery_tasks.py:46:42: ANN001 Missing type annotation for function argument `mock_db_session_factory`
   |
45 | @pytest.fixture
46 | def execution_context(mock_orchestrator, mock_db_session_factory):
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
47 |   """Provides a mock ProtocolExecutionContext."""
48 |   return ProtocolExecutionContext(
   |

tests/core/test_celery_tasks.py:47:3: D401 First line of docstring should be in imperative mood: "Provides a mock ProtocolExecutionContext."
   |
45 | @pytest.fixture
46 | def execution_context(mock_orchestrator, mock_db_session_factory):
47 |   """Provides a mock ProtocolExecutionContext."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
48 |   return ProtocolExecutionContext(
49 |     db_session_factory=mock_db_session_factory, orchestrator=mock_orchestrator,
   |

tests/core/test_celery_tasks.py:60:7: ANN201 Missing return type annotation for public function `test_initialize_celery_context`
   |
58 |   """Test suite for the main protocol execution Celery task."""
59 | 
60 |   def test_initialize_celery_context(self, mock_orchestrator, mock_db_session_factory):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
61 |     """Test that the context initialization function works correctly."""
62 |     # Arrange
   |
   = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:60:44: ANN001 Missing type annotation for function argument `mock_orchestrator`
   |
58 |   """Test suite for the main protocol execution Celery task."""
59 | 
60 |   def test_initialize_celery_context(self, mock_orchestrator, mock_db_session_factory):
   |                                            ^^^^^^^^^^^^^^^^^ ANN001
61 |     """Test that the context initialization function works correctly."""
62 |     # Arrange
   |

tests/core/test_celery_tasks.py:60:63: ANN001 Missing type annotation for function argument `mock_db_session_factory`
   |
58 |   """Test suite for the main protocol execution Celery task."""
59 | 
60 |   def test_initialize_celery_context(self, mock_orchestrator, mock_db_session_factory):
   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
61 |     """Test that the context initialization function works correctly."""
62 |     # Arrange
   |

tests/core/test_celery_tasks.py:69:7: S101 Use of `assert` detected
   |
67 |       from praxis.backend.core.celery_tasks import _execution_context
68 | 
69 |       assert _execution_context is not None
   |       ^^^^^^ S101
70 |       assert _execution_context.orchestrator is mock_orchestrator
   |

tests/core/test_celery_tasks.py:70:7: S101 Use of `assert` detected
   |
69 |       assert _execution_context is not None
70 |       assert _execution_context.orchestrator is mock_orchestrator
   |       ^^^^^^ S101
71 | 
72 |   def test_task_happy_path(self, execution_context):
   |

tests/core/test_celery_tasks.py:72:7: ANN201 Missing return type annotation for public function `test_task_happy_path`
   |
70 |       assert _execution_context.orchestrator is mock_orchestrator
71 | 
72 |   def test_task_happy_path(self, execution_context):
   |       ^^^^^^^^^^^^^^^^^^^^ ANN201
73 |     """Test the successful execution path of the Celery task."""
74 |     # Arrange
   |
   = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:72:34: ANN001 Missing type annotation for function argument `execution_context`
   |
70 |       assert _execution_context.orchestrator is mock_orchestrator
71 | 
72 |   def test_task_happy_path(self, execution_context):
   |                                  ^^^^^^^^^^^^^^^^^ ANN001
73 |     """Test the successful execution path of the Celery task."""
74 |     # Arrange
   |

tests/core/test_celery_tasks.py:85:39: PGH003 Use specific rule codes when ignoring type issues
   |
83 |       # Act
84 |       result = (
85 |         execute_protocol_run_task.s(  # type: ignore
   |                                       ^^^^^^^^^^^^^^ PGH003
86 |           protocol_run_id=str(TEST_RUN_ID),
87 |           user_params={"volume": 50},
   |

tests/core/test_celery_tasks.py:96:7: S101 Use of `assert` detected
   |
94 |       # Assert
95 |       mock_asyncio_run.assert_called_once()
96 |       assert result == expected_result
   |       ^^^^^^ S101
97 | 
98 |   def test_task_no_context(self):
   |

tests/core/test_celery_tasks.py:98:7: ANN201 Missing return type annotation for public function `test_task_no_context`
    |
 96 |       assert result == expected_result
 97 | 
 98 |   def test_task_no_context(self):
    |       ^^^^^^^^^^^^^^^^^^^^ ANN201
 99 |     """Test that the task fails gracefully if the context is not initialized."""
100 |     # Arrange: Ensure context is None
    |
    = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:110:7: S101 Use of `assert` detected
    |
109 |       # Assert
110 |       assert not result["success"]
    |       ^^^^^^ S101
111 |       assert "context is not initialized" in result["error"]
    |

tests/core/test_celery_tasks.py:111:7: S101 Use of `assert` detected
    |
109 |       # Assert
110 |       assert not result["success"]
111 |       assert "context is not initialized" in result["error"]
    |       ^^^^^^ S101
112 | 
113 |   def test_task_catches_general_exception(self, execution_context):
    |

tests/core/test_celery_tasks.py:113:7: ANN201 Missing return type annotation for public function `test_task_catches_general_exception`
    |
111 |       assert "context is not initialized" in result["error"]
112 | 
113 |   def test_task_catches_general_exception(self, execution_context):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
114 |     """Test that the main task function catches exceptions from the async runner."""
115 |     # Arrange
    |
    = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:113:49: ANN001 Missing type annotation for function argument `execution_context`
    |
111 |       assert "context is not initialized" in result["error"]
112 | 
113 |   def test_task_catches_general_exception(self, execution_context):
    |                                                 ^^^^^^^^^^^^^^^^^ ANN001
114 |     """Test that the main task function catches exceptions from the async runner."""
115 |     # Arrange
    |

tests/core/test_celery_tasks.py:135:7: S101 Use of `assert` detected
    |
134 |       # Assert
135 |       assert not result["success"]
    |       ^^^^^^ S101
136 |       assert error_message in result["error"]
137 |       # Check that the fallback error handler was called
    |

tests/core/test_celery_tasks.py:136:7: S101 Use of `assert` detected
    |
134 |       # Assert
135 |       assert not result["success"]
136 |       assert error_message in result["error"]
    |       ^^^^^^ S101
137 |       # Check that the fallback error handler was called
138 |       assert mock_asyncio_run.call_count == 2
    |

tests/core/test_celery_tasks.py:138:7: S101 Use of `assert` detected
    |
136 |       assert error_message in result["error"]
137 |       # Check that the fallback error handler was called
138 |       assert mock_asyncio_run.call_count == 2
    |       ^^^^^^ S101
139 | 
140 |   async def test_async_helper_happy_path(self, execution_context):
    |

tests/core/test_celery_tasks.py:138:45: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
136 |       assert error_message in result["error"]
137 |       # Check that the fallback error handler was called
138 |       assert mock_asyncio_run.call_count == 2
    |                                             ^ PLR2004
139 | 
140 |   async def test_async_helper_happy_path(self, execution_context):
    |

tests/core/test_celery_tasks.py:140:13: ANN201 Missing return type annotation for public function `test_async_helper_happy_path`
    |
138 |       assert mock_asyncio_run.call_count == 2
139 | 
140 |   async def test_async_helper_happy_path(self, execution_context):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
141 |     """Test the internal async execution logic for a successful run."""
142 |     # Arrange
    |
    = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:140:48: ANN001 Missing type annotation for function argument `execution_context`
    |
138 |       assert mock_asyncio_run.call_count == 2
139 | 
140 |   async def test_async_helper_happy_path(self, execution_context):
    |                                                ^^^^^^^^^^^^^^^^^ ANN001
141 |     """Test the internal async execution logic for a successful run."""
142 |     # Arrange
    |

tests/core/test_celery_tasks.py:173:7: S101 Use of `assert` detected
    |
171 |       )
172 |       execution_context.orchestrator.execute_existing_protocol_run.assert_awaited_once()
173 |       assert result["success"]
    |       ^^^^^^ S101
174 |       assert result["final_status"] == ProtocolRunStatusEnum.COMPLETED.value
    |

tests/core/test_celery_tasks.py:174:7: S101 Use of `assert` detected
    |
172 |       execution_context.orchestrator.execute_existing_protocol_run.assert_awaited_once()
173 |       assert result["success"]
174 |       assert result["final_status"] == ProtocolRunStatusEnum.COMPLETED.value
    |       ^^^^^^ S101
175 | 
176 |   async def test_async_helper_orchestrator_fails(self, execution_context):
    |

tests/core/test_celery_tasks.py:176:13: ANN201 Missing return type annotation for public function `test_async_helper_orchestrator_fails`
    |
174 |       assert result["final_status"] == ProtocolRunStatusEnum.COMPLETED.value
175 | 
176 |   async def test_async_helper_orchestrator_fails(self, execution_context):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
177 |     """Test that a failure in the orchestrator is caught and handled."""
178 |     # Arrange
    |
    = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:176:56: ANN001 Missing type annotation for function argument `execution_context`
    |
174 |       assert result["final_status"] == ProtocolRunStatusEnum.COMPLETED.value
175 | 
176 |   async def test_async_helper_orchestrator_fails(self, execution_context):
    |                                                        ^^^^^^^^^^^^^^^^^ ANN001
177 |     """Test that a failure in the orchestrator is caught and handled."""
178 |     # Arrange
    |

tests/core/test_celery_tasks.py:194:7: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
192 |         from praxis.backend.core.celery_tasks import _execute_protocol_async
193 |   
194 |         with patch(
    |  _______^
195 | |         "praxis.backend.core.celery_tasks._execution_context", execution_context,
196 | |       ):
197 | |         with pytest.raises(RuntimeError, match="Test Fail"):
    | |____________________________________________________________^ SIM117
198 |             await _execute_protocol_async(TEST_RUN_ID, {}, None, TEST_CELERY_TASK_ID)
    |
    = help: Combine `with` statements

tests/core/test_celery_tasks.py:202:7: S101 Use of `assert` detected
    |
200 |       # Assert the final status update was to FAILED
201 |       final_call = mock_update.call_args_list[-1]
202 |       assert final_call.kwargs["new_status"] == ProtocolRunStatusEnum.FAILED
    |       ^^^^^^ S101
    |

tests/core/test_celery_tasks.py:205:5: ANN201 Missing return type annotation for public function `test_health_check_task`
    |
205 | def test_health_check_task():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
206 |   """Test the simple health check task."""
207 |   # Act
    |
    = help: Add return type annotation: `None`

tests/core/test_celery_tasks.py:208:51: PGH003 Use specific rule codes when ignoring type issues
    |
206 |   """Test the simple health check task."""
207 |   # Act
208 |   result: EagerResult = health_check.s().apply()  # type: ignore
    |                                                   ^^^^^^^^^^^^^^ PGH003
209 | 
210 |   # Assert
    |

tests/core/test_celery_tasks.py:211:3: S101 Use of `assert` detected
    |
210 |   # Assert
211 |   assert result.successful()
    |   ^^^^^^ S101
212 |   assert result.result["status"] == "healthy"
213 |   assert "timestamp" in result.result
    |

tests/core/test_celery_tasks.py:212:3: S101 Use of `assert` detected
    |
210 |   # Assert
211 |   assert result.successful()
212 |   assert result.result["status"] == "healthy"
    |   ^^^^^^ S101
213 |   assert "timestamp" in result.result
    |

tests/core/test_celery_tasks.py:213:3: S101 Use of `assert` detected
    |
211 |   assert result.successful()
212 |   assert result.result["status"] == "healthy"
213 |   assert "timestamp" in result.result
    |   ^^^^^^ S101
    |

tests/core/test_decorators.py:1:1: INP001 File `tests/core/test_decorators.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_decorators.py:40:5: ANN201 Missing return type annotation for public function `manage_registry_and_contextvar`
   |
39 | @pytest.fixture(autouse=True)
40 | def manage_registry_and_contextvar():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
41 |   """Fixture to ensure a clean slate for each test."""
42 |   original_registry = PROTOCOL_REGISTRY.copy()
   |
   = help: Add return type annotation

tests/core/test_decorators.py:55:3: D401 First line of docstring should be in imperative mood: "Provides a mock PraxisRunContext for runtime tests."
   |
53 | @pytest.fixture
54 | def mock_run_context() -> MagicMock:
55 |   """Provides a mock PraxisRunContext for runtime tests."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
56 |   context = MagicMock(spec=PraxisRunContext)
57 |   context.run_accession_id = TEST_RUN_ID
   |

tests/core/test_decorators.py:71:3: D205 1 blank line required between summary line and description
   |
69 |   @pytest.mark.asyncio
70 |   class TestProtocolDecoratorSetup:
71 |     """Tests the decorator's setup-time behavior (static analysis, registry population).
   |  ___^
72 | |   Functions are decorated inside each test to ensure isolation.
73 | |   """
   | |_____^ D205
74 |   
75 |     async def test_registry_population_and_full_parsing(self):
   |
   = help: Insert single blank line

tests/core/test_decorators.py:75:13: ANN201 Missing return type annotation for public function `test_registry_population_and_full_parsing`
   |
73 |   """
74 | 
75 |   async def test_registry_population_and_full_parsing(self):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
76 |     """Test that a decorated function is correctly parsed and added to the registry."""
   |
   = help: Add return type annotation: `None`

tests/core/test_decorators.py:79:15: PLR0913 Too many arguments in function definition (6 > 5)
   |
78 |     # Arrange
79 |     async def my_protocol(
   |               ^^^^^^^^^^^ PLR0913
80 |       state: dict,
81 |       source: Plate,
   |

tests/core/test_decorators.py:79:15: ANN202 Missing return type annotation for private function `my_protocol`
   |
78 |     # Arrange
79 |     async def my_protocol(
   |               ^^^^^^^^^^^ ANN202
80 |       state: dict,
81 |       source: Plate,
   |
   = help: Add return type annotation: `None`

tests/core/test_decorators.py:84:7: FBT001 Boolean-typed positional argument in function definition
   |
82 |       tips: TipRack | None,
83 |       volume: float = 100.0,
84 |       enabled: bool = True,
   |       ^^^^^^^ FBT001
85 |       target: Plate | None = None,
86 |     ):
   |

tests/core/test_decorators.py:84:7: FBT002 Boolean default positional argument in function definition
   |
82 |       tips: TipRack | None,
83 |       volume: float = 100.0,
84 |       enabled: bool = True,
   |       ^^^^^^^ FBT002
85 |       target: Plate | None = None,
86 |     ):
   |

tests/core/test_decorators.py:87:7: D401 First line of docstring should be in imperative mood: "A sample protocol."
   |
85 |       target: Plate | None = None,
86 |     ):
87 |       """A sample protocol."""
   |       ^^^^^^^^^^^^^^^^^^^^^^^^ D401
88 | 
89 |     # Act
   |

tests/core/test_decorators.py:103:5: S101 Use of `assert` detected
    |
102 |     # Assert
103 |     assert "test_protocol_v1.0" in PROTOCOL_REGISTRY
    |     ^^^^^^ S101
104 |     runtime_info = PROTOCOL_REGISTRY["test_protocol_v1.0"]
105 |     definition = runtime_info.pydantic_definition
    |

tests/core/test_decorators.py:107:5: S101 Use of `assert` detected
    |
105 |     definition = runtime_info.pydantic_definition
106 | 
107 |     assert definition.name == "test_protocol"
    |     ^^^^^^ S101
108 |     assert definition.version == "1.0"
109 |     assert definition.is_top_level is True
    |

tests/core/test_decorators.py:108:5: S101 Use of `assert` detected
    |
107 |     assert definition.name == "test_protocol"
108 |     assert definition.version == "1.0"
    |     ^^^^^^ S101
109 |     assert definition.is_top_level is True
110 |     assert definition.description == "Custom Description"
    |

tests/core/test_decorators.py:109:5: S101 Use of `assert` detected
    |
107 |     assert definition.name == "test_protocol"
108 |     assert definition.version == "1.0"
109 |     assert definition.is_top_level is True
    |     ^^^^^^ S101
110 |     assert definition.description == "Custom Description"
111 |     assert definition.function_name == "my_protocol"
    |

tests/core/test_decorators.py:110:5: S101 Use of `assert` detected
    |
108 |     assert definition.version == "1.0"
109 |     assert definition.is_top_level is True
110 |     assert definition.description == "Custom Description"
    |     ^^^^^^ S101
111 |     assert definition.function_name == "my_protocol"
    |

tests/core/test_decorators.py:111:5: S101 Use of `assert` detected
    |
109 |     assert definition.is_top_level is True
110 |     assert definition.description == "Custom Description"
111 |     assert definition.function_name == "my_protocol"
    |     ^^^^^^ S101
112 | 
113 |     params = {p.name: p for p in definition.parameters}
    |

tests/core/test_decorators.py:116:5: S101 Use of `assert` detected
    |
114 |     assets = {a.name: a for a in definition.assets}
115 | 
116 |     assert "state" in params
    |     ^^^^^^ S101
117 |     assert "volume" in params
118 |     assert "enabled" in params
    |

tests/core/test_decorators.py:117:5: S101 Use of `assert` detected
    |
116 |     assert "state" in params
117 |     assert "volume" in params
    |     ^^^^^^ S101
118 |     assert "enabled" in params
119 |     assert "source" in assets
    |

tests/core/test_decorators.py:118:5: S101 Use of `assert` detected
    |
116 |     assert "state" in params
117 |     assert "volume" in params
118 |     assert "enabled" in params
    |     ^^^^^^ S101
119 |     assert "source" in assets
120 |     assert "tips" in assets
    |

tests/core/test_decorators.py:119:5: S101 Use of `assert` detected
    |
117 |     assert "volume" in params
118 |     assert "enabled" in params
119 |     assert "source" in assets
    |     ^^^^^^ S101
120 |     assert "tips" in assets
121 |     assert "target" in assets
    |

tests/core/test_decorators.py:120:5: S101 Use of `assert` detected
    |
118 |     assert "enabled" in params
119 |     assert "source" in assets
120 |     assert "tips" in assets
    |     ^^^^^^ S101
121 |     assert "target" in assets
    |

tests/core/test_decorators.py:121:5: S101 Use of `assert` detected
    |
119 |     assert "source" in assets
120 |     assert "tips" in assets
121 |     assert "target" in assets
    |     ^^^^^^ S101
122 | 
123 |     # Check parameter details
    |

tests/core/test_decorators.py:124:5: S101 Use of `assert` detected
    |
123 |     # Check parameter details
124 |     assert params["volume"].optional is True
    |     ^^^^^^ S101
125 |     assert params["volume"].default_value_repr == "100.0"
126 |     assert params["volume"].description == "The volume in uL"
    |

tests/core/test_decorators.py:125:5: S101 Use of `assert` detected
    |
123 |     # Check parameter details
124 |     assert params["volume"].optional is True
125 |     assert params["volume"].default_value_repr == "100.0"
    |     ^^^^^^ S101
126 |     assert params["volume"].description == "The volume in uL"
127 |     assert params["enabled"].ui_hints.label == "Enable Feature"
    |

tests/core/test_decorators.py:126:5: S101 Use of `assert` detected
    |
124 |     assert params["volume"].optional is True
125 |     assert params["volume"].default_value_repr == "100.0"
126 |     assert params["volume"].description == "The volume in uL"
    |     ^^^^^^ S101
127 |     assert params["enabled"].ui_hints.label == "Enable Feature"
128 |     assert (
    |

tests/core/test_decorators.py:127:5: S101 Use of `assert` detected
    |
125 |     assert params["volume"].default_value_repr == "100.0"
126 |     assert params["volume"].description == "The volume in uL"
127 |     assert params["enabled"].ui_hints.label == "Enable Feature"
    |     ^^^^^^ S101
128 |     assert (
129 |       params["enabled"].actual_type_str == "bool"
    |

tests/core/test_decorators.py:128:5: S101 Use of `assert` detected
    |
126 |     assert params["volume"].description == "The volume in uL"
127 |     assert params["enabled"].ui_hints.label == "Enable Feature"
128 |     assert (
    |     ^^^^^^ S101
129 |       params["enabled"].actual_type_str == "bool"
130 |     )  # Ensure it resolves to the simple type
    |

tests/core/test_decorators.py:133:5: S101 Use of `assert` detected
    |
132 |     # Check asset details
133 |     assert assets["source"].optional is False
    |     ^^^^^^ S101
134 |     assert assets["source"].actual_type_str == "Plate"
135 |     assert assets["tips"].optional is True
    |

tests/core/test_decorators.py:134:5: S101 Use of `assert` detected
    |
132 |     # Check asset details
133 |     assert assets["source"].optional is False
134 |     assert assets["source"].actual_type_str == "Plate"
    |     ^^^^^^ S101
135 |     assert assets["tips"].optional is True
136 |     assert (
    |

tests/core/test_decorators.py:135:5: S101 Use of `assert` detected
    |
133 |     assert assets["source"].optional is False
134 |     assert assets["source"].actual_type_str == "Plate"
135 |     assert assets["tips"].optional is True
    |     ^^^^^^ S101
136 |     assert (
137 |       "Optional[pylabrobot.resources.tip_rack.TipRack]" in assets["tips"].type_hint_str
    |

tests/core/test_decorators.py:136:5: S101 Use of `assert` detected
    |
134 |     assert assets["source"].actual_type_str == "Plate"
135 |     assert assets["tips"].optional is True
136 |     assert (
    |     ^^^^^^ S101
137 |       "Optional[pylabrobot.resources.tip_rack.TipRack]" in assets["tips"].type_hint_str
138 |     )
    |

tests/core/test_decorators.py:139:5: S101 Use of `assert` detected
    |
137 |       "Optional[pylabrobot.resources.tip_rack.TipRack]" in assets["tips"].type_hint_str
138 |     )
139 |     assert (
    |     ^^^^^^ S101
140 |       "Union[pylabrobot.resources.plate.Plate, NoneType]"
141 |       in assets["target"].type_hint_str
    |

tests/core/test_decorators.py:144:13: ANN201 Missing return type annotation for public function `test_raises_error_for_missing_state_param_for_top_level`
    |
142 |     )
143 | 
144 |   async def test_raises_error_for_missing_state_param_for_top_level(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
145 |     """Test a TypeError is raised for a top-level protocol without a state parameter."""
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:147:15: ANN202 Missing return type annotation for private function `invalid_top_level`
    |
145 |     """Test a TypeError is raised for a top-level protocol without a state parameter."""
146 | 
147 |     async def invalid_top_level(plate: Plate):
    |               ^^^^^^^^^^^^^^^^^ ANN202
148 |       pass
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:156:13: ANN201 Missing return type annotation for public function `test_raises_error_for_missing_deck_param_with_preconfigure`
    |
154 |       decorator(invalid_top_level)
155 | 
156 |   async def test_raises_error_for_missing_deck_param_with_preconfigure(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |     """Test a TypeError is raised if preconfigure_deck is True but the deck is missing."""
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:159:15: ANN202 Missing return type annotation for private function `invalid_deck_protocol`
    |
157 |     """Test a TypeError is raised if preconfigure_deck is True but the deck is missing."""
158 | 
159 |     async def invalid_deck_protocol(state: dict):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN202
160 |       pass
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:166:13: ANN201 Missing return type annotation for public function `test_raises_error_for_invalid_top_level_name`
    |
164 |       decorator(invalid_deck_protocol)
165 | 
166 |   async def test_raises_error_for_invalid_top_level_name(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
167 |     """Test a ValueError is raised for an invalid top-level protocol name."""
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:169:15: ANN202 Missing return type annotation for private function `protocol_with_bad_name`
    |
167 |     """Test a ValueError is raised for an invalid top-level protocol name."""
168 | 
169 |     async def protocol_with_bad_name(state: dict):
    |               ^^^^^^^^^^^^^^^^^^^^^^ ANN202
170 |       pass
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:179:3: D205 1 blank line required between summary line and description
    |
177 |   @pytest.mark.asyncio
178 |   class TestProtocolDecoratorRuntime:
179 |     """Tests the decorator's runtime wrapper logic.
    |  ___^
180 | |   Uses a fixture to provide a pre-decorated function for testing.
181 | |   """
    | |_____^ D205
182 |   
183 |     @pytest.fixture
    |
    = help: Insert single blank line

tests/core/test_decorators.py:185:5: D401 First line of docstring should be in imperative mood: "Provides a fully decorated and registered async function for runtime tests."
    |
183 |   @pytest.fixture
184 |   async def decorated_protocol(self) -> Callable:
185 |     """Provides a fully decorated and registered async function for runtime tests."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
186 | 
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
    |

tests/core/test_decorators.py:187:15: ANN202 Missing return type annotation for private function `my_runtime_protocol`
    |
185 |     """Provides a fully decorated and registered async function for runtime tests."""
186 | 
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
    |               ^^^^^^^^^^^^^^^^^^^ ANN202
188 |       if volume < 0:
189 |         raise ValueError("Volume cannot be negative")
    |
    = help: Add return type annotation

tests/core/test_decorators.py:187:35: ARG001 Unused function argument: `state`
    |
185 |     """Provides a fully decorated and registered async function for runtime tests."""
186 | 
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
    |                                   ^^^^^ ARG001
188 |       if volume < 0:
189 |         raise ValueError("Volume cannot be negative")
    |

tests/core/test_decorators.py:187:63: ARG001 Unused function argument: `resource`
    |
185 |     """Provides a fully decorated and registered async function for runtime tests."""
186 | 
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
    |                                                               ^^^^^^^^ ARG001
188 |       if volume < 0:
189 |         raise ValueError("Volume cannot be negative")
    |

tests/core/test_decorators.py:189:15: TRY003 Avoid specifying long messages outside the exception class
    |
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
188 |       if volume < 0:
189 |         raise ValueError("Volume cannot be negative")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
190 |       return {"status": "ok", "volume_processed": volume}
    |

tests/core/test_decorators.py:189:26: EM101 Exception must not use a string literal, assign to variable first
    |
187 |     async def my_runtime_protocol(state: dict, volume: float, resource: Resource):
188 |       if volume < 0:
189 |         raise ValueError("Volume cannot be negative")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM101
190 |       return {"status": "ok", "volume_processed": volume}
    |
    = help: Assign to variable; remove string literal

tests/core/test_decorators.py:201:5: D401 First line of docstring should be in imperative mood: "Provides a decorated and registered synchronous function."
    |
199 |   @pytest.fixture
200 |   async def decorated_sync_protocol(self) -> Callable:
201 |     """Provides a decorated and registered synchronous function."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
202 | 
203 |     def my_sync_protocol(state: dict):
    |

tests/core/test_decorators.py:203:9: ANN202 Missing return type annotation for private function `my_sync_protocol`
    |
201 |     """Provides a decorated and registered synchronous function."""
202 | 
203 |     def my_sync_protocol(state: dict):
    |         ^^^^^^^^^^^^^^^^ ANN202
204 |       return "sync complete"
    |
    = help: Add return type annotation: `str`

tests/core/test_decorators.py:203:26: ARG001 Unused function argument: `state`
    |
201 |     """Provides a decorated and registered synchronous function."""
202 | 
203 |     def my_sync_protocol(state: dict):
    |                          ^^^^^ ARG001
204 |       return "sync complete"
    |

tests/core/test_decorators.py:222:13: ANN201 Missing return type annotation for public function `test_wrapper_successful_execution`
    |
220 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
221 |   )
222 |   async def test_wrapper_successful_execution(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
223 |     self,
224 |     mock_start,
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:224:5: ANN001 Missing type annotation for function argument `mock_start`
    |
222 |   async def test_wrapper_successful_execution(
223 |     self,
224 |     mock_start,
    |     ^^^^^^^^^^ ANN001
225 |     mock_end,
226 |     mock_get_control,
    |

tests/core/test_decorators.py:225:5: ANN001 Missing type annotation for function argument `mock_end`
    |
223 |     self,
224 |     mock_start,
225 |     mock_end,
    |     ^^^^^^^^ ANN001
226 |     mock_get_control,
227 |     decorated_protocol,
    |

tests/core/test_decorators.py:226:5: ANN001 Missing type annotation for function argument `mock_get_control`
    |
224 |     mock_start,
225 |     mock_end,
226 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ANN001
227 |     decorated_protocol,
228 |     mock_run_context,
    |

tests/core/test_decorators.py:226:5: ARG002 Unused method argument: `mock_get_control`
    |
224 |     mock_start,
225 |     mock_end,
226 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ARG002
227 |     decorated_protocol,
228 |     mock_run_context,
    |

tests/core/test_decorators.py:227:5: ANN001 Missing type annotation for function argument `decorated_protocol`
    |
225 |     mock_end,
226 |     mock_get_control,
227 |     decorated_protocol,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
228 |     mock_run_context,
229 |   ):
    |

tests/core/test_decorators.py:228:5: ANN001 Missing type annotation for function argument `mock_run_context`
    |
226 |     mock_get_control,
227 |     decorated_protocol,
228 |     mock_run_context,
    |     ^^^^^^^^^^^^^^^^ ANN001
229 |   ):
230 |     """Test a successful run of a decorated async function."""
    |

tests/core/test_decorators.py:238:5: S101 Use of `assert` detected
    |
236 |     result = await decorated_protocol(state={}, volume=150.0, resource=mock_resource)
237 | 
238 |     assert result == {"status": "ok", "volume_processed": 150.0}
    |     ^^^^^^ S101
239 |     mock_start.assert_awaited_once()
240 |     mock_end.assert_awaited_once()
    |

tests/core/test_decorators.py:242:5: S101 Use of `assert` detected
    |
240 |     mock_end.assert_awaited_once()
241 |     end_kwargs = mock_end.await_args.kwargs
242 |     assert end_kwargs["status"] == FunctionCallStatusEnum.SUCCESS
    |     ^^^^^^ S101
243 |     assert '"volume_processed": 150.0' in end_kwargs["return_value_json"]
244 |     assert end_kwargs["error_message"] is None
    |

tests/core/test_decorators.py:243:5: S101 Use of `assert` detected
    |
241 |     end_kwargs = mock_end.await_args.kwargs
242 |     assert end_kwargs["status"] == FunctionCallStatusEnum.SUCCESS
243 |     assert '"volume_processed": 150.0' in end_kwargs["return_value_json"]
    |     ^^^^^^ S101
244 |     assert end_kwargs["error_message"] is None
    |

tests/core/test_decorators.py:244:5: S101 Use of `assert` detected
    |
242 |     assert end_kwargs["status"] == FunctionCallStatusEnum.SUCCESS
243 |     assert '"volume_processed": 150.0' in end_kwargs["return_value_json"]
244 |     assert end_kwargs["error_message"] is None
    |     ^^^^^^ S101
245 | 
246 |   @patch(
    |

tests/core/test_decorators.py:255:13: ANN201 Missing return type annotation for public function `test_wrapper_handles_sync_function`
    |
253 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
254 |   )
255 |   async def test_wrapper_handles_sync_function(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
256 |     self,
257 |     mock_start,
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:257:5: ANN001 Missing type annotation for function argument `mock_start`
    |
255 |   async def test_wrapper_handles_sync_function(
256 |     self,
257 |     mock_start,
    |     ^^^^^^^^^^ ANN001
258 |     mock_end,
259 |     mock_get_control,
    |

tests/core/test_decorators.py:258:5: ANN001 Missing type annotation for function argument `mock_end`
    |
256 |     self,
257 |     mock_start,
258 |     mock_end,
    |     ^^^^^^^^ ANN001
259 |     mock_get_control,
260 |     decorated_sync_protocol,
    |

tests/core/test_decorators.py:259:5: ANN001 Missing type annotation for function argument `mock_get_control`
    |
257 |     mock_start,
258 |     mock_end,
259 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ANN001
260 |     decorated_sync_protocol,
261 |     mock_run_context,
    |

tests/core/test_decorators.py:259:5: ARG002 Unused method argument: `mock_get_control`
    |
257 |     mock_start,
258 |     mock_end,
259 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ARG002
260 |     decorated_sync_protocol,
261 |     mock_run_context,
    |

tests/core/test_decorators.py:260:5: ANN001 Missing type annotation for function argument `decorated_sync_protocol`
    |
258 |     mock_end,
259 |     mock_get_control,
260 |     decorated_sync_protocol,
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
261 |     mock_run_context,
262 |   ):
    |

tests/core/test_decorators.py:261:5: ANN001 Missing type annotation for function argument `mock_run_context`
    |
259 |     mock_get_control,
260 |     decorated_sync_protocol,
261 |     mock_run_context,
    |     ^^^^^^^^^^^^^^^^ ANN001
262 |   ):
263 |     """Test that a synchronous decorated function is run in an executor."""
    |

tests/core/test_decorators.py:270:5: S101 Use of `assert` detected
    |
268 |     result = await decorated_sync_protocol(state={})
269 | 
270 |     assert result == "sync complete"
    |     ^^^^^^ S101
271 |     mock_end.assert_awaited_once()
272 |     end_kwargs = mock_end.await_args.kwargs
    |

tests/core/test_decorators.py:273:5: S101 Use of `assert` detected
    |
271 |     mock_end.assert_awaited_once()
272 |     end_kwargs = mock_end.await_args.kwargs
273 |     assert end_kwargs["status"] == FunctionCallStatusEnum.SUCCESS
    |     ^^^^^^ S101
274 |     assert end_kwargs["return_value_json"] == '"sync complete"'
    |

tests/core/test_decorators.py:274:5: S101 Use of `assert` detected
    |
272 |     end_kwargs = mock_end.await_args.kwargs
273 |     assert end_kwargs["status"] == FunctionCallStatusEnum.SUCCESS
274 |     assert end_kwargs["return_value_json"] == '"sync complete"'
    |     ^^^^^^ S101
275 | 
276 |   @patch(
    |

tests/core/test_decorators.py:285:13: ANN201 Missing return type annotation for public function `test_wrapper_handles_exception`
    |
283 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
284 |   )
285 |   async def test_wrapper_handles_exception(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
286 |     self,
287 |     mock_start,
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:287:5: ANN001 Missing type annotation for function argument `mock_start`
    |
285 |   async def test_wrapper_handles_exception(
286 |     self,
287 |     mock_start,
    |     ^^^^^^^^^^ ANN001
288 |     mock_end,
289 |     mock_get_control,
    |

tests/core/test_decorators.py:288:5: ANN001 Missing type annotation for function argument `mock_end`
    |
286 |     self,
287 |     mock_start,
288 |     mock_end,
    |     ^^^^^^^^ ANN001
289 |     mock_get_control,
290 |     decorated_protocol,
    |

tests/core/test_decorators.py:289:5: ANN001 Missing type annotation for function argument `mock_get_control`
    |
287 |     mock_start,
288 |     mock_end,
289 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ANN001
290 |     decorated_protocol,
291 |     mock_run_context,
    |

tests/core/test_decorators.py:289:5: ARG002 Unused method argument: `mock_get_control`
    |
287 |     mock_start,
288 |     mock_end,
289 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ARG002
290 |     decorated_protocol,
291 |     mock_run_context,
    |

tests/core/test_decorators.py:290:5: ANN001 Missing type annotation for function argument `decorated_protocol`
    |
288 |     mock_end,
289 |     mock_get_control,
290 |     decorated_protocol,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
291 |     mock_run_context,
292 |   ):
    |

tests/core/test_decorators.py:291:5: ANN001 Missing type annotation for function argument `mock_run_context`
    |
289 |     mock_get_control,
290 |     decorated_protocol,
291 |     mock_run_context,
    |     ^^^^^^^^^^^^^^^^ ANN001
292 |   ):
293 |     """Test that exceptions are caught, logged with ERROR status, and re-raised."""
    |

tests/core/test_decorators.py:303:5: S101 Use of `assert` detected
    |
301 |     mock_end.assert_awaited_once()
302 |     end_kwargs = mock_end.await_args.kwargs
303 |     assert end_kwargs["status"] == FunctionCallStatusEnum.ERROR
    |     ^^^^^^ S101
304 |     assert "Volume cannot be negative" in end_kwargs["error_message"]
305 |     assert "ValueError" in end_kwargs["error_traceback"]
    |

tests/core/test_decorators.py:304:5: S101 Use of `assert` detected
    |
302 |     end_kwargs = mock_end.await_args.kwargs
303 |     assert end_kwargs["status"] == FunctionCallStatusEnum.ERROR
304 |     assert "Volume cannot be negative" in end_kwargs["error_message"]
    |     ^^^^^^ S101
305 |     assert "ValueError" in end_kwargs["error_traceback"]
    |

tests/core/test_decorators.py:305:5: S101 Use of `assert` detected
    |
303 |     assert end_kwargs["status"] == FunctionCallStatusEnum.ERROR
304 |     assert "Volume cannot be negative" in end_kwargs["error_message"]
305 |     assert "ValueError" in end_kwargs["error_traceback"]
    |     ^^^^^^ S101
306 | 
307 |   async def test_wrapper_fails_without_valid_context(
    |

tests/core/test_decorators.py:307:13: ANN201 Missing return type annotation for public function `test_wrapper_fails_without_valid_context`
    |
305 |     assert "ValueError" in end_kwargs["error_traceback"]
306 | 
307 |   async def test_wrapper_fails_without_valid_context(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
308 |     self, decorated_protocol, monkeypatch,
309 |   ):
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:308:11: ANN001 Missing type annotation for function argument `decorated_protocol`
    |
307 |   async def test_wrapper_fails_without_valid_context(
308 |     self, decorated_protocol, monkeypatch,
    |           ^^^^^^^^^^^^^^^^^^ ANN001
309 |   ):
310 |     """Test that calling a decorated function without a proper context raises a RuntimeError."""
    |

tests/core/test_decorators.py:308:31: ANN001 Missing type annotation for function argument `monkeypatch`
    |
307 |   async def test_wrapper_fails_without_valid_context(
308 |     self, decorated_protocol, monkeypatch,
    |                               ^^^^^^^^^^^ ANN001
309 |   ):
310 |     """Test that calling a decorated function without a proper context raises a RuntimeError."""
    |

tests/core/test_decorators.py:324:13: PLR0913 Too many arguments in function definition (6 > 5)
    |
322 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
323 |   )
324 |   async def test_run_control_cancel(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
325 |     self,
326 |     mock_start,
    |

tests/core/test_decorators.py:324:13: ANN201 Missing return type annotation for public function `test_run_control_cancel`
    |
322 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
323 |   )
324 |   async def test_run_control_cancel(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
325 |     self,
326 |     mock_start,
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:326:5: ANN001 Missing type annotation for function argument `mock_start`
    |
324 |   async def test_run_control_cancel(
325 |     self,
326 |     mock_start,
    |     ^^^^^^^^^^ ANN001
327 |     mock_update_status,
328 |     mock_get_control,
    |

tests/core/test_decorators.py:327:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
325 |     self,
326 |     mock_start,
327 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
328 |     mock_get_control,
329 |     mock_clear_control,
    |

tests/core/test_decorators.py:328:5: ANN001 Missing type annotation for function argument `mock_get_control`
    |
326 |     mock_start,
327 |     mock_update_status,
328 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ANN001
329 |     mock_clear_control,
330 |     decorated_protocol,
    |

tests/core/test_decorators.py:329:5: ANN001 Missing type annotation for function argument `mock_clear_control`
    |
327 |     mock_update_status,
328 |     mock_get_control,
329 |     mock_clear_control,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
330 |     decorated_protocol,
331 |     mock_run_context,
    |

tests/core/test_decorators.py:329:5: ARG002 Unused method argument: `mock_clear_control`
    |
327 |     mock_update_status,
328 |     mock_get_control,
329 |     mock_clear_control,
    |     ^^^^^^^^^^^^^^^^^^ ARG002
330 |     decorated_protocol,
331 |     mock_run_context,
    |

tests/core/test_decorators.py:330:5: ANN001 Missing type annotation for function argument `decorated_protocol`
    |
328 |     mock_get_control,
329 |     mock_clear_control,
330 |     decorated_protocol,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
331 |     mock_run_context,
332 |   ):
    |

tests/core/test_decorators.py:331:5: ANN001 Missing type annotation for function argument `mock_run_context`
    |
329 |     mock_clear_control,
330 |     decorated_protocol,
331 |     mock_run_context,
    |     ^^^^^^^^^^^^^^^^ ANN001
332 |   ):
333 |     """Test the CANCEL control flow, ensuring it raises ProtocolCancelledError."""
    |

tests/core/test_decorators.py:342:5: S101 Use of `assert` detected
    |
341 |     status_updates = [call.args[1] for call in mock_update_status.call_args_list]
342 |     assert ProtocolRunStatusEnum.CANCELING in status_updates
    |     ^^^^^^ S101
343 |     assert ProtocolRunStatusEnum.CANCELLED in status_updates
    |

tests/core/test_decorators.py:343:5: S101 Use of `assert` detected
    |
341 |     status_updates = [call.args[1] for call in mock_update_status.call_args_list]
342 |     assert ProtocolRunStatusEnum.CANCELING in status_updates
343 |     assert ProtocolRunStatusEnum.CANCELLED in status_updates
    |     ^^^^^^ S101
344 | 
345 |   @patch("asyncio.sleep", new_callable=AsyncMock)
    |

tests/core/test_decorators.py:356:13: PLR0913 Too many arguments in function definition (8 > 5)
    |
354 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
355 |   )
356 |   async def test_run_control_pause_resume(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
357 |     self,
358 |     mock_start,
    |

tests/core/test_decorators.py:356:13: ANN201 Missing return type annotation for public function `test_run_control_pause_resume`
    |
354 |     "praxis.backend.core.decorators.log_function_call_start", new_callable=AsyncMock,
355 |   )
356 |   async def test_run_control_pause_resume(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
357 |     self,
358 |     mock_start,
    |
    = help: Add return type annotation: `None`

tests/core/test_decorators.py:358:5: ANN001 Missing type annotation for function argument `mock_start`
    |
356 |   async def test_run_control_pause_resume(
357 |     self,
358 |     mock_start,
    |     ^^^^^^^^^^ ANN001
359 |     mock_end,
360 |     mock_update_status,
    |

tests/core/test_decorators.py:359:5: ANN001 Missing type annotation for function argument `mock_end`
    |
357 |     self,
358 |     mock_start,
359 |     mock_end,
    |     ^^^^^^^^ ANN001
360 |     mock_update_status,
361 |     mock_get_control,
    |

tests/core/test_decorators.py:360:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
358 |     mock_start,
359 |     mock_end,
360 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
361 |     mock_get_control,
362 |     mock_clear_control,
    |

tests/core/test_decorators.py:361:5: ANN001 Missing type annotation for function argument `mock_get_control`
    |
359 |     mock_end,
360 |     mock_update_status,
361 |     mock_get_control,
    |     ^^^^^^^^^^^^^^^^ ANN001
362 |     mock_clear_control,
363 |     mock_sleep,
    |

tests/core/test_decorators.py:362:5: ANN001 Missing type annotation for function argument `mock_clear_control`
    |
360 |     mock_update_status,
361 |     mock_get_control,
362 |     mock_clear_control,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
363 |     mock_sleep,
364 |     decorated_protocol,
    |

tests/core/test_decorators.py:363:5: ANN001 Missing type annotation for function argument `mock_sleep`
    |
361 |     mock_get_control,
362 |     mock_clear_control,
363 |     mock_sleep,
    |     ^^^^^^^^^^ ANN001
364 |     decorated_protocol,
365 |     mock_run_context,
    |

tests/core/test_decorators.py:364:5: ANN001 Missing type annotation for function argument `decorated_protocol`
    |
362 |     mock_clear_control,
363 |     mock_sleep,
364 |     decorated_protocol,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
365 |     mock_run_context,
366 |   ):
    |

tests/core/test_decorators.py:365:5: ANN001 Missing type annotation for function argument `mock_run_context`
    |
363 |     mock_sleep,
364 |     decorated_protocol,
365 |     mock_run_context,
    |     ^^^^^^^^^^^^^^^^ ANN001
366 |   ):
367 |     """Test the PAUSE/RESUME control flow."""
    |

tests/core/test_decorators.py:376:5: S101 Use of `assert` detected
    |
374 |     result = await decorated_protocol(state={}, volume=50, resource=mock_resource)
375 | 
376 |     assert result is not None  # Should complete successfully
    |     ^^^^^^ S101
377 |     mock_sleep.assert_awaited_once_with(1)
    |

tests/core/test_decorators.py:380:5: S101 Use of `assert` detected
    |
379 |     status_updates = [call.args[1] for call in mock_update_status.call_args_list]
380 |     assert ProtocolRunStatusEnum.PAUSING in status_updates
    |     ^^^^^^ S101
381 |     assert ProtocolRunStatusEnum.PAUSED in status_updates
382 |     assert ProtocolRunStatusEnum.RESUMING in status_updates
    |

tests/core/test_decorators.py:381:5: S101 Use of `assert` detected
    |
379 |     status_updates = [call.args[1] for call in mock_update_status.call_args_list]
380 |     assert ProtocolRunStatusEnum.PAUSING in status_updates
381 |     assert ProtocolRunStatusEnum.PAUSED in status_updates
    |     ^^^^^^ S101
382 |     assert ProtocolRunStatusEnum.RESUMING in status_updates
383 |     assert ProtocolRunStatusEnum.RUNNING in status_updates
    |

tests/core/test_decorators.py:382:5: S101 Use of `assert` detected
    |
380 |     assert ProtocolRunStatusEnum.PAUSING in status_updates
381 |     assert ProtocolRunStatusEnum.PAUSED in status_updates
382 |     assert ProtocolRunStatusEnum.RESUMING in status_updates
    |     ^^^^^^ S101
383 |     assert ProtocolRunStatusEnum.RUNNING in status_updates
    |

tests/core/test_decorators.py:383:5: S101 Use of `assert` detected
    |
381 |     assert ProtocolRunStatusEnum.PAUSED in status_updates
382 |     assert ProtocolRunStatusEnum.RESUMING in status_updates
383 |     assert ProtocolRunStatusEnum.RUNNING in status_updates
    |     ^^^^^^ S101
384 | 
385 |     # Check clear was called for PAUSE, RESUME
    |

tests/core/test_decorators.py:386:5: S101 Use of `assert` detected
    |
385 |     # Check clear was called for PAUSE, RESUME
386 |     assert mock_clear_control.call_count == 2
    |     ^^^^^^ S101
387 |     # Check final log has SUCCESS status
388 |     mock_end.assert_awaited_once()
    |

tests/core/test_decorators.py:386:45: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
385 |     # Check clear was called for PAUSE, RESUME
386 |     assert mock_clear_control.call_count == 2
    |                                             ^ PLR2004
387 |     # Check final log has SUCCESS status
388 |     mock_end.assert_awaited_once()
    |

tests/core/test_decorators.py:389:5: S101 Use of `assert` detected
    |
387 |     # Check final log has SUCCESS status
388 |     mock_end.assert_awaited_once()
389 |     assert mock_end.await_args.kwargs["status"] == FunctionCallStatusEnum.SUCCESS
    |     ^^^^^^ S101
    |

tests/core/test_orchestrator.py:1:1: INP001 File `tests/core/test_orchestrator.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_orchestrator.py:67:46: ARG001 Unused function argument: `mock_workcell`
   |
66 | @pytest.fixture
67 | def orchestrator(mock_db_session: AsyncMock, mock_workcell: MagicMock) -> Orchestrator:
   |                                              ^^^^^^^^^^^^^ ARG001
68 |   """Provide an Orchestrator instance with mocked dependencies."""
69 |   # Patch AssetManager and WorkcellRuntime for the orchestrator
   |

tests/core/test_orchestrator.py:80:5: ANN201 Missing return type annotation for public function `clear_registry`
   |
79 | @pytest.fixture(autouse=True)
80 | def clear_registry():
   |     ^^^^^^^^^^^^^^ ANN201
81 |   """Clear the protocol registry before each test."""
82 |   original_registry = PROTOCOL_REGISTRY.copy()
   |
   = help: Add return type annotation

tests/core/test_orchestrator.py:102:13: PLR0913 Too many arguments in function definition (7 > 5)
    |
100 |   )
101 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
102 |   async def test_execute_protocol_happy_path(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
103 |     self,
104 |     mock_update_status: AsyncMock,
    |

tests/core/test_orchestrator.py:102:13: ANN201 Missing return type annotation for public function `test_execute_protocol_happy_path`
    |
100 |   )
101 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
102 |   async def test_execute_protocol_happy_path(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
103 |     self,
104 |     mock_update_status: AsyncMock,
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:135:5: S101 Use of `assert` detected
    |
134 |     # Assert
135 |     assert result == {"result": "success"}
    |     ^^^^^^ S101
136 |     mock_update_status.assert_has_calls(
137 |       [
    |

tests/core/test_orchestrator.py:148:5: S101 Use of `assert` detected
    |
146 |     mock_protocol_func.assert_awaited_once()
147 |     kwargs = mock_protocol_func.get("await_args", {"kwargs": {}}).get("kwargs", {})
148 |     assert "test_asset" in kwargs
    |     ^^^^^^ S101
149 | 
150 |   @patch("praxis.backend.core.orchestrator.WorkcellRuntime")
    |

tests/core/test_orchestrator.py:156:13: PLR0913 Too many arguments in function definition (7 > 5)
    |
154 |   )
155 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
156 |   async def test_execute_protocol_handles_exception(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
157 |     self,
158 |     mock_update_status: AsyncMock,
    |

tests/core/test_orchestrator.py:156:13: ANN201 Missing return type annotation for public function `test_execute_protocol_handles_exception`
    |
154 |   )
155 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
156 |   async def test_execute_protocol_handles_exception(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
157 |     self,
158 |     mock_update_status: AsyncMock,
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:160:5: ARG002 Unused method argument: `mock_asset_manager_cls`
    |
158 |     mock_update_status: AsyncMock,
159 |     mock_get_protocol_def: AsyncMock,
160 |     mock_asset_manager_cls: MagicMock,
    |     ^^^^^^^^^^^^^^^^^^^^^^ ARG002
161 |     mock_workcell_runtime_cls: MagicMock,
162 |     orchestrator: Orchestrator,
    |

tests/core/test_orchestrator.py:202:13: PLR0913 Too many arguments in function definition (7 > 5)
    |
200 |   )
201 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
202 |   async def test_execute_protocol_handles_cancellation(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
203 |     self,
204 |     mock_update_status: AsyncMock,
    |

tests/core/test_orchestrator.py:202:13: ANN201 Missing return type annotation for public function `test_execute_protocol_handles_cancellation`
    |
200 |   )
201 |   @patch("praxis.backend.core.orchestrator.update_protocol_run_status")
202 |   async def test_execute_protocol_handles_cancellation(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
203 |     self,
204 |     mock_update_status: AsyncMock,
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:206:5: ARG002 Unused method argument: `mock_asset_manager_cls`
    |
204 |     mock_update_status: AsyncMock,
205 |     mock_get_protocol_def: AsyncMock,
206 |     mock_asset_manager_cls: MagicMock,
    |     ^^^^^^^^^^^^^^^^^^^^^^ ARG002
207 |     mock_workcell_runtime_cls: MagicMock,
208 |     orchestrator: Orchestrator,
    |

tests/core/test_orchestrator.py:235:5: S101 Use of `assert` detected
    |
233 |     # Assert
234 |     failed_call = call(mock_db_session, TEST_RUN_ID, ProtocolRunStatusEnum.FAILED, ANY)
235 |     assert failed_call not in mock_update_status.call_args_list
    |     ^^^^^^ S101
236 |     mock_workcell_runtime.teardown.assert_awaited_once()
    |

tests/core/test_orchestrator.py:246:13: ANN201 Missing return type annotation for public function `test_execute_raises_error_if_protocol_not_found`
    |
244 |     "praxis.backend.core.orchestrator.get_protocol_definition_orm_by_name_and_version",
245 |   )
246 |   async def test_execute_raises_error_if_protocol_not_found(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
247 |     self, mock_get_protocol_def: AsyncMock, orchestrator: Orchestrator,
248 |   ):
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:265:13: ANN201 Missing return type annotation for public function `test_execute_raises_error_if_asset_is_missing`
    |
263 |     "praxis.backend.core.orchestrator.get_protocol_definition_orm_by_name_and_version",
264 |   )
265 |   async def test_execute_raises_error_if_asset_is_missing(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
266 |     self,
267 |     mock_get_protocol_def: AsyncMock,
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:298:13: ANN201 Missing return type annotation for public function `test_execute_loads_protocol_not_in_registry`
    |
296 |     "praxis.backend.core.orchestrator.get_protocol_definition_orm_by_name_and_version",
297 |   )
298 |   async def test_execute_loads_protocol_not_in_registry(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
299 |     self,
300 |     mock_get_protocol_def: AsyncMock,
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:316:9: ANN202 Missing return type annotation for private function `loader_side_effect`
    |
314 |     )
315 | 
316 |     def loader_side_effect(*args, **kwargs):
    |         ^^^^^^^^^^^^^^^^^^ ANN202
317 |       PROTOCOL_REGISTRY[f"{TEST_PROTOCOL_NAME}_v{TEST_PROTOCOL_VERSION}"] = runtime_info
    |
    = help: Add return type annotation: `None`

tests/core/test_orchestrator.py:316:28: ANN002 Missing type annotation for `*args`
    |
314 |     )
315 | 
316 |     def loader_side_effect(*args, **kwargs):
    |                            ^^^^^ ANN002
317 |       PROTOCOL_REGISTRY[f"{TEST_PROTOCOL_NAME}_v{TEST_PROTOCOL_VERSION}"] = runtime_info
    |

tests/core/test_orchestrator.py:316:29: ARG001 Unused function argument: `args`
    |
314 |     )
315 | 
316 |     def loader_side_effect(*args, **kwargs):
    |                             ^^^^ ARG001
317 |       PROTOCOL_REGISTRY[f"{TEST_PROTOCOL_NAME}_v{TEST_PROTOCOL_VERSION}"] = runtime_info
    |

tests/core/test_orchestrator.py:316:35: ANN003 Missing type annotation for `**kwargs`
    |
314 |     )
315 | 
316 |     def loader_side_effect(*args, **kwargs):
    |                                   ^^^^^^^^ ANN003
317 |       PROTOCOL_REGISTRY[f"{TEST_PROTOCOL_NAME}_v{TEST_PROTOCOL_VERSION}"] = runtime_info
    |

tests/core/test_orchestrator.py:316:37: ARG001 Unused function argument: `kwargs`
    |
314 |     )
315 | 
316 |     def loader_side_effect(*args, **kwargs):
    |                                     ^^^^^^ ARG001
317 |       PROTOCOL_REGISTRY[f"{TEST_PROTOCOL_NAME}_v{TEST_PROTOCOL_VERSION}"] = runtime_info
    |

tests/core/test_protocol_code_manager.py:1:1: INP001 File `tests/core/test_protocol_code_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_protocol_code_manager.py:18:5: PLR0913 Too many arguments in function definition (10 > 5)
   |
18 | def make_protocol_def_orm(
   |     ^^^^^^^^^^^^^^^^^^^^^ PLR0913
19 |   name: str = "test_protocol",
20 |   version: str = "1.0.0",
   |

tests/core/test_protocol_code_manager.py:18:5: ANN201 Missing return type annotation for public function `make_protocol_def_orm`
   |
18 | def make_protocol_def_orm(
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |   name: str = "test_protocol",
20 |   version: str = "1.0.0",
   |
   = help: Add return type annotation

tests/core/test_protocol_code_manager.py:23:29: B008 Do not perform function call `uuid.UUID` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
21 |   module_name: str = "dummy_module",
22 |   function_name: str = "dummy_func",
23 |   accession_id: uuid.UUID = uuid.UUID("018f4a3b-3c48-7c87-8c4c-35e6a172c74d"),
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B008
24 |   source_repository_accession_id=None,
25 |   source_repository=None,
   |

tests/core/test_protocol_code_manager.py:24:3: ANN001 Missing type annotation for function argument `source_repository_accession_id`
   |
22 |   function_name: str = "dummy_func",
23 |   accession_id: uuid.UUID = uuid.UUID("018f4a3b-3c48-7c87-8c4c-35e6a172c74d"),
24 |   source_repository_accession_id=None,
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
25 |   source_repository=None,
26 |   commit_hash=None,
   |

tests/core/test_protocol_code_manager.py:25:3: ANN001 Missing type annotation for function argument `source_repository`
   |
23 |   accession_id: uuid.UUID = uuid.UUID("018f4a3b-3c48-7c87-8c4c-35e6a172c74d"),
24 |   source_repository_accession_id=None,
25 |   source_repository=None,
   |   ^^^^^^^^^^^^^^^^^ ANN001
26 |   commit_hash=None,
27 |   file_system_source_accession_id=None,
   |

tests/core/test_protocol_code_manager.py:26:3: ANN001 Missing type annotation for function argument `commit_hash`
   |
24 |   source_repository_accession_id=None,
25 |   source_repository=None,
26 |   commit_hash=None,
   |   ^^^^^^^^^^^ ANN001
27 |   file_system_source_accession_id=None,
28 |   file_system_source=None,
   |

tests/core/test_protocol_code_manager.py:27:3: ANN001 Missing type annotation for function argument `file_system_source_accession_id`
   |
25 |   source_repository=None,
26 |   commit_hash=None,
27 |   file_system_source_accession_id=None,
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
28 |   file_system_source=None,
29 | ):
   |

tests/core/test_protocol_code_manager.py:28:3: ANN001 Missing type annotation for function argument `file_system_source`
   |
26 |   commit_hash=None,
27 |   file_system_source_accession_id=None,
28 |   file_system_source=None,
   |   ^^^^^^^^^^^^^^^^^^ ANN001
29 | ):
30 |   """Create a dummy ORM protocol definition for testing."""
   |

tests/core/test_protocol_code_manager.py:45:5: PLR0913 Too many arguments in function definition (6 > 5)
   |
45 | def make_pydantic_def(
   |     ^^^^^^^^^^^^^^^^^ PLR0913
46 |   accession_id: uuid.UUID = uuid.UUID("018f4a3b-3c48-7c87-8c4c-35e6a172c74d"),
47 |   name: str = "test",
   |

tests/core/test_protocol_code_manager.py:46:29: B008 Do not perform function call `uuid.UUID` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   |
45 | def make_pydantic_def(
46 |   accession_id: uuid.UUID = uuid.UUID("018f4a3b-3c48-7c87-8c4c-35e6a172c74d"),
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B008
47 |   name: str = "test",
48 |   version: str = "1.0.0",
   |

tests/core/test_protocol_code_manager.py:49:27: S108 Probable insecure usage of temporary file or directory: "/tmp/file.py"
   |
47 |   name: str = "test",
48 |   version: str = "1.0.0",
49 |   source_file_path: str = "/tmp/file.py",
   |                           ^^^^^^^^^^^^^^ S108
50 |   module_name: str = "dummy_module",
51 |   function_name: str = "dummy_func",
   |

tests/core/test_protocol_code_manager.py:64:5: ANN201 Missing return type annotation for public function `test_temporary_sys_path_adds_and_removes`
   |
64 | def test_temporary_sys_path_adds_and_removes():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
65 |   """Test that temporary_sys_path adds and removes a path from sys.path."""
66 |   dummy_path = "/tmp/dummy_path"
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:66:16: S108 Probable insecure usage of temporary file or directory: "/tmp/dummy_path"
   |
64 | def test_temporary_sys_path_adds_and_removes():
65 |   """Test that temporary_sys_path adds and removes a path from sys.path."""
66 |   dummy_path = "/tmp/dummy_path"
   |                ^^^^^^^^^^^^^^^^^ S108
67 |   sys_path_orig = list(sys.path)
68 |   with temporary_sys_path(dummy_path):
   |

tests/core/test_protocol_code_manager.py:69:5: S101 Use of `assert` detected
   |
67 |   sys_path_orig = list(sys.path)
68 |   with temporary_sys_path(dummy_path):
69 |     assert sys.path[0] == dummy_path
   |     ^^^^^^ S101
70 |   assert sys.path == sys_path_orig
   |

tests/core/test_protocol_code_manager.py:70:3: S101 Use of `assert` detected
   |
68 |   with temporary_sys_path(dummy_path):
69 |     assert sys.path[0] == dummy_path
70 |   assert sys.path == sys_path_orig
   |   ^^^^^^ S101
   |

tests/core/test_protocol_code_manager.py:73:5: ANN201 Missing return type annotation for public function `test_temporary_sys_path_noop`
   |
73 | def test_temporary_sys_path_noop():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |   """Test that temporary_sys_path does nothing if path is None."""
75 |   sys_path_orig = list(sys.path)
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:77:5: S101 Use of `assert` detected
   |
75 |   sys_path_orig = list(sys.path)
76 |   with temporary_sys_path(None):
77 |     assert sys.path == sys_path_orig
   |     ^^^^^^ S101
78 |   assert sys.path == sys_path_orig
   |

tests/core/test_protocol_code_manager.py:78:3: S101 Use of `assert` detected
   |
76 |   with temporary_sys_path(None):
77 |     assert sys.path == sys_path_orig
78 |   assert sys.path == sys_path_orig
   |   ^^^^^^ S101
   |

tests/core/test_protocol_code_manager.py:81:5: ANN201 Missing return type annotation for public function `test_load_protocol_function_success`
   |
81 | def test_load_protocol_function_success(monkeypatch):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
82 |   """Test loading a protocol function with a valid _protocol_definition."""
83 |   pcm = ProtocolCodeManager()
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:81:41: ANN001 Missing type annotation for function argument `monkeypatch`
   |
81 | def test_load_protocol_function_success(monkeypatch):
   |                                         ^^^^^^^^^^^ ANN001
82 |   """Test loading a protocol function with a valid _protocol_definition."""
83 |   pcm = ProtocolCodeManager()
   |

tests/core/test_protocol_code_manager.py:87:7: ANN202 Missing return type annotation for private function `dummy_func`
   |
85 |   function_name = "test_func"
86 | 
87 |   def dummy_func():
   |       ^^^^^^^^^^ ANN202
88 |     pass
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:90:3: SLF001 Private member accessed: `_protocol_definition`
   |
88 |     pass
89 | 
90 |   dummy_func._protocol_definition = make_pydantic_def()
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
91 |   dummy_mod = types.ModuleType(module_name)
92 |   setattr(dummy_mod, function_name, dummy_func)
   |

tests/core/test_protocol_code_manager.py:94:16: SLF001 Private member accessed: `_load_protocol_function`
   |
92 |   setattr(dummy_mod, function_name, dummy_func)
93 |   monkeypatch.setitem(sys.modules, module_name, dummy_mod)
94 |   func, pdef = pcm._load_protocol_function(module_name, function_name)
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
95 |   assert func is dummy_func
96 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
   |

tests/core/test_protocol_code_manager.py:95:3: S101 Use of `assert` detected
   |
93 |   monkeypatch.setitem(sys.modules, module_name, dummy_mod)
94 |   func, pdef = pcm._load_protocol_function(module_name, function_name)
95 |   assert func is dummy_func
   |   ^^^^^^ S101
96 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
   |

tests/core/test_protocol_code_manager.py:96:3: S101 Use of `assert` detected
   |
94 |   func, pdef = pcm._load_protocol_function(module_name, function_name)
95 |   assert func is dummy_func
96 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
   |   ^^^^^^ S101
   |

tests/core/test_protocol_code_manager.py:99:5: ANN201 Missing return type annotation for public function `test_load_protocol_function_missing_func`
    |
 99 | def test_load_protocol_function_missing_func(monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
100 |   """Test loading a protocol function that does not exist."""
101 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:99:46: ANN001 Missing type annotation for function argument `monkeypatch`
    |
 99 | def test_load_protocol_function_missing_func(monkeypatch):
    |                                              ^^^^^^^^^^^ ANN001
100 |   """Test loading a protocol function that does not exist."""
101 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:106:5: SLF001 Private member accessed: `_load_protocol_function`
    |
104 |   monkeypatch.setitem(sys.modules, module_name, dummy_mod)
105 |   with pytest.raises(AttributeError):
106 |     pcm._load_protocol_function(module_name, "not_found")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_protocol_code_manager.py:109:5: ANN201 Missing return type annotation for public function `test_load_protocol_function_invalid_protocol_def`
    |
109 | def test_load_protocol_function_invalid_protocol_def(monkeypatch):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
110 |   """Test loading a protocol function with invalid _protocol_definition."""
111 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:109:54: ANN001 Missing type annotation for function argument `monkeypatch`
    |
109 | def test_load_protocol_function_invalid_protocol_def(monkeypatch):
    |                                                      ^^^^^^^^^^^ ANN001
110 |   """Test loading a protocol function with invalid _protocol_definition."""
111 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:115:7: ANN202 Missing return type annotation for private function `dummy_func`
    |
113 |   function_name = "test_func"
114 | 
115 |   def dummy_func():
    |       ^^^^^^^^^^ ANN202
116 |     pass
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:118:3: SLF001 Private member accessed: `_protocol_definition`
    |
116 |     pass
117 | 
118 |   dummy_func._protocol_definition = None  # Not a valid pydantic def
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
119 |   dummy_mod = types.ModuleType(module_name)
120 |   setattr(dummy_mod, function_name, dummy_func)
    |

tests/core/test_protocol_code_manager.py:123:5: SLF001 Private member accessed: `_load_protocol_function`
    |
121 |   monkeypatch.setitem(sys.modules, module_name, dummy_mod)
122 |   with pytest.raises(AttributeError):
123 |     pcm._load_protocol_function(module_name, function_name)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_protocol_code_manager.py:127:11: ANN201 Missing return type annotation for public function `test_run_git_command_success`
    |
126 | @pytest.mark.asyncio
127 | async def test_run_git_command_success(monkeypatch):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
128 |   """Test successful execution of a git command."""
129 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:127:40: ANN001 Missing type annotation for function argument `monkeypatch`
    |
126 | @pytest.mark.asyncio
127 | async def test_run_git_command_success(monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
128 |   """Test successful execution of a git command."""
129 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:131:49: ARG005 Unused lambda argument: `a`
    |
129 |   pcm = ProtocolCodeManager()
130 |   dummy_result = mock.Mock(stdout="ok", stderr="", returncode=0)
131 |   monkeypatch.setattr("subprocess.run", lambda *a, **k: dummy_result)
    |                                                 ^ ARG005
132 |   out = await pcm._run_git_command(["git", "status"], cwd="/", suppress_output=True)
133 |   assert out == "ok"
    |

tests/core/test_protocol_code_manager.py:131:54: ARG005 Unused lambda argument: `k`
    |
129 |   pcm = ProtocolCodeManager()
130 |   dummy_result = mock.Mock(stdout="ok", stderr="", returncode=0)
131 |   monkeypatch.setattr("subprocess.run", lambda *a, **k: dummy_result)
    |                                                      ^ ARG005
132 |   out = await pcm._run_git_command(["git", "status"], cwd="/", suppress_output=True)
133 |   assert out == "ok"
    |

tests/core/test_protocol_code_manager.py:132:15: SLF001 Private member accessed: `_run_git_command`
    |
130 |   dummy_result = mock.Mock(stdout="ok", stderr="", returncode=0)
131 |   monkeypatch.setattr("subprocess.run", lambda *a, **k: dummy_result)
132 |   out = await pcm._run_git_command(["git", "status"], cwd="/", suppress_output=True)
    |               ^^^^^^^^^^^^^^^^^^^^ SLF001
133 |   assert out == "ok"
    |

tests/core/test_protocol_code_manager.py:133:3: S101 Use of `assert` detected
    |
131 |   monkeypatch.setattr("subprocess.run", lambda *a, **k: dummy_result)
132 |   out = await pcm._run_git_command(["git", "status"], cwd="/", suppress_output=True)
133 |   assert out == "ok"
    |   ^^^^^^ S101
    |

tests/core/test_protocol_code_manager.py:137:11: ANN201 Missing return type annotation for public function `test_run_git_command_failure`
    |
136 | @pytest.mark.asyncio
137 | async def test_run_git_command_failure(monkeypatch):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
138 |   """Test failure of a git command raises RuntimeError."""
139 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:137:40: ANN001 Missing type annotation for function argument `monkeypatch`
    |
136 | @pytest.mark.asyncio
137 | async def test_run_git_command_failure(monkeypatch):
    |                                        ^^^^^^^^^^^ ANN001
138 |   """Test failure of a git command raises RuntimeError."""
139 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:141:7: ANN202 Missing return type annotation for private function `fail_run`
    |
139 |   pcm = ProtocolCodeManager()
140 | 
141 |   def fail_run(*a, **k):
    |       ^^^^^^^^ ANN202
142 |     raise subprocess.CalledProcessError(1, ["git", "fail"], output="", stderr="fail")
    |
    = help: Add return type annotation: `NoReturn`

tests/core/test_protocol_code_manager.py:141:16: ANN002 Missing type annotation for `*a`
    |
139 |   pcm = ProtocolCodeManager()
140 | 
141 |   def fail_run(*a, **k):
    |                ^^ ANN002
142 |     raise subprocess.CalledProcessError(1, ["git", "fail"], output="", stderr="fail")
    |

tests/core/test_protocol_code_manager.py:141:17: ARG001 Unused function argument: `a`
    |
139 |   pcm = ProtocolCodeManager()
140 | 
141 |   def fail_run(*a, **k):
    |                 ^ ARG001
142 |     raise subprocess.CalledProcessError(1, ["git", "fail"], output="", stderr="fail")
    |

tests/core/test_protocol_code_manager.py:141:20: ANN003 Missing type annotation for `**k`
    |
139 |   pcm = ProtocolCodeManager()
140 | 
141 |   def fail_run(*a, **k):
    |                    ^^^ ANN003
142 |     raise subprocess.CalledProcessError(1, ["git", "fail"], output="", stderr="fail")
    |

tests/core/test_protocol_code_manager.py:141:22: ARG001 Unused function argument: `k`
    |
139 |   pcm = ProtocolCodeManager()
140 | 
141 |   def fail_run(*a, **k):
    |                      ^ ARG001
142 |     raise subprocess.CalledProcessError(1, ["git", "fail"], output="", stderr="fail")
    |

tests/core/test_protocol_code_manager.py:146:11: SLF001 Private member accessed: `_run_git_command`
    |
144 |   monkeypatch.setattr("subprocess.run", fail_run)
145 |   with pytest.raises(RuntimeError):
146 |     await pcm._run_git_command(["git", "fail"], cwd="/", suppress_output=True)
    |           ^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_protocol_code_manager.py:150:11: ANN201 Missing return type annotation for public function `test_prepare_protocol_code_git`
    |
149 | @pytest.mark.asyncio
150 | async def test_prepare_protocol_code_git(monkeypatch):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
151 |   """Test prepare_protocol_code with a git source."""
152 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:150:42: ANN001 Missing type annotation for function argument `monkeypatch`
    |
149 | @pytest.mark.asyncio
150 | async def test_prepare_protocol_code_git(monkeypatch):
    |                                          ^^^^^^^^^^^ ANN001
151 |   """Test prepare_protocol_code with a git source."""
152 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:155:30: S108 Probable insecure usage of temporary file or directory: "/tmp/repo"
    |
153 |   repo = mock.Mock()
154 |   repo.git_url = "https://example.com/repo.git"
155 |   repo.local_checkout_path = "/tmp/repo"
    |                              ^^^^^^^^^^^ S108
156 |   repo.name = "repo"
157 |   orm = make_protocol_def_orm(
    |

tests/core/test_protocol_code_manager.py:165:7: ANN202 Missing return type annotation for private function `dummy_func`
    |
163 |   monkeypatch.setattr(pcm, "_checkout_specific_commit", mock.AsyncMock())
164 | 
165 |   def dummy_func():
    |       ^^^^^^^^^^ ANN202
166 |     pass
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:171:13: ARG005 Unused lambda argument: `a`
    |
169 |     pcm,
170 |     "_load_protocol_function",
171 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |             ^ ARG005
172 |   )
173 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:171:18: ARG005 Unused lambda argument: `k`
    |
169 |     pcm,
170 |     "_load_protocol_function",
171 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |                  ^ ARG005
172 |   )
173 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:174:3: S101 Use of `assert` detected
    |
172 |   )
173 |   func, pdef = await pcm.prepare_protocol_code(orm)
174 |   assert callable(func)
    |   ^^^^^^ S101
175 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |

tests/core/test_protocol_code_manager.py:175:3: S101 Use of `assert` detected
    |
173 |   func, pdef = await pcm.prepare_protocol_code(orm)
174 |   assert callable(func)
175 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |   ^^^^^^ S101
    |

tests/core/test_protocol_code_manager.py:179:11: ANN201 Missing return type annotation for public function `test_prepare_protocol_code_filesystem`
    |
178 | @pytest.mark.asyncio
179 | async def test_prepare_protocol_code_filesystem(monkeypatch, tmp_path):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
180 |   """Test prepare_protocol_code with a filesystem source."""
181 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:179:49: ANN001 Missing type annotation for function argument `monkeypatch`
    |
178 | @pytest.mark.asyncio
179 | async def test_prepare_protocol_code_filesystem(monkeypatch, tmp_path):
    |                                                 ^^^^^^^^^^^ ANN001
180 |   """Test prepare_protocol_code with a filesystem source."""
181 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:179:62: ANN001 Missing type annotation for function argument `tmp_path`
    |
178 | @pytest.mark.asyncio
179 | async def test_prepare_protocol_code_filesystem(monkeypatch, tmp_path):
    |                                                              ^^^^^^^^ ANN001
180 |   """Test prepare_protocol_code with a filesystem source."""
181 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:189:7: ANN202 Missing return type annotation for private function `dummy_func`
    |
187 |   )
188 | 
189 |   def dummy_func():
    |       ^^^^^^^^^^ ANN202
190 |     pass
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:195:13: ARG005 Unused lambda argument: `a`
    |
193 |     pcm,
194 |     "_load_protocol_function",
195 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |             ^ ARG005
196 |   )
197 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:195:18: ARG005 Unused lambda argument: `k`
    |
193 |     pcm,
194 |     "_load_protocol_function",
195 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |                  ^ ARG005
196 |   )
197 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:198:3: S101 Use of `assert` detected
    |
196 |   )
197 |   func, pdef = await pcm.prepare_protocol_code(orm)
198 |   assert callable(func)
    |   ^^^^^^ S101
199 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |

tests/core/test_protocol_code_manager.py:199:3: S101 Use of `assert` detected
    |
197 |   func, pdef = await pcm.prepare_protocol_code(orm)
198 |   assert callable(func)
199 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |   ^^^^^^ S101
    |

tests/core/test_protocol_code_manager.py:203:11: ANN201 Missing return type annotation for public function `test_prepare_protocol_code_direct_import`
    |
202 | @pytest.mark.asyncio
203 | async def test_prepare_protocol_code_direct_import(monkeypatch):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
204 |   """Test prepare_protocol_code with direct import (no source)."""
205 |   pcm = ProtocolCodeManager()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:203:52: ANN001 Missing type annotation for function argument `monkeypatch`
    |
202 | @pytest.mark.asyncio
203 | async def test_prepare_protocol_code_direct_import(monkeypatch):
    |                                                    ^^^^^^^^^^^ ANN001
204 |   """Test prepare_protocol_code with direct import (no source)."""
205 |   pcm = ProtocolCodeManager()
    |

tests/core/test_protocol_code_manager.py:208:7: ANN202 Missing return type annotation for private function `dummy_func`
    |
206 |   orm = make_protocol_def_orm()
207 | 
208 |   def dummy_func():
    |       ^^^^^^^^^^ ANN202
209 |     pass
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_code_manager.py:214:13: ARG005 Unused lambda argument: `a`
    |
212 |     pcm,
213 |     "_load_protocol_function",
214 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |             ^ ARG005
215 |   )
216 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:214:18: ARG005 Unused lambda argument: `k`
    |
212 |     pcm,
213 |     "_load_protocol_function",
214 |     lambda *a, **k: (dummy_func, make_pydantic_def()),
    |                  ^ ARG005
215 |   )
216 |   func, pdef = await pcm.prepare_protocol_code(orm)
    |

tests/core/test_protocol_code_manager.py:217:3: S101 Use of `assert` detected
    |
215 |   )
216 |   func, pdef = await pcm.prepare_protocol_code(orm)
217 |   assert callable(func)
    |   ^^^^^^ S101
218 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |

tests/core/test_protocol_code_manager.py:218:3: S101 Use of `assert` detected
    |
216 |   func, pdef = await pcm.prepare_protocol_code(orm)
217 |   assert callable(func)
218 |   assert isinstance(pdef, FunctionProtocolDefinitionModel)
    |   ^^^^^^ S101
    |

tests/core/test_protocol_execution_service.py:1:1: INP001 File `tests/core/test_protocol_execution_service.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_protocol_execution_service.py:13:5: ANN201 Missing return type annotation for public function `db_session_factory`
   |
12 | @pytest.fixture
13 | def db_session_factory():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
14 |   """Fixture for a mock database session factory."""
15 |   return MagicMock()
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:19:5: ANN201 Missing return type annotation for public function `asset_manager`
   |
18 | @pytest.fixture
19 | def asset_manager():
   |     ^^^^^^^^^^^^^ ANN201
20 |   """Fixture for a mock AssetManager."""
21 |   return MagicMock()
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:25:5: ANN201 Missing return type annotation for public function `workcell_runtime`
   |
24 | @pytest.fixture
25 | def workcell_runtime():
   |     ^^^^^^^^^^^^^^^^ ANN201
26 |   """Fixture for a mock WorkcellRuntime."""
27 |   return MagicMock()
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:31:5: ANN201 Missing return type annotation for public function `scheduler`
   |
30 | @pytest.fixture
31 | def scheduler():
   |     ^^^^^^^^^ ANN201
32 |   """Fixture for a mock ProtocolScheduler."""
33 |   mock = MagicMock()
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:41:5: ANN201 Missing return type annotation for public function `orchestrator`
   |
40 | @pytest.fixture
41 | def orchestrator():
   |     ^^^^^^^^^^^^ ANN201
42 |   """Fixture for a mock Orchestrator."""
43 |   mock = MagicMock()
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:49:5: ANN201 Missing return type annotation for public function `service`
   |
48 | @pytest.fixture
49 | def service(
   |     ^^^^^^^ ANN201
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
51 | ):
   |
   = help: Add return type annotation

tests/core/test_protocol_execution_service.py:50:3: ANN001 Missing type annotation for function argument `db_session_factory`
   |
48 | @pytest.fixture
49 | def service(
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
   |   ^^^^^^^^^^^^^^^^^^ ANN001
51 | ):
52 |   """Fixture for ProtocolExecutionService with all dependencies mocked."""
   |

tests/core/test_protocol_execution_service.py:50:23: ANN001 Missing type annotation for function argument `asset_manager`
   |
48 | @pytest.fixture
49 | def service(
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
   |                       ^^^^^^^^^^^^^ ANN001
51 | ):
52 |   """Fixture for ProtocolExecutionService with all dependencies mocked."""
   |

tests/core/test_protocol_execution_service.py:50:38: ANN001 Missing type annotation for function argument `workcell_runtime`
   |
48 | @pytest.fixture
49 | def service(
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
   |                                      ^^^^^^^^^^^^^^^^ ANN001
51 | ):
52 |   """Fixture for ProtocolExecutionService with all dependencies mocked."""
   |

tests/core/test_protocol_execution_service.py:50:56: ANN001 Missing type annotation for function argument `scheduler`
   |
48 | @pytest.fixture
49 | def service(
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
   |                                                        ^^^^^^^^^ ANN001
51 | ):
52 |   """Fixture for ProtocolExecutionService with all dependencies mocked."""
   |

tests/core/test_protocol_execution_service.py:50:67: ANN001 Missing type annotation for function argument `orchestrator`
   |
48 | @pytest.fixture
49 | def service(
50 |   db_session_factory, asset_manager, workcell_runtime, scheduler, orchestrator,
   |                                                                   ^^^^^^^^^^^^ ANN001
51 | ):
52 |   """Fixture for ProtocolExecutionService with all dependencies mocked."""
   |

tests/core/test_protocol_execution_service.py:63:11: ANN201 Missing return type annotation for public function `test_execute_protocol_immediately`
   |
62 | @pytest.mark.asyncio
63 | async def test_execute_protocol_immediately(service, orchestrator):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
64 |   """Test immediate protocol execution bypassing the scheduler."""
65 |   result = await service.execute_protocol_immediately(
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_execution_service.py:63:45: ANN001 Missing type annotation for function argument `service`
   |
62 | @pytest.mark.asyncio
63 | async def test_execute_protocol_immediately(service, orchestrator):
   |                                             ^^^^^^^ ANN001
64 |   """Test immediate protocol execution bypassing the scheduler."""
65 |   result = await service.execute_protocol_immediately(
   |

tests/core/test_protocol_execution_service.py:63:54: ANN001 Missing type annotation for function argument `orchestrator`
   |
62 | @pytest.mark.asyncio
63 | async def test_execute_protocol_immediately(service, orchestrator):
   |                                                      ^^^^^^^^^^^^ ANN001
64 |   """Test immediate protocol execution bypassing the scheduler."""
65 |   result = await service.execute_protocol_immediately(
   |

tests/core/test_protocol_execution_service.py:74:3: S101 Use of `assert` detected
   |
72 |   )
73 |   orchestrator.execute_protocol.assert_awaited_once()
74 |   assert result == "protocol_run_result"
   |   ^^^^^^ S101
   |

tests/core/test_protocol_execution_service.py:79:11: ANN201 Missing return type annotation for public function `test_schedule_protocol_execution`
   |
77 | @pytest.mark.asyncio
78 | @patch("praxis.backend.core.protocol_execution_service.svc")
79 | async def test_schedule_protocol_execution(mock_svc, service, scheduler):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
80 |   """Test scheduling a protocol for asynchronous execution."""
81 |   protocol_def_orm = MagicMock()
   |
   = help: Add return type annotation: `None`

tests/core/test_protocol_execution_service.py:79:44: ANN001 Missing type annotation for function argument `mock_svc`
   |
77 | @pytest.mark.asyncio
78 | @patch("praxis.backend.core.protocol_execution_service.svc")
79 | async def test_schedule_protocol_execution(mock_svc, service, scheduler):
   |                                            ^^^^^^^^ ANN001
80 |   """Test scheduling a protocol for asynchronous execution."""
81 |   protocol_def_orm = MagicMock()
   |

tests/core/test_protocol_execution_service.py:79:54: ANN001 Missing type annotation for function argument `service`
   |
77 | @pytest.mark.asyncio
78 | @patch("praxis.backend.core.protocol_execution_service.svc")
79 | async def test_schedule_protocol_execution(mock_svc, service, scheduler):
   |                                                      ^^^^^^^ ANN001
80 |   """Test scheduling a protocol for asynchronous execution."""
81 |   protocol_def_orm = MagicMock()
   |

tests/core/test_protocol_execution_service.py:79:63: ANN001 Missing type annotation for function argument `scheduler`
   |
77 | @pytest.mark.asyncio
78 | @patch("praxis.backend.core.protocol_execution_service.svc")
79 | async def test_schedule_protocol_execution(mock_svc, service, scheduler):
   |                                                               ^^^^^^^^^ ANN001
80 |   """Test scheduling a protocol for asynchronous execution."""
81 |   protocol_def_orm = MagicMock()
   |

tests/core/test_protocol_execution_service.py:99:3: S101 Use of `assert` detected
    |
 97 |     source_name="test_source",
 98 |   )
 99 |   assert result is not None
    |   ^^^^^^ S101
100 |   scheduler.schedule_protocol_execution.assert_awaited_once()
101 |   mock_svc.create_protocol_run.assert_awaited_once()
    |

tests/core/test_protocol_execution_service.py:106:11: ANN201 Missing return type annotation for public function `test_get_protocol_run_status`
    |
104 | @pytest.mark.asyncio
105 | @patch("praxis.backend.core.protocol_execution_service.svc")
106 | async def test_get_protocol_run_status(mock_svc, service, scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
107 |   """Test getting the status of a protocol run."""
108 |   protocol_run_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_execution_service.py:106:40: ANN001 Missing type annotation for function argument `mock_svc`
    |
104 | @pytest.mark.asyncio
105 | @patch("praxis.backend.core.protocol_execution_service.svc")
106 | async def test_get_protocol_run_status(mock_svc, service, scheduler):
    |                                        ^^^^^^^^ ANN001
107 |   """Test getting the status of a protocol run."""
108 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:106:50: ANN001 Missing type annotation for function argument `service`
    |
104 | @pytest.mark.asyncio
105 | @patch("praxis.backend.core.protocol_execution_service.svc")
106 | async def test_get_protocol_run_status(mock_svc, service, scheduler):
    |                                                  ^^^^^^^ ANN001
107 |   """Test getting the status of a protocol run."""
108 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:106:59: ANN001 Missing type annotation for function argument `scheduler`
    |
104 | @pytest.mark.asyncio
105 | @patch("praxis.backend.core.protocol_execution_service.svc")
106 | async def test_get_protocol_run_status(mock_svc, service, scheduler):
    |                                                           ^^^^^^^^^ ANN001
107 |   """Test getting the status of a protocol run."""
108 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:106:59: ARG001 Unused function argument: `scheduler`
    |
104 | @pytest.mark.asyncio
105 | @patch("praxis.backend.core.protocol_execution_service.svc")
106 | async def test_get_protocol_run_status(mock_svc, service, scheduler):
    |                                                           ^^^^^^^^^ ARG001
107 |   """Test getting the status of a protocol run."""
108 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:123:3: S101 Use of `assert` detected
    |
122 |   status = await service.get_protocol_run_status(protocol_run_id)
123 |   assert status["protocol_run_id"] == str(protocol_run_id)
    |   ^^^^^^ S101
124 |   assert status["status"] == ProtocolRunStatusEnum.PREPARING.value
125 |   assert status["schedule_info"] == {"status": "SCHEDULED"}
    |

tests/core/test_protocol_execution_service.py:124:3: S101 Use of `assert` detected
    |
122 |   status = await service.get_protocol_run_status(protocol_run_id)
123 |   assert status["protocol_run_id"] == str(protocol_run_id)
124 |   assert status["status"] == ProtocolRunStatusEnum.PREPARING.value
    |   ^^^^^^ S101
125 |   assert status["schedule_info"] == {"status": "SCHEDULED"}
    |

tests/core/test_protocol_execution_service.py:125:3: S101 Use of `assert` detected
    |
123 |   assert status["protocol_run_id"] == str(protocol_run_id)
124 |   assert status["status"] == ProtocolRunStatusEnum.PREPARING.value
125 |   assert status["schedule_info"] == {"status": "SCHEDULED"}
    |   ^^^^^^ S101
    |

tests/core/test_protocol_execution_service.py:130:11: ANN201 Missing return type annotation for public function `test_cancel_protocol_run`
    |
128 | @pytest.mark.asyncio
129 | @patch("praxis.backend.core.protocol_execution_service.svc")
130 | async def test_cancel_protocol_run(mock_svc, service, scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
131 |   """Test cancelling a protocol run."""
132 |   protocol_run_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_protocol_execution_service.py:130:36: ANN001 Missing type annotation for function argument `mock_svc`
    |
128 | @pytest.mark.asyncio
129 | @patch("praxis.backend.core.protocol_execution_service.svc")
130 | async def test_cancel_protocol_run(mock_svc, service, scheduler):
    |                                    ^^^^^^^^ ANN001
131 |   """Test cancelling a protocol run."""
132 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:130:46: ANN001 Missing type annotation for function argument `service`
    |
128 | @pytest.mark.asyncio
129 | @patch("praxis.backend.core.protocol_execution_service.svc")
130 | async def test_cancel_protocol_run(mock_svc, service, scheduler):
    |                                              ^^^^^^^ ANN001
131 |   """Test cancelling a protocol run."""
132 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:130:55: ANN001 Missing type annotation for function argument `scheduler`
    |
128 | @pytest.mark.asyncio
129 | @patch("praxis.backend.core.protocol_execution_service.svc")
130 | async def test_cancel_protocol_run(mock_svc, service, scheduler):
    |                                                       ^^^^^^^^^ ANN001
131 |   """Test cancelling a protocol run."""
132 |   protocol_run_id = uuid.uuid4()
    |

tests/core/test_protocol_execution_service.py:142:3: S101 Use of `assert` detected
    |
140 |   mock_svc.update_protocol_run_status.assert_awaited_once()
141 |   db_session.commit.assert_awaited_once()
142 |   assert result is True
    |   ^^^^^^ S101
    |

tests/core/test_run_context.py:1:1: INP001 File `tests/core/test_run_context.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_run_context.py:17:9: ANN204 Missing return type annotation for special method `__repr__`
   |
15 |     """Dummy Resource for testing."""
16 | 
17 |     def __repr__(self):
   |         ^^^^^^^^ ANN204
18 |         """Return a string representation."""
19 |         return "<DummyResource name=resource1>"
   |
   = help: Add return type annotation: `str`

tests/core/test_run_context.py:25:9: ANN204 Missing return type annotation for special method `__repr__`
   |
23 |     """Dummy Deck for testing."""
24 | 
25 |     def __repr__(self):
   |         ^^^^^^^^ ANN204
26 |         """Return a string representation."""
27 |         return "<DummyDeck name=deck1>"
   |
   = help: Add return type annotation: `str`

tests/core/test_run_context.py:37:5: ANN201 Missing return type annotation for public function `test_praxis_run_context_init`
   |
37 | def test_praxis_run_context_init():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
38 |     """Test PraxisRunContext initialization."""
39 |     run_id = uuid.uuid4()
   |
   = help: Add return type annotation: `None`

tests/core/test_run_context.py:47:5: S101 Use of `assert` detected
   |
45 |         current_db_session=session,
46 |     )
47 |     assert ctx.run_accession_id == run_id
   |     ^^^^^^ S101
48 |     assert ctx.canonical_state is state
49 |     assert ctx.current_db_session is session
   |

tests/core/test_run_context.py:48:5: S101 Use of `assert` detected
   |
46 |     )
47 |     assert ctx.run_accession_id == run_id
48 |     assert ctx.canonical_state is state
   |     ^^^^^^ S101
49 |     assert ctx.current_db_session is session
50 |     assert ctx.current_call_log_db_accession_id is None
   |

tests/core/test_run_context.py:49:5: S101 Use of `assert` detected
   |
47 |     assert ctx.run_accession_id == run_id
48 |     assert ctx.canonical_state is state
49 |     assert ctx.current_db_session is session
   |     ^^^^^^ S101
50 |     assert ctx.current_call_log_db_accession_id is None
51 |     assert ctx._call_sequence_next_val == 1
   |

tests/core/test_run_context.py:50:5: S101 Use of `assert` detected
   |
48 |     assert ctx.canonical_state is state
49 |     assert ctx.current_db_session is session
50 |     assert ctx.current_call_log_db_accession_id is None
   |     ^^^^^^ S101
51 |     assert ctx._call_sequence_next_val == 1
   |

tests/core/test_run_context.py:51:5: S101 Use of `assert` detected
   |
49 |     assert ctx.current_db_session is session
50 |     assert ctx.current_call_log_db_accession_id is None
51 |     assert ctx._call_sequence_next_val == 1
   |     ^^^^^^ S101
   |

tests/core/test_run_context.py:51:12: SLF001 Private member accessed: `_call_sequence_next_val`
   |
49 |     assert ctx.current_db_session is session
50 |     assert ctx.current_call_log_db_accession_id is None
51 |     assert ctx._call_sequence_next_val == 1
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
   |

tests/core/test_run_context.py:54:5: ANN201 Missing return type annotation for public function `test_get_and_increment_sequence_val`
   |
54 | def test_get_and_increment_sequence_val():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
55 |     """Test get_and_increment_sequence_val increments and returns correctly."""
56 |     ctx = PraxisRunContext(
   |
   = help: Add return type annotation: `None`

tests/core/test_run_context.py:61:5: S101 Use of `assert` detected
   |
59 |         current_db_session=MagicMock(spec=AsyncSession),
60 |     )
61 |     assert ctx.get_and_increment_sequence_val() == 1
   |     ^^^^^^ S101
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
   |

tests/core/test_run_context.py:62:5: S101 Use of `assert` detected
   |
60 |     )
61 |     assert ctx.get_and_increment_sequence_val() == 1
62 |     assert ctx._call_sequence_next_val == 2
   |     ^^^^^^ S101
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |

tests/core/test_run_context.py:62:12: SLF001 Private member accessed: `_call_sequence_next_val`
   |
60 |     )
61 |     assert ctx.get_and_increment_sequence_val() == 1
62 |     assert ctx._call_sequence_next_val == 2
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |

tests/core/test_run_context.py:62:43: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
60 |     )
61 |     assert ctx.get_and_increment_sequence_val() == 1
62 |     assert ctx._call_sequence_next_val == 2
   |                                           ^ PLR2004
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |

tests/core/test_run_context.py:63:5: S101 Use of `assert` detected
   |
61 |     assert ctx.get_and_increment_sequence_val() == 1
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
   |     ^^^^^^ S101
64 |     assert ctx._call_sequence_next_val == 3
   |

tests/core/test_run_context.py:63:52: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
61 |     assert ctx.get_and_increment_sequence_val() == 1
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
   |                                                    ^ PLR2004
64 |     assert ctx._call_sequence_next_val == 3
   |

tests/core/test_run_context.py:64:5: S101 Use of `assert` detected
   |
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |     ^^^^^^ S101
   |

tests/core/test_run_context.py:64:12: SLF001 Private member accessed: `_call_sequence_next_val`
   |
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
   |

tests/core/test_run_context.py:64:43: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
62 |     assert ctx._call_sequence_next_val == 2
63 |     assert ctx.get_and_increment_sequence_val() == 2
64 |     assert ctx._call_sequence_next_val == 3
   |                                           ^ PLR2004
   |

tests/core/test_run_context.py:67:5: ANN201 Missing return type annotation for public function `test_create_context_for_nested_call`
   |
67 | def test_create_context_for_nested_call():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     """Test create_context_for_nested_call returns a new context with new parent ID."""
69 |     parent_id = uuid.uuid4()
   |
   = help: Add return type annotation: `None`

tests/core/test_run_context.py:75:5: SLF001 Private member accessed: `_call_sequence_next_val`
   |
73 |         current_db_session=MagicMock(spec=AsyncSession),
74 |     )
75 |     ctx._call_sequence_next_val = 42
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
76 |     nested_ctx = ctx.create_context_for_nested_call(parent_id)
77 |     assert nested_ctx.run_accession_id == ctx.run_accession_id
   |

tests/core/test_run_context.py:77:5: S101 Use of `assert` detected
   |
75 |     ctx._call_sequence_next_val = 42
76 |     nested_ctx = ctx.create_context_for_nested_call(parent_id)
77 |     assert nested_ctx.run_accession_id == ctx.run_accession_id
   |     ^^^^^^ S101
78 |     assert nested_ctx.canonical_state is ctx.canonical_state
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
   |

tests/core/test_run_context.py:78:5: S101 Use of `assert` detected
   |
76 |     nested_ctx = ctx.create_context_for_nested_call(parent_id)
77 |     assert nested_ctx.run_accession_id == ctx.run_accession_id
78 |     assert nested_ctx.canonical_state is ctx.canonical_state
   |     ^^^^^^ S101
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
   |

tests/core/test_run_context.py:79:5: S101 Use of `assert` detected
   |
77 |     assert nested_ctx.run_accession_id == ctx.run_accession_id
78 |     assert nested_ctx.canonical_state is ctx.canonical_state
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
   |     ^^^^^^ S101
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
81 |     assert nested_ctx._call_sequence_next_val == 42
   |

tests/core/test_run_context.py:80:5: S101 Use of `assert` detected
   |
78 |     assert nested_ctx.canonical_state is ctx.canonical_state
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
   |     ^^^^^^ S101
81 |     assert nested_ctx._call_sequence_next_val == 42
82 |     # Changing nested_ctx sequence does not affect parent
   |

tests/core/test_run_context.py:81:5: S101 Use of `assert` detected
   |
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
81 |     assert nested_ctx._call_sequence_next_val == 42
   |     ^^^^^^ S101
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
   |

tests/core/test_run_context.py:81:12: SLF001 Private member accessed: `_call_sequence_next_val`
   |
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
81 |     assert nested_ctx._call_sequence_next_val == 42
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
   |

tests/core/test_run_context.py:81:50: PLR2004 Magic value used in comparison, consider replacing `42` with a constant variable
   |
79 |     assert nested_ctx.current_db_session is ctx.current_db_session
80 |     assert nested_ctx.current_call_log_db_accession_id == parent_id
81 |     assert nested_ctx._call_sequence_next_val == 42
   |                                                  ^^ PLR2004
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
   |

tests/core/test_run_context.py:84:5: S101 Use of `assert` detected
   |
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
84 |     assert ctx._call_sequence_next_val == 42
   |     ^^^^^^ S101
   |

tests/core/test_run_context.py:84:12: SLF001 Private member accessed: `_call_sequence_next_val`
   |
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
84 |     assert ctx._call_sequence_next_val == 42
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
   |

tests/core/test_run_context.py:84:43: PLR2004 Magic value used in comparison, consider replacing `42` with a constant variable
   |
82 |     # Changing nested_ctx sequence does not affect parent
83 |     nested_ctx.get_and_increment_sequence_val()
84 |     assert ctx._call_sequence_next_val == 42
   |                                           ^^ PLR2004
   |

tests/core/test_run_context.py:87:5: ANN201 Missing return type annotation for public function `test_serialize_arguments_basic_types`
   |
87 | def test_serialize_arguments_basic_types():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     """Test serialize_arguments with basic types."""
89 |     args = (1, "foo", 3.14)
   |
   = help: Add return type annotation: `None`

tests/core/test_run_context.py:92:5: S101 Use of `assert` detected
   |
90 |     kwargs = {"a": 2, "b": "bar"}
91 |     result = serialize_arguments(args, kwargs)
92 |     assert "1" in result and "foo" in result and "3.14" in result
   |     ^^^^^^ S101
93 |     assert "a" in result and "bar" in result
   |

tests/core/test_run_context.py:92:5: PT018 Assertion should be broken down into multiple parts
   |
90 |     kwargs = {"a": 2, "b": "bar"}
91 |     result = serialize_arguments(args, kwargs)
92 |     assert "1" in result and "foo" in result and "3.14" in result
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
93 |     assert "a" in result and "bar" in result
   |
   = help: Break down assertion into multiple parts

tests/core/test_run_context.py:93:5: S101 Use of `assert` detected
   |
91 |     result = serialize_arguments(args, kwargs)
92 |     assert "1" in result and "foo" in result and "3.14" in result
93 |     assert "a" in result and "bar" in result
   |     ^^^^^^ S101
   |

tests/core/test_run_context.py:93:5: PT018 Assertion should be broken down into multiple parts
   |
91 |     result = serialize_arguments(args, kwargs)
92 |     assert "1" in result and "foo" in result and "3.14" in result
93 |     assert "a" in result and "bar" in result
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
   |
   = help: Break down assertion into multiple parts

tests/core/test_run_context.py:96:5: ANN201 Missing return type annotation for public function `test_serialize_arguments_pydantic_model`
   |
96 | def test_serialize_arguments_pydantic_model():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
97 |     """Test serialize_arguments with a Pydantic model."""
98 |     model = DummyModel(foo=123, bar="baz")
   |
   = help: Add return type annotation: `None`

tests/core/test_run_context.py:102:5: S101 Use of `assert` detected
    |
100 |     kwargs = {"x": model}
101 |     result = serialize_arguments(args, kwargs)
102 |     assert "foo" in result and "bar" in result and "123" in result and "baz" in result
    |     ^^^^^^ S101
    |

tests/core/test_run_context.py:102:5: PT018 Assertion should be broken down into multiple parts
    |
100 |     kwargs = {"x": model}
101 |     result = serialize_arguments(args, kwargs)
102 |     assert "foo" in result and "bar" in result and "123" in result and "baz" in result
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
    |
    = help: Break down assertion into multiple parts

tests/core/test_run_context.py:105:5: ANN201 Missing return type annotation for public function `test_serialize_arguments_custom_types`
    |
105 | def test_serialize_arguments_custom_types():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
106 |     """Test serialize_arguments with custom types.
    |
    = help: Add return type annotation: `None`

tests/core/test_run_context.py:121:5: S101 Use of `assert` detected
    |
119 |     kwargs = {"ctx": ctx, "state": state, "resource": resource, "deck": deck}
120 |     result = serialize_arguments(args, kwargs)
121 |     assert "PraxisRunContext object" in result
    |     ^^^^^^ S101
122 |     assert "PraxisState object" in result
123 |     assert "<DummyResource name=resource1>" in result
    |

tests/core/test_run_context.py:122:5: S101 Use of `assert` detected
    |
120 |     result = serialize_arguments(args, kwargs)
121 |     assert "PraxisRunContext object" in result
122 |     assert "PraxisState object" in result
    |     ^^^^^^ S101
123 |     assert "<DummyResource name=resource1>" in result
124 |     assert "<DummyDeck name=deck1>" in result
    |

tests/core/test_run_context.py:123:5: S101 Use of `assert` detected
    |
121 |     assert "PraxisRunContext object" in result
122 |     assert "PraxisState object" in result
123 |     assert "<DummyResource name=resource1>" in result
    |     ^^^^^^ S101
124 |     assert "<DummyDeck name=deck1>" in result
    |

tests/core/test_run_context.py:124:5: S101 Use of `assert` detected
    |
122 |     assert "PraxisState object" in result
123 |     assert "<DummyResource name=resource1>" in result
124 |     assert "<DummyDeck name=deck1>" in result
    |     ^^^^^^ S101
    |

tests/core/test_run_context.py:127:5: ANN201 Missing return type annotation for public function `test_serialize_arguments_excludes_praxis_run_context_kwarg`
    |
127 | def test_serialize_arguments_excludes_praxis_run_context_kwarg():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
128 |     """Test that __praxis_run_context__ is excluded from kwargs in serialization."""
129 |     args = (1,)
    |
    = help: Add return type annotation: `None`

tests/core/test_run_context.py:132:5: S101 Use of `assert` detected
    |
130 |     kwargs = {"foo": 2, "__praxis_run_context__": "should be excluded"}
131 |     result = serialize_arguments(args, kwargs)
132 |     assert "__praxis_run_context__" not in result
    |     ^^^^^^ S101
133 |     assert "foo" in result
    |

tests/core/test_run_context.py:133:5: S101 Use of `assert` detected
    |
131 |     result = serialize_arguments(args, kwargs)
132 |     assert "__praxis_run_context__" not in result
133 |     assert "foo" in result
    |     ^^^^^^ S101
    |

tests/core/test_run_context.py:136:5: ANN201 Missing return type annotation for public function `test_serialize_arguments_typeerror_fallback`
    |
136 | def test_serialize_arguments_typeerror_fallback():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
137 |     """Test serialize_arguments fallback when TypeError is raised."""
138 |     class Unserializable:
    |
    = help: Add return type annotation: `None`

tests/core/test_run_context.py:146:9: ANN202 Missing return type annotation for private function `fake_json_dumps`
    |
144 |     orig_json_dumps = json.dumps
145 |     call_count = {"n": 0}
146 |     def fake_json_dumps(*a, **kw):
    |         ^^^^^^^^^^^^^^^ ANN202
147 |         if call_count["n"] == 0:
148 |             call_count["n"] += 1
    |
    = help: Add return type annotation

tests/core/test_run_context.py:146:25: ANN002 Missing type annotation for `*a`
    |
144 |     orig_json_dumps = json.dumps
145 |     call_count = {"n": 0}
146 |     def fake_json_dumps(*a, **kw):
    |                         ^^ ANN002
147 |         if call_count["n"] == 0:
148 |             call_count["n"] += 1
    |

tests/core/test_run_context.py:146:29: ANN003 Missing type annotation for `**kw`
    |
144 |     orig_json_dumps = json.dumps
145 |     call_count = {"n": 0}
146 |     def fake_json_dumps(*a, **kw):
    |                             ^^^^ ANN003
147 |         if call_count["n"] == 0:
148 |             call_count["n"] += 1
    |

tests/core/test_run_context.py:149:29: EM101 Exception must not use a string literal, assign to variable first
    |
147 |         if call_count["n"] == 0:
148 |             call_count["n"] += 1
149 |             raise TypeError("fail")
    |                             ^^^^^^ EM101
150 |         return orig_json_dumps(*a, **kw)
151 |     with patch("json.dumps", side_effect=fake_json_dumps):
    |
    = help: Assign to variable; remove string literal

tests/core/test_run_context.py:153:9: S101 Use of `assert` detected
    |
151 |     with patch("json.dumps", side_effect=fake_json_dumps):
152 |         result = serialize_arguments(args, kwargs)
153 |         assert "Unserializable object" in result or "Unserializable" in result
    |         ^^^^^^ S101
    |

tests/core/test_scheduler.py:1:1: INP001 File `tests/core/test_scheduler.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_scheduler.py:21:5: ANN201 Missing return type annotation for public function `mock_db_session`
   |
20 | @pytest.fixture
21 | def mock_db_session():
   |     ^^^^^^^^^^^^^^^ ANN201
22 |   """Fixture for a mock async database session."""
23 |   session = AsyncMock()
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:29:5: ANN201 Missing return type annotation for public function `db_session_factory`
   |
28 | @pytest.fixture
29 | def db_session_factory(mock_db_session):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
30 |   """Fixture for a mock async session factory."""
31 |   factory = MagicMock()
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:29:24: ANN001 Missing type annotation for function argument `mock_db_session`
   |
28 | @pytest.fixture
29 | def db_session_factory(mock_db_session):
   |                        ^^^^^^^^^^^^^^^ ANN001
30 |   """Fixture for a mock async session factory."""
31 |   factory = MagicMock()
   |

tests/core/test_scheduler.py:39:5: ANN201 Missing return type annotation for public function `mock_celery_app`
   |
38 | @pytest.fixture
39 | def mock_celery_app():
   |     ^^^^^^^^^^^^^^^ ANN201
40 |   """Fixture for a mock Celery app instance."""
41 |   return MagicMock(spec=Celery)
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:45:5: ANN201 Missing return type annotation for public function `scheduler`
   |
44 | @pytest.fixture
45 | def scheduler(db_session_factory, mock_celery_app):
   |     ^^^^^^^^^ ANN201
46 |   """Fixture for a ProtocolScheduler instance."""
47 |   with patch("praxis.backend.core.scheduler.get_logger"):
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:45:15: ANN001 Missing type annotation for function argument `db_session_factory`
   |
44 | @pytest.fixture
45 | def scheduler(db_session_factory, mock_celery_app):
   |               ^^^^^^^^^^^^^^^^^^ ANN001
46 |   """Fixture for a ProtocolScheduler instance."""
47 |   with patch("praxis.backend.core.scheduler.get_logger"):
   |

tests/core/test_scheduler.py:45:35: ANN001 Missing type annotation for function argument `mock_celery_app`
   |
44 | @pytest.fixture
45 | def scheduler(db_session_factory, mock_celery_app):
   |                                   ^^^^^^^^^^^^^^^ ANN001
46 |   """Fixture for a ProtocolScheduler instance."""
47 |   with patch("praxis.backend.core.scheduler.get_logger"):
   |

tests/core/test_scheduler.py:56:5: ANN201 Missing return type annotation for public function `protocol_def_orm`
   |
55 | @pytest.fixture
56 | def protocol_def_orm():
   |     ^^^^^^^^^^^^^^^^ ANN201
57 |   """Fixture for a mock FunctionProtocolDefinitionOrm."""
58 |   asset_def = MagicMock(spec=AssetDefinitionOrm)
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:77:5: ANN201 Missing return type annotation for public function `protocol_run_orm`
   |
76 | @pytest.fixture
77 | def protocol_run_orm(protocol_def_orm):
   |     ^^^^^^^^^^^^^^^^ ANN201
78 |   """Fixture for a mock ProtocolRunOrm."""
79 |   run = MagicMock(spec=ProtocolRunOrm)
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:77:22: ANN001 Missing type annotation for function argument `protocol_def_orm`
   |
76 | @pytest.fixture
77 | def protocol_run_orm(protocol_def_orm):
   |                      ^^^^^^^^^^^^^^^^ ANN001
78 |   """Fixture for a mock ProtocolRunOrm."""
79 |   run = MagicMock(spec=ProtocolRunOrm)
   |

tests/core/test_scheduler.py:87:5: ANN201 Missing return type annotation for public function `runtime_asset_requirement`
   |
86 | @pytest.fixture
87 | def runtime_asset_requirement():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |   """Fixture for a mock RuntimeAssetRequirement."""
89 |   req = MagicMock(spec=RuntimeAssetRequirement)
   |
   = help: Add return type annotation

tests/core/test_scheduler.py:95:5: ANN201 Missing return type annotation for public function `test_schedule_entry_init`
   |
95 | def test_schedule_entry_init(runtime_asset_requirement):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
96 |   """Test ScheduleEntry initialization."""
97 |   run_id = uuid.uuid4()
   |
   = help: Add return type annotation: `None`

tests/core/test_scheduler.py:95:30: ANN001 Missing type annotation for function argument `runtime_asset_requirement`
   |
95 | def test_schedule_entry_init(runtime_asset_requirement):
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
96 |   """Test ScheduleEntry initialization."""
97 |   run_id = uuid.uuid4()
   |

tests/core/test_scheduler.py:106:3: S101 Use of `assert` detected
    |
104 |     priority=5,
105 |   )
106 |   assert entry.protocol_run_id == run_id
    |   ^^^^^^ S101
107 |   assert entry.protocol_name == "test_proto"
108 |   assert entry.required_assets == assets
    |

tests/core/test_scheduler.py:107:3: S101 Use of `assert` detected
    |
105 |   )
106 |   assert entry.protocol_run_id == run_id
107 |   assert entry.protocol_name == "test_proto"
    |   ^^^^^^ S101
108 |   assert entry.required_assets == assets
109 |   assert entry.estimated_duration_ms == 1000
    |

tests/core/test_scheduler.py:108:3: S101 Use of `assert` detected
    |
106 |   assert entry.protocol_run_id == run_id
107 |   assert entry.protocol_name == "test_proto"
108 |   assert entry.required_assets == assets
    |   ^^^^^^ S101
109 |   assert entry.estimated_duration_ms == 1000
110 |   assert entry.priority == 5
    |

tests/core/test_scheduler.py:109:3: S101 Use of `assert` detected
    |
107 |   assert entry.protocol_name == "test_proto"
108 |   assert entry.required_assets == assets
109 |   assert entry.estimated_duration_ms == 1000
    |   ^^^^^^ S101
110 |   assert entry.priority == 5
111 |   assert entry.status == "QUEUED"
    |

tests/core/test_scheduler.py:109:41: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
107 |   assert entry.protocol_name == "test_proto"
108 |   assert entry.required_assets == assets
109 |   assert entry.estimated_duration_ms == 1000
    |                                         ^^^^ PLR2004
110 |   assert entry.priority == 5
111 |   assert entry.status == "QUEUED"
    |

tests/core/test_scheduler.py:110:3: S101 Use of `assert` detected
    |
108 |   assert entry.required_assets == assets
109 |   assert entry.estimated_duration_ms == 1000
110 |   assert entry.priority == 5
    |   ^^^^^^ S101
111 |   assert entry.status == "QUEUED"
112 |   assert isinstance(entry.scheduled_at, datetime)
    |

tests/core/test_scheduler.py:110:28: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
108 |   assert entry.required_assets == assets
109 |   assert entry.estimated_duration_ms == 1000
110 |   assert entry.priority == 5
    |                            ^ PLR2004
111 |   assert entry.status == "QUEUED"
112 |   assert isinstance(entry.scheduled_at, datetime)
    |

tests/core/test_scheduler.py:111:3: S101 Use of `assert` detected
    |
109 |   assert entry.estimated_duration_ms == 1000
110 |   assert entry.priority == 5
111 |   assert entry.status == "QUEUED"
    |   ^^^^^^ S101
112 |   assert isinstance(entry.scheduled_at, datetime)
113 |   assert entry.celery_task_id is None
    |

tests/core/test_scheduler.py:112:3: S101 Use of `assert` detected
    |
110 |   assert entry.priority == 5
111 |   assert entry.status == "QUEUED"
112 |   assert isinstance(entry.scheduled_at, datetime)
    |   ^^^^^^ S101
113 |   assert entry.celery_task_id is None
    |

tests/core/test_scheduler.py:113:3: S101 Use of `assert` detected
    |
111 |   assert entry.status == "QUEUED"
112 |   assert isinstance(entry.scheduled_at, datetime)
113 |   assert entry.celery_task_id is None
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:118:11: ANN201 Missing return type annotation for public function `test_analyze_protocol_requirements`
    |
116 | @pytest.mark.asyncio
117 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
118 | async def test_analyze_protocol_requirements(mock_uuid7, scheduler, protocol_def_orm):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
119 |   """Test asset requirement analysis."""
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:118:46: ANN001 Missing type annotation for function argument `mock_uuid7`
    |
116 | @pytest.mark.asyncio
117 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
118 | async def test_analyze_protocol_requirements(mock_uuid7, scheduler, protocol_def_orm):
    |                                              ^^^^^^^^^^ ANN001
119 |   """Test asset requirement analysis."""
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
    |

tests/core/test_scheduler.py:118:46: ARG001 Unused function argument: `mock_uuid7`
    |
116 | @pytest.mark.asyncio
117 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
118 | async def test_analyze_protocol_requirements(mock_uuid7, scheduler, protocol_def_orm):
    |                                              ^^^^^^^^^^ ARG001
119 |   """Test asset requirement analysis."""
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
    |

tests/core/test_scheduler.py:118:58: ANN001 Missing type annotation for function argument `scheduler`
    |
116 | @pytest.mark.asyncio
117 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
118 | async def test_analyze_protocol_requirements(mock_uuid7, scheduler, protocol_def_orm):
    |                                                          ^^^^^^^^^ ANN001
119 |   """Test asset requirement analysis."""
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
    |

tests/core/test_scheduler.py:118:69: ANN001 Missing type annotation for function argument `protocol_def_orm`
    |
116 | @pytest.mark.asyncio
117 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
118 | async def test_analyze_protocol_requirements(mock_uuid7, scheduler, protocol_def_orm):
    |                                                                     ^^^^^^^^^^^^^^^^ ANN001
119 |   """Test asset requirement analysis."""
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
    |

tests/core/test_scheduler.py:122:3: S101 Use of `assert` detected
    |
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
121 | 
122 |   assert len(requirements) == 2
    |   ^^^^^^ S101
123 |   asset_req = requirements[0]
124 |   assert asset_req.asset_name == "test_asset"
    |

tests/core/test_scheduler.py:122:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
120 |   requirements = await scheduler.analyze_protocol_requirements(protocol_def_orm, {})
121 | 
122 |   assert len(requirements) == 2
    |                               ^ PLR2004
123 |   asset_req = requirements[0]
124 |   assert asset_req.asset_name == "test_asset"
    |

tests/core/test_scheduler.py:124:3: S101 Use of `assert` detected
    |
122 |   assert len(requirements) == 2
123 |   asset_req = requirements[0]
124 |   assert asset_req.asset_name == "test_asset"
    |   ^^^^^^ S101
125 |   assert asset_req.asset_type == "asset"
    |

tests/core/test_scheduler.py:125:3: S101 Use of `assert` detected
    |
123 |   asset_req = requirements[0]
124 |   assert asset_req.asset_name == "test_asset"
125 |   assert asset_req.asset_type == "asset"
    |   ^^^^^^ S101
126 | 
127 |   deck_req = requirements[1]
    |

tests/core/test_scheduler.py:128:3: S101 Use of `assert` detected
    |
127 |   deck_req = requirements[1]
128 |   assert deck_req.asset_name == "deck"
    |   ^^^^^^ S101
129 |   assert deck_req.asset_type == "deck"
130 |   assert deck_req.asset_definition.fqn == "pylabrobot.resources.Deck"
    |

tests/core/test_scheduler.py:129:3: S101 Use of `assert` detected
    |
127 |   deck_req = requirements[1]
128 |   assert deck_req.asset_name == "deck"
129 |   assert deck_req.asset_type == "deck"
    |   ^^^^^^ S101
130 |   assert deck_req.asset_definition.fqn == "pylabrobot.resources.Deck"
    |

tests/core/test_scheduler.py:130:3: S101 Use of `assert` detected
    |
128 |   assert deck_req.asset_name == "deck"
129 |   assert deck_req.asset_type == "deck"
130 |   assert deck_req.asset_definition.fqn == "pylabrobot.resources.Deck"
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:135:11: ANN201 Missing return type annotation for public function `test_reserve_assets_success`
    |
133 | @pytest.mark.asyncio
134 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
135 | async def test_reserve_assets_success(mock_uuid7, scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
136 |   """Test successful asset reservation."""
137 |   run_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:135:39: ANN001 Missing type annotation for function argument `mock_uuid7`
    |
133 | @pytest.mark.asyncio
134 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
135 | async def test_reserve_assets_success(mock_uuid7, scheduler):
    |                                       ^^^^^^^^^^ ANN001
136 |   """Test successful asset reservation."""
137 |   run_id = uuid.uuid4()
    |

tests/core/test_scheduler.py:135:39: ARG001 Unused function argument: `mock_uuid7`
    |
133 | @pytest.mark.asyncio
134 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
135 | async def test_reserve_assets_success(mock_uuid7, scheduler):
    |                                       ^^^^^^^^^^ ARG001
136 |   """Test successful asset reservation."""
137 |   run_id = uuid.uuid4()
    |

tests/core/test_scheduler.py:135:51: ANN001 Missing type annotation for function argument `scheduler`
    |
133 | @pytest.mark.asyncio
134 | @patch("praxis.backend.core.scheduler.uuid7", return_value=uuid.uuid4())
135 | async def test_reserve_assets_success(mock_uuid7, scheduler):
    |                                                   ^^^^^^^^^ ANN001
136 |   """Test successful asset reservation."""
137 |   run_id = uuid.uuid4()
    |

tests/core/test_scheduler.py:145:3: S101 Use of `assert` detected
    |
143 |   success = await scheduler.reserve_assets(requirements, run_id)
144 | 
145 |   assert success is True
    |   ^^^^^^ S101
146 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id}
147 |   assert req.reservation_id is not None
    |

tests/core/test_scheduler.py:146:3: S101 Use of `assert` detected
    |
145 |   assert success is True
146 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id}
    |   ^^^^^^ S101
147 |   assert req.reservation_id is not None
    |

tests/core/test_scheduler.py:146:10: SLF001 Private member accessed: `_asset_reservations`
    |
145 |   assert success is True
146 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id}
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
147 |   assert req.reservation_id is not None
    |

tests/core/test_scheduler.py:147:3: S101 Use of `assert` detected
    |
145 |   assert success is True
146 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id}
147 |   assert req.reservation_id is not None
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:151:11: ANN201 Missing return type annotation for public function `test_reserve_assets_failure_and_rollback`
    |
150 | @pytest.mark.asyncio
151 | async def test_reserve_assets_failure_and_rollback(scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
152 |   """Test failed asset reservation and rollback."""
153 |   run_id_1 = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:151:52: ANN001 Missing type annotation for function argument `scheduler`
    |
150 | @pytest.mark.asyncio
151 | async def test_reserve_assets_failure_and_rollback(scheduler):
    |                                                    ^^^^^^^^^ ANN001
152 |   """Test failed asset reservation and rollback."""
153 |   run_id_1 = uuid.uuid4()
    |

tests/core/test_scheduler.py:161:3: SLF001 Private member accessed: `_asset_reservations`
    |
160 |   # Pre-reserve the asset
161 |   scheduler._asset_reservations["asset:test_asset"] = {run_id_1}
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
162 | 
163 |   success = await scheduler.reserve_assets(requirements, run_id_2)
    |

tests/core/test_scheduler.py:165:3: S101 Use of `assert` detected
    |
163 |   success = await scheduler.reserve_assets(requirements, run_id_2)
164 | 
165 |   assert success is False
    |   ^^^^^^ S101
166 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id_1}
    |

tests/core/test_scheduler.py:166:3: S101 Use of `assert` detected
    |
165 |   assert success is False
166 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id_1}
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:166:10: SLF001 Private member accessed: `_asset_reservations`
    |
165 |   assert success is False
166 |   assert scheduler._asset_reservations["asset:test_asset"] == {run_id_1}
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_scheduler.py:172:11: ANN201 Missing return type annotation for public function `test_schedule_protocol_execution_success`
    |
170 | @patch("praxis.backend.core.scheduler.execute_protocol_run_task")
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
174 | ):
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:173:3: ANN001 Missing type annotation for function argument `mock_svc`
    |
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
    |   ^^^^^^^^ ANN001
174 | ):
175 |   """Test successful scheduling of a protocol."""
    |

tests/core/test_scheduler.py:173:13: ANN001 Missing type annotation for function argument `mock_celery_task`
    |
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
    |             ^^^^^^^^^^^^^^^^ ANN001
174 | ):
175 |   """Test successful scheduling of a protocol."""
    |

tests/core/test_scheduler.py:173:31: ANN001 Missing type annotation for function argument `scheduler`
    |
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
    |                               ^^^^^^^^^ ANN001
174 | ):
175 |   """Test successful scheduling of a protocol."""
    |

tests/core/test_scheduler.py:173:42: ANN001 Missing type annotation for function argument `protocol_run_orm`
    |
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
    |                                          ^^^^^^^^^^^^^^^^ ANN001
174 | ):
175 |   """Test successful scheduling of a protocol."""
    |

tests/core/test_scheduler.py:173:60: ANN001 Missing type annotation for function argument `mock_db_session`
    |
171 | @patch("praxis.backend.core.scheduler.svc")
172 | async def test_schedule_protocol_execution_success(
173 |   mock_svc, mock_celery_task, scheduler, protocol_run_orm, mock_db_session,
    |                                                            ^^^^^^^^^^^^^^^ ANN001
174 | ):
175 |   """Test successful scheduling of a protocol."""
    |

tests/core/test_scheduler.py:182:3: S101 Use of `assert` detected
    |
180 |   success = await scheduler.schedule_protocol_execution(protocol_run_orm, {}, None)
181 | 
182 |   assert success is True
    |   ^^^^^^ S101
183 |   mock_svc.update_protocol_run_status.assert_called_with(
184 |     mock_db_session,
    |

tests/core/test_scheduler.py:191:3: S101 Use of `assert` detected
    |
189 |   mock_db_session.commit.assert_called_once()
190 |   mock_celery_task.delay.assert_called_once()
191 |   assert protocol_run_orm.accession_id in scheduler._active_schedules
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:191:43: SLF001 Private member accessed: `_active_schedules`
    |
189 |   mock_db_session.commit.assert_called_once()
190 |   mock_celery_task.delay.assert_called_once()
191 |   assert protocol_run_orm.accession_id in scheduler._active_schedules
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_scheduler.py:196:11: ANN201 Missing return type annotation for public function `test_schedule_protocol_asset_failure`
    |
194 | @pytest.mark.asyncio
195 | @patch("praxis.backend.core.scheduler.svc")
196 | async def test_schedule_protocol_asset_failure(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
197 |   mock_svc, scheduler, protocol_run_orm, mock_db_session,
198 | ):
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:197:3: ANN001 Missing type annotation for function argument `mock_svc`
    |
195 | @patch("praxis.backend.core.scheduler.svc")
196 | async def test_schedule_protocol_asset_failure(
197 |   mock_svc, scheduler, protocol_run_orm, mock_db_session,
    |   ^^^^^^^^ ANN001
198 | ):
199 |   """Test scheduling failure due to asset reservation."""
    |

tests/core/test_scheduler.py:197:13: ANN001 Missing type annotation for function argument `scheduler`
    |
195 | @patch("praxis.backend.core.scheduler.svc")
196 | async def test_schedule_protocol_asset_failure(
197 |   mock_svc, scheduler, protocol_run_orm, mock_db_session,
    |             ^^^^^^^^^ ANN001
198 | ):
199 |   """Test scheduling failure due to asset reservation."""
    |

tests/core/test_scheduler.py:197:24: ANN001 Missing type annotation for function argument `protocol_run_orm`
    |
195 | @patch("praxis.backend.core.scheduler.svc")
196 | async def test_schedule_protocol_asset_failure(
197 |   mock_svc, scheduler, protocol_run_orm, mock_db_session,
    |                        ^^^^^^^^^^^^^^^^ ANN001
198 | ):
199 |   """Test scheduling failure due to asset reservation."""
    |

tests/core/test_scheduler.py:197:42: ANN001 Missing type annotation for function argument `mock_db_session`
    |
195 | @patch("praxis.backend.core.scheduler.svc")
196 | async def test_schedule_protocol_asset_failure(
197 |   mock_svc, scheduler, protocol_run_orm, mock_db_session,
    |                                          ^^^^^^^^^^^^^^^ ANN001
198 | ):
199 |   """Test scheduling failure due to asset reservation."""
    |

tests/core/test_scheduler.py:205:3: S101 Use of `assert` detected
    |
203 |   success = await scheduler.schedule_protocol_execution(protocol_run_orm, {}, None)
204 | 
205 |   assert success is False
    |   ^^^^^^ S101
206 |   mock_svc.update_protocol_run_status.assert_called_with(
207 |     mock_db_session,
    |

tests/core/test_scheduler.py:212:3: S101 Use of `assert` detected
    |
210 |     output_data_json=ANY,
211 |   )
212 |   assert protocol_run_orm.accession_id not in scheduler._active_schedules
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:212:47: SLF001 Private member accessed: `_active_schedules`
    |
210 |     output_data_json=ANY,
211 |   )
212 |   assert protocol_run_orm.accession_id not in scheduler._active_schedules
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_scheduler.py:216:11: ANN201 Missing return type annotation for public function `test_cancel_scheduled_run`
    |
215 | @pytest.mark.asyncio
216 | async def test_cancel_scheduled_run(scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
217 |   """Test cancelling a scheduled run."""
218 |   run_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:216:37: ANN001 Missing type annotation for function argument `scheduler`
    |
215 | @pytest.mark.asyncio
216 | async def test_cancel_scheduled_run(scheduler):
    |                                     ^^^^^^^^^ ANN001
217 |   """Test cancelling a scheduled run."""
218 |   run_id = uuid.uuid4()
    |

tests/core/test_scheduler.py:225:3: SLF001 Private member accessed: `_active_schedules`
    |
223 |     protocol_run_id=run_id, protocol_name="test", required_assets=[req],
224 |   )
225 |   scheduler._active_schedules[run_id] = entry
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
226 |   scheduler._asset_reservations["asset:cancellable_asset"] = {run_id}
    |

tests/core/test_scheduler.py:226:3: SLF001 Private member accessed: `_asset_reservations`
    |
224 |   )
225 |   scheduler._active_schedules[run_id] = entry
226 |   scheduler._asset_reservations["asset:cancellable_asset"] = {run_id}
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
227 | 
228 |   success = await scheduler.cancel_scheduled_run(run_id)
    |

tests/core/test_scheduler.py:230:3: S101 Use of `assert` detected
    |
228 |   success = await scheduler.cancel_scheduled_run(run_id)
229 | 
230 |   assert success is True
    |   ^^^^^^ S101
231 |   assert run_id not in scheduler._active_schedules
232 |   assert "asset:cancellable_asset" not in scheduler._asset_reservations
    |

tests/core/test_scheduler.py:231:3: S101 Use of `assert` detected
    |
230 |   assert success is True
231 |   assert run_id not in scheduler._active_schedules
    |   ^^^^^^ S101
232 |   assert "asset:cancellable_asset" not in scheduler._asset_reservations
    |

tests/core/test_scheduler.py:231:24: SLF001 Private member accessed: `_active_schedules`
    |
230 |   assert success is True
231 |   assert run_id not in scheduler._active_schedules
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
232 |   assert "asset:cancellable_asset" not in scheduler._asset_reservations
    |

tests/core/test_scheduler.py:232:3: S101 Use of `assert` detected
    |
230 |   assert success is True
231 |   assert run_id not in scheduler._active_schedules
232 |   assert "asset:cancellable_asset" not in scheduler._asset_reservations
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:232:43: SLF001 Private member accessed: `_asset_reservations`
    |
230 |   assert success is True
231 |   assert run_id not in scheduler._active_schedules
232 |   assert "asset:cancellable_asset" not in scheduler._asset_reservations
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/core/test_scheduler.py:236:11: ANN201 Missing return type annotation for public function `test_get_schedule_status`
    |
235 | @pytest.mark.asyncio
236 | async def test_get_schedule_status(scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
237 |   """Test getting schedule status."""
238 |   run_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:236:36: ANN001 Missing type annotation for function argument `scheduler`
    |
235 | @pytest.mark.asyncio
236 | async def test_get_schedule_status(scheduler):
    |                                    ^^^^^^^^^ ANN001
237 |   """Test getting schedule status."""
238 |   run_id = uuid.uuid4()
    |

tests/core/test_scheduler.py:242:3: SLF001 Private member accessed: `_active_schedules`
    |
240 |     protocol_run_id=run_id, protocol_name="test", required_assets=[],
241 |   )
242 |   scheduler._active_schedules[run_id] = entry
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
243 | 
244 |   status = await scheduler.get_schedule_status(run_id)
    |

tests/core/test_scheduler.py:245:3: S101 Use of `assert` detected
    |
244 |   status = await scheduler.get_schedule_status(run_id)
245 |   assert status is not None
    |   ^^^^^^ S101
246 |   assert status["protocol_run_id"] == str(run_id)
    |

tests/core/test_scheduler.py:246:3: S101 Use of `assert` detected
    |
244 |   status = await scheduler.get_schedule_status(run_id)
245 |   assert status is not None
246 |   assert status["protocol_run_id"] == str(run_id)
    |   ^^^^^^ S101
247 | 
248 |   non_existent_status = await scheduler.get_schedule_status(uuid.uuid4())
    |

tests/core/test_scheduler.py:249:3: S101 Use of `assert` detected
    |
248 |   non_existent_status = await scheduler.get_schedule_status(uuid.uuid4())
249 |   assert non_existent_status is None
    |   ^^^^^^ S101
    |

tests/core/test_scheduler.py:253:11: ANN201 Missing return type annotation for public function `test_list_active_schedules`
    |
252 | @pytest.mark.asyncio
253 | async def test_list_active_schedules(scheduler):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
254 |   """Test listing active schedules."""
255 |   run_id1 = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/core/test_scheduler.py:253:38: ANN001 Missing type annotation for function argument `scheduler`
    |
252 | @pytest.mark.asyncio
253 | async def test_list_active_schedules(scheduler):
    |                                      ^^^^^^^^^ ANN001
254 |   """Test listing active schedules."""
255 |   run_id1 = uuid.uuid4()
    |

tests/core/test_scheduler.py:257:3: SLF001 Private member accessed: `_active_schedules`
    |
255 |   run_id1 = uuid.uuid4()
256 |   run_id2 = uuid.uuid4()
257 |   scheduler._active_schedules[run_id1] = ScheduleEntry(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
258 |     protocol_run_id=run_id1, protocol_name="p1", required_assets=[],
259 |   )
    |

tests/core/test_scheduler.py:260:3: SLF001 Private member accessed: `_active_schedules`
    |
258 |     protocol_run_id=run_id1, protocol_name="p1", required_assets=[],
259 |   )
260 |   scheduler._active_schedules[run_id2] = ScheduleEntry(
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
261 |     protocol_run_id=run_id2, protocol_name="p2", required_assets=[],
262 |   )
    |

tests/core/test_scheduler.py:265:3: S101 Use of `assert` detected
    |
264 |   schedules = await scheduler.list_active_schedules()
265 |   assert len(schedules) == 2
    |   ^^^^^^ S101
266 |   run_ids = {uuid.UUID(s["protocol_run_id"]) for s in schedules}
267 |   assert {run_id1, run_id2} == run_ids
    |

tests/core/test_scheduler.py:265:28: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
264 |   schedules = await scheduler.list_active_schedules()
265 |   assert len(schedules) == 2
    |                            ^ PLR2004
266 |   run_ids = {uuid.UUID(s["protocol_run_id"]) for s in schedules}
267 |   assert {run_id1, run_id2} == run_ids
    |

tests/core/test_scheduler.py:267:3: S101 Use of `assert` detected
    |
265 |   assert len(schedules) == 2
266 |   run_ids = {uuid.UUID(s["protocol_run_id"]) for s in schedules}
267 |   assert {run_id1, run_id2} == run_ids
    |   ^^^^^^ S101
    |

tests/core/test_workcell.py:1:1: INP001 File `tests/core/test_workcell.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_workcell.py:18:7: ANN204 Missing return type annotation for special method `__init__`
   |
16 |   """A mock backend for testing."""
17 | 
18 |   def __init__(self):
   |       ^^^^^^^^ ANN204
19 |     """Initialize the mock backend."""
20 |     super().__init__()
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:22:13: ANN201 Missing return type annotation for public function `setup`
   |
20 |     super().__init__()
21 | 
22 |   async def setup(self):
   |             ^^^^^ ANN201
23 |     """Set up the mock backend (no-op)."""
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:25:13: ANN201 Missing return type annotation for public function `stop`
   |
23 |     """Set up the mock backend (no-op)."""
24 | 
25 |   async def stop(self):
   |             ^^^^ ANN201
26 |     """Stop the mock backend (no-op)."""
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:38:7: ANN204 Missing return type annotation for special method `__init__`
   |
36 |   """A mock machine that is not a resource."""
37 | 
38 |   def __init__(self, backend: MockBackend):
   |       ^^^^^^^^ ANN204
39 |     """Initialize the mock pure machine with a backend."""
40 |     super().__init__(backend=backend)
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:46:7: ANN204 Missing return type annotation for special method `__init__`
   |
44 |   """A mock resource that is not a machine."""
45 | 
46 |   def __init__(self, name: str, category: str = "plates", **kwargs):
   |       ^^^^^^^^ ANN204
47 |     """Initialize the mock pure resource with a name and category."""
48 |     super().__init__(
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:46:59: ANN003 Missing type annotation for `**kwargs`
   |
44 |   """A mock resource that is not a machine."""
45 | 
46 |   def __init__(self, name: str, category: str = "plates", **kwargs):
   |                                                           ^^^^^^^^ ANN003
47 |     """Initialize the mock pure resource with a name and category."""
48 |     super().__init__(
   |

tests/core/test_workcell.py:56:7: ANN204 Missing return type annotation for special method `__init__`
   |
54 |   """A mock asset that is both a machine and a resource."""
55 | 
56 |   def __init__(
   |       ^^^^^^^^ ANN204
57 |     self, name: str, backend: MockBackend, category: str = "robot_arms", **kwargs,
58 |   ):
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:57:74: ANN003 Missing type annotation for `**kwargs`
   |
56 |   def __init__(
57 |     self, name: str, backend: MockBackend, category: str = "robot_arms", **kwargs,
   |                                                                          ^^^^^^^^ ANN003
58 |   ):
59 |     """Initialize the mock machine resource with a name, backend, and category."""
   |

tests/core/test_workcell.py:70:7: ANN201 Missing return type annotation for public function `load_state`
   |
68 |     return {"name": self.name, "state": self.state}
69 | 
70 |   def load_state(self, state: dict):
   |       ^^^^^^^^^^ ANN201
71 |     """Load the state into the mock machine resource."""
72 |     self.state = state.get("state", "loaded_default")
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:78:47: S108 Probable insecure usage of temporary file or directory: "/tmp/test_cell.json"
   |
76 | def workcell() -> Workcell:
77 |   """Fixture for a Workcell instance with a temporary save file."""
78 |   return Workcell(name="test_cell", save_file="/tmp/test_cell.json")
   |                                               ^^^^^^^^^^^^^^^^^^^^^ S108
   |

tests/core/test_workcell.py:84:7: ANN201 Missing return type annotation for public function `test_add_pure_machine_asset`
   |
82 |   """Tests for the Workcell container class."""
83 | 
84 |   def test_add_pure_machine_asset(self, workcell: Workcell, mock_backend: MockBackend):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
85 |     """Test adding a machine that is NOT a resource."""
86 |     machine = MockPureMachine(backend=mock_backend)
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:90:5: S101 Use of `assert` detected
   |
88 |     # Pure machine has no '.name', so it's identified by its hash in the workcell
89 |     asset_key = str(machine.__hash__())
90 |     assert machine in workcell.children
   |     ^^^^^^ S101
91 |     assert asset_key in workcell
92 |     assert workcell[asset_key] == machine
   |

tests/core/test_workcell.py:91:5: S101 Use of `assert` detected
   |
89 |     asset_key = str(machine.__hash__())
90 |     assert machine in workcell.children
91 |     assert asset_key in workcell
   |     ^^^^^^ S101
92 |     assert workcell[asset_key] == machine
   |

tests/core/test_workcell.py:92:5: S101 Use of `assert` detected
   |
90 |     assert machine in workcell.children
91 |     assert asset_key in workcell
92 |     assert workcell[asset_key] == machine
   |     ^^^^^^ S101
93 | 
94 |   def test_add_pure_resource_asset(self, workcell: Workcell):
   |

tests/core/test_workcell.py:94:7: ANN201 Missing return type annotation for public function `test_add_pure_resource_asset`
   |
92 |     assert workcell[asset_key] == machine
93 | 
94 |   def test_add_pure_resource_asset(self, workcell: Workcell):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
95 |     """Test adding a resource-only asset to the workcell."""
96 |     resource = MockPureResource(
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell.py:100:5: S101 Use of `assert` detected
    |
 98 |     )
 99 |     workcell.add_asset(resource)
100 |     assert resource in workcell.children
    |     ^^^^^^ S101
101 |     assert "test_plate" in workcell.plates  # type: ignore
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
    |

tests/core/test_workcell.py:101:5: S101 Use of `assert` detected
    |
 99 |     workcell.add_asset(resource)
100 |     assert resource in workcell.children
101 |     assert "test_plate" in workcell.plates  # type: ignore
    |     ^^^^^^ S101
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
    |

tests/core/test_workcell.py:101:45: PGH003 Use specific rule codes when ignoring type issues
    |
 99 |     workcell.add_asset(resource)
100 |     assert resource in workcell.children
101 |     assert "test_plate" in workcell.plates  # type: ignore
    |                                             ^^^^^^^^^^^^^^ PGH003
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
    |

tests/core/test_workcell.py:102:5: S101 Use of `assert` detected
    |
100 |     assert resource in workcell.children
101 |     assert "test_plate" in workcell.plates  # type: ignore
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
    |     ^^^^^^ S101
103 | 
104 |   def test_add_machine_resource_asset(
    |

tests/core/test_workcell.py:102:55: PGH003 Use specific rule codes when ignoring type issues
    |
100 |     assert resource in workcell.children
101 |     assert "test_plate" in workcell.plates  # type: ignore
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
    |                                                       ^^^^^^^^^^^^^^ PGH003
103 | 
104 |   def test_add_machine_resource_asset(
    |

tests/core/test_workcell.py:104:7: ANN201 Missing return type annotation for public function `test_add_machine_resource_asset`
    |
102 |     assert workcell.plates["test_plate"] == resource  # type: ignore
103 | 
104 |   def test_add_machine_resource_asset(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
105 |     self, workcell: Workcell, mock_backend: MockBackend,
106 |   ):
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell.py:112:5: S101 Use of `assert` detected
    |
110 |     )
111 |     workcell.add_asset(machine_resource)
112 |     assert machine_resource in workcell.children
    |     ^^^^^^ S101
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
    |

tests/core/test_workcell.py:113:5: S101 Use of `assert` detected
    |
111 |     workcell.add_asset(machine_resource)
112 |     assert machine_resource in workcell.children
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
    |     ^^^^^^ S101
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
115 |     assert "robot_arm" in workcell.all_machines
    |

tests/core/test_workcell.py:113:48: PGH003 Use specific rule codes when ignoring type issues
    |
111 |     workcell.add_asset(machine_resource)
112 |     assert machine_resource in workcell.children
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
    |                                                ^^^^^^^^^^^^^^ PGH003
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
115 |     assert "robot_arm" in workcell.all_machines
    |

tests/core/test_workcell.py:114:5: S101 Use of `assert` detected
    |
112 |     assert machine_resource in workcell.children
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
    |     ^^^^^^ S101
115 |     assert "robot_arm" in workcell.all_machines
    |

tests/core/test_workcell.py:114:66: PGH003 Use specific rule codes when ignoring type issues
    |
112 |     assert machine_resource in workcell.children
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
    |                                                                  ^^^^^^^^^^^^^^ PGH003
115 |     assert "robot_arm" in workcell.all_machines
    |

tests/core/test_workcell.py:115:5: S101 Use of `assert` detected
    |
113 |     assert "robot_arm" in workcell.robot_arms  # type: ignore
114 |     assert workcell.robot_arms["robot_arm"] == machine_resource  # type: ignore
115 |     assert "robot_arm" in workcell.all_machines
    |     ^^^^^^ S101
    |

tests/core/test_workcell_runtime.py:1:1: INP001 File `tests/core/test_workcell_runtime.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/core/test_workcell_runtime.py:29:5: ANN201 Missing return type annotation for public function `mock_db_session_factory`
   |
28 | @pytest.fixture
29 | def mock_db_session_factory():
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |   """Fixture for a mock SQLAlchemy async session factory."""
31 |   mock_session = AsyncMock()
   |
   = help: Add return type annotation

tests/core/test_workcell_runtime.py:39:5: ANN201 Missing return type annotation for public function `mock_main_workcell`
   |
38 | @pytest.fixture
39 | def mock_main_workcell():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
40 |   """Fixture for a mock core Workcell object."""
41 |   return MagicMock(spec=Workcell)
   |
   = help: Add return type annotation

tests/core/test_workcell_runtime.py:46:22: ANN001 Missing type annotation for function argument `mock_workcell_cls`
   |
44 | @pytest.fixture
45 | @patch("praxis.backend.core.workcell_runtime.Workcell")
46 | def workcell_runtime(mock_workcell_cls, mock_db_session_factory) -> WorkcellRuntime:
   |                      ^^^^^^^^^^^^^^^^^ ANN001
47 |   """Fixture for a WorkcellRuntime instance with mocked dependencies."""
48 |   mock_workcell_instance = mock_workcell_cls.return_value
   |

tests/core/test_workcell_runtime.py:46:41: ANN001 Missing type annotation for function argument `mock_db_session_factory`
   |
44 | @pytest.fixture
45 | @patch("praxis.backend.core.workcell_runtime.Workcell")
46 | def workcell_runtime(mock_workcell_cls, mock_db_session_factory) -> WorkcellRuntime:
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
47 |   """Fixture for a WorkcellRuntime instance with mocked dependencies."""
48 |   mock_workcell_instance = mock_workcell_cls.return_value
   |

tests/core/test_workcell_runtime.py:52:24: S108 Probable insecure usage of temporary file or directory: "/tmp/test_runtime.json"
   |
50 |     db_session_factory=mock_db_session_factory,
51 |     workcell_name="test_runtime",
52 |     workcell_save_file="/tmp/test_runtime.json",
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ S108
53 |   )
54 |   runtime._main_workcell = mock_workcell_instance
   |

tests/core/test_workcell_runtime.py:54:3: SLF001 Private member accessed: `_main_workcell`
   |
52 |     workcell_save_file="/tmp/test_runtime.json",
53 |   )
54 |   runtime._main_workcell = mock_workcell_instance
   |   ^^^^^^^^^^^^^^^^^^^^^^ SLF001
55 |   return runtime
   |

tests/core/test_workcell_runtime.py:61:5: ANN201 Missing return type annotation for public function `test_get_class_from_fqn_success`
   |
61 | def test_get_class_from_fqn_success():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
62 |   """Test that _get_class_from_fqn successfully imports and returns a class."""
63 |   cls = _get_class_from_fqn("unittest.mock.MagicMock")
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:64:3: S101 Use of `assert` detected
   |
62 |   """Test that _get_class_from_fqn successfully imports and returns a class."""
63 |   cls = _get_class_from_fqn("unittest.mock.MagicMock")
64 |   assert cls is MagicMock
   |   ^^^^^^ S101
   |

tests/core/test_workcell_runtime.py:67:5: ANN201 Missing return type annotation for public function `test_get_class_from_fqn_failure`
   |
67 | def test_get_class_from_fqn_failure():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |   """Test that _get_class_from_fqn raises ValueError for an invalid FQN."""
69 |   with pytest.raises(ValueError):
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:69:22: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   |
67 | def test_get_class_from_fqn_failure():
68 |   """Test that _get_class_from_fqn raises ValueError for an invalid FQN."""
69 |   with pytest.raises(ValueError):
   |                      ^^^^^^^^^^ PT011
70 |     _get_class_from_fqn("invalid_fqn")
71 |   with pytest.raises(ImportError):
   |

tests/core/test_workcell_runtime.py:86:13: ANN201 Missing return type annotation for public function `test_link_workcell_to_db_creates_new`
   |
84 |   @patch("praxis.backend.services.create_workcell")
85 |   @patch("praxis.backend.services.read_workcell_state", new_callable=AsyncMock)
86 |   async def test_link_workcell_to_db_creates_new(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
87 |     self,
88 |     mock_read_state,
   |
   = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:88:5: ANN001 Missing type annotation for function argument `mock_read_state`
   |
86 |   async def test_link_workcell_to_db_creates_new(
87 |     self,
88 |     mock_read_state,
   |     ^^^^^^^^^^^^^^^ ANN001
89 |     mock_create_workcell,
90 |     workcell_runtime,
   |

tests/core/test_workcell_runtime.py:89:5: ANN001 Missing type annotation for function argument `mock_create_workcell`
   |
87 |     self,
88 |     mock_read_state,
89 |     mock_create_workcell,
   |     ^^^^^^^^^^^^^^^^^^^^ ANN001
90 |     workcell_runtime,
91 |   ):
   |

tests/core/test_workcell_runtime.py:90:5: ANN001 Missing type annotation for function argument `workcell_runtime`
   |
88 |     mock_read_state,
89 |     mock_create_workcell,
90 |     workcell_runtime,
   |     ^^^^^^^^^^^^^^^^ ANN001
91 |   ):
92 |     """Test that a new workcell is created in the DB if one doesn't exist."""
   |

tests/core/test_workcell_runtime.py:97:11: SLF001 Private member accessed: `_link_workcell_to_db`
   |
95 |     mock_create_workcell.return_value = mock_created_orm
96 | 
97 |     await workcell_runtime._link_workcell_to_db()
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
98 | 
99 |     mock_create_workcell.assert_awaited_once()
   |

tests/core/test_workcell_runtime.py:100:5: S101 Use of `assert` detected
    |
 99 |     mock_create_workcell.assert_awaited_once()
100 |     assert workcell_runtime._workcell_db_accession_id == mock_created_orm.accession_id
    |     ^^^^^^ S101
101 |     workcell_runtime._main_workcell.load_all_state.assert_not_called()
    |

tests/core/test_workcell_runtime.py:100:12: SLF001 Private member accessed: `_workcell_db_accession_id`
    |
 99 |     mock_create_workcell.assert_awaited_once()
100 |     assert workcell_runtime._workcell_db_accession_id == mock_created_orm.accession_id
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
101 |     workcell_runtime._main_workcell.load_all_state.assert_not_called()
    |

tests/core/test_workcell_runtime.py:101:5: SLF001 Private member accessed: `_main_workcell`
    |
 99 |     mock_create_workcell.assert_awaited_once()
100 |     assert workcell_runtime._workcell_db_accession_id == mock_created_orm.accession_id
101 |     workcell_runtime._main_workcell.load_all_state.assert_not_called()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
102 | 
103 |   @patch("praxis.backend.services.create_workcell")
    |

tests/core/test_workcell_runtime.py:105:13: ANN201 Missing return type annotation for public function `test_link_workcell_to_db_loads_existing`
    |
103 |   @patch("praxis.backend.services.create_workcell")
104 |   @patch("praxis.backend.services.read_workcell_state", new_callable=AsyncMock)
105 |   async def test_link_workcell_to_db_loads_existing(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
106 |     self,
107 |     mock_read_state,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:107:5: ANN001 Missing type annotation for function argument `mock_read_state`
    |
105 |   async def test_link_workcell_to_db_loads_existing(
106 |     self,
107 |     mock_read_state,
    |     ^^^^^^^^^^^^^^^ ANN001
108 |     mock_create_workcell,
109 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:108:5: ANN001 Missing type annotation for function argument `mock_create_workcell`
    |
106 |     self,
107 |     mock_read_state,
108 |     mock_create_workcell,
    |     ^^^^^^^^^^^^^^^^^^^^ ANN001
109 |     workcell_runtime,
110 |   ):
    |

tests/core/test_workcell_runtime.py:109:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
107 |     mock_read_state,
108 |     mock_create_workcell,
109 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
110 |   ):
111 |     """Test that existing state is loaded from the DB."""
    |

tests/core/test_workcell_runtime.py:117:11: SLF001 Private member accessed: `_link_workcell_to_db`
    |
115 |     mock_create_workcell.return_value = mock_created_orm
116 | 
117 |     await workcell_runtime._link_workcell_to_db()
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
118 | 
119 |     mock_create_workcell.assert_awaited_once()  # Still links
    |

tests/core/test_workcell_runtime.py:120:5: SLF001 Private member accessed: `_main_workcell`
    |
119 |     mock_create_workcell.assert_awaited_once()  # Still links
120 |     workcell_runtime._main_workcell.load_all_state.assert_called_once_with(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
121 |       existing_state,
122 |     )
    |

tests/core/test_workcell_runtime.py:125:13: ANN201 Missing return type annotation for public function `test_start_and_stop_state_sync`
    |
124 |   @patch("asyncio.create_task")
125 |   async def test_start_and_stop_state_sync(self, mock_create_task, workcell_runtime):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
126 |     """Test the starting and stopping of the state sync task."""
127 |     workcell_runtime._link_workcell_to_db = AsyncMock()
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:125:50: ANN001 Missing type annotation for function argument `mock_create_task`
    |
124 |   @patch("asyncio.create_task")
125 |   async def test_start_and_stop_state_sync(self, mock_create_task, workcell_runtime):
    |                                                  ^^^^^^^^^^^^^^^^ ANN001
126 |     """Test the starting and stopping of the state sync task."""
127 |     workcell_runtime._link_workcell_to_db = AsyncMock()
    |

tests/core/test_workcell_runtime.py:125:68: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
124 |   @patch("asyncio.create_task")
125 |   async def test_start_and_stop_state_sync(self, mock_create_task, workcell_runtime):
    |                                                                    ^^^^^^^^^^^^^^^^ ANN001
126 |     """Test the starting and stopping of the state sync task."""
127 |     workcell_runtime._link_workcell_to_db = AsyncMock()
    |

tests/core/test_workcell_runtime.py:127:5: SLF001 Private member accessed: `_link_workcell_to_db`
    |
125 |   async def test_start_and_stop_state_sync(self, mock_create_task, workcell_runtime):
126 |     """Test the starting and stopping of the state sync task."""
127 |     workcell_runtime._link_workcell_to_db = AsyncMock()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
128 |     mock_task = MagicMock()
129 |     mock_task.done.return_value = False
    |

tests/core/test_workcell_runtime.py:133:5: SLF001 Private member accessed: `_link_workcell_to_db`
    |
132 |     await workcell_runtime.start_workcell_state_sync()
133 |     workcell_runtime._link_workcell_to_db.assert_awaited_once()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
134 |     mock_create_task.assert_called_once()
135 |     assert workcell_runtime._state_sync_task is mock_task
    |

tests/core/test_workcell_runtime.py:135:5: S101 Use of `assert` detected
    |
133 |     workcell_runtime._link_workcell_to_db.assert_awaited_once()
134 |     mock_create_task.assert_called_once()
135 |     assert workcell_runtime._state_sync_task is mock_task
    |     ^^^^^^ S101
136 | 
137 |     await workcell_runtime.stop_workcell_state_sync()
    |

tests/core/test_workcell_runtime.py:135:12: SLF001 Private member accessed: `_state_sync_task`
    |
133 |     workcell_runtime._link_workcell_to_db.assert_awaited_once()
134 |     mock_create_task.assert_called_once()
135 |     assert workcell_runtime._state_sync_task is mock_task
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
136 | 
137 |     await workcell_runtime.stop_workcell_state_sync()
    |

tests/core/test_workcell_runtime.py:147:13: ANN201 Missing return type annotation for public function `test_initialize_machine_resource_success`
    |
146 |   @patch("praxis.backend.services.update_machine_status")
147 |   async def test_initialize_machine_resource_success(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
148 |     self,
149 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:149:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
147 |   async def test_initialize_machine_resource_success(
148 |     self,
149 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
150 |     mock_get_fqn,
151 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:150:5: ANN001 Missing type annotation for function argument `mock_get_fqn`
    |
148 |     self,
149 |     mock_update_status,
150 |     mock_get_fqn,
    |     ^^^^^^^^^^^^ ANN001
151 |     workcell_runtime,
152 |     mock_main_workcell,
    |

tests/core/test_workcell_runtime.py:151:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
149 |     mock_update_status,
150 |     mock_get_fqn,
151 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
152 |     mock_main_workcell,
153 |   ):
    |

tests/core/test_workcell_runtime.py:152:5: ANN001 Missing type annotation for function argument `mock_main_workcell`
    |
150 |     mock_get_fqn,
151 |     workcell_runtime,
152 |     mock_main_workcell,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
153 |   ):
154 |     """Test the successful initialization of a machine that is also a resource."""
    |

tests/core/test_workcell_runtime.py:169:5: S101 Use of `assert` detected
    |
167 |     initialized_machine = await workcell_runtime.initialize_machine(mock_machine_orm)
168 | 
169 |     assert isinstance(initialized_machine, MockMachineResource)
    |     ^^^^^^ S101
170 |     mock_get_fqn.assert_called_with("my_module.MockMachineResource")
171 |     # initialize_machine calls setup(), which is mocked in MockPlrMachine
    |

tests/core/test_workcell_runtime.py:172:5: S101 Use of `assert` detected
    |
170 |     mock_get_fqn.assert_called_with("my_module.MockMachineResource")
171 |     # initialize_machine calls setup(), which is mocked in MockPlrMachine
172 |     assert hasattr(initialized_machine, "setup")
    |     ^^^^^^ S101
173 |     assert workcell_runtime._active_machines[machine_id] is initialized_machine
174 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_machine)
    |

tests/core/test_workcell_runtime.py:173:5: S101 Use of `assert` detected
    |
171 |     # initialize_machine calls setup(), which is mocked in MockPlrMachine
172 |     assert hasattr(initialized_machine, "setup")
173 |     assert workcell_runtime._active_machines[machine_id] is initialized_machine
    |     ^^^^^^ S101
174 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_machine)
175 |     mock_update_status.assert_awaited_with(
    |

tests/core/test_workcell_runtime.py:173:12: SLF001 Private member accessed: `_active_machines`
    |
171 |     # initialize_machine calls setup(), which is mocked in MockPlrMachine
172 |     assert hasattr(initialized_machine, "setup")
173 |     assert workcell_runtime._active_machines[machine_id] is initialized_machine
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
174 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_machine)
175 |     mock_update_status.assert_awaited_with(
    |

tests/core/test_workcell_runtime.py:183:13: ANN201 Missing return type annotation for public function `test_initialize_machine_fails_on_setup`
    |
182 |   @patch("praxis.backend.services.update_machine_status")
183 |   async def test_initialize_machine_fails_on_setup(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
184 |     self,
185 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:185:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
183 |   async def test_initialize_machine_fails_on_setup(
184 |     self,
185 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
186 |     mock_get_fqn,
187 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:186:5: ANN001 Missing type annotation for function argument `mock_get_fqn`
    |
184 |     self,
185 |     mock_update_status,
186 |     mock_get_fqn,
    |     ^^^^^^^^^^^^ ANN001
187 |     workcell_runtime,
188 |   ):
    |

tests/core/test_workcell_runtime.py:187:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
185 |     mock_update_status,
186 |     mock_get_fqn,
187 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
188 |   ):
189 |     """Test that initialization fails if the machine's setup method fails."""
    |

tests/core/test_workcell_runtime.py:215:13: ANN201 Missing return type annotation for public function `test_create_or_get_resource_success`
    |
214 |   @patch("praxis.backend.services.update_resource_instance_location_and_status")
215 |   async def test_create_or_get_resource_success(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
216 |     self,
217 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:217:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
215 |   async def test_create_or_get_resource_success(
216 |     self,
217 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
218 |     mock_get_fqn,
219 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:218:5: ANN001 Missing type annotation for function argument `mock_get_fqn`
    |
216 |     self,
217 |     mock_update_status,
218 |     mock_get_fqn,
    |     ^^^^^^^^^^^^ ANN001
219 |     workcell_runtime,
220 |     mock_main_workcell,
    |

tests/core/test_workcell_runtime.py:219:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
217 |     mock_update_status,
218 |     mock_get_fqn,
219 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
220 |     mock_main_workcell,
221 |   ):
    |

tests/core/test_workcell_runtime.py:220:5: ANN001 Missing type annotation for function argument `mock_main_workcell`
    |
218 |     mock_get_fqn,
219 |     workcell_runtime,
220 |     mock_main_workcell,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
221 |   ):
222 |     """Test successful creation of a new pure resource."""
    |

tests/core/test_workcell_runtime.py:238:5: S101 Use of `assert` detected
    |
236 |     )
237 | 
238 |     assert isinstance(initialized_resource, MockPureResource)
    |     ^^^^^^ S101
239 |     assert workcell_runtime._active_resources[resource_id] is initialized_resource
240 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_resource)
    |

tests/core/test_workcell_runtime.py:239:5: S101 Use of `assert` detected
    |
238 |     assert isinstance(initialized_resource, MockPureResource)
239 |     assert workcell_runtime._active_resources[resource_id] is initialized_resource
    |     ^^^^^^ S101
240 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_resource)
241 |     mock_update_status.assert_not_called()
    |

tests/core/test_workcell_runtime.py:239:12: SLF001 Private member accessed: `_active_resources`
    |
238 |     assert isinstance(initialized_resource, MockPureResource)
239 |     assert workcell_runtime._active_resources[resource_id] is initialized_resource
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
240 |     mock_main_workcell.add_asset.assert_called_once_with(initialized_resource)
241 |     mock_update_status.assert_not_called()
    |

tests/core/test_workcell_runtime.py:243:13: ANN201 Missing return type annotation for public function `test_get_active_machine_failure`
    |
241 |     mock_update_status.assert_not_called()
242 | 
243 |   async def test_get_active_machine_failure(self, workcell_runtime):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
244 |     """Test that getting a non-existent active machine raises an error."""
245 |     with pytest.raises(WorkcellRuntimeError, match="not found in active machines"):
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:243:51: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
241 |     mock_update_status.assert_not_called()
242 | 
243 |   async def test_get_active_machine_failure(self, workcell_runtime):
    |                                                   ^^^^^^^^^^^^^^^^ ANN001
244 |     """Test that getting a non-existent active machine raises an error."""
245 |     with pytest.raises(WorkcellRuntimeError, match="not found in active machines"):
    |

tests/core/test_workcell_runtime.py:249:13: ANN201 Missing return type annotation for public function `test_shutdown_machine`
    |
248 |   @patch("praxis.backend.services.update_machine_status")
249 |   async def test_shutdown_machine(
    |             ^^^^^^^^^^^^^^^^^^^^^ ANN201
250 |     self,
251 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:251:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
249 |   async def test_shutdown_machine(
250 |     self,
251 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
252 |     mock_get_fqn,
253 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:252:5: ANN001 Missing type annotation for function argument `mock_get_fqn`
    |
250 |     self,
251 |     mock_update_status,
252 |     mock_get_fqn,
    |     ^^^^^^^^^^^^ ANN001
253 |     workcell_runtime,
254 |   ):
    |

tests/core/test_workcell_runtime.py:252:5: ARG002 Unused method argument: `mock_get_fqn`
    |
250 |     self,
251 |     mock_update_status,
252 |     mock_get_fqn,
    |     ^^^^^^^^^^^^ ARG002
253 |     workcell_runtime,
254 |   ):
    |

tests/core/test_workcell_runtime.py:253:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
251 |     mock_update_status,
252 |     mock_get_fqn,
253 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
254 |   ):
255 |     """Test successfully shutting down a machine."""
    |

tests/core/test_workcell_runtime.py:258:5: SLF001 Private member accessed: `_active_machines`
    |
256 |     machine_id = uuid.uuid4()
257 |     mock_plr_machine = MockMachineResource(name="TestBot", backend=MockBackend())
258 |     workcell_runtime._active_machines[machine_id] = mock_plr_machine
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
259 | 
260 |     await workcell_runtime.shutdown_machine(machine_id)
    |

tests/core/test_workcell_runtime.py:263:5: S101 Use of `assert` detected
    |
262 |     # stop() is mocked in the base MockPlrMachine class
263 |     assert hasattr(mock_plr_machine, "stop")
    |     ^^^^^^ S101
264 |     assert machine_id not in workcell_runtime._active_machines
265 |     mock_update_status.assert_awaited_with(
    |

tests/core/test_workcell_runtime.py:264:5: S101 Use of `assert` detected
    |
262 |     # stop() is mocked in the base MockPlrMachine class
263 |     assert hasattr(mock_plr_machine, "stop")
264 |     assert machine_id not in workcell_runtime._active_machines
    |     ^^^^^^ S101
265 |     mock_update_status.assert_awaited_with(
266 |       ANY,
    |

tests/core/test_workcell_runtime.py:264:30: SLF001 Private member accessed: `_active_machines`
    |
262 |     # stop() is mocked in the base MockPlrMachine class
263 |     assert hasattr(mock_plr_machine, "stop")
264 |     assert machine_id not in workcell_runtime._active_machines
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
265 |     mock_update_status.assert_awaited_with(
266 |       ANY,
    |

tests/core/test_workcell_runtime.py:278:7: ANN201 Missing return type annotation for public function `mock_deck`
    |
277 |   @pytest.fixture
278 |   def mock_deck(self):
    |       ^^^^^^^^^ ANN201
279 |     """Fixture for a mock PyLabRobot Deck."""
280 |     deck = MagicMock(spec=Deck)
    |
    = help: Add return type annotation

tests/core/test_workcell_runtime.py:285:7: ANN201 Missing return type annotation for public function `setup_assets`
    |
284 |   @pytest.fixture
285 |   def setup_assets(self, workcell_runtime, mock_deck):
    |       ^^^^^^^^^^^^ ANN201
286 |     """Helper fixture to populate runtime with a deck and a resource."""
287 |     deck_id = uuid.uuid4()
    |
    = help: Add return type annotation

tests/core/test_workcell_runtime.py:285:26: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
284 |   @pytest.fixture
285 |   def setup_assets(self, workcell_runtime, mock_deck):
    |                          ^^^^^^^^^^^^^^^^ ANN001
286 |     """Helper fixture to populate runtime with a deck and a resource."""
287 |     deck_id = uuid.uuid4()
    |

tests/core/test_workcell_runtime.py:285:44: ANN001 Missing type annotation for function argument `mock_deck`
    |
284 |   @pytest.fixture
285 |   def setup_assets(self, workcell_runtime, mock_deck):
    |                                            ^^^^^^^^^ ANN001
286 |     """Helper fixture to populate runtime with a deck and a resource."""
287 |     deck_id = uuid.uuid4()
    |

tests/core/test_workcell_runtime.py:286:5: D401 First line of docstring should be in imperative mood: "Helper fixture to populate runtime with a deck and a resource."
    |
284 |   @pytest.fixture
285 |   def setup_assets(self, workcell_runtime, mock_deck):
286 |     """Helper fixture to populate runtime with a deck and a resource."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
287 |     deck_id = uuid.uuid4()
288 |     resource_id = uuid.uuid4()
    |

tests/core/test_workcell_runtime.py:289:5: SLF001 Private member accessed: `_active_decks`
    |
287 |     deck_id = uuid.uuid4()
288 |     resource_id = uuid.uuid4()
289 |     workcell_runtime._active_decks[deck_id] = mock_deck
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
290 |     workcell_runtime._active_resources[resource_id] = MockPureResource(
291 |       name="plate_to_assign",
    |

tests/core/test_workcell_runtime.py:290:5: SLF001 Private member accessed: `_active_resources`
    |
288 |     resource_id = uuid.uuid4()
289 |     workcell_runtime._active_decks[deck_id] = mock_deck
290 |     workcell_runtime._active_resources[resource_id] = MockPureResource(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
291 |       name="plate_to_assign",
292 |     )
    |

tests/core/test_workcell_runtime.py:298:13: ANN201 Missing return type annotation for public function `test_assign_resource_to_deck_by_position`
    |
296 |   @patch("praxis.backend.services.read_deck_type_definition")
297 |   @patch("praxis.backend.services.update_resource_instance_location_and_status")
298 |   async def test_assign_resource_to_deck_by_position(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
299 |     self,
300 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:300:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
298 |   async def test_assign_resource_to_deck_by_position(
299 |     self,
300 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
301 |     mock_read_deck_type,
302 |     mock_read_deck,
    |

tests/core/test_workcell_runtime.py:301:5: ANN001 Missing type annotation for function argument `mock_read_deck_type`
    |
299 |     self,
300 |     mock_update_status,
301 |     mock_read_deck_type,
    |     ^^^^^^^^^^^^^^^^^^^ ANN001
302 |     mock_read_deck,
303 |     workcell_runtime,
    |

tests/core/test_workcell_runtime.py:302:5: ANN001 Missing type annotation for function argument `mock_read_deck`
    |
300 |     mock_update_status,
301 |     mock_read_deck_type,
302 |     mock_read_deck,
    |     ^^^^^^^^^^^^^^ ANN001
303 |     workcell_runtime,
304 |     setup_assets,
    |

tests/core/test_workcell_runtime.py:303:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
301 |     mock_read_deck_type,
302 |     mock_read_deck,
303 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
304 |     setup_assets,
305 |   ):
    |

tests/core/test_workcell_runtime.py:304:5: ANN001 Missing type annotation for function argument `setup_assets`
    |
302 |     mock_read_deck,
303 |     workcell_runtime,
304 |     setup_assets,
    |     ^^^^^^^^^^^^ ANN001
305 |   ):
306 |     """Test assigning a resource to a deck using a position identifier."""
    |

tests/core/test_workcell_runtime.py:336:5: S101 Use of `assert` detected
    |
334 |     mock_deck.assign_child_resource.assert_called_once()
335 |     args, kwargs = mock_deck.assign_child_resource.call_args
336 |     assert isinstance(kwargs["resource"], MockPureResource)
    |     ^^^^^^ S101
337 |     assert kwargs["location"] == Coordinate(10, 20, 30)
338 |     mock_update_status.assert_awaited_once_with(
    |

tests/core/test_workcell_runtime.py:337:5: S101 Use of `assert` detected
    |
335 |     args, kwargs = mock_deck.assign_child_resource.call_args
336 |     assert isinstance(kwargs["resource"], MockPureResource)
337 |     assert kwargs["location"] == Coordinate(10, 20, 30)
    |     ^^^^^^ S101
338 |     mock_update_status.assert_awaited_once_with(
339 |       ANY,
    |

tests/core/test_workcell_runtime.py:347:13: ANN201 Missing return type annotation for public function `test_clear_deck_position`
    |
346 |   @patch("praxis.backend.services.update_resource_instance_location_and_status")
347 |   async def test_clear_deck_position(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
348 |     self,
349 |     mock_update_status,
    |
    = help: Add return type annotation: `None`

tests/core/test_workcell_runtime.py:349:5: ANN001 Missing type annotation for function argument `mock_update_status`
    |
347 |   async def test_clear_deck_position(
348 |     self,
349 |     mock_update_status,
    |     ^^^^^^^^^^^^^^^^^^ ANN001
350 |     workcell_runtime,
351 |     setup_assets,
    |

tests/core/test_workcell_runtime.py:350:5: ANN001 Missing type annotation for function argument `workcell_runtime`
    |
348 |     self,
349 |     mock_update_status,
350 |     workcell_runtime,
    |     ^^^^^^^^^^^^^^^^ ANN001
351 |     setup_assets,
352 |   ):
    |

tests/core/test_workcell_runtime.py:351:5: ANN001 Missing type annotation for function argument `setup_assets`
    |
349 |     mock_update_status,
350 |     workcell_runtime,
351 |     setup_assets,
    |     ^^^^^^^^^^^^ ANN001
352 |   ):
353 |     """Test clearing a resource from a deck position."""
    |

tests/integration_discovery_execution_tests.py:1:1: INP001 File `tests/integration_discovery_execution_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/integration_discovery_execution_tests.py:1:15: PGH003 Use specific rule codes when ignoring type issues
  |
1 | import pytest # type: ignore
  |               ^^^^^^^^^^^^^^ PGH003
2 | import os
3 | import sys
  |

tests/integration_discovery_execution_tests.py:21:61: COM812 Trailing comma missing
   |
19 |     FunctionProtocolDefinitionOrm, ParameterDefinitionOrm, AssetDefinitionOrm,
20 |     ProtocolRunOrm, FunctionCallLogOrm, ProtocolRunStatusEnum, FunctionCallStatusEnum,
21 |     ProtocolSourceRepositoryOrm, FileSystemProtocolSourceOrm # Ensured these are grouped
   |                                                              COM812
22 | )
23 | import json # For serializing in assertions
   |
   = help: Add trailing comma

tests/integration_discovery_execution_tests.py:31:38: PGH003 Use specific rule codes when ignoring type issues
   |
29 |     from jsonschema import ValidationError as JsonSchemaValidationError
30 | except ImportError: # pragma: no cover
31 |     JsonSchemaValidationError = None # type: ignore
   |                                      ^^^^^^^^^^^^^^ PGH003
32 | from unittest.mock import call, patch # Ensure patch is imported
33 | from praxis.backend.protocol_core.protocol_definition_models import ParameterMetadataModel, AssetRequirementModel
   |

tests/integration_discovery_execution_tests.py:37:35: COM812 Trailing comma missing
   |
35 |     ResourceStatusEnum, ManagedDeviceStatusEnum,
36 |     ResourceDefinitionOrm, ManagedDeviceOrm as ManagedDeviceOrmReal,
37 |     ResourceOrm as ResourceOrmReal
   |                                    COM812
38 | )
39 | # Import WorkcellRuntime to patch its methods (though we'll mock its instance methods)
   |
   = help: Add trailing comma

tests/integration_discovery_execution_tests.py:67:17: SyntaxError: missing closing quote in string literal
   |
65 |     os.makedirs(pkg_root_dir)
66 |     with open(os.path.join(pkg_root_dir, "__init__.py"), "w", encoding="utf-8") as f:
67 |         f.write("# Integration test protocol package root
   |                 ^
68 | ")
   |

tests/integration_discovery_execution_tests.py:68:1: SyntaxError: missing closing quote in string literal
   |
66 |     with open(os.path.join(pkg_root_dir, "__init__.py"), "w", encoding="utf-8") as f:
67 |         f.write("# Integration test protocol package root
68 | ")
   | ^
69 | 
70 |     protocol_content = """
   |

tests/integration_discovery_execution_tests.py:98:4: SyntaxError: Expected ')', found newline
    |
 96 |     state.main_protocol_completed = True # type: ignore
 97 |     return {"status": "main_complete", "nested_result": nested_result, "final_message": initial_message}
 98 | """
    |    ^
 99 |     with open(os.path.join(pkg_root_dir, "protocol_module.py"), "w", encoding="utf-8") as f:
100 |         f.write(protocol_content)
    |

tests/integration_discovery_execution_tests.py:122:121: E501 Line too long (126 > 120)
    |
120 |     mock_fpd_instance.parameters = [] # Mocked list of ParameterDefinitionOrm
121 |     mock_fpd_instance.assets = []    # Mocked list of AssetDefinitionOrm
122 |     mock_fpd_instance.file_system_source = MagicMock(spec=FileSystemProtocolSourceOrm, base_path='dummy/fs/path_for_mock_fpd')
    |                                                                                                                         ^^^^^^ E501
123 |     mock_fpd_instance.source_repository = None
124 |     mock_fpd_instance.pydantic_definition = MagicMock(spec=FunctionProtocolDefinitionModel) # Critical for Orchestrator
    |

tests/integration_discovery_execution_tests.py:136:121: E501 Line too long (171 > 120)
    |
134 |             assets=[MagicMock(name=a.name) for a in protocol_pydantic.assets],
135 |             source_repository_accession_id=kwargs.get('source_repository_accession_id'),
136 |             source_repository=MagicMock(spec=ProtocolSourceRepositoryOrm, local_checkout_path='dummy/repo/path') if kwargs.get('source_repository_accession_id') else None,
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
137 |             file_system_source_accession_id=kwargs.get('file_system_source_accession_id'),
138 |             file_system_source=MagicMock(spec=FileSystemProtocolSourceOrm, base_path='dummy_scan_path_for_upsert_fixture') if kwargs.get('file_system_source_accession_id') else None,
    |

tests/integration_discovery_execution_tests.py:138:121: E501 Line too long (182 > 120)
    |
136 |             source_repository=MagicMock(spec=ProtocolSourceRepositoryOrm, local_checkout_path='dummy/repo/path') if kwargs.get('source_repository_accession_id') else None,
137 |             file_system_source_accession_id=kwargs.get('file_system_source_accession_id'),
138 |             file_system_source=MagicMock(spec=FileSystemProtocolSourceOrm, base_path='dummy_scan_path_for_upsert_fixture') if kwargs.get('file_system_source_accession_id') else None,
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
139 |             commit_hash=kwargs.get('commit_hash'),
140 |             pydantic_definition=protocol_pydantic
    |

tests/integration_discovery_execution_tests.py:140:50: COM812 Trailing comma missing
    |
138 |             file_system_source=MagicMock(spec=FileSystemProtocolSourceOrm, base_path='dummy_scan_path_for_upsert_fixture') if kwargs.get('file_system_source_accession_id') else None,
139 |             commit_hash=kwargs.get('commit_hash'),
140 |             pydantic_definition=protocol_pydantic
    |                                                   COM812
141 |         )
142 |     )
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:141:10: COM812 Trailing comma missing
    |
139 |             commit_hash=kwargs.get('commit_hash'),
140 |             pydantic_definition=protocol_pydantic
141 |         )
    |           COM812
142 |     )
143 |     _mock_get_fpd_details = MagicMock(return_value=mock_fpd_instance)
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:144:121: E501 Line too long (125 > 120)
    |
142 |     )
143 |     _mock_get_fpd_details = MagicMock(return_value=mock_fpd_instance)
144 |     _mock_create_pr = MagicMock(return_value=MagicMock(spec=ProtocolRunOrm, id=789, run_accession_id="default_accession_id"))
    |                                                                                                                         ^^^^^ E501
145 |     _mock_update_pr_status = MagicMock(return_value=MagicMock(spec=ProtocolRunOrm))
146 |     _mock_log_fcs = MagicMock(return_value=MagicMock(spec=FunctionCallLogOrm, id=101112))
    |

tests/integration_discovery_execution_tests.py:190:47: COM812 Trailing comma missing
    |
188 |         mock_data_services: dict[str, MagicMock], # MODIFIED: Use new fixture name
189 |         mock_redis_for_state: MagicMock,
190 |         mock_asset_manager_instance: MagicMock
    |                                                COM812
191 |     ):
192 |         # --- 1. Discovery Phase ---
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:197:46: COM812 Trailing comma missing
    |
195 |         discovered_defs_orm_mocks = discovery_service.discover_and_upsert_protocols(
196 |             search_paths=[temp_integration_protocols],
197 |             file_system_source_accession_id=1
    |                                               COM812
198 |         )
199 |         # Assertion for upsert_function_protocol_definition (mocked by mock_data_services)
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:227:121: E501 Line too long (121 > 120)
    |
226 |         from praxis.backend.protocol_core.definitions import PROTOCOL_REGISTRY
227 |         registry_key = f"{mod.main_protocol._protocol_definition.name}_v{mod.main_protocol._protocol_definition.version}"
    |                                                                                                                         ^ E501
228 |         if registry_key in PROTOCOL_REGISTRY:
229 |              PROTOCOL_REGISTRY[registry_key]['pydantic_definition'] = mod.main_protocol._protocol_definition
    |

tests/integration_discovery_execution_tests.py:248:45: COM812 Trailing comma missing
    |
246 |             file_system_source_accession_id=1,
247 |             user_input_params=user_params,
248 |             initial_state_data=initial_state
    |                                              COM812
249 |         )
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:261:121: E501 Line too long (123 > 120)
    |
259 |             top_level_protocol_definition_accession_id=main_proto_orm_mock.accession_id,
260 |             status=ProtocolRunStatusEnum.PREPARING,
261 |             input_parameters_json=json.dumps(user_params, default=lambda o: o.name if isinstance(o, Resource) else str(o)),
    |                                                                                                                         ^^^ E501
262 |             initial_state_json=json.dumps(initial_state)
263 |         )
    |

tests/integration_discovery_execution_tests.py:262:57: COM812 Trailing comma missing
    |
260 |             status=ProtocolRunStatusEnum.PREPARING,
261 |             input_parameters_json=json.dumps(user_params, default=lambda o: o.name if isinstance(o, Resource) else str(o)),
262 |             initial_state_json=json.dumps(initial_state)
    |                                                          COM812
263 |         )
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:286:121: E501 Line too long (170 > 120)
    |
284 |         assert log_end_mock.call_count == 2
285 | 
286 |         main_call_start_kwargs = next(c.kwargs for c in log_start_mock.call_args_list if c.kwargs['function_definition_accession_id'] == main_proto_orm_mock.accession_id)
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
287 |         assert main_call_start_kwargs['protocol_run_orm_accession_id'] == final_run_orm.accession_id
288 |         assert main_call_start_kwargs['parent_function_call_log_accession_id'] is None
    |

tests/integration_discovery_execution_tests.py:290:121: E501 Line too long (183 > 120)
    |
288 |         assert main_call_start_kwargs['parent_function_call_log_accession_id'] is None
289 | 
290 |         main_call_log_entry_mock = next(c.return_value for c in log_start_mock.side_effect_history if c.kwargs['function_definition_accession_id'] == main_proto_orm_mock.accession_id)
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
291 | 
292 |         nested_call_start_kwargs = next(c.kwargs for c in log_start_mock.call_args_list if c.kwargs['function_definition_accession_id'] == nested_proto_orm_mock.accession_id)
    |

tests/integration_discovery_execution_tests.py:292:121: E501 Line too long (174 > 120)
    |
290 |         main_call_log_entry_mock = next(c.return_value for c in log_start_mock.side_effect_history if c.kwargs['function_definition_accession_id'] == main_proto_orm_mock.accession_id)
291 | 
292 |         nested_call_start_kwargs = next(c.kwargs for c in log_start_mock.call_args_list if c.kwargs['function_definition_accession_id'] == nested_proto_orm_mock.accession_id)
    |                                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
293 |         assert nested_call_start_kwargs['protocol_run_orm_accession_id'] == final_run_orm.accession_id
294 |         assert nested_call_start_kwargs['parent_function_call_log_accession_id'] == main_call_log_entry_mock.accession_id
    |

tests/integration_discovery_execution_tests.py:294:121: E501 Line too long (121 > 120)
    |
292 |         nested_call_start_kwargs = next(c.kwargs for c in log_start_mock.call_args_list if c.kwargs['function_definition_accession_id'] == nested_proto_orm_mock.accession_id)
293 |         assert nested_call_start_kwargs['protocol_run_orm_accession_id'] == final_run_orm.accession_id
294 |         assert nested_call_start_kwargs['parent_function_call_log_accession_id'] == main_call_log_entry_mock.accession_id
    |                                                                                                                         ^ E501
295 | 
296 |         final_output = json.loads(update_calls[-1].kwargs['output_data_json'])
    |

tests/integration_discovery_execution_tests.py:305:48: COM812 Trailing comma missing
    |
303 |         mock_asset_manager_instance.acquire_asset.assert_called_once_with(
304 |             protocol_run_accession_id=test_run_accession_id,
305 |             asset_requirement=pipette_asset_req
    |                                                 COM812
306 |         )
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:314:47: COM812 Trailing comma missing
    |
312 |         mock_data_services: dict[str, MagicMock], # MODIFIED: Use new fixture name
313 |         mock_redis_for_state: MagicMock,
314 |         mock_asset_manager_instance: MagicMock
    |                                                COM812
315 |     ):
316 |         # --- Setup: Discovery (to get Pydantic model into PROTOCOL_REGISTRY) ---
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:319:89: COM812 Trailing comma missing
    |
317 |         discovery_service = ProtocolDiscoveryService(db_session=mock_db_session)
318 |         discovered_defs_orm_mocks = discovery_service.discover_and_upsert_protocols(
319 |             search_paths=[temp_integration_protocols], file_system_source_accession_id=1
    |                                                                                          COM812
320 |         )
321 |         main_proto_discovered_mock_orm = next((p for p in discovered_defs_orm_mocks if p.name == "MainIntegrationProtocol"), None)
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:321:121: E501 Line too long (130 > 120)
    |
319 |             search_paths=[temp_integration_protocols], file_system_source_accession_id=1
320 |         )
321 |         main_proto_discovered_mock_orm = next((p for p in discovered_defs_orm_mocks if p.name == "MainIntegrationProtocol"), None)
    |                                                                                                                         ^^^^^^^^^^ E501
322 |         assert main_proto_discovered_mock_orm is not None
    |

tests/integration_discovery_execution_tests.py:346:38: COM812 Trailing comma missing
    |
344 |                 file_system_source_accession_id=1,
345 |                 user_input_params=invalid_user_params,
346 |                 initial_state_data={}
    |                                       COM812
347 |             )
    |
    = help: Add trailing comma

tests/integration_discovery_execution_tests.py:360:47: COM812 Trailing comma missing
    |
358 |         mock_data_services: dict[str, MagicMock], # MODIFIED: Use new fixture name
359 |         mock_redis_for_state: MagicMock,
360 |         mock_asset_manager_instance: MagicMock
    |                                                COM812
361 |     ):
362 |         # This test is complex to set up perfectly without modifying the actual protocol definition
    |
    = help: Add trailing comma

tests/models/test_asset_lock_manager_pydantic_models.py:1:1: INP001 File `tests/models/test_asset_lock_manager_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_asset_lock_manager_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/asset_lock_manager_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_asset_lock_manager_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/asset_lock_manager_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_asset_lock_manager_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/asset_lock_manager_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_asset_lock_manager_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_asset_lock_manager_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_asset_lock_manager_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_asset_manager_pydantic_models.py:1:1: INP001 File `tests/models/test_asset_manager_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_asset_manager_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/asset_manager_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_asset_manager_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/asset_manager_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_asset_manager_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/asset_manager_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_asset_manager_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_asset_manager_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_asset_manager_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_asset_orm.py:1:1: INP001 File `tests/models/test_asset_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_asset_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/asset_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_asset_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/asset_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_asset_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/asset_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_asset_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_asset_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_asset_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_asset_pydantic_models.py:1:1: INP001 File `tests/models/test_asset_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_asset_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/asset_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_asset_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/asset_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_asset_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/asset_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_asset_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_asset_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_asset_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_deck_orm.py:1:1: INP001 File `tests/models/test_deck_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_deck_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/deck_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_deck_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/deck_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_deck_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/deck_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_deck_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_deck_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_deck_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_deck_pydantic_models.py:1:1: INP001 File `tests/models/test_deck_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_deck_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/deck_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_deck_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/deck_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_deck_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/deck_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_deck_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_deck_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_deck_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_enums.py:1:1: INP001 File `tests/models/test_enums.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_enums.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/enums.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_enums.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/enums.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_enums.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/enums.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_enums.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_enums.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_enums.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_filters.py:1:1: INP001 File `tests/models/test_filters.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_filters.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/filters.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_filters.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/filters.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_filters.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/filters.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_filters.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_filters.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_filters.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_function_data_output_orm.py:1:1: INP001 File `tests/models/test_function_data_output_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_function_data_output_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_function_data_output_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_function_data_output_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_function_data_output_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_function_data_output_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_function_data_output_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_function_data_output_pydantic_models.py:1:1: INP001 File `tests/models/test_function_data_output_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_function_data_output_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_function_data_output_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_function_data_output_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/function_data_output_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_function_data_output_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_function_data_output_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_function_data_output_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_machine_orm.py:1:1: INP001 File `tests/models/test_machine_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_machine_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/machine_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_machine_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/machine_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_machine_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/machine_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_machine_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_machine_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_machine_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_machine_pydantic_models.py:1:1: INP001 File `tests/models/test_machine_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_machine_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/machine_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_machine_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/machine_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_machine_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/machine_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_machine_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_machine_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_machine_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_protocol_definitions_orm.py:1:1: INP001 File `tests/models/test_protocol_definitions_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_protocol_definitions_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_definitions_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_protocol_definitions_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_definitions_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_protocol_definitions_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_definitions_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_protocol_definitions_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_protocol_definitions_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_protocol_definitions_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_protocol_pydantic_models.py:1:1: INP001 File `tests/models/test_protocol_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_protocol_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_protocol_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_protocol_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/protocol_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_protocol_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_protocol_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_protocol_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_pydantic_base.py:1:1: INP001 File `tests/models/test_pydantic_base.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_pydantic_base.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/pydantic_base.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_pydantic_base.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/pydantic_base.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_pydantic_base.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/pydantic_base.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_pydantic_base.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_pydantic_base.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_pydantic_base.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_resource_orm.py:1:1: INP001 File `tests/models/test_resource_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_resource_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/resource_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_resource_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/resource_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_resource_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/resource_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_resource_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_resource_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_resource_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_resource_pydantic_models.py:1:1: INP001 File `tests/models/test_resource_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_resource_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/resource_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_resource_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/resource_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_resource_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/resource_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_resource_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_resource_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_resource_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_scheduler_orm.py:1:1: INP001 File `tests/models/test_scheduler_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_scheduler_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_scheduler_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_scheduler_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_scheduler_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_scheduler_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_scheduler_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_scheduler_pydantic.py:1:1: INP001 File `tests/models/test_scheduler_pydantic.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_scheduler_pydantic.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_pydantic.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_scheduler_pydantic.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_pydantic.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_scheduler_pydantic.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/scheduler_pydantic.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_scheduler_pydantic.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_scheduler_pydantic.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_scheduler_pydantic.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_timestamp_mixin.py:1:1: INP001 File `tests/models/test_timestamp_mixin.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_timestamp_mixin.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/timestamp_mixin.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_timestamp_mixin.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/timestamp_mixin.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_timestamp_mixin.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/timestamp_mixin.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_timestamp_mixin.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_timestamp_mixin.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_timestamp_mixin.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_user_management_orm.py:1:1: INP001 File `tests/models/test_user_management_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_user_management_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/user_management_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_user_management_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/user_management_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_user_management_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/user_management_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_user_management_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_user_management_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_user_management_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_workcell_orm.py:1:1: INP001 File `tests/models/test_workcell_orm.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_workcell_orm.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_orm.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_workcell_orm.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_orm.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_workcell_orm.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_orm.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_workcell_orm.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_workcell_orm.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_workcell_orm.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/models/test_workcell_pydantic_models.py:1:1: INP001 File `tests/models/test_workcell_pydantic_models.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/models/test_workcell_pydantic_models.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_pydantic_models.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/models/test_workcell_pydantic_models.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_pydantic_models.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/models/test_workcell_pydantic_models.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/models/workcell_pydantic_models.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/models/test_workcell_pydantic_models.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/models/test_workcell_pydantic_models.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/models/test_workcell_pydantic_models.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/orchestrator_tests.py:1:1: INP001 File `tests/orchestrator_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/orchestrator_tests.py:1:1: D100 Missing docstring in public module
tests/orchestrator_tests.py:23:43: PLC0414 Import alias does not rename original package
   |
21 |   FunctionProtocolDefinitionModel,
22 | )
23 | from praxis.backend.services.state import PraxisState as PraxisState
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
24 | from praxis.backend.utils.errors import AssetAcquisitionError
   |
   = help: Remove import alias

tests/orchestrator_tests.py:36:7: D101 Missing docstring in public class
   |
36 | class MockPlrPlate:
   |       ^^^^^^^^^^^^ D101
37 |   pass
   |

tests/orchestrator_tests.py:40:7: D101 Missing docstring in public class
   |
40 | class MockPlrPipette:
   |       ^^^^^^^^^^^^^^ D101
41 |   pass
   |

tests/orchestrator_tests.py:44:7: D101 Missing docstring in public class
   |
44 | class MockPlrTipRack:
   |       ^^^^^^^^^^^^^^ D101
45 |   pass
   |

tests/orchestrator_tests.py:58:5: ANN201 Missing return type annotation for public function `mock_db_session`
   |
57 | @pytest.fixture
58 | def mock_db_session():  # Removed self
   |     ^^^^^^^^^^^^^^^ ANN201
59 |   return MagicMock()
   |
   = help: Add return type annotation

tests/orchestrator_tests.py:58:5: D103 Missing docstring in public function
   |
57 | @pytest.fixture
58 | def mock_db_session():  # Removed self
   |     ^^^^^^^^^^^^^^^ D103
59 |   return MagicMock()
   |

tests/orchestrator_tests.py:63:5: ANN201 Missing return type annotation for public function `mock_asset_manager`
   |
62 | @pytest.fixture
63 | def mock_asset_manager():  # Removed self
   |     ^^^^^^^^^^^^^^^^^^ ANN201
64 |   mock_am = MagicMock()
65 |   mock_am.acquire_asset.return_value = (
   |
   = help: Add return type annotation

tests/orchestrator_tests.py:63:5: D103 Missing docstring in public function
   |
62 | @pytest.fixture
63 | def mock_asset_manager():  # Removed self
   |     ^^^^^^^^^^^^^^^^^^ D103
64 |   mock_am = MagicMock()
65 |   mock_am.acquire_asset.return_value = (
   |

tests/orchestrator_tests.py:76:5: ANN201 Missing return type annotation for public function `mock_protocol_def_orm`
   |
75 | @pytest.fixture
76 | def mock_protocol_def_orm():  # Removed self
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
77 |   # Create a somewhat realistic FunctionProtocolDefinitionOrm mock
78 |   pdo = MagicMock(spec=FunctionProtocolDefinitionOrm)
   |
   = help: Add return type annotation

tests/orchestrator_tests.py:76:5: D103 Missing docstring in public function
   |
75 | @pytest.fixture
76 | def mock_protocol_def_orm():  # Removed self
   |     ^^^^^^^^^^^^^^^^^^^^^ D103
77 |   # Create a somewhat realistic FunctionProtocolDefinitionOrm mock
78 |   pdo = MagicMock(spec=FunctionProtocolDefinitionOrm)
   |

tests/orchestrator_tests.py:114:5: ANN201 Missing return type annotation for public function `mock_protocol_run_orm`
    |
113 | @pytest.fixture
114 | def mock_protocol_run_orm():  # Removed self
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
115 |   pro = MagicMock(spec=ProtocolRunOrm)
116 |   pro.accession_id = 99
    |
    = help: Add return type annotation

tests/orchestrator_tests.py:114:5: D103 Missing docstring in public function
    |
113 | @pytest.fixture
114 | def mock_protocol_run_orm():  # Removed self
    |     ^^^^^^^^^^^^^^^^^^^^^ D103
115 |   pro = MagicMock(spec=ProtocolRunOrm)
116 |   pro.accession_id = 99
    |

tests/orchestrator_tests.py:117:30: F821 Undefined name `uuid`
    |
115 |   pro = MagicMock(spec=ProtocolRunOrm)
116 |   pro.accession_id = 99
117 |   pro.run_accession_id = str(uuid.uuid4())
    |                              ^^^^ F821
118 |   # Status is set to PREPARING by create_protocol_run initially
119 |   pro.status = ProtocolRunStatusEnum.PREPARING
    |

tests/orchestrator_tests.py:124:5: ANN201 Missing return type annotation for public function `orchestrator_instance`
    |
123 | @pytest.fixture
124 | def orchestrator_instance(
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
125 |   mock_db_session, mock_asset_manager,
126 | ):  # Removed self from params
    |
    = help: Add return type annotation

tests/orchestrator_tests.py:124:5: D103 Missing docstring in public function
    |
123 | @pytest.fixture
124 | def orchestrator_instance(
    |     ^^^^^^^^^^^^^^^^^^^^^ D103
125 |   mock_db_session, mock_asset_manager,
126 | ):  # Removed self from params
    |

tests/orchestrator_tests.py:125:3: ANN001 Missing type annotation for function argument `mock_db_session`
    |
123 | @pytest.fixture
124 | def orchestrator_instance(
125 |   mock_db_session, mock_asset_manager,
    |   ^^^^^^^^^^^^^^^ ANN001
126 | ):  # Removed self from params
127 |   with patch(
    |

tests/orchestrator_tests.py:125:20: ANN001 Missing type annotation for function argument `mock_asset_manager`
    |
123 | @pytest.fixture
124 | def orchestrator_instance(
125 |   mock_db_session, mock_asset_manager,
    |                    ^^^^^^^^^^^^^^^^^^ ANN001
126 | ):  # Removed self from params
127 |   with patch(
    |

tests/orchestrator_tests.py:160:7: D101 Missing docstring in public class
    |
160 | class TestOrchestratorExecutionControl:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
161 |   @pytest.fixture
162 |   def mock_protocol_wrapper_func(self):  # Removed self
    |

tests/orchestrator_tests.py:162:7: ANN201 Missing return type annotation for public function `mock_protocol_wrapper_func`
    |
160 | class TestOrchestratorExecutionControl:
161 |   @pytest.fixture
162 |   def mock_protocol_wrapper_func(self):  # Removed self
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
163 |     mf = MagicMock(name="mock_protocol_wrapper_func")
164 |     mf.return_value = {"status": "mock_protocol_completed"}
    |
    = help: Add return type annotation

tests/orchestrator_tests.py:162:7: D102 Missing docstring in public method
    |
160 | class TestOrchestratorExecutionControl:
161 |   @pytest.fixture
162 |   def mock_protocol_wrapper_func(self):  # Removed self
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
163 |     mf = MagicMock(name="mock_protocol_wrapper_func")
164 |     mf.return_value = {"status": "mock_protocol_completed"}
    |

tests/orchestrator_tests.py:167:7: ANN201 Missing return type annotation for public function `test_pause_and_resume_flow`
    |
165 |     return mf
166 | 
167 |   def test_pause_and_resume_flow(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
168 |     self,
169 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:167:7: D102 Missing docstring in public method
    |
165 |     return mf
166 | 
167 |   def test_pause_and_resume_flow(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
168 |     self,
169 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:169:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
167 |   def test_pause_and_resume_flow(
168 |     self,
169 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
170 |     mock_protocol_def_orm,
171 |     mock_protocol_run_orm,
    |

tests/orchestrator_tests.py:170:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
168 |     self,
169 |     orchestrator_instance,
170 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
171 |     mock_protocol_run_orm,
172 |     mock_protocol_wrapper_func,
    |

tests/orchestrator_tests.py:171:5: ANN001 Missing type annotation for function argument `mock_protocol_run_orm`
    |
169 |     orchestrator_instance,
170 |     mock_protocol_def_orm,
171 |     mock_protocol_run_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
172 |     mock_protocol_wrapper_func,
173 |   ):
    |

tests/orchestrator_tests.py:172:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func`
    |
170 |     mock_protocol_def_orm,
171 |     mock_protocol_run_orm,
172 |     mock_protocol_wrapper_func,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
173 |   ):
174 |     orchestrator, mock_sleep = orchestrator_instance
    |

tests/orchestrator_tests.py:183:5: SLF001 Private member accessed: `_prepare_protocol_code`
    |
181 |     mock_create_protocol_run.return_value = mock_protocol_run_orm
182 | 
183 |     orchestrator._prepare_protocol_code = MagicMock(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
184 |       return_value=(mock_protocol_wrapper_func, decorator_meta),
185 |     )
    |

tests/orchestrator_tests.py:186:5: SLF001 Private member accessed: `_prepare_arguments`
    |
184 |       return_value=(mock_protocol_wrapper_func, decorator_meta),
185 |     )
186 |     orchestrator._prepare_arguments = MagicMock(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
187 |       return_value=({}, None, []),
188 |     )  # No assets for this test
    |

tests/orchestrator_tests.py:203:5: S101 Use of `assert` detected
    |
202 |     mock_run_control_clear.assert_any_call(mock_protocol_run_orm.run_accession_id)
203 |     assert mock_run_control_clear.call_count == 2  # For PAUSE and RESUME
    |     ^^^^^^ S101
204 | 
205 |     expected_status_calls = [
    |

tests/orchestrator_tests.py:203:49: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
202 |     mock_run_control_clear.assert_any_call(mock_protocol_run_orm.run_accession_id)
203 |     assert mock_run_control_clear.call_count == 2  # For PAUSE and RESUME
    |                                                 ^ PLR2004
204 | 
205 |     expected_status_calls = [
    |

tests/orchestrator_tests.py:224:5: S101 Use of `assert` detected
    |
223 |     actual_calls = mock_update_protocol_run_status.call_args_list
224 |     assert actual_calls == expected_status_calls
    |     ^^^^^^ S101
225 | 
226 |     mock_protocol_wrapper_func.assert_called_once()
    |

tests/orchestrator_tests.py:227:5: S101 Use of `assert` detected
    |
226 |     mock_protocol_wrapper_func.assert_called_once()
227 |     assert mock_sleep.call_count >= 2
    |     ^^^^^^ S101
228 | 
229 |   def test_cancel_during_pause_flow(
    |

tests/orchestrator_tests.py:227:37: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
226 |     mock_protocol_wrapper_func.assert_called_once()
227 |     assert mock_sleep.call_count >= 2
    |                                     ^ PLR2004
228 | 
229 |   def test_cancel_during_pause_flow(
    |

tests/orchestrator_tests.py:229:7: ANN201 Missing return type annotation for public function `test_cancel_during_pause_flow`
    |
227 |     assert mock_sleep.call_count >= 2
228 | 
229 |   def test_cancel_during_pause_flow(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
230 |     self,
231 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:229:7: D102 Missing docstring in public method
    |
227 |     assert mock_sleep.call_count >= 2
228 | 
229 |   def test_cancel_during_pause_flow(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
230 |     self,
231 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:231:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
229 |   def test_cancel_during_pause_flow(
230 |     self,
231 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
232 |     mock_protocol_def_orm,
233 |     mock_protocol_run_orm,
    |

tests/orchestrator_tests.py:232:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
230 |     self,
231 |     orchestrator_instance,
232 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
233 |     mock_protocol_run_orm,
234 |     mock_protocol_wrapper_func,
    |

tests/orchestrator_tests.py:233:5: ANN001 Missing type annotation for function argument `mock_protocol_run_orm`
    |
231 |     orchestrator_instance,
232 |     mock_protocol_def_orm,
233 |     mock_protocol_run_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
234 |     mock_protocol_wrapper_func,
235 |   ):
    |

tests/orchestrator_tests.py:234:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func`
    |
232 |     mock_protocol_def_orm,
233 |     mock_protocol_run_orm,
234 |     mock_protocol_wrapper_func,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
235 |   ):
236 |     orchestrator, mock_sleep = orchestrator_instance
    |

tests/orchestrator_tests.py:242:5: SLF001 Private member accessed: `_prepare_protocol_code`
    |
240 |     mock_get_protocol_definition_details.return_value = protocol_def
241 |     mock_create_protocol_run.return_value = mock_protocol_run_orm
242 |     orchestrator._prepare_protocol_code = MagicMock(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
243 |       return_value=(mock_protocol_wrapper_func, decorator_meta),
244 |     )
    |

tests/orchestrator_tests.py:249:5: SLF001 Private member accessed: `_prepare_arguments`
    |
247 |       {"type": "machine", "orm_accession_id": 123, "name_in_protocol": "mock_machine"},
248 |     ]
249 |     orchestrator._prepare_arguments = MagicMock(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
250 |       return_value=({}, None, acquired_assets_info),
251 |     )
    |

tests/orchestrator_tests.py:265:5: S101 Use of `assert` detected
    |
264 |     mock_run_control_clear.assert_any_call(mock_protocol_run_orm.run_accession_id)
265 |     assert mock_run_control_clear.call_count == 2
    |     ^^^^^^ S101
266 | 
267 |     actual_calls = mock_update_protocol_run_status.call_args_list
    |

tests/orchestrator_tests.py:265:49: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
264 |     mock_run_control_clear.assert_any_call(mock_protocol_run_orm.run_accession_id)
265 |     assert mock_run_control_clear.call_count == 2
    |                                                 ^ PLR2004
266 | 
267 |     actual_calls = mock_update_protocol_run_status.call_args_list
    |

tests/orchestrator_tests.py:269:5: S101 Use of `assert` detected
    |
267 |     actual_calls = mock_update_protocol_run_status.call_args_list
268 | 
269 |     assert actual_calls[0] == call(
    |     ^^^^^^ S101
270 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.RUNNING,
271 |     )
    |

tests/orchestrator_tests.py:272:5: S101 Use of `assert` detected
    |
270 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.RUNNING,
271 |     )
272 |     assert actual_calls[1] == call(
    |     ^^^^^^ S101
273 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.PAUSING,
274 |     )
    |

tests/orchestrator_tests.py:275:5: S101 Use of `assert` detected
    |
273 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.PAUSING,
274 |     )
275 |     assert actual_calls[2] == call(
    |     ^^^^^^ S101
276 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.PAUSED,
277 |     )
    |

tests/orchestrator_tests.py:278:5: S101 Use of `assert` detected
    |
276 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.PAUSED,
277 |     )
278 |     assert actual_calls[3] == call(
    |     ^^^^^^ S101
279 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.CANCELING,
280 |     )
    |

tests/orchestrator_tests.py:281:5: S101 Use of `assert` detected
    |
279 |       ANY, mock_protocol_run_orm.accession_id, ProtocolRunStatusEnum.CANCELING,
280 |     )
281 |     assert actual_calls[4] == call(
    |     ^^^^^^ S101
282 |       ANY,
283 |       mock_protocol_run_orm.accession_id,
    |

tests/orchestrator_tests.py:295:5: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
293 |     orchestrator.asset_manager.release_resource.assert_not_called()
294 | 
295 |   # TODO: Add more tests here for:
    |     ^^^^ TD002
296 |   # - test_cancel_before_execution_starts (after _prepare_arguments, before pause loop)
297 |   # - test_cancel_at_very_beginning (first command check)
    |

tests/orchestrator_tests.py:295:5: TD003 Missing issue link on the line following this TODO
    |
293 |     orchestrator.asset_manager.release_resource.assert_not_called()
294 | 
295 |   # TODO: Add more tests here for:
    |     ^^^^ TD003
296 |   # - test_cancel_before_execution_starts (after _prepare_arguments, before pause loop)
297 |   # - test_cancel_at_very_beginning (first command check)
    |

tests/orchestrator_tests.py:295:5: FIX002 Line contains TODO, consider resolving the issue
    |
293 |     orchestrator.asset_manager.release_resource.assert_not_called()
294 | 
295 |   # TODO: Add more tests here for:
    |     ^^^^ FIX002
296 |   # - test_cancel_before_execution_starts (after _prepare_arguments, before pause loop)
297 |   # - test_cancel_at_very_beginning (first command check)
    |

tests/orchestrator_tests.py:306:7: D101 Missing docstring in public class
    |
306 | class TestOrchestratorGitOps:
    |       ^^^^^^^^^^^^^^^^^^^^^^ D101
307 |   # Tests for _prepare_protocol_code with Git operations (ORCH-4)
    |

tests/orchestrator_tests.py:310:7: ANN201 Missing return type annotation for public function `mock_git_protocol_def_orm`
    |
309 |   @pytest.fixture
310 |   def mock_git_protocol_def_orm(self, mock_protocol_def_orm):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
311 |     """Modifies the standard protocol_def_orm to include git source info."""
312 |     protocol_def, decorator_meta = mock_protocol_def_orm
    |
    = help: Add return type annotation

tests/orchestrator_tests.py:310:39: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
309 |   @pytest.fixture
310 |   def mock_git_protocol_def_orm(self, mock_protocol_def_orm):
    |                                       ^^^^^^^^^^^^^^^^^^^^^ ANN001
311 |     """Modifies the standard protocol_def_orm to include git source info."""
312 |     protocol_def, decorator_meta = mock_protocol_def_orm
    |

tests/orchestrator_tests.py:311:5: D401 First line of docstring should be in imperative mood: "Modifies the standard protocol_def_orm to include git source info."
    |
309 |   @pytest.fixture
310 |   def mock_git_protocol_def_orm(self, mock_protocol_def_orm):
311 |     """Modifies the standard protocol_def_orm to include git source info."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
312 |     protocol_def, decorator_meta = mock_protocol_def_orm
313 |     # Clear file system source if it exists from the base fixture
    |

tests/orchestrator_tests.py:323:41: S108 Probable insecure usage of temporary file or directory: "/tmp/test_repo_checkout"
    |
321 |     mock_repo_orm.name = "TestGitRepo"
322 |     mock_repo_orm.git_url = "git@example.com:test/repo.git"
323 |     mock_repo_orm.local_checkout_path = "/tmp/test_repo_checkout"
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ S108
324 |     protocol_def.source_repository = mock_repo_orm
325 |     protocol_def.commit_hash = "testcommithash123"
    |

tests/orchestrator_tests.py:337:7: ANN201 Missing return type annotation for public function `test_clone_repo_if_checkout_path_does_not_exist`
    |
335 |   @patch("praxis.backend.core.orchestrator.os")
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
339 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:337:7: D102 Missing docstring in public method
    |
335 |   @patch("praxis.backend.core.orchestrator.os")
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
339 |   ):
    |

tests/orchestrator_tests.py:338:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
339 |   ):
340 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:338:32: ANN001 Missing type annotation for function argument `mock_os`
    |
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
339 |   ):
340 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:338:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
339 |   ):
340 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:338:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
336 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
337 |   def test_clone_repo_if_checkout_path_does_not_exist(
338 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
339 |   ):
340 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:347:5: ERA001 Found commented-out code
    |
346 |     mock_os.path.exists.return_value = False  # Checkout path does not exist
347 |     # mock_os.path.isdir.return_value = False # Consistent with path not existing
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
348 |     # mock_os.listdir # Not called if path doesn't exist
    |
    = help: Remove commented-out code

tests/orchestrator_tests.py:351:121: E501 Line too long (123 > 120)
    |
350 |     # Mock subprocess.run calls
351 |     # 1. git rev-parse (fails because dir doesn't exist yet, or _run_git_command not called directly, depends on structure)
    |                                                                                                                         ^^^ E501
352 |     #    The code calls os.path.exists first, then os.makedirs, then git clone.
353 |     #    git rev-parse --is-inside-work-tree is called *after* potential clone or if path exists.
    |

tests/orchestrator_tests.py:355:5: ERA001 Found commented-out code
    |
353 |     #    git rev-parse --is-inside-work-tree is called *after* potential clone or if path exists.
354 |     #    So, for this path, it's: os.path.exists(checkout_path) -> False
355 |     #                               os.makedirs(checkout_path)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
356 |     #                               _run_git_command(["git", "clone", ...])
357 |     #                               _run_git_command(["git", "checkout", ...])
    |
    = help: Remove commented-out code

tests/orchestrator_tests.py:356:5: ERA001 Found commented-out code
    |
354 |     #    So, for this path, it's: os.path.exists(checkout_path) -> False
355 |     #                               os.makedirs(checkout_path)
356 |     #                               _run_git_command(["git", "clone", ...])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
357 |     #                               _run_git_command(["git", "checkout", ...])
358 |     #                               _run_git_command(["git", "rev-parse", "HEAD"])
    |
    = help: Remove commented-out code

tests/orchestrator_tests.py:357:5: ERA001 Found commented-out code
    |
355 |     #                               os.makedirs(checkout_path)
356 |     #                               _run_git_command(["git", "clone", ...])
357 |     #                               _run_git_command(["git", "checkout", ...])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
358 |     #                               _run_git_command(["git", "rev-parse", "HEAD"])
    |
    = help: Remove commented-out code

tests/orchestrator_tests.py:358:5: ERA001 Found commented-out code
    |
356 |     #                               _run_git_command(["git", "clone", ...])
357 |     #                               _run_git_command(["git", "checkout", ...])
358 |     #                               _run_git_command(["git", "rev-parse", "HEAD"])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
359 | 
360 |     # Simulate successful subprocess calls
    |
    = help: Remove commented-out code

tests/orchestrator_tests.py:379:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
377 |       mock_import_module.return_value = mock_module
378 | 
379 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
380 | 
381 |     mock_os.path.exists.assert_any_call(checkout_path)
    |

tests/orchestrator_tests.py:384:5: F841 Local variable `expected_subprocess_calls` is assigned to but never used
    |
382 |     mock_os.makedirs.assert_called_once_with(checkout_path, exist_ok=True)
383 | 
384 |     expected_subprocess_calls = [
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ F841
385 |       call(
386 |         ["git", "clone", git_url, checkout_path],
    |
    = help: Remove assignment to unused variable `expected_subprocess_calls`

tests/orchestrator_tests.py:410:5: S101 Use of `assert` detected
    |
408 |     # Check if the actual calls match the expected calls, ignoring suppress_output for simplicity if necessary
409 |     # For more precise matching, you might need to inspect call_args objects.
410 |     assert mock_subprocess_run.call_count == 3
    |     ^^^^^^ S101
411 |     # Simplified check of commands, actual comparison is more involved due to suppress_output kwarg
412 |     assert mock_subprocess_run.call_args_list[0].args[0][:2] == ["git", "clone"]
    |

tests/orchestrator_tests.py:410:46: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
408 |     # Check if the actual calls match the expected calls, ignoring suppress_output for simplicity if necessary
409 |     # For more precise matching, you might need to inspect call_args objects.
410 |     assert mock_subprocess_run.call_count == 3
    |                                              ^ PLR2004
411 |     # Simplified check of commands, actual comparison is more involved due to suppress_output kwarg
412 |     assert mock_subprocess_run.call_args_list[0].args[0][:2] == ["git", "clone"]
    |

tests/orchestrator_tests.py:412:5: S101 Use of `assert` detected
    |
410 |     assert mock_subprocess_run.call_count == 3
411 |     # Simplified check of commands, actual comparison is more involved due to suppress_output kwarg
412 |     assert mock_subprocess_run.call_args_list[0].args[0][:2] == ["git", "clone"]
    |     ^^^^^^ S101
413 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "checkout"]
414 |     assert mock_subprocess_run.call_args_list[2].args[0][:3] == [
    |

tests/orchestrator_tests.py:413:5: S101 Use of `assert` detected
    |
411 |     # Simplified check of commands, actual comparison is more involved due to suppress_output kwarg
412 |     assert mock_subprocess_run.call_args_list[0].args[0][:2] == ["git", "clone"]
413 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "checkout"]
    |     ^^^^^^ S101
414 |     assert mock_subprocess_run.call_args_list[2].args[0][:3] == [
415 |       "git",
    |

tests/orchestrator_tests.py:414:5: S101 Use of `assert` detected
    |
412 |     assert mock_subprocess_run.call_args_list[0].args[0][:2] == ["git", "clone"]
413 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "checkout"]
414 |     assert mock_subprocess_run.call_args_list[2].args[0][:3] == [
    |     ^^^^^^ S101
415 |       "git",
416 |       "rev-parse",
    |

tests/orchestrator_tests.py:422:7: ANN201 Missing return type annotation for public function `test_clone_repo_if_checkout_path_exists_empty_not_git`
    |
420 |   @patch("praxis.backend.core.orchestrator.os")
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
424 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:422:7: D102 Missing docstring in public method
    |
420 |   @patch("praxis.backend.core.orchestrator.os")
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
424 |   ):
    |

tests/orchestrator_tests.py:423:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
424 |   ):
425 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:423:32: ANN001 Missing type annotation for function argument `mock_os`
    |
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
424 |   ):
425 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:423:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
424 |   ):
425 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:423:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
421 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
422 |   def test_clone_repo_if_checkout_path_exists_empty_not_git(
423 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
424 |   ):
425 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:428:5: F841 Local variable `git_url` is assigned to but never used
    |
426 |     protocol_def, _ = mock_git_protocol_def_orm
427 |     checkout_path = protocol_def.source_repository.local_checkout_path
428 |     git_url = protocol_def.source_repository.git_url
    |     ^^^^^^^ F841
429 |     commit_hash = protocol_def.commit_hash
    |
    = help: Remove assignment to unused variable `git_url`

tests/orchestrator_tests.py:460:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
458 |       setattr(mock_module, protocol_def.function_name, mock_protocol_func)
459 |       mock_import_module.return_value = mock_module
460 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
461 | 
462 |     mock_os.path.exists.assert_called_with(checkout_path)
    |

tests/orchestrator_tests.py:467:5: S101 Use of `assert` detected
    |
466 |     # Check subprocess calls
467 |     assert mock_subprocess_run.call_count == 4
    |     ^^^^^^ S101
468 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
469 |       "git",
    |

tests/orchestrator_tests.py:467:46: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
466 |     # Check subprocess calls
467 |     assert mock_subprocess_run.call_count == 4
    |                                              ^ PLR2004
468 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
469 |       "git",
    |

tests/orchestrator_tests.py:468:5: S101 Use of `assert` detected
    |
466 |     # Check subprocess calls
467 |     assert mock_subprocess_run.call_count == 4
468 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
    |     ^^^^^^ S101
469 |       "git",
470 |       "rev-parse",
    |

tests/orchestrator_tests.py:473:5: S101 Use of `assert` detected
    |
471 |       "--is-inside-work-tree",
472 |     ]
473 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "clone"]
    |     ^^^^^^ S101
474 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
475 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
    |

tests/orchestrator_tests.py:474:5: S101 Use of `assert` detected
    |
472 |     ]
473 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "clone"]
474 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
    |     ^^^^^^ S101
475 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
476 |       "git",
    |

tests/orchestrator_tests.py:475:5: S101 Use of `assert` detected
    |
473 |     assert mock_subprocess_run.call_args_list[1].args[0][:2] == ["git", "clone"]
474 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
475 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
    |     ^^^^^^ S101
476 |       "git",
477 |       "rev-parse",
    |

tests/orchestrator_tests.py:483:7: ANN201 Missing return type annotation for public function `test_fetch_repo_if_checkout_path_is_git_repo`
    |
481 |   @patch("praxis.backend.core.orchestrator.os")
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
485 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:483:7: D102 Missing docstring in public method
    |
481 |   @patch("praxis.backend.core.orchestrator.os")
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
485 |   ):
    |

tests/orchestrator_tests.py:484:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
485 |   ):
486 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:484:32: ANN001 Missing type annotation for function argument `mock_os`
    |
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
485 |   ):
486 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:484:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
485 |   ):
486 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:484:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
482 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
483 |   def test_fetch_repo_if_checkout_path_is_git_repo(
484 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
485 |   ):
486 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:514:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
512 |       setattr(mock_module, protocol_def.function_name, mock_protocol_func)
513 |       mock_import_module.return_value = mock_module
514 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
515 | 
516 |     mock_os.path.exists.assert_called_with(checkout_path)
    |

tests/orchestrator_tests.py:520:5: S101 Use of `assert` detected
    |
518 |     mock_os.makedirs.assert_not_called()
519 | 
520 |     assert mock_subprocess_run.call_count == 4
    |     ^^^^^^ S101
521 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
522 |       "git",
    |

tests/orchestrator_tests.py:520:46: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
518 |     mock_os.makedirs.assert_not_called()
519 | 
520 |     assert mock_subprocess_run.call_count == 4
    |                                              ^ PLR2004
521 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
522 |       "git",
    |

tests/orchestrator_tests.py:521:5: S101 Use of `assert` detected
    |
520 |     assert mock_subprocess_run.call_count == 4
521 |     assert mock_subprocess_run.call_args_list[0].args[0] == [
    |     ^^^^^^ S101
522 |       "git",
523 |       "rev-parse",
    |

tests/orchestrator_tests.py:526:5: S101 Use of `assert` detected
    |
524 |       "--is-inside-work-tree",
525 |     ]
526 |     assert mock_subprocess_run.call_args_list[1].args[0] == ["git", "fetch", "origin"]
    |     ^^^^^^ S101
527 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
528 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
    |

tests/orchestrator_tests.py:527:5: S101 Use of `assert` detected
    |
525 |     ]
526 |     assert mock_subprocess_run.call_args_list[1].args[0] == ["git", "fetch", "origin"]
527 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
    |     ^^^^^^ S101
528 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
529 |       "git",
    |

tests/orchestrator_tests.py:528:5: S101 Use of `assert` detected
    |
526 |     assert mock_subprocess_run.call_args_list[1].args[0] == ["git", "fetch", "origin"]
527 |     assert mock_subprocess_run.call_args_list[2].args[0][:2] == ["git", "checkout"]
528 |     assert mock_subprocess_run.call_args_list[3].args[0][:3] == [
    |     ^^^^^^ S101
529 |       "git",
530 |       "rev-parse",
    |

tests/orchestrator_tests.py:536:7: ANN201 Missing return type annotation for public function `test_checkout_path_exists_not_git_not_empty_raises_value_error`
    |
534 |   @patch("praxis.backend.core.orchestrator.os")
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
538 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:536:7: D102 Missing docstring in public method
    |
534 |   @patch("praxis.backend.core.orchestrator.os")
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
538 |   ):
    |

tests/orchestrator_tests.py:537:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
538 |   ):
539 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:537:32: ANN001 Missing type annotation for function argument `mock_os`
    |
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
538 |   ):
539 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:537:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
538 |   ):
539 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:537:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
535 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
536 |   def test_checkout_path_exists_not_git_not_empty_raises_value_error(
537 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
538 |   ):
539 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:560:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
558 |       match=f"Path '{checkout_path}' exists, is not a Git repository, and is not empty.",
559 |     ):
560 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
561 | 
562 |     mock_os.path.exists.assert_called_once_with(checkout_path)
    |

tests/orchestrator_tests.py:576:7: ANN201 Missing return type annotation for public function `test_git_checkout_head_verification_fail_raises_runtime_error`
    |
574 |   @patch("praxis.backend.core.orchestrator.os")
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
578 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:576:7: D102 Missing docstring in public method
    |
574 |   @patch("praxis.backend.core.orchestrator.os")
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
578 |   ):
    |

tests/orchestrator_tests.py:577:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
578 |   ):
579 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:577:32: ANN001 Missing type annotation for function argument `mock_os`
    |
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
578 |   ):
579 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:577:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
578 |   ):
579 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:577:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
575 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
576 |   def test_git_checkout_head_verification_fail_raises_runtime_error(
577 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
578 |   ):
579 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:581:5: F841 Local variable `checkout_path` is assigned to but never used
    |
579 |     orchestrator, _ = orchestrator_instance
580 |     protocol_def, _ = mock_git_protocol_def_orm
581 |     checkout_path = protocol_def.source_repository.local_checkout_path
    |     ^^^^^^^^^^^^^ F841
582 |     commit_hash = protocol_def.commit_hash
583 |     wrong_commit_hash = "wronghash789"
    |
    = help: Remove assignment to unused variable `checkout_path`

tests/orchestrator_tests.py:605:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
603 |       match=f"Failed to checkout commit '{commit_hash}'. HEAD is at '{wrong_commit_hash}'",
604 |     ):
605 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
606 | 
607 |     assert (
    |

tests/orchestrator_tests.py:607:5: S101 Use of `assert` detected
    |
605 |       orchestrator._prepare_protocol_code(protocol_def)
606 | 
607 |     assert (
    |     ^^^^^^ S101
608 |       mock_subprocess_run.call_count == 5
609 |     )  # rev-parse, fetch, checkout, rev-parse HEAD, rev-parse target^{commit}
    |

tests/orchestrator_tests.py:608:41: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
607 |     assert (
608 |       mock_subprocess_run.call_count == 5
    |                                         ^ PLR2004
609 |     )  # rev-parse, fetch, checkout, rev-parse HEAD, rev-parse target^{commit}
    |

tests/orchestrator_tests.py:613:7: ANN201 Missing return type annotation for public function `test_git_command_fails_raises_runtime_error`
    |
611 |   @patch("praxis.backend.core.orchestrator.os")
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
615 |   ):
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:613:7: D102 Missing docstring in public method
    |
611 |   @patch("praxis.backend.core.orchestrator.os")
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
615 |   ):
    |

tests/orchestrator_tests.py:614:11: ANN001 Missing type annotation for function argument `mock_subprocess_run`
    |
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |           ^^^^^^^^^^^^^^^^^^^ ANN001
615 |   ):
616 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:614:32: ANN001 Missing type annotation for function argument `mock_os`
    |
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                ^^^^^^^ ANN001
615 |   ):
616 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:614:41: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
615 |   ):
616 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:614:64: ANN001 Missing type annotation for function argument `mock_git_protocol_def_orm`
    |
612 |   @patch("praxis.backend.core.orchestrator.subprocess.run")
613 |   def test_git_command_fails_raises_runtime_error(
614 |     self, mock_subprocess_run, mock_os, orchestrator_instance, mock_git_protocol_def_orm,
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
615 |   ):
616 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:618:5: F841 Local variable `checkout_path` is assigned to but never used
    |
616 |     orchestrator, _ = orchestrator_instance
617 |     protocol_def, _ = mock_git_protocol_def_orm
618 |     checkout_path = protocol_def.source_repository.local_checkout_path
    |     ^^^^^^^^^^^^^ F841
619 | 
620 |     mock_os.path.exists.return_value = True  # Is a git repo
    |
    = help: Remove assignment to unused variable `checkout_path`

tests/orchestrator_tests.py:633:7: SLF001 Private member accessed: `_prepare_protocol_code`
    |
632 |     with pytest.raises(RuntimeError, match="Command 'git fetch origin' failed"):
633 |       orchestrator._prepare_protocol_code(protocol_def)
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
634 | 
635 |     assert mock_subprocess_run.call_count == 2
    |

tests/orchestrator_tests.py:635:5: S101 Use of `assert` detected
    |
633 |       orchestrator._prepare_protocol_code(protocol_def)
634 | 
635 |     assert mock_subprocess_run.call_count == 2
    |     ^^^^^^ S101
636 | 
637 |   def test_no_git_source_skips_git_ops(
    |

tests/orchestrator_tests.py:635:46: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
633 |       orchestrator._prepare_protocol_code(protocol_def)
634 | 
635 |     assert mock_subprocess_run.call_count == 2
    |                                              ^ PLR2004
636 | 
637 |   def test_no_git_source_skips_git_ops(
    |

tests/orchestrator_tests.py:637:7: ANN201 Missing return type annotation for public function `test_no_git_source_skips_git_ops`
    |
635 |     assert mock_subprocess_run.call_count == 2
636 | 
637 |   def test_no_git_source_skips_git_ops(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
638 |     self,
639 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:637:7: D102 Missing docstring in public method
    |
635 |     assert mock_subprocess_run.call_count == 2
636 | 
637 |   def test_no_git_source_skips_git_ops(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
638 |     self,
639 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:639:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
637 |   def test_no_git_source_skips_git_ops(
638 |     self,
639 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
640 |     mock_protocol_def_orm,  # Uses standard fixture, not git one
641 |   ):
    |

tests/orchestrator_tests.py:640:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
638 |     self,
639 |     orchestrator_instance,
640 |     mock_protocol_def_orm,  # Uses standard fixture, not git one
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
641 |   ):
642 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:651:5: S101 Use of `assert` detected
    |
649 |     protocol_def.source_repository = None
650 |     # It should have a file system source from the fixture
651 |     assert protocol_def.file_system_source is not None
    |     ^^^^^^ S101
652 | 
653 |     with patch("importlib.import_module") as mock_import_module, patch(
    |

tests/orchestrator_tests.py:669:9: SLF001 Private member accessed: `_prepare_protocol_code`
    |
667 |       # For this test, we only care that no git ops are attempted.
668 |       try:
669 |         orchestrator._prepare_protocol_code(protocol_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
670 |       except (
671 |         ValueError
    |

tests/orchestrator_tests.py:673:9: T201 `print` found
    |
671 |         ValueError
672 |       ) as e:  # Catching potential errors from non-git path if files dont exist
673 |         print(f"Caught ValueError, likely from file system path: {e}")
    |         ^^^^^ T201
674 |       except ImportError as e:
675 |         print(f"Caught ImportError, likely from file system path: {e}")
    |
    = help: Remove `print`

tests/orchestrator_tests.py:675:9: T201 `print` found
    |
673 |         print(f"Caught ValueError, likely from file system path: {e}")
674 |       except ImportError as e:
675 |         print(f"Caught ImportError, likely from file system path: {e}")
    |         ^^^^^ T201
676 | 
677 |       mock_subproc_run.assert_not_called()  # Key assertion: no git commands run
    |
    = help: Remove `print`

tests/orchestrator_tests.py:680:7: D101 Missing docstring in public class
    |
680 | class TestOrchestratorArgumentPreparation:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
681 |   # Covers deck loading (ORCH-7) and asset inference (ORCH-8) in _prepare_arguments
    |

tests/orchestrator_tests.py:684:7: ANN201 Missing return type annotation for public function `mock_protocol_wrapper_func_for_args`
    |
683 |   @pytest.fixture
684 |   def mock_protocol_wrapper_func_for_args(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
685 |     # This mock is for _prepare_arguments to inspect its signature for asset inference
686 |     # The actual execution of this mock is not part of _prepare_arguments
    |
    = help: Add return type annotation

tests/orchestrator_tests.py:684:7: D102 Missing docstring in public method
    |
683 |   @pytest.fixture
684 |   def mock_protocol_wrapper_func_for_args(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
685 |     # This mock is for _prepare_arguments to inspect its signature for asset inference
686 |     # The actual execution of this mock is not part of _prepare_arguments
    |

tests/orchestrator_tests.py:693:7: ANN201 Missing return type annotation for public function `test_deck_loading_with_string_input`
    |
692 |   # --- Deck Loading Tests (ORCH-7) ---
693 |   def test_deck_loading_with_string_input(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
694 |     self,
695 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:693:7: D102 Missing docstring in public method
    |
692 |   # --- Deck Loading Tests (ORCH-7) ---
693 |   def test_deck_loading_with_string_input(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
694 |     self,
695 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:695:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
693 |   def test_deck_loading_with_string_input(
694 |     self,
695 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
696 |     mock_protocol_def_orm,
697 |     mock_db_session,
    |

tests/orchestrator_tests.py:696:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
694 |     self,
695 |     orchestrator_instance,
696 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
697 |     mock_db_session,
698 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:697:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
695 |     orchestrator_instance,
696 |     mock_protocol_def_orm,
697 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
698 |     mock_protocol_wrapper_func_for_args,
699 |   ):
    |

tests/orchestrator_tests.py:697:5: ARG002 Unused method argument: `mock_db_session`
    |
695 |     orchestrator_instance,
696 |     mock_protocol_def_orm,
697 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
698 |     mock_protocol_wrapper_func_for_args,
699 |   ):
    |

tests/orchestrator_tests.py:698:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
696 |     mock_protocol_def_orm,
697 |     mock_db_session,
698 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
699 |   ):
700 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:718:24: SLF001 Private member accessed: `_prepare_arguments`
    |
716 |     )
717 | 
718 |     final_args, _, _ = orchestrator._prepare_arguments(
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
719 |       protocol_def,
720 |       decorator_meta,
    |

tests/orchestrator_tests.py:730:5: S101 Use of `assert` detected
    |
728 |       protocol_run_accession_id="test_run",
729 |     )
730 |     assert final_args["my_deck"] == mock_live_deck_obj
    |     ^^^^^^ S101
731 | 
732 |   def test_deck_loading_with_plrdeck_input(
    |

tests/orchestrator_tests.py:732:7: ANN201 Missing return type annotation for public function `test_deck_loading_with_plrdeck_input`
    |
730 |     assert final_args["my_deck"] == mock_live_deck_obj
731 | 
732 |   def test_deck_loading_with_plrdeck_input(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
733 |     self,
734 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:732:7: D102 Missing docstring in public method
    |
730 |     assert final_args["my_deck"] == mock_live_deck_obj
731 | 
732 |   def test_deck_loading_with_plrdeck_input(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
733 |     self,
734 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:734:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
732 |   def test_deck_loading_with_plrdeck_input(
733 |     self,
734 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
735 |     mock_protocol_def_orm,
736 |     mock_db_session,
    |

tests/orchestrator_tests.py:735:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
733 |     self,
734 |     orchestrator_instance,
735 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
736 |     mock_db_session,
737 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:736:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
734 |     orchestrator_instance,
735 |     mock_protocol_def_orm,
736 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
737 |     mock_protocol_wrapper_func_for_args,
738 |   ):
    |

tests/orchestrator_tests.py:736:5: ARG002 Unused method argument: `mock_db_session`
    |
734 |     orchestrator_instance,
735 |     mock_protocol_def_orm,
736 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
737 |     mock_protocol_wrapper_func_for_args,
738 |   ):
    |

tests/orchestrator_tests.py:737:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
735 |     mock_protocol_def_orm,
736 |     mock_db_session,
737 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
738 |   ):
739 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:760:24: SLF001 Private member accessed: `_prepare_arguments`
    |
758 |     )
759 | 
760 |     final_args, _, _ = orchestrator._prepare_arguments(
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
761 |       protocol_def,
762 |       decorator_meta,
    |

tests/orchestrator_tests.py:772:5: S101 Use of `assert` detected
    |
770 |       protocol_run_accession_id="test_run_plr",
771 |     )
772 |     assert final_args["the_deck"] == mock_live_deck_obj
    |     ^^^^^^ S101
773 | 
774 |   def test_deck_loading_deck_param_not_provided_mandatory(
    |

tests/orchestrator_tests.py:774:7: ANN201 Missing return type annotation for public function `test_deck_loading_deck_param_not_provided_mandatory`
    |
772 |     assert final_args["the_deck"] == mock_live_deck_obj
773 | 
774 |   def test_deck_loading_deck_param_not_provided_mandatory(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
775 |     self,
776 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:774:7: D102 Missing docstring in public method
    |
772 |     assert final_args["the_deck"] == mock_live_deck_obj
773 | 
774 |   def test_deck_loading_deck_param_not_provided_mandatory(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
775 |     self,
776 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:776:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
774 |   def test_deck_loading_deck_param_not_provided_mandatory(
775 |     self,
776 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
777 |     mock_protocol_def_orm,
778 |     mock_db_session,
    |

tests/orchestrator_tests.py:777:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
775 |     self,
776 |     orchestrator_instance,
777 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
778 |     mock_db_session,
779 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:778:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
776 |     orchestrator_instance,
777 |     mock_protocol_def_orm,
778 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
779 |     mock_protocol_wrapper_func_for_args,
780 |   ):
    |

tests/orchestrator_tests.py:778:5: ARG002 Unused method argument: `mock_db_session`
    |
776 |     orchestrator_instance,
777 |     mock_protocol_def_orm,
778 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
779 |     mock_protocol_wrapper_func_for_args,
780 |   ):
    |

tests/orchestrator_tests.py:779:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
777 |     mock_protocol_def_orm,
778 |     mock_db_session,
779 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
780 |   ):
781 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:800:7: SLF001 Private member accessed: `_prepare_arguments`
    |
798 |       ValueError, match="Mandatory deck parameter 'mandatory_deck' was not provided",
799 |     ):
800 |       orchestrator._prepare_arguments(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
801 |         protocol_def,
802 |         decorator_meta,
    |

tests/orchestrator_tests.py:809:7: ANN201 Missing return type annotation for public function `test_deck_loading_deck_param_not_provided_optional`
    |
807 |     orchestrator.asset_manager.apply_deck_instance.assert_not_called()
808 | 
809 |   def test_deck_loading_deck_param_not_provided_optional(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
810 |     self,
811 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:809:7: D102 Missing docstring in public method
    |
807 |     orchestrator.asset_manager.apply_deck_instance.assert_not_called()
808 | 
809 |   def test_deck_loading_deck_param_not_provided_optional(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
810 |     self,
811 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:811:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
809 |   def test_deck_loading_deck_param_not_provided_optional(
810 |     self,
811 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
812 |     mock_protocol_def_orm,
813 |     mock_db_session,
    |

tests/orchestrator_tests.py:812:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
810 |     self,
811 |     orchestrator_instance,
812 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
813 |     mock_db_session,
814 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:813:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
811 |     orchestrator_instance,
812 |     mock_protocol_def_orm,
813 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
814 |     mock_protocol_wrapper_func_for_args,
815 |   ):
    |

tests/orchestrator_tests.py:813:5: ARG002 Unused method argument: `mock_db_session`
    |
811 |     orchestrator_instance,
812 |     mock_protocol_def_orm,
813 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
814 |     mock_protocol_wrapper_func_for_args,
815 |   ):
    |

tests/orchestrator_tests.py:814:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
812 |     mock_protocol_def_orm,
813 |     mock_db_session,
814 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
815 |   ):
816 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:831:24: SLF001 Private member accessed: `_prepare_arguments`
    |
829 |     orchestrator.asset_manager.apply_deck_instance = MagicMock()
830 | 
831 |     final_args, _, _ = orchestrator._prepare_arguments(
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
832 |       protocol_def,
833 |       decorator_meta,
    |

tests/orchestrator_tests.py:840:5: S101 Use of `assert` detected
    |
839 |     orchestrator.asset_manager.apply_deck_instance.assert_not_called()
840 |     assert (
    |     ^^^^^^ S101
841 |       "optional_deck" not in final_args
842 |     )  # Or assert it's None if explicitly set for optional missing
    |

tests/orchestrator_tests.py:844:7: ANN201 Missing return type annotation for public function `test_deck_loading_apply_deck_config_fails`
    |
842 |     )  # Or assert it's None if explicitly set for optional missing
843 | 
844 |   def test_deck_loading_apply_deck_config_fails(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
845 |     self,
846 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:844:7: D102 Missing docstring in public method
    |
842 |     )  # Or assert it's None if explicitly set for optional missing
843 | 
844 |   def test_deck_loading_apply_deck_config_fails(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
845 |     self,
846 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:846:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
844 |   def test_deck_loading_apply_deck_config_fails(
845 |     self,
846 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
847 |     mock_protocol_def_orm,
848 |     mock_db_session,
    |

tests/orchestrator_tests.py:847:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
845 |     self,
846 |     orchestrator_instance,
847 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
848 |     mock_db_session,
849 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:848:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
846 |     orchestrator_instance,
847 |     mock_protocol_def_orm,
848 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
849 |     mock_protocol_wrapper_func_for_args,
850 |   ):
    |

tests/orchestrator_tests.py:848:5: ARG002 Unused method argument: `mock_db_session`
    |
846 |     orchestrator_instance,
847 |     mock_protocol_def_orm,
848 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
849 |     mock_protocol_wrapper_func_for_args,
850 |   ):
    |

tests/orchestrator_tests.py:849:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
847 |     mock_protocol_def_orm,
848 |     mock_db_session,
849 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
850 |   ):
851 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:871:7: SLF001 Private member accessed: `_prepare_arguments`
    |
869 |       ValueError, match="Failed to acquire mandatory asset 'deck_will_fail'",
870 |     ):  # Error is wrapped
871 |       orchestrator._prepare_arguments(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
872 |         protocol_def,
873 |         decorator_meta,
    |

tests/orchestrator_tests.py:879:7: ANN201 Missing return type annotation for public function `test_deck_loading_preconfigure_deck_false`
    |
877 |       )
878 | 
879 |   def test_deck_loading_preconfigure_deck_false(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
880 |     self,
881 |     orchestrator_instance,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:879:7: D102 Missing docstring in public method
    |
877 |       )
878 | 
879 |   def test_deck_loading_preconfigure_deck_false(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
880 |     self,
881 |     orchestrator_instance,
    |

tests/orchestrator_tests.py:881:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
879 |   def test_deck_loading_preconfigure_deck_false(
880 |     self,
881 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
882 |     mock_protocol_def_orm,
883 |     mock_db_session,
    |

tests/orchestrator_tests.py:882:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
880 |     self,
881 |     orchestrator_instance,
882 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
883 |     mock_db_session,
884 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:883:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
881 |     orchestrator_instance,
882 |     mock_protocol_def_orm,
883 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
884 |     mock_protocol_wrapper_func_for_args,
885 |   ):
    |

tests/orchestrator_tests.py:883:5: ARG002 Unused method argument: `mock_db_session`
    |
881 |     orchestrator_instance,
882 |     mock_protocol_def_orm,
883 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ARG002
884 |     mock_protocol_wrapper_func_for_args,
885 |   ):
    |

tests/orchestrator_tests.py:884:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
882 |     mock_protocol_def_orm,
883 |     mock_db_session,
884 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
885 |   ):
886 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:903:24: SLF001 Private member accessed: `_prepare_arguments`
    |
901 |     orchestrator.asset_manager.apply_deck_instance = MagicMock()
902 | 
903 |     final_args, _, _ = orchestrator._prepare_arguments(
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
904 |       protocol_def,
905 |       decorator_meta,
    |

tests/orchestrator_tests.py:932:5: S101 Use of `assert` detected
    |
930 |     # Option 2: _prepare_arguments needs adjustment.
931 |     # Based on current _prepare_arguments, if is_deck_param=True, it's only handled by preconfigure_deck logic.
932 |     assert "my_deck_no_config" not in final_args  # Current behavior
    |     ^^^^^^ S101
933 | 
934 |   # --- Asset Inference Tests (ORCH-8) ---
    |

tests/orchestrator_tests.py:939:7: ANN201 Missing return type annotation for public function `test_infer_resource_asset_from_type_hint`
    |
938 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
939 |   def test_infer_resource_asset_from_type_hint(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
940 |     self,
941 |     mock_asset_data_service_in_orchestrator,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:939:7: D102 Missing docstring in public method
    |
938 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
939 |   def test_infer_resource_asset_from_type_hint(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
940 |     self,
941 |     mock_asset_data_service_in_orchestrator,
    |

tests/orchestrator_tests.py:941:5: ANN001 Missing type annotation for function argument `mock_asset_data_service_in_orchestrator`
    |
939 |   def test_infer_resource_asset_from_type_hint(
940 |     self,
941 |     mock_asset_data_service_in_orchestrator,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
942 |     orchestrator_instance,
943 |     mock_protocol_def_orm,
    |

tests/orchestrator_tests.py:942:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
940 |     self,
941 |     mock_asset_data_service_in_orchestrator,
942 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
943 |     mock_protocol_def_orm,
944 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:943:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
941 |     mock_asset_data_service_in_orchestrator,
942 |     orchestrator_instance,
943 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
944 |     mock_protocol_wrapper_func_for_args,
945 |     mock_db_session,
    |

tests/orchestrator_tests.py:944:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
942 |     orchestrator_instance,
943 |     mock_protocol_def_orm,
944 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
945 |     mock_db_session,
946 |   ):
    |

tests/orchestrator_tests.py:945:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
943 |     mock_protocol_def_orm,
944 |     mock_protocol_wrapper_func_for_args,
945 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
946 |   ):
947 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:951:9: ANN202 Missing return type annotation for private function `original_protocol`
    |
950 |     # Define a dummy protocol function with a resource type hint
951 |     def original_protocol(plate_param: MockPlrPlate):
    |         ^^^^^^^^^^^^^^^^^ ANN202
952 |       pass
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:966:38: SLF001 Private member accessed: `_prepare_arguments`
    |
964 |     )
965 | 
966 |     final_args, _, acquired_assets = orchestrator._prepare_arguments(
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
967 |       protocol_def,
968 |       decorator_meta,
    |

tests/orchestrator_tests.py:982:5: S101 Use of `assert` detected
    |
980 |     )
981 | 
982 |     assert called_asset_req.name == "plate_param"
    |     ^^^^^^ S101
983 |     assert called_asset_req.actual_type_str == "mock_plate_definition_name"
984 |     assert not called_asset_req.optional
    |

tests/orchestrator_tests.py:983:5: S101 Use of `assert` detected
    |
982 |     assert called_asset_req.name == "plate_param"
983 |     assert called_asset_req.actual_type_str == "mock_plate_definition_name"
    |     ^^^^^^ S101
984 |     assert not called_asset_req.optional
985 |     assert final_args["plate_param"] == live_asset_mock
    |

tests/orchestrator_tests.py:984:5: S101 Use of `assert` detected
    |
982 |     assert called_asset_req.name == "plate_param"
983 |     assert called_asset_req.actual_type_str == "mock_plate_definition_name"
984 |     assert not called_asset_req.optional
    |     ^^^^^^ S101
985 |     assert final_args["plate_param"] == live_asset_mock
986 |     assert len(acquired_assets) == 1
    |

tests/orchestrator_tests.py:985:5: S101 Use of `assert` detected
    |
983 |     assert called_asset_req.actual_type_str == "mock_plate_definition_name"
984 |     assert not called_asset_req.optional
985 |     assert final_args["plate_param"] == live_asset_mock
    |     ^^^^^^ S101
986 |     assert len(acquired_assets) == 1
987 |     assert acquired_assets[0]["name_in_protocol"] == "plate_param"
    |

tests/orchestrator_tests.py:986:5: S101 Use of `assert` detected
    |
984 |     assert not called_asset_req.optional
985 |     assert final_args["plate_param"] == live_asset_mock
986 |     assert len(acquired_assets) == 1
    |     ^^^^^^ S101
987 |     assert acquired_assets[0]["name_in_protocol"] == "plate_param"
    |

tests/orchestrator_tests.py:987:5: S101 Use of `assert` detected
    |
985 |     assert final_args["plate_param"] == live_asset_mock
986 |     assert len(acquired_assets) == 1
987 |     assert acquired_assets[0]["name_in_protocol"] == "plate_param"
    |     ^^^^^^ S101
988 | 
989 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
    |

tests/orchestrator_tests.py:990:7: ANN201 Missing return type annotation for public function `test_infer_machine_asset_from_type_hint`
    |
989 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
990 |   def test_infer_machine_asset_from_type_hint(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
991 |     self,
992 |     mock_asset_data_service_in_orchestrator,
    |
    = help: Add return type annotation: `None`

tests/orchestrator_tests.py:990:7: D102 Missing docstring in public method
    |
989 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
990 |   def test_infer_machine_asset_from_type_hint(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
991 |     self,
992 |     mock_asset_data_service_in_orchestrator,
    |

tests/orchestrator_tests.py:992:5: ANN001 Missing type annotation for function argument `mock_asset_data_service_in_orchestrator`
    |
990 |   def test_infer_machine_asset_from_type_hint(
991 |     self,
992 |     mock_asset_data_service_in_orchestrator,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
993 |     orchestrator_instance,
994 |     mock_protocol_def_orm,
    |

tests/orchestrator_tests.py:993:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
    |
991 |     self,
992 |     mock_asset_data_service_in_orchestrator,
993 |     orchestrator_instance,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
994 |     mock_protocol_def_orm,
995 |     mock_protocol_wrapper_func_for_args,
    |

tests/orchestrator_tests.py:994:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
    |
992 |     mock_asset_data_service_in_orchestrator,
993 |     orchestrator_instance,
994 |     mock_protocol_def_orm,
    |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
995 |     mock_protocol_wrapper_func_for_args,
996 |     mock_db_session,
    |

tests/orchestrator_tests.py:995:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
    |
993 |     orchestrator_instance,
994 |     mock_protocol_def_orm,
995 |     mock_protocol_wrapper_func_for_args,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
996 |     mock_db_session,
997 |   ):
    |

tests/orchestrator_tests.py:996:5: ANN001 Missing type annotation for function argument `mock_db_session`
    |
994 |     mock_protocol_def_orm,
995 |     mock_protocol_wrapper_func_for_args,
996 |     mock_db_session,
    |     ^^^^^^^^^^^^^^^ ANN001
997 |   ):
998 |     orchestrator, _ = orchestrator_instance
    |

tests/orchestrator_tests.py:1001:9: ANN202 Missing return type annotation for private function `original_protocol`
     |
 999 |     protocol_def, decorator_meta = mock_protocol_def_orm
1000 | 
1001 |     def original_protocol(pipette_param: MockPlrPipette):
     |         ^^^^^^^^^^^^^^^^^ ANN202
1002 |       pass
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1013:38: SLF001 Private member accessed: `_prepare_arguments`
     |
1011 |     )
1012 | 
1013 |     final_args, _, acquired_assets = orchestrator._prepare_arguments(
     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1014 |       protocol_def,
1015 |       decorator_meta,
     |

tests/orchestrator_tests.py:1030:5: S101 Use of `assert` detected
     |
1028 |     )
1029 | 
1030 |     assert called_asset_req.name == "pipette_param"
     |     ^^^^^^ S101
1031 |     assert (
1032 |       called_asset_req.actual_type_str == "pylabrobot.liquid_handling.pipettes.Pipette"
     |

tests/orchestrator_tests.py:1031:5: S101 Use of `assert` detected
     |
1030 |     assert called_asset_req.name == "pipette_param"
1031 |     assert (
     |     ^^^^^^ S101
1032 |       called_asset_req.actual_type_str == "pylabrobot.liquid_handling.pipettes.Pipette"
1033 |     )  # FQN used for machines
     |

tests/orchestrator_tests.py:1034:5: S101 Use of `assert` detected
     |
1032 |       called_asset_req.actual_type_str == "pylabrobot.liquid_handling.pipettes.Pipette"
1033 |     )  # FQN used for machines
1034 |     assert not called_asset_req.optional
     |     ^^^^^^ S101
1035 |     assert final_args["pipette_param"] == live_asset_mock
1036 |     assert len(acquired_assets) == 1
     |

tests/orchestrator_tests.py:1035:5: S101 Use of `assert` detected
     |
1033 |     )  # FQN used for machines
1034 |     assert not called_asset_req.optional
1035 |     assert final_args["pipette_param"] == live_asset_mock
     |     ^^^^^^ S101
1036 |     assert len(acquired_assets) == 1
     |

tests/orchestrator_tests.py:1036:5: S101 Use of `assert` detected
     |
1034 |     assert not called_asset_req.optional
1035 |     assert final_args["pipette_param"] == live_asset_mock
1036 |     assert len(acquired_assets) == 1
     |     ^^^^^^ S101
1037 | 
1038 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
     |

tests/orchestrator_tests.py:1039:7: ANN201 Missing return type annotation for public function `test_infer_optional_asset_acquisition_fails`
     |
1038 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
1039 |   def test_infer_optional_asset_acquisition_fails(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1040 |     self,
1041 |     mock_asset_data_service_in_orchestrator,
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1039:7: D102 Missing docstring in public method
     |
1038 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
1039 |   def test_infer_optional_asset_acquisition_fails(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
1040 |     self,
1041 |     mock_asset_data_service_in_orchestrator,
     |

tests/orchestrator_tests.py:1041:5: ANN001 Missing type annotation for function argument `mock_asset_data_service_in_orchestrator`
     |
1039 |   def test_infer_optional_asset_acquisition_fails(
1040 |     self,
1041 |     mock_asset_data_service_in_orchestrator,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1042 |     orchestrator_instance,
1043 |     mock_protocol_def_orm,
     |

tests/orchestrator_tests.py:1042:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
     |
1040 |     self,
1041 |     mock_asset_data_service_in_orchestrator,
1042 |     orchestrator_instance,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1043 |     mock_protocol_def_orm,
1044 |     mock_protocol_wrapper_func_for_args,
     |

tests/orchestrator_tests.py:1043:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
     |
1041 |     mock_asset_data_service_in_orchestrator,
1042 |     orchestrator_instance,
1043 |     mock_protocol_def_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1044 |     mock_protocol_wrapper_func_for_args,
1045 |     mock_db_session,
     |

tests/orchestrator_tests.py:1044:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
     |
1042 |     orchestrator_instance,
1043 |     mock_protocol_def_orm,
1044 |     mock_protocol_wrapper_func_for_args,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1045 |     mock_db_session,
1046 |   ):
     |

tests/orchestrator_tests.py:1045:5: ANN001 Missing type annotation for function argument `mock_db_session`
     |
1043 |     mock_protocol_def_orm,
1044 |     mock_protocol_wrapper_func_for_args,
1045 |     mock_db_session,
     |     ^^^^^^^^^^^^^^^ ANN001
1046 |   ):
1047 |     orchestrator, _ = orchestrator_instance
     |

tests/orchestrator_tests.py:1045:5: ARG002 Unused method argument: `mock_db_session`
     |
1043 |     mock_protocol_def_orm,
1044 |     mock_protocol_wrapper_func_for_args,
1045 |     mock_db_session,
     |     ^^^^^^^^^^^^^^^ ARG002
1046 |   ):
1047 |     orchestrator, _ = orchestrator_instance
     |

tests/orchestrator_tests.py:1052:9: ANN202 Missing return type annotation for private function `original_protocol`
     |
1050 |     # Need to import Optional from typing for the signature
1051 | 
1052 |     def original_protocol(optional_rack: MockPlrTipRack | None):
     |         ^^^^^^^^^^^^^^^^^ ANN202
1053 |       pass
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1057:121: E501 Line too long (134 > 120)
     |
1055 |     mock_protocol_wrapper_func_for_args.__wrapped__ = original_protocol
1056 | 
1057 |     mock_asset_data_service_in_orchestrator.get_resource_definition_by_fqn.return_value = None  # Treat as machine for simplicity here
     |                                                                                                                         ^^^^^^^^^^^^^^ E501
1058 |     orchestrator.asset_manager.acquire_asset = MagicMock(
1059 |       side_effect=AssetAcquisitionError("Cannot acquire optional rack"),
     |

tests/orchestrator_tests.py:1062:38: SLF001 Private member accessed: `_prepare_arguments`
     |
1060 |     )
1061 | 
1062 |     final_args, _, acquired_assets = orchestrator._prepare_arguments(
     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1063 |       protocol_def,
1064 |       decorator_meta,
     |

tests/orchestrator_tests.py:1074:5: S101 Use of `assert` detected
     |
1072 |       orchestrator.asset_manager.acquire_asset.call_args[1]["asset_requirement"]
1073 |     )
1074 |     assert called_asset_req.name == "optional_rack"
     |     ^^^^^^ S101
1075 |     assert called_asset_req.optional
1076 |     assert (
     |

tests/orchestrator_tests.py:1075:5: S101 Use of `assert` detected
     |
1073 |     )
1074 |     assert called_asset_req.name == "optional_rack"
1075 |     assert called_asset_req.optional
     |     ^^^^^^ S101
1076 |     assert (
1077 |       final_args["optional_rack"] is None
     |

tests/orchestrator_tests.py:1076:5: S101 Use of `assert` detected
     |
1074 |     assert called_asset_req.name == "optional_rack"
1075 |     assert called_asset_req.optional
1076 |     assert (
     |     ^^^^^^ S101
1077 |       final_args["optional_rack"] is None
1078 |     )  # Should be set to None if optional and acquisition fails
     |

tests/orchestrator_tests.py:1079:5: S101 Use of `assert` detected
     |
1077 |       final_args["optional_rack"] is None
1078 |     )  # Should be set to None if optional and acquisition fails
1079 |     assert len(acquired_assets) == 0  # No asset successfully acquired
     |     ^^^^^^ S101
1080 | 
1081 |   def test_infer_asset_non_plr_type_is_ignored(
     |

tests/orchestrator_tests.py:1081:7: ANN201 Missing return type annotation for public function `test_infer_asset_non_plr_type_is_ignored`
     |
1079 |     assert len(acquired_assets) == 0  # No asset successfully acquired
1080 | 
1081 |   def test_infer_asset_non_plr_type_is_ignored(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1082 |     self,
1083 |     orchestrator_instance,
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1081:7: D102 Missing docstring in public method
     |
1079 |     assert len(acquired_assets) == 0  # No asset successfully acquired
1080 | 
1081 |   def test_infer_asset_non_plr_type_is_ignored(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
1082 |     self,
1083 |     orchestrator_instance,
     |

tests/orchestrator_tests.py:1083:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
     |
1081 |   def test_infer_asset_non_plr_type_is_ignored(
1082 |     self,
1083 |     orchestrator_instance,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1084 |     mock_protocol_def_orm,
1085 |     mock_protocol_wrapper_func_for_args,
     |

tests/orchestrator_tests.py:1084:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
     |
1082 |     self,
1083 |     orchestrator_instance,
1084 |     mock_protocol_def_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1085 |     mock_protocol_wrapper_func_for_args,
1086 |   ):
     |

tests/orchestrator_tests.py:1085:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
     |
1083 |     orchestrator_instance,
1084 |     mock_protocol_def_orm,
1085 |     mock_protocol_wrapper_func_for_args,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1086 |   ):
1087 |     orchestrator, _ = orchestrator_instance
     |

tests/orchestrator_tests.py:1090:9: ANN202 Missing return type annotation for private function `original_protocol`
     |
1088 |     protocol_def, decorator_meta = mock_protocol_def_orm
1089 | 
1090 |     def original_protocol(name: str, count: int):
     |         ^^^^^^^^^^^^^^^^^ ANN202
1091 |       pass
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1097:38: SLF001 Private member accessed: `_prepare_arguments`
     |
1095 |     orchestrator.asset_manager.acquire_asset = MagicMock()
1096 | 
1097 |     final_args, _, acquired_assets = orchestrator._prepare_arguments(
     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1098 |       protocol_def,
1099 |       decorator_meta,
     |

tests/orchestrator_tests.py:1106:5: S101 Use of `assert` detected
     |
1105 |     orchestrator.asset_manager.acquire_asset.assert_not_called()
1106 |     assert (
     |     ^^^^^^ S101
1107 |       "name" in final_args
1108 |     )  # Normal params should still be processed if in defined_params_from_meta or user_input
     |

tests/orchestrator_tests.py:1109:5: S101 Use of `assert` detected
     |
1107 |       "name" in final_args
1108 |     )  # Normal params should still be processed if in defined_params_from_meta or user_input
1109 |     assert "count" in final_args
     |     ^^^^^^ S101
1110 |     assert len(acquired_assets) == 0
     |

tests/orchestrator_tests.py:1110:5: S101 Use of `assert` detected
     |
1108 |     )  # Normal params should still be processed if in defined_params_from_meta or user_input
1109 |     assert "count" in final_args
1110 |     assert len(acquired_assets) == 0
     |     ^^^^^^ S101
1111 | 
1112 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
     |

tests/orchestrator_tests.py:1113:7: ANN201 Missing return type annotation for public function `test_explicit_asset_definition_overrides_inference`
     |
1112 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
1113 |   def test_explicit_asset_definition_overrides_inference(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1114 |     self,
1115 |     mock_asset_data_service_in_orchestrator,
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1113:7: D102 Missing docstring in public method
     |
1112 |   @patch("praxis.backend.core.orchestrator.asset_data_service")
1113 |   def test_explicit_asset_definition_overrides_inference(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
1114 |     self,
1115 |     mock_asset_data_service_in_orchestrator,
     |

tests/orchestrator_tests.py:1115:5: ANN001 Missing type annotation for function argument `mock_asset_data_service_in_orchestrator`
     |
1113 |   def test_explicit_asset_definition_overrides_inference(
1114 |     self,
1115 |     mock_asset_data_service_in_orchestrator,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1116 |     orchestrator_instance,
1117 |     mock_protocol_def_orm,
     |

tests/orchestrator_tests.py:1116:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
     |
1114 |     self,
1115 |     mock_asset_data_service_in_orchestrator,
1116 |     orchestrator_instance,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1117 |     mock_protocol_def_orm,
1118 |     mock_protocol_wrapper_func_for_args,
     |

tests/orchestrator_tests.py:1117:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
     |
1115 |     mock_asset_data_service_in_orchestrator,
1116 |     orchestrator_instance,
1117 |     mock_protocol_def_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1118 |     mock_protocol_wrapper_func_for_args,
1119 |   ):
     |

tests/orchestrator_tests.py:1118:5: ANN001 Missing type annotation for function argument `mock_protocol_wrapper_func_for_args`
     |
1116 |     orchestrator_instance,
1117 |     mock_protocol_def_orm,
1118 |     mock_protocol_wrapper_func_for_args,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1119 |   ):
1120 |     orchestrator, _ = orchestrator_instance
     |

tests/orchestrator_tests.py:1127:33: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
     |
1125 |       name="my_plate",
1126 |       actual_type_str="explicit_plate_def_name",
1127 |       type_hint_str="plate",  # TODO: check formatting here
     |                                 ^^^^ TD002
1128 |       optional=False,
1129 |     )
     |

tests/orchestrator_tests.py:1127:33: TD003 Missing issue link on the line following this TODO
     |
1125 |       name="my_plate",
1126 |       actual_type_str="explicit_plate_def_name",
1127 |       type_hint_str="plate",  # TODO: check formatting here
     |                                 ^^^^ TD003
1128 |       optional=False,
1129 |     )
     |

tests/orchestrator_tests.py:1127:33: FIX002 Line contains TODO, consider resolving the issue
     |
1125 |       name="my_plate",
1126 |       actual_type_str="explicit_plate_def_name",
1127 |       type_hint_str="plate",  # TODO: check formatting here
     |                                 ^^^^ FIX002
1128 |       optional=False,
1129 |     )
     |

tests/orchestrator_tests.py:1139:9: ANN202 Missing return type annotation for private function `original_protocol`
     |
1138 |     # Protocol function also has a type hint for "my_plate"
1139 |     def original_protocol(my_plate: MockPlrPlate, another_param: int):
     |         ^^^^^^^^^^^^^^^^^ ANN202
1140 |       pass
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1152:38: SLF001 Private member accessed: `_prepare_arguments`
     |
1150 |     )
1151 | 
1152 |     final_args, _, acquired_assets = orchestrator._prepare_arguments(
     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1153 |       protocol_def,
1154 |       decorator_meta,
     |

tests/orchestrator_tests.py:1163:7: S101 Use of `assert` detected
     |
1161 |     # because "my_plate" was explicitly defined.
1162 |     for call_obj in mock_asset_data_service_in_orchestrator.get_resource_definition_by_fqn.call_args_list:
1163 |       assert call_obj.args[1] != "pylabrobot.resources.plate.Plate"
     |       ^^^^^^ S101
1164 |       # Note: If other assets were inferred, it might have been called for them.
     |

tests/orchestrator_tests.py:1171:5: S101 Use of `assert` detected
     |
1169 |     )
1170 | 
1171 |     assert called_asset_req.name == "my_plate"
     |     ^^^^^^ S101
1172 |     assert (
1173 |       called_asset_req.actual_type_str == "explicit_plate_def_name"
     |

tests/orchestrator_tests.py:1172:5: S101 Use of `assert` detected
     |
1171 |     assert called_asset_req.name == "my_plate"
1172 |     assert (
     |     ^^^^^^ S101
1173 |       called_asset_req.actual_type_str == "explicit_plate_def_name"
1174 |     )  # From explicit definition
     |

tests/orchestrator_tests.py:1175:5: S101 Use of `assert` detected
     |
1173 |       called_asset_req.actual_type_str == "explicit_plate_def_name"
1174 |     )  # From explicit definition
1175 |     assert final_args["my_plate"] == live_asset_mock
     |     ^^^^^^ S101
1176 |     assert len(acquired_assets) == 1
1177 |     assert acquired_assets[0]["name_in_protocol"] == "my_plate"
     |

tests/orchestrator_tests.py:1176:5: S101 Use of `assert` detected
     |
1174 |     )  # From explicit definition
1175 |     assert final_args["my_plate"] == live_asset_mock
1176 |     assert len(acquired_assets) == 1
     |     ^^^^^^ S101
1177 |     assert acquired_assets[0]["name_in_protocol"] == "my_plate"
     |

tests/orchestrator_tests.py:1177:5: S101 Use of `assert` detected
     |
1175 |     assert final_args["my_plate"] == live_asset_mock
1176 |     assert len(acquired_assets) == 1
1177 |     assert acquired_assets[0]["name_in_protocol"] == "my_plate"
     |     ^^^^^^ S101
1178 | 
1179 |   # --- Tests for In-Step Command Handling (Decorator Logic) ---
     |

tests/orchestrator_tests.py:1185:7: PLR0913 Too many arguments in function definition (8 > 5)
     |
1183 |   @patch("praxis.backend.protocol_core.decorators.update_protocol_run_status")
1184 |   @patch("praxis.backend.protocol_core.decorators.time.sleep")
1185 |   def test_pause_resume_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
1186 |     self,
1187 |     mock_decorator_sleep,
     |

tests/orchestrator_tests.py:1185:7: ANN201 Missing return type annotation for public function `test_pause_resume_during_protocol_step`
     |
1183 |   @patch("praxis.backend.protocol_core.decorators.update_protocol_run_status")
1184 |   @patch("praxis.backend.protocol_core.decorators.time.sleep")
1185 |   def test_pause_resume_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1186 |     self,
1187 |     mock_decorator_sleep,
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1185:7: D102 Missing docstring in public method
     |
1183 |   @patch("praxis.backend.protocol_core.decorators.update_protocol_run_status")
1184 |   @patch("praxis.backend.protocol_core.decorators.time.sleep")
1185 |   def test_pause_resume_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
1186 |     self,
1187 |     mock_decorator_sleep,
     |

tests/orchestrator_tests.py:1187:5: ANN001 Missing type annotation for function argument `mock_decorator_sleep`
     |
1185 |   def test_pause_resume_during_protocol_step(
1186 |     self,
1187 |     mock_decorator_sleep,
     |     ^^^^^^^^^^^^^^^^^^^^ ANN001
1188 |     mock_decorator_update_status,
1189 |     mock_decorator_clear_cmd,
     |

tests/orchestrator_tests.py:1188:5: ANN001 Missing type annotation for function argument `mock_decorator_update_status`
     |
1186 |     self,
1187 |     mock_decorator_sleep,
1188 |     mock_decorator_update_status,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1189 |     mock_decorator_clear_cmd,
1190 |     mock_decorator_get_cmd,
     |

tests/orchestrator_tests.py:1189:5: ANN001 Missing type annotation for function argument `mock_decorator_clear_cmd`
     |
1187 |     mock_decorator_sleep,
1188 |     mock_decorator_update_status,
1189 |     mock_decorator_clear_cmd,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1190 |     mock_decorator_get_cmd,
1191 |     orchestrator_instance,
     |

tests/orchestrator_tests.py:1190:5: ANN001 Missing type annotation for function argument `mock_decorator_get_cmd`
     |
1188 |     mock_decorator_update_status,
1189 |     mock_decorator_clear_cmd,
1190 |     mock_decorator_get_cmd,
     |     ^^^^^^^^^^^^^^^^^^^^^^ ANN001
1191 |     orchestrator_instance,
1192 |     mock_protocol_def_orm,
     |

tests/orchestrator_tests.py:1191:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
     |
1189 |     mock_decorator_clear_cmd,
1190 |     mock_decorator_get_cmd,
1191 |     orchestrator_instance,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1192 |     mock_protocol_def_orm,
1193 |     mock_protocol_run_orm,
     |

tests/orchestrator_tests.py:1192:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
     |
1190 |     mock_decorator_get_cmd,
1191 |     orchestrator_instance,
1192 |     mock_protocol_def_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1193 |     mock_protocol_run_orm,
1194 |     mock_db_session,  # For context
     |

tests/orchestrator_tests.py:1193:5: ANN001 Missing type annotation for function argument `mock_protocol_run_orm`
     |
1191 |     orchestrator_instance,
1192 |     mock_protocol_def_orm,
1193 |     mock_protocol_run_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1194 |     mock_db_session,  # For context
1195 |   ):
     |

tests/orchestrator_tests.py:1194:5: ANN001 Missing type annotation for function argument `mock_db_session`
     |
1192 |     mock_protocol_def_orm,
1193 |     mock_protocol_run_orm,
1194 |     mock_db_session,  # For context
     |     ^^^^^^^^^^^^^^^ ANN001
1195 |   ):
1196 |     orchestrator, _ = orchestrator_instance  # Orchestrator's sleep mock not used here
     |

tests/orchestrator_tests.py:1224:9: ANN202 Missing return type annotation for private function `mock_protocol_wrapper_side_effect`
     |
1222 |     )
1223 | 
1224 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
1225 |       # This simulates the decorator's command handling logic
1226 |       # __praxis_run_context__ is passed by the orchestrator to the wrapper
     |
     = help: Add return type annotation

tests/orchestrator_tests.py:1224:43: ANN002 Missing type annotation for `*args`
     |
1222 |     )
1223 | 
1224 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |                                           ^^^^^ ANN002
1225 |       # This simulates the decorator's command handling logic
1226 |       # __praxis_run_context__ is passed by the orchestrator to the wrapper
     |

tests/orchestrator_tests.py:1224:50: ANN003 Missing type annotation for `**kwargs`
     |
1222 |     )
1223 | 
1224 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |                                                  ^^^^^^^^ ANN003
1225 |       # This simulates the decorator's command handling logic
1226 |       # __praxis_run_context__ is passed by the orchestrator to the wrapper
     |

tests/orchestrator_tests.py:1232:7: F841 Local variable `cmd1` is assigned to but never used
     |
1231 |       # Simulate 1st command check in decorator (before user code)
1232 |       cmd1 = mock_decorator_get_cmd(ctx.run_accession_id)  # Sees None
     |       ^^^^ F841
1233 |       # No command, so it would proceed to call user_protocol_function_mock,
1234 |       # but we embed further command checks as if they are part of user_protocol_function_mock's execution flow
     |
     = help: Remove assignment to unused variable `cmd1`

tests/orchestrator_tests.py:1270:19: TRY003 Avoid specifying long messages outside the exception class
     |
1268 |             paused = False
1269 |           elif cmd_in_pause == "CANCEL":  # Should not happen in this test's side_effect
1270 |             raise ProtocolCancelledError("Cancelled during pause")
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
1271 | 
1272 |       # If resumed, the actual user function is called
     |

tests/orchestrator_tests.py:1270:42: EM101 Exception must not use a string literal, assign to variable first
     |
1268 |             paused = False
1269 |           elif cmd_in_pause == "CANCEL":  # Should not happen in this test's side_effect
1270 |             raise ProtocolCancelledError("Cancelled during pause")
     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^ EM101
1271 | 
1272 |       # If resumed, the actual user function is called
     |
     = help: Assign to variable; remove string literal

tests/orchestrator_tests.py:1276:14: RET504 Unnecessary assignment to `result` before `return` statement
     |
1274 |         *args, **{k: v for k, v in kwargs.items() if k != "__praxis_run_context__"},
1275 |       )
1276 |       return result
     |              ^^^^^^ RET504
1277 | 
1278 |     mock_wrapper_func_instance = MagicMock(
     |
     = help: Remove unnecessary assignment

tests/orchestrator_tests.py:1284:5: SLF001 Private member accessed: `_prepare_protocol_code`
     |
1282 |     mock_wrapper_func_instance.protocol_metadata = decorator_meta
1283 | 
1284 |     orchestrator._prepare_protocol_code = MagicMock(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1285 |       return_value=(mock_wrapper_func_instance, decorator_meta),
1286 |     )
     |

tests/orchestrator_tests.py:1287:5: SLF001 Private member accessed: `_prepare_arguments`
     |
1285 |       return_value=(mock_wrapper_func_instance, decorator_meta),
1286 |     )
1287 |     orchestrator._prepare_arguments = MagicMock(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1288 |       return_value=(
1289 |         {},
     |

tests/orchestrator_tests.py:1303:5: S101 Use of `assert` detected
     |
1302 |     # Assertions
1303 |     assert result == {"status": "user_code_completed"}
     |     ^^^^^^ S101
1304 |     user_protocol_function_mock.assert_called_once()  # Ensure the actual user code ran
     |

tests/orchestrator_tests.py:1339:5: S101 Use of `assert` detected
     |
1337 |       ],
1338 |     )
1339 |     assert mock_decorator_clear_cmd.call_count == 2
     |     ^^^^^^ S101
1340 |     assert mock_decorator_sleep.call_count >= 2  # At least two sleeps during pause
     |

tests/orchestrator_tests.py:1339:51: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1337 |       ],
1338 |     )
1339 |     assert mock_decorator_clear_cmd.call_count == 2
     |                                                   ^ PLR2004
1340 |     assert mock_decorator_sleep.call_count >= 2  # At least two sleeps during pause
     |

tests/orchestrator_tests.py:1340:5: S101 Use of `assert` detected
     |
1338 |     )
1339 |     assert mock_decorator_clear_cmd.call_count == 2
1340 |     assert mock_decorator_sleep.call_count >= 2  # At least two sleeps during pause
     |     ^^^^^^ S101
1341 | 
1342 |     # Check Orchestrator's status updates (it will still log COMPLETED at the end)
     |

tests/orchestrator_tests.py:1340:47: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1338 |     )
1339 |     assert mock_decorator_clear_cmd.call_count == 2
1340 |     assert mock_decorator_sleep.call_count >= 2  # At least two sleeps during pause
     |                                               ^ PLR2004
1341 | 
1342 |     # Check Orchestrator's status updates (it will still log COMPLETED at the end)
     |

tests/orchestrator_tests.py:1350:5: S101 Use of `assert` detected
     |
1348 |       output_data_json=ANY,
1349 |     )
1350 |     assert (
     |     ^^^^^^ S101
1351 |       mock_update_protocol_run_status.call_args_list[-1]
1352 |       == orchestrator_final_status_call
     |

tests/orchestrator_tests.py:1361:7: PLR0913 Too many arguments in function definition (9 > 5)
     |
1359 |     "praxis.backend.protocol_core.decorators.time.sleep",
1360 |   )  # Though not used in cancel path
1361 |   def test_cancel_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
1362 |     self,
1363 |     mock_decorator_sleep,
     |

tests/orchestrator_tests.py:1361:7: ANN201 Missing return type annotation for public function `test_cancel_during_protocol_step`
     |
1359 |     "praxis.backend.protocol_core.decorators.time.sleep",
1360 |   )  # Though not used in cancel path
1361 |   def test_cancel_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
1362 |     self,
1363 |     mock_decorator_sleep,
     |
     = help: Add return type annotation: `None`

tests/orchestrator_tests.py:1361:7: D102 Missing docstring in public method
     |
1359 |     "praxis.backend.protocol_core.decorators.time.sleep",
1360 |   )  # Though not used in cancel path
1361 |   def test_cancel_during_protocol_step(
     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
1362 |     self,
1363 |     mock_decorator_sleep,
     |

tests/orchestrator_tests.py:1363:5: ANN001 Missing type annotation for function argument `mock_decorator_sleep`
     |
1361 |   def test_cancel_during_protocol_step(
1362 |     self,
1363 |     mock_decorator_sleep,
     |     ^^^^^^^^^^^^^^^^^^^^ ANN001
1364 |     mock_decorator_update_status,
1365 |     mock_decorator_clear_cmd,
     |

tests/orchestrator_tests.py:1363:5: ARG002 Unused method argument: `mock_decorator_sleep`
     |
1361 |   def test_cancel_during_protocol_step(
1362 |     self,
1363 |     mock_decorator_sleep,
     |     ^^^^^^^^^^^^^^^^^^^^ ARG002
1364 |     mock_decorator_update_status,
1365 |     mock_decorator_clear_cmd,
     |

tests/orchestrator_tests.py:1364:5: ANN001 Missing type annotation for function argument `mock_decorator_update_status`
     |
1362 |     self,
1363 |     mock_decorator_sleep,
1364 |     mock_decorator_update_status,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1365 |     mock_decorator_clear_cmd,
1366 |     mock_decorator_get_cmd,
     |

tests/orchestrator_tests.py:1365:5: ANN001 Missing type annotation for function argument `mock_decorator_clear_cmd`
     |
1363 |     mock_decorator_sleep,
1364 |     mock_decorator_update_status,
1365 |     mock_decorator_clear_cmd,
     |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
1366 |     mock_decorator_get_cmd,
1367 |     orchestrator_instance,
     |

tests/orchestrator_tests.py:1366:5: ANN001 Missing type annotation for function argument `mock_decorator_get_cmd`
     |
1364 |     mock_decorator_update_status,
1365 |     mock_decorator_clear_cmd,
1366 |     mock_decorator_get_cmd,
     |     ^^^^^^^^^^^^^^^^^^^^^^ ANN001
1367 |     orchestrator_instance,
1368 |     mock_protocol_def_orm,
     |

tests/orchestrator_tests.py:1367:5: ANN001 Missing type annotation for function argument `orchestrator_instance`
     |
1365 |     mock_decorator_clear_cmd,
1366 |     mock_decorator_get_cmd,
1367 |     orchestrator_instance,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1368 |     mock_protocol_def_orm,
1369 |     mock_protocol_run_orm,
     |

tests/orchestrator_tests.py:1368:5: ANN001 Missing type annotation for function argument `mock_protocol_def_orm`
     |
1366 |     mock_decorator_get_cmd,
1367 |     orchestrator_instance,
1368 |     mock_protocol_def_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1369 |     mock_protocol_run_orm,
1370 |     mock_db_session,
     |

tests/orchestrator_tests.py:1369:5: ANN001 Missing type annotation for function argument `mock_protocol_run_orm`
     |
1367 |     orchestrator_instance,
1368 |     mock_protocol_def_orm,
1369 |     mock_protocol_run_orm,
     |     ^^^^^^^^^^^^^^^^^^^^^ ANN001
1370 |     mock_db_session,
1371 |     mock_asset_manager,
     |

tests/orchestrator_tests.py:1370:5: ANN001 Missing type annotation for function argument `mock_db_session`
     |
1368 |     mock_protocol_def_orm,
1369 |     mock_protocol_run_orm,
1370 |     mock_db_session,
     |     ^^^^^^^^^^^^^^^ ANN001
1371 |     mock_asset_manager,
1372 |   ):
     |

tests/orchestrator_tests.py:1371:5: ANN001 Missing type annotation for function argument `mock_asset_manager`
     |
1369 |     mock_protocol_run_orm,
1370 |     mock_db_session,
1371 |     mock_asset_manager,
     |     ^^^^^^^^^^^^^^^^^^ ANN001
1372 |   ):
1373 |     orchestrator, _ = orchestrator_instance
     |

tests/orchestrator_tests.py:1395:9: ANN202 Missing return type annotation for private function `mock_protocol_wrapper_side_effect`
     |
1393 |     user_protocol_function_mock = MagicMock()  # This should not be called
1394 | 
1395 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN202
1396 |       ctx = kwargs.get("__praxis_run_context__", mock_praxis_run_context)
     |
     = help: Add return type annotation

tests/orchestrator_tests.py:1395:43: ANN002 Missing type annotation for `*args`
     |
1393 |     user_protocol_function_mock = MagicMock()  # This should not be called
1394 | 
1395 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |                                           ^^^^^ ANN002
1396 |       ctx = kwargs.get("__praxis_run_context__", mock_praxis_run_context)
     |

tests/orchestrator_tests.py:1395:50: ANN003 Missing type annotation for `**kwargs`
     |
1393 |     user_protocol_function_mock = MagicMock()  # This should not be called
1394 | 
1395 |     def mock_protocol_wrapper_side_effect(*args, **kwargs):
     |                                                  ^^^^^^^^ ANN003
1396 |       ctx = kwargs.get("__praxis_run_context__", mock_praxis_run_context)
     |

tests/orchestrator_tests.py:1398:7: F841 Local variable `cmd1` is assigned to but never used
     |
1396 |       ctx = kwargs.get("__praxis_run_context__", mock_praxis_run_context)
1397 | 
1398 |       cmd1 = mock_decorator_get_cmd(ctx.run_accession_id)  # Sees None
     |       ^^^^ F841
1399 | 
1400 |       # Simulate decorator checking for command *during* the step
     |
     = help: Remove assignment to unused variable `cmd1`

tests/orchestrator_tests.py:1415:15: TRY003 Avoid specifying long messages outside the exception class
     |
1413 |             output_data_json=ANY,
1414 |           )
1415 |           raise ProtocolCancelledError(
     |  _______________^
1416 | |           f"Cancelled by user during step {ctx.run_accession_id}",
1417 | |         )
     | |_________^ TRY003
1418 |   
1419 |         user_protocol_function_mock(
     |

tests/orchestrator_tests.py:1416:11: EM102 Exception must not use an f-string literal, assign to variable first
     |
1414 |         )
1415 |         raise ProtocolCancelledError(
1416 |           f"Cancelled by user during step {ctx.run_accession_id}",
     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ EM102
1417 |         )
     |
     = help: Assign to variable; remove f-string literal

tests/orchestrator_tests.py:1437:5: SLF001 Private member accessed: `_prepare_arguments`
     |
1435 |       },
1436 |     ]
1437 |     orchestrator._prepare_arguments = MagicMock(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1438 |       return_value=(
1439 |         {},
     |

tests/orchestrator_tests.py:1445:5: SLF001 Private member accessed: `_prepare_protocol_code`
     |
1443 |     )
1444 | 
1445 |     orchestrator._prepare_protocol_code = MagicMock(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
1446 |       return_value=(mock_wrapper_func_instance, decorator_meta),
1447 |     )
     |

tests/orchestrator_tests.py:1487:5: S101 Use of `assert` detected
     |
1485 |     )
1486 |     # Ensure the *last* call to the orchestrator's mock_update_protocol_run_status was for CANCELLED
1487 |     assert (
     |     ^^^^^^ S101
1488 |       mock_update_protocol_run_status.call_args_list[-1]
1489 |       == orchestrator_final_status_call
     |

tests/praxis_state_tests.py:1:1: INP001 File `tests/praxis_state_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/praxis_state_tests.py:1:1: D100 Missing docstring in public module
tests/praxis_state_tests.py:4:16: PGH003 Use specific rule codes when ignoring type issues
  |
2 | from unittest.mock import MagicMock, patch
3 | 
4 | import pytest  # type: ignore
  |                ^^^^^^^^^^^^^^ PGH003
5 | import redis  # For mocking redis.exceptions.ConnectionError
  |

tests/praxis_state_tests.py:8:3: PLC0414 Import alias does not rename original package
  |
7 | from praxis.backend.services.state import (
8 |   PraxisState as PraxisState,
  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
9 | )  # Assuming State is aliased as PraxisState typically
  |
  = help: Remove import alias

tests/praxis_state_tests.py:14:5: ANN201 Missing return type annotation for public function `mock_redis_client`
   |
12 | # Mock Redis client for all tests in this file
13 | @pytest.fixture(autouse=True)
14 | def mock_redis_client():
   |     ^^^^^^^^^^^^^^^^^ ANN201
15 |   # This mock will replace redis.Redis globally for the duration of tests in this module.
16 |   # Individual tests can then .return_value on specific methods like get, set, delete, ping.
   |
   = help: Add return type annotation

tests/praxis_state_tests.py:14:5: D103 Missing docstring in public function
   |
12 | # Mock Redis client for all tests in this file
13 | @pytest.fixture(autouse=True)
14 | def mock_redis_client():
   |     ^^^^^^^^^^^^^^^^^ D103
15 |   # This mock will replace redis.Redis globally for the duration of tests in this module.
16 |   # Individual tests can then .return_value on specific methods like get, set, delete, ping.
   |

tests/praxis_state_tests.py:23:7: D101 Missing docstring in public class
   |
23 | class TestPraxisState:
   |       ^^^^^^^^^^^^^^^ D101
24 |   def test_init_requires_run_accession_id(self):
25 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
   |

tests/praxis_state_tests.py:24:7: ANN201 Missing return type annotation for public function `test_init_requires_run_accession_id`
   |
23 | class TestPraxisState:
24 |   def test_init_requires_run_accession_id(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
25 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
26 |       PraxisState(run_accession_id="")  # type: ignore
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:24:7: D102 Missing docstring in public method
   |
23 | class TestPraxisState:
24 |   def test_init_requires_run_accession_id(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
25 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
26 |       PraxisState(run_accession_id="")  # type: ignore
   |

tests/praxis_state_tests.py:26:41: PGH003 Use specific rule codes when ignoring type issues
   |
24 |   def test_init_requires_run_accession_id(self):
25 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
26 |       PraxisState(run_accession_id="")  # type: ignore
   |                                         ^^^^^^^^^^^^^^ PGH003
27 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
28 |       PraxisState(run_accession_id="   ")  # type: ignore
   |

tests/praxis_state_tests.py:28:44: PGH003 Use specific rule codes when ignoring type issues
   |
26 |       PraxisState(run_accession_id="")  # type: ignore
27 |     with pytest.raises(ValueError, match="run_accession_id must be a non-empty string"):
28 |       PraxisState(run_accession_id="   ")  # type: ignore
   |                                            ^^^^^^^^^^^^^^ PGH003
29 | 
30 |   def test_init_connects_to_redis_and_loads_initial_state(
   |

tests/praxis_state_tests.py:30:7: ANN201 Missing return type annotation for public function `test_init_connects_to_redis_and_loads_initial_state`
   |
28 |       PraxisState(run_accession_id="   ")  # type: ignore
29 | 
30 |   def test_init_connects_to_redis_and_loads_initial_state(
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
31 |     self, mock_redis_client: MagicMock,
32 |   ):
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:30:7: D102 Missing docstring in public method
   |
28 |       PraxisState(run_accession_id="   ")  # type: ignore
29 | 
30 |   def test_init_connects_to_redis_and_loads_initial_state(
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
31 |     self, mock_redis_client: MagicMock,
32 |   ):
   |

tests/praxis_state_tests.py:41:5: S101 Use of `assert` detected
   |
39 |     mock_redis_client.ping.assert_called_once()
40 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_123")
41 |     assert state.to_dict() == {"initial_key": "initial_value"}
   |     ^^^^^^ S101
42 |     assert state._data == {
43 |       "initial_key": "initial_value",
   |

tests/praxis_state_tests.py:42:5: S101 Use of `assert` detected
   |
40 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_123")
41 |     assert state.to_dict() == {"initial_key": "initial_value"}
42 |     assert state._data == {
   |     ^^^^^^ S101
43 |       "initial_key": "initial_value",
44 |     }  # Check internal representation too
   |

tests/praxis_state_tests.py:42:12: SLF001 Private member accessed: `_data`
   |
40 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_123")
41 |     assert state.to_dict() == {"initial_key": "initial_value"}
42 |     assert state._data == {
   |            ^^^^^^^^^^^ SLF001
43 |       "initial_key": "initial_value",
44 |     }  # Check internal representation too
   |

tests/praxis_state_tests.py:46:7: ANN201 Missing return type annotation for public function `test_init_handles_empty_state_from_redis`
   |
44 |     }  # Check internal representation too
45 | 
46 |   def test_init_handles_empty_state_from_redis(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
47 |     mock_redis_client.get.return_value = (
48 |       None  # No state in Redis for this run_accession_id
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:46:7: D102 Missing docstring in public method
   |
44 |     }  # Check internal representation too
45 | 
46 |   def test_init_handles_empty_state_from_redis(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
47 |     mock_redis_client.get.return_value = (
48 |       None  # No state in Redis for this run_accession_id
   |

tests/praxis_state_tests.py:55:5: S101 Use of `assert` detected
   |
53 |     mock_redis_client.ping.assert_called_once()
54 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_new")
55 |     assert state.to_dict() == {}
   |     ^^^^^^ S101
56 |     assert state._data == {}
   |

tests/praxis_state_tests.py:56:5: S101 Use of `assert` detected
   |
54 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_new")
55 |     assert state.to_dict() == {}
56 |     assert state._data == {}
   |     ^^^^^^ S101
57 | 
58 |   def test_init_handles_redis_connection_error(self, mock_redis_client: MagicMock):
   |

tests/praxis_state_tests.py:56:12: SLF001 Private member accessed: `_data`
   |
54 |     mock_redis_client.get.assert_called_once_with("praxis_state:test_run_new")
55 |     assert state.to_dict() == {}
56 |     assert state._data == {}
   |            ^^^^^^^^^^^ SLF001
57 | 
58 |   def test_init_handles_redis_connection_error(self, mock_redis_client: MagicMock):
   |

tests/praxis_state_tests.py:58:7: ANN201 Missing return type annotation for public function `test_init_handles_redis_connection_error`
   |
56 |     assert state._data == {}
57 | 
58 |   def test_init_handles_redis_connection_error(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
59 |     # Configure the constructor mock to make ping raise ConnectionError
60 |     mock_redis_client.ping.side_effect = redis.exceptions.ConnectionError(
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:58:7: D102 Missing docstring in public method
   |
56 |     assert state._data == {}
57 | 
58 |   def test_init_handles_redis_connection_error(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
59 |     # Configure the constructor mock to make ping raise ConnectionError
60 |     mock_redis_client.ping.side_effect = redis.exceptions.ConnectionError(
   |

tests/praxis_state_tests.py:70:7: ANN201 Missing return type annotation for public function `test_init_handles_json_decode_error`
   |
68 |       PraxisState(run_accession_id="test_run_conn_error")
69 | 
70 |   def test_init_handles_json_decode_error(self, mock_redis_client: MagicMock, caplog):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
71 |     mock_redis_client.get.return_value = b"this is not json"
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:70:7: D102 Missing docstring in public method
   |
68 |       PraxisState(run_accession_id="test_run_conn_error")
69 | 
70 |   def test_init_handles_json_decode_error(self, mock_redis_client: MagicMock, caplog):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
71 |     mock_redis_client.get.return_value = b"this is not json"
   |

tests/praxis_state_tests.py:70:79: ANN001 Missing type annotation for function argument `caplog`
   |
68 |       PraxisState(run_accession_id="test_run_conn_error")
69 | 
70 |   def test_init_handles_json_decode_error(self, mock_redis_client: MagicMock, caplog):
   |                                                                               ^^^^^^ ANN001
71 |     mock_redis_client.get.return_value = b"this is not json"
   |

tests/praxis_state_tests.py:75:5: S101 Use of `assert` detected
   |
73 |     state = PraxisState(run_accession_id="test_run_json_error")
74 | 
75 |     assert state.to_dict() == {}  # Should default to empty dict
   |     ^^^^^^ S101
76 |     assert "JSONDecodeError while loading state" in caplog.text
77 |     assert "Raw data: b'this is not json'" in caplog.text
   |

tests/praxis_state_tests.py:76:5: S101 Use of `assert` detected
   |
75 |     assert state.to_dict() == {}  # Should default to empty dict
76 |     assert "JSONDecodeError while loading state" in caplog.text
   |     ^^^^^^ S101
77 |     assert "Raw data: b'this is not json'" in caplog.text
   |

tests/praxis_state_tests.py:77:5: S101 Use of `assert` detected
   |
75 |     assert state.to_dict() == {}  # Should default to empty dict
76 |     assert "JSONDecodeError while loading state" in caplog.text
77 |     assert "Raw data: b'this is not json'" in caplog.text
   |     ^^^^^^ S101
78 | 
79 |   def test_setitem_saves_to_redis_and_updates_data(self, mock_redis_client: MagicMock):
   |

tests/praxis_state_tests.py:79:7: ANN201 Missing return type annotation for public function `test_setitem_saves_to_redis_and_updates_data`
   |
77 |     assert "Raw data: b'this is not json'" in caplog.text
78 | 
79 |   def test_setitem_saves_to_redis_and_updates_data(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
80 |     mock_redis_client.get.return_value = None  # Start with empty state
81 |     state = PraxisState(run_accession_id="test_run_set")
   |
   = help: Add return type annotation: `None`

tests/praxis_state_tests.py:79:7: D102 Missing docstring in public method
   |
77 |     assert "Raw data: b'this is not json'" in caplog.text
78 | 
79 |   def test_setitem_saves_to_redis_and_updates_data(self, mock_redis_client: MagicMock):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
80 |     mock_redis_client.get.return_value = None  # Start with empty state
81 |     state = PraxisState(run_accession_id="test_run_set")
   |

tests/praxis_state_tests.py:85:5: S101 Use of `assert` detected
   |
83 |     state["my_key"] = "my_value"
84 | 
85 |     assert state._data["my_key"] == "my_value"
   |     ^^^^^^ S101
86 |     mock_redis_client.set.assert_called_once_with(
87 |       "praxis_state:test_run_set", json.dumps({"my_key": "my_value"}).encode("utf-8"),
   |

tests/praxis_state_tests.py:85:12: SLF001 Private member accessed: `_data`
   |
83 |     state["my_key"] = "my_value"
84 | 
85 |     assert state._data["my_key"] == "my_value"
   |            ^^^^^^^^^^^ SLF001
86 |     mock_redis_client.set.assert_called_once_with(
87 |       "praxis_state:test_run_set", json.dumps({"my_key": "my_value"}).encode("utf-8"),
   |

tests/praxis_state_tests.py:97:5: S101 Use of `assert` detected
   |
95 |       ),
96 |     )
97 |     assert state._data["another_key"] == {"nested": 123}
   |     ^^^^^^ S101
98 | 
99 |   def test_getitem_retrieves_from_data(self, mock_redis_client: MagicMock):
   |

tests/praxis_state_tests.py:97:12: SLF001 Private member accessed: `_data`
   |
95 |       ),
96 |     )
97 |     assert state._data["another_key"] == {"nested": 123}
   |            ^^^^^^^^^^^ SLF001
98 | 
99 |   def test_getitem_retrieves_from_data(self, mock_redis_client: MagicMock):
   |

tests/praxis_state_tests.py:99:7: ANN201 Missing return type annotation for public function `test_getitem_retrieves_from_data`
    |
 97 |     assert state._data["another_key"] == {"nested": 123}
 98 | 
 99 |   def test_getitem_retrieves_from_data(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
100 |     initial_data = {"key1": "val1"}
101 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:99:7: D102 Missing docstring in public method
    |
 97 |     assert state._data["another_key"] == {"nested": 123}
 98 | 
 99 |   def test_getitem_retrieves_from_data(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
100 |     initial_data = {"key1": "val1"}
101 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |

tests/praxis_state_tests.py:104:5: S101 Use of `assert` detected
    |
102 |     state = PraxisState(run_accession_id="test_run_get")
103 | 
104 |     assert state["key1"] == "val1"
    |     ^^^^^^ S101
105 |     with pytest.raises(KeyError):
106 |       _ = state["non_existent_key"]  # pylint: disable=pointless-statement
    |

tests/praxis_state_tests.py:108:7: ANN201 Missing return type annotation for public function `test_delitem_saves_to_redis_and_updates_data`
    |
106 |       _ = state["non_existent_key"]  # pylint: disable=pointless-statement
107 | 
108 |   def test_delitem_saves_to_redis_and_updates_data(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
109 |     initial_data = {"key1": "val1", "key_to_del": "delete_me"}
110 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:108:7: D102 Missing docstring in public method
    |
106 |       _ = state["non_existent_key"]  # pylint: disable=pointless-statement
107 | 
108 |   def test_delitem_saves_to_redis_and_updates_data(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
109 |     initial_data = {"key1": "val1", "key_to_del": "delete_me"}
110 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |

tests/praxis_state_tests.py:115:5: S101 Use of `assert` detected
    |
113 |     del state["key_to_del"]
114 | 
115 |     assert "key_to_del" not in state._data
    |     ^^^^^^ S101
116 |     mock_redis_client.set.assert_called_once_with(
117 |       "praxis_state:test_run_del", json.dumps({"key1": "val1"}).encode("utf-8"),
    |

tests/praxis_state_tests.py:115:32: SLF001 Private member accessed: `_data`
    |
113 |     del state["key_to_del"]
114 | 
115 |     assert "key_to_del" not in state._data
    |                                ^^^^^^^^^^^ SLF001
116 |     mock_redis_client.set.assert_called_once_with(
117 |       "praxis_state:test_run_del", json.dumps({"key1": "val1"}).encode("utf-8"),
    |

tests/praxis_state_tests.py:120:7: ANN201 Missing return type annotation for public function `test_get_method`
    |
118 |     )
119 | 
120 |   def test_get_method(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^ ANN201
121 |     initial_data = {"key1": "val1"}
122 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:120:7: D102 Missing docstring in public method
    |
118 |     )
119 | 
120 |   def test_get_method(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^ D102
121 |     initial_data = {"key1": "val1"}
122 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |

tests/praxis_state_tests.py:125:5: S101 Use of `assert` detected
    |
123 |     state = PraxisState(run_accession_id="test_run_get_method")
124 | 
125 |     assert state.get("key1") == "val1"
    |     ^^^^^^ S101
126 |     assert state.get("non_existent_key") is None
127 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |

tests/praxis_state_tests.py:126:5: S101 Use of `assert` detected
    |
125 |     assert state.get("key1") == "val1"
126 |     assert state.get("non_existent_key") is None
    |     ^^^^^^ S101
127 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |

tests/praxis_state_tests.py:127:5: S101 Use of `assert` detected
    |
125 |     assert state.get("key1") == "val1"
126 |     assert state.get("non_existent_key") is None
127 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |     ^^^^^^ S101
128 | 
129 |   def test_update_method_saves_to_redis(self, mock_redis_client: MagicMock):
    |

tests/praxis_state_tests.py:129:7: ANN201 Missing return type annotation for public function `test_update_method_saves_to_redis`
    |
127 |     assert state.get("non_existent_key", "default_val") == "default_val"
128 | 
129 |   def test_update_method_saves_to_redis(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
130 |     mock_redis_client.get.return_value = json.dumps({"key1": "val1_orig"}).encode(
131 |       "utf-8",
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:129:7: D102 Missing docstring in public method
    |
127 |     assert state.get("non_existent_key", "default_val") == "default_val"
128 | 
129 |   def test_update_method_saves_to_redis(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
130 |     mock_redis_client.get.return_value = json.dumps({"key1": "val1_orig"}).encode(
131 |       "utf-8",
    |

tests/praxis_state_tests.py:138:5: S101 Use of `assert` detected
    |
137 |     expected_data = {"key1": "val1_new", "key2": "val2"}
138 |     assert state.to_dict() == expected_data
    |     ^^^^^^ S101
139 |     mock_redis_client.set.assert_called_once_with(
140 |       "praxis_state:test_run_update", json.dumps(expected_data).encode("utf-8"),
    |

tests/praxis_state_tests.py:143:7: ANN201 Missing return type annotation for public function `test_to_dict_returns_copy`
    |
141 |     )
142 | 
143 |   def test_to_dict_returns_copy(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
144 |     initial_data = {"key1": "val1"}
145 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:143:7: D102 Missing docstring in public method
    |
141 |     )
142 | 
143 |   def test_to_dict_returns_copy(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^ D102
144 |     initial_data = {"key1": "val1"}
145 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |

tests/praxis_state_tests.py:149:5: S101 Use of `assert` detected
    |
148 |     state_dict = state.to_dict()
149 |     assert state_dict == initial_data
    |     ^^^^^^ S101
150 |     state_dict["new_key_local_only"] = "not_in_state_object"
151 |     assert "new_key_local_only" not in state._data  # Ensure it's a copy
    |

tests/praxis_state_tests.py:151:5: S101 Use of `assert` detected
    |
149 |     assert state_dict == initial_data
150 |     state_dict["new_key_local_only"] = "not_in_state_object"
151 |     assert "new_key_local_only" not in state._data  # Ensure it's a copy
    |     ^^^^^^ S101
152 | 
153 |   def test_clear_clears_data_and_deletes_from_redis(self, mock_redis_client: MagicMock):
    |

tests/praxis_state_tests.py:151:40: SLF001 Private member accessed: `_data`
    |
149 |     assert state_dict == initial_data
150 |     state_dict["new_key_local_only"] = "not_in_state_object"
151 |     assert "new_key_local_only" not in state._data  # Ensure it's a copy
    |                                        ^^^^^^^^^^^ SLF001
152 | 
153 |   def test_clear_clears_data_and_deletes_from_redis(self, mock_redis_client: MagicMock):
    |

tests/praxis_state_tests.py:153:7: ANN201 Missing return type annotation for public function `test_clear_clears_data_and_deletes_from_redis`
    |
151 |     assert "new_key_local_only" not in state._data  # Ensure it's a copy
152 | 
153 |   def test_clear_clears_data_and_deletes_from_redis(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
154 |     initial_data = {"key1": "val1"}
155 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:153:7: D102 Missing docstring in public method
    |
151 |     assert "new_key_local_only" not in state._data  # Ensure it's a copy
152 | 
153 |   def test_clear_clears_data_and_deletes_from_redis(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
154 |     initial_data = {"key1": "val1"}
155 |     mock_redis_client.get.return_value = json.dumps(initial_data).encode("utf-8")
    |

tests/praxis_state_tests.py:158:5: S101 Use of `assert` detected
    |
156 |     state = PraxisState(run_accession_id="test_run_clear")
157 | 
158 |     assert state.to_dict() == initial_data  # Ensure it's loaded
    |     ^^^^^^ S101
159 |     state.clear()
    |

tests/praxis_state_tests.py:161:5: S101 Use of `assert` detected
    |
159 |     state.clear()
160 | 
161 |     assert state.to_dict() == {}
    |     ^^^^^^ S101
162 |     assert state._data == {}
163 |     mock_redis_client.delete.assert_called_once_with("praxis_state:test_run_clear")
    |

tests/praxis_state_tests.py:162:5: S101 Use of `assert` detected
    |
161 |     assert state.to_dict() == {}
162 |     assert state._data == {}
    |     ^^^^^^ S101
163 |     mock_redis_client.delete.assert_called_once_with("praxis_state:test_run_clear")
    |

tests/praxis_state_tests.py:162:12: SLF001 Private member accessed: `_data`
    |
161 |     assert state.to_dict() == {}
162 |     assert state._data == {}
    |            ^^^^^^^^^^^ SLF001
163 |     mock_redis_client.delete.assert_called_once_with("praxis_state:test_run_clear")
    |

tests/praxis_state_tests.py:165:7: ANN201 Missing return type annotation for public function `test_attribute_access_set_and_get`
    |
163 |     mock_redis_client.delete.assert_called_once_with("praxis_state:test_run_clear")
164 | 
165 |   def test_attribute_access_set_and_get(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
166 |     mock_redis_client.get.return_value = None
167 |     state = PraxisState(run_accession_id="test_run_attr")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:165:7: D102 Missing docstring in public method
    |
163 |     mock_redis_client.delete.assert_called_once_with("praxis_state:test_run_clear")
164 | 
165 |   def test_attribute_access_set_and_get(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
166 |     mock_redis_client.get.return_value = None
167 |     state = PraxisState(run_accession_id="test_run_attr")
    |

tests/praxis_state_tests.py:170:5: S101 Use of `assert` detected
    |
169 |     state.my_attr = "attr_value"  # Tests __setattr__
170 |     assert state.my_attr == "attr_value"  # Tests __getattr__
    |     ^^^^^^ S101
171 |     assert state["my_attr"] == "attr_value"  # Verify via __getitem__ too
    |

tests/praxis_state_tests.py:171:5: S101 Use of `assert` detected
    |
169 |     state.my_attr = "attr_value"  # Tests __setattr__
170 |     assert state.my_attr == "attr_value"  # Tests __getattr__
171 |     assert state["my_attr"] == "attr_value"  # Verify via __getitem__ too
    |     ^^^^^^ S101
172 | 
173 |     expected_data = {"my_attr": "attr_value"}
    |

tests/praxis_state_tests.py:178:7: ANN201 Missing return type annotation for public function `test_attribute_access_get_non_existent`
    |
176 |     )
177 | 
178 |   def test_attribute_access_get_non_existent(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
179 |     mock_redis_client.get.return_value = None
180 |     state = PraxisState(run_accession_id="test_run_attr_get_fail")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:178:7: D102 Missing docstring in public method
    |
176 |     )
177 | 
178 |   def test_attribute_access_get_non_existent(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
179 |     mock_redis_client.get.return_value = None
180 |     state = PraxisState(run_accession_id="test_run_attr_get_fail")
    |

tests/praxis_state_tests.py:184:7: ANN201 Missing return type annotation for public function `test_set_internal_attribute`
    |
182 |       _ = state.non_existent_attr  # pylint: disable=pointless-statement
183 | 
184 |   def test_set_internal_attribute(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
185 |     mock_redis_client.get.return_value = None
186 |     state = PraxisState(run_accession_id="test_run_internal_attr")
    |
    = help: Add return type annotation: `None`

tests/praxis_state_tests.py:184:7: D102 Missing docstring in public method
    |
182 |       _ = state.non_existent_attr  # pylint: disable=pointless-statement
183 | 
184 |   def test_set_internal_attribute(self, mock_redis_client: MagicMock):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
185 |     mock_redis_client.get.return_value = None
186 |     state = PraxisState(run_accession_id="test_run_internal_attr")
    |

tests/praxis_state_tests.py:192:5: SLF001 Private member accessed: `_data`
    |
190 |       "new_accession_id"  # Should be handled by super().__setattr__
191 |     )
192 |     state._data = {
    |     ^^^^^^^^^^^ SLF001
193 |       "internal_override": "danger",
194 |     }  # Should be handled by super().__setattr__
    |

tests/praxis_state_tests.py:196:5: S101 Use of `assert` detected
    |
194 |     }  # Should be handled by super().__setattr__
195 | 
196 |     assert state.run_accession_id == "new_accession_id"
    |     ^^^^^^ S101
197 |     assert state._data == {"internal_override": "danger"}
198 |     mock_redis_client.set.assert_not_called()  # No save should happen for these internal attrs
    |

tests/praxis_state_tests.py:197:5: S101 Use of `assert` detected
    |
196 |     assert state.run_accession_id == "new_accession_id"
197 |     assert state._data == {"internal_override": "danger"}
    |     ^^^^^^ S101
198 |     mock_redis_client.set.assert_not_called()  # No save should happen for these internal attrs
    |

tests/praxis_state_tests.py:197:12: SLF001 Private member accessed: `_data`
    |
196 |     assert state.run_accession_id == "new_accession_id"
197 |     assert state._data == {"internal_override": "danger"}
    |            ^^^^^^^^^^^ SLF001
198 |     mock_redis_client.set.assert_not_called()  # No save should happen for these internal attrs
    |

tests/protocol_core_tests.py:1:1: INP001 File `tests/protocol_core_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/protocol_core_tests.py:1:1: D100 Missing docstring in public module
tests/protocol_core_tests.py:2:16: PGH003 Use specific rule codes when ignoring type issues
  |
2 | import pytest  # type: ignore
  |                ^^^^^^^^^^^^^^ PGH003
3 | 
4 | from praxis.backend.core.decorators import protocol_function
  |

tests/protocol_core_tests.py:12:7: D101 Missing docstring in public class
   |
11 | # Dummy PLR-like classes for type hinting in tests
12 | class DummyPipette(
   |       ^^^^^^^^^^^^ D101
13 |   Resource,
14 | ):  # Assuming Resource can be instantiated like this for test
   |

tests/protocol_core_tests.py:15:7: ANN204 Missing return type annotation for special method `__init__`
   |
13 |   Resource,
14 | ):  # Assuming Resource can be instantiated like this for test
15 |   def __init__(self, name: str, **kwargs):
   |       ^^^^^^^^ ANN204
16 |     super().__init__(
17 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_pipette", **kwargs,
   |
   = help: Add return type annotation: `None`

tests/protocol_core_tests.py:15:7: D107 Missing docstring in `__init__`
   |
13 |   Resource,
14 | ):  # Assuming Resource can be instantiated like this for test
15 |   def __init__(self, name: str, **kwargs):
   |       ^^^^^^^^ D107
16 |     super().__init__(
17 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_pipette", **kwargs,
   |

tests/protocol_core_tests.py:15:33: ANN003 Missing type annotation for `**kwargs`
   |
13 |   Resource,
14 | ):  # Assuming Resource can be instantiated like this for test
15 |   def __init__(self, name: str, **kwargs):
   |                                 ^^^^^^^^ ANN003
16 |     super().__init__(
17 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_pipette", **kwargs,
   |

tests/protocol_core_tests.py:21:7: D101 Missing docstring in public class
   |
21 | class DummyPlate(Resource):
   |       ^^^^^^^^^^ D101
22 |   def __init__(self, name: str, **kwargs):
23 |     super().__init__(
   |

tests/protocol_core_tests.py:22:7: ANN204 Missing return type annotation for special method `__init__`
   |
21 | class DummyPlate(Resource):
22 |   def __init__(self, name: str, **kwargs):
   |       ^^^^^^^^ ANN204
23 |     super().__init__(
24 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_plate", **kwargs,
   |
   = help: Add return type annotation: `None`

tests/protocol_core_tests.py:22:7: D107 Missing docstring in `__init__`
   |
21 | class DummyPlate(Resource):
22 |   def __init__(self, name: str, **kwargs):
   |       ^^^^^^^^ D107
23 |     super().__init__(
24 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_plate", **kwargs,
   |

tests/protocol_core_tests.py:22:33: ANN003 Missing type annotation for `**kwargs`
   |
21 | class DummyPlate(Resource):
22 |   def __init__(self, name: str, **kwargs):
   |                                 ^^^^^^^^ ANN003
23 |     super().__init__(
24 |       name=name, size_x=1, size_y=1, size_z=1, category="dummy_plate", **kwargs,
   |

tests/protocol_core_tests.py:29:5: ANN201 Missing return type annotation for public function `minimal_protocol_function_def`
   |
28 | @pytest.fixture
29 | def minimal_protocol_function_def():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |   @protocol_function(name="TestMinimal", version="1.0")
31 |   def _minimal_func(state: PraxisState):
   |
   = help: Add return type annotation

tests/protocol_core_tests.py:29:5: D103 Missing docstring in public function
   |
28 | @pytest.fixture
29 | def minimal_protocol_function_def():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
30 |   @protocol_function(name="TestMinimal", version="1.0")
31 |   def _minimal_func(state: PraxisState):
   |

tests/protocol_core_tests.py:31:7: ANN202 Missing return type annotation for private function `_minimal_func`
   |
29 | def minimal_protocol_function_def():
30 |   @protocol_function(name="TestMinimal", version="1.0")
31 |   def _minimal_func(state: PraxisState):
   |       ^^^^^^^^^^^^^ ANN202
32 |     return "done"
   |
   = help: Add return type annotation: `str`

tests/protocol_core_tests.py:31:21: ARG001 Unused function argument: `state`
   |
29 | def minimal_protocol_function_def():
30 |   @protocol_function(name="TestMinimal", version="1.0")
31 |   def _minimal_func(state: PraxisState):
   |                     ^^^^^ ARG001
32 |     return "done"
   |

tests/protocol_core_tests.py:38:5: ANN201 Missing return type annotation for public function `complex_protocol_function_def`
   |
37 | @pytest.fixture
38 | def complex_protocol_function_def():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
39 |   @protocol_function(
40 |     name="TestComplex",
   |
   = help: Add return type annotation

tests/protocol_core_tests.py:38:5: D103 Missing docstring in public function
   |
37 | @pytest.fixture
38 | def complex_protocol_function_def():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D103
39 |   @protocol_function(
40 |     name="TestComplex",
   |

tests/protocol_core_tests.py:54:7: ANN202 Missing return type annotation for private function `_complex_func`
   |
52 |     },
53 |   )
54 |   def _complex_func(
   |       ^^^^^^^^^^^^^ ANN202
55 |     state: PraxisState,
56 |     pipette: DummyPipette,
   |
   = help: Add return type annotation: `str`

tests/protocol_core_tests.py:55:5: ARG001 Unused function argument: `state`
   |
53 |   )
54 |   def _complex_func(
55 |     state: PraxisState,
   |     ^^^^^ ARG001
56 |     pipette: DummyPipette,
57 |     count: int = 5,
   |

tests/protocol_core_tests.py:62:121: E501 Line too long (131 > 120)
   |
60 |   ):
61 |     """Docstring for complex func."""
62 |     return f"ran {count} times for {name or 'default'} with {pipette.name} and {target_plate.name if target_plate else 'no plate'}"
   |                                                                                                                         ^^^^^^^^^^^ E501
63 | 
64 |   return _complex_func
   |

tests/protocol_core_tests.py:67:7: D101 Missing docstring in public class
   |
67 | class TestProtocolFunctionDecoratorMetadata:
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
   |

tests/protocol_core_tests.py:68:7: ANN201 Missing return type annotation for public function `test_decorator_attaches_pydantic_model`
   |
67 | class TestProtocolFunctionDecoratorMetadata:
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
70 |     assert isinstance(
   |
   = help: Add return type annotation: `None`

tests/protocol_core_tests.py:68:7: D102 Missing docstring in public method
   |
67 | class TestProtocolFunctionDecoratorMetadata:
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
70 |     assert isinstance(
   |

tests/protocol_core_tests.py:68:52: ANN001 Missing type annotation for function argument `minimal_protocol_function_def`
   |
67 | class TestProtocolFunctionDecoratorMetadata:
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
70 |     assert isinstance(
   |

tests/protocol_core_tests.py:69:5: S101 Use of `assert` detected
   |
67 | class TestProtocolFunctionDecoratorMetadata:
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
   |     ^^^^^^ S101
70 |     assert isinstance(
71 |       minimal_protocol_function_def._protocol_definition,
   |

tests/protocol_core_tests.py:70:5: S101 Use of `assert` detected
   |
68 |   def test_decorator_attaches_pydantic_model(self, minimal_protocol_function_def):
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
70 |     assert isinstance(
   |     ^^^^^^ S101
71 |       minimal_protocol_function_def._protocol_definition,
72 |       FunctionProtocolDefinitionModel,
   |

tests/protocol_core_tests.py:71:7: SLF001 Private member accessed: `_protocol_definition`
   |
69 |     assert hasattr(minimal_protocol_function_def, "_protocol_definition")
70 |     assert isinstance(
71 |       minimal_protocol_function_def._protocol_definition,
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
72 |       FunctionProtocolDefinitionModel,
73 |     )
   |

tests/protocol_core_tests.py:75:7: ANN201 Missing return type annotation for public function `test_minimal_definition_attributes`
   |
73 |     )
74 | 
75 |   def test_minimal_definition_attributes(self, minimal_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
76 |     model = minimal_protocol_function_def._protocol_definition
77 |     assert model.name == "TestMinimal"
   |
   = help: Add return type annotation: `None`

tests/protocol_core_tests.py:75:7: D102 Missing docstring in public method
   |
73 |     )
74 | 
75 |   def test_minimal_definition_attributes(self, minimal_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
76 |     model = minimal_protocol_function_def._protocol_definition
77 |     assert model.name == "TestMinimal"
   |

tests/protocol_core_tests.py:75:48: ANN001 Missing type annotation for function argument `minimal_protocol_function_def`
   |
73 |     )
74 | 
75 |   def test_minimal_definition_attributes(self, minimal_protocol_function_def):
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
76 |     model = minimal_protocol_function_def._protocol_definition
77 |     assert model.name == "TestMinimal"
   |

tests/protocol_core_tests.py:76:13: SLF001 Private member accessed: `_protocol_definition`
   |
75 |   def test_minimal_definition_attributes(self, minimal_protocol_function_def):
76 |     model = minimal_protocol_function_def._protocol_definition
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
77 |     assert model.name == "TestMinimal"
78 |     assert model.version == "1.0"
   |

tests/protocol_core_tests.py:77:5: S101 Use of `assert` detected
   |
75 |   def test_minimal_definition_attributes(self, minimal_protocol_function_def):
76 |     model = minimal_protocol_function_def._protocol_definition
77 |     assert model.name == "TestMinimal"
   |     ^^^^^^ S101
78 |     assert model.version == "1.0"
79 |     assert model.description == "No description provided."  # Default from decorator
   |

tests/protocol_core_tests.py:78:5: S101 Use of `assert` detected
   |
76 |     model = minimal_protocol_function_def._protocol_definition
77 |     assert model.name == "TestMinimal"
78 |     assert model.version == "1.0"
   |     ^^^^^^ S101
79 |     assert model.description == "No description provided."  # Default from decorator
80 |     assert model.function_name == "_minimal_func"
   |

tests/protocol_core_tests.py:79:5: S101 Use of `assert` detected
   |
77 |     assert model.name == "TestMinimal"
78 |     assert model.version == "1.0"
79 |     assert model.description == "No description provided."  # Default from decorator
   |     ^^^^^^ S101
80 |     assert model.function_name == "_minimal_func"
81 |     assert model.module_name == __name__  # Test runs in this module
   |

tests/protocol_core_tests.py:80:5: S101 Use of `assert` detected
   |
78 |     assert model.version == "1.0"
79 |     assert model.description == "No description provided."  # Default from decorator
80 |     assert model.function_name == "_minimal_func"
   |     ^^^^^^ S101
81 |     assert model.module_name == __name__  # Test runs in this module
82 |     assert not model.is_top_level
   |

tests/protocol_core_tests.py:81:5: S101 Use of `assert` detected
   |
79 |     assert model.description == "No description provided."  # Default from decorator
80 |     assert model.function_name == "_minimal_func"
81 |     assert model.module_name == __name__  # Test runs in this module
   |     ^^^^^^ S101
82 |     assert not model.is_top_level
83 |     assert model.state_param_name == "state"  # Default
   |

tests/protocol_core_tests.py:82:5: S101 Use of `assert` detected
   |
80 |     assert model.function_name == "_minimal_func"
81 |     assert model.module_name == __name__  # Test runs in this module
82 |     assert not model.is_top_level
   |     ^^^^^^ S101
83 |     assert model.state_param_name == "state"  # Default
   |

tests/protocol_core_tests.py:83:5: S101 Use of `assert` detected
   |
81 |     assert model.module_name == __name__  # Test runs in this module
82 |     assert not model.is_top_level
83 |     assert model.state_param_name == "state"  # Default
   |     ^^^^^^ S101
84 | 
85 |     assert len(model.parameters) == 1
   |

tests/protocol_core_tests.py:85:5: S101 Use of `assert` detected
   |
83 |     assert model.state_param_name == "state"  # Default
84 | 
85 |     assert len(model.parameters) == 1
   |     ^^^^^^ S101
86 |     state_param = model.parameters[0]
87 |     assert state_param.name == "state"
   |

tests/protocol_core_tests.py:87:5: S101 Use of `assert` detected
   |
85 |     assert len(model.parameters) == 1
86 |     state_param = model.parameters[0]
87 |     assert state_param.name == "state"
   |     ^^^^^^ S101
88 |     assert "PraxisState" in state_param.actual_type_str
89 |     assert not state_param.optional
   |

tests/protocol_core_tests.py:88:5: S101 Use of `assert` detected
   |
86 |     state_param = model.parameters[0]
87 |     assert state_param.name == "state"
88 |     assert "PraxisState" in state_param.actual_type_str
   |     ^^^^^^ S101
89 |     assert not state_param.optional
   |

tests/protocol_core_tests.py:89:5: S101 Use of `assert` detected
   |
87 |     assert state_param.name == "state"
88 |     assert "PraxisState" in state_param.actual_type_str
89 |     assert not state_param.optional
   |     ^^^^^^ S101
90 | 
91 |     assert len(model.assets) == 0
   |

tests/protocol_core_tests.py:91:5: S101 Use of `assert` detected
   |
89 |     assert not state_param.optional
90 | 
91 |     assert len(model.assets) == 0
   |     ^^^^^^ S101
92 | 
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
   |

tests/protocol_core_tests.py:93:7: ANN201 Missing return type annotation for public function `test_complex_definition_attributes`
   |
91 |     assert len(model.assets) == 0
92 | 
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
94 |     model = complex_protocol_function_def._protocol_definition
95 |     assert model.name == "TestComplex"
   |
   = help: Add return type annotation: `None`

tests/protocol_core_tests.py:93:7: D102 Missing docstring in public method
   |
91 |     assert len(model.assets) == 0
92 | 
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
94 |     model = complex_protocol_function_def._protocol_definition
95 |     assert model.name == "TestComplex"
   |

tests/protocol_core_tests.py:93:48: ANN001 Missing type annotation for function argument `complex_protocol_function_def`
   |
91 |     assert len(model.assets) == 0
92 | 
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
94 |     model = complex_protocol_function_def._protocol_definition
95 |     assert model.name == "TestComplex"
   |

tests/protocol_core_tests.py:94:13: SLF001 Private member accessed: `_protocol_definition`
   |
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
94 |     model = complex_protocol_function_def._protocol_definition
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
95 |     assert model.name == "TestComplex"
96 |     assert model.version == "1.1"
   |

tests/protocol_core_tests.py:95:5: S101 Use of `assert` detected
   |
93 |   def test_complex_definition_attributes(self, complex_protocol_function_def):
94 |     model = complex_protocol_function_def._protocol_definition
95 |     assert model.name == "TestComplex"
   |     ^^^^^^ S101
96 |     assert model.version == "1.1"
97 |     assert model.description == "A complex test protocol."  # Explicit description
   |

tests/protocol_core_tests.py:96:5: S101 Use of `assert` detected
   |
94 |     model = complex_protocol_function_def._protocol_definition
95 |     assert model.name == "TestComplex"
96 |     assert model.version == "1.1"
   |     ^^^^^^ S101
97 |     assert model.description == "A complex test protocol."  # Explicit description
98 |     assert model.is_top_level
   |

tests/protocol_core_tests.py:97:5: S101 Use of `assert` detected
   |
95 |     assert model.name == "TestComplex"
96 |     assert model.version == "1.1"
97 |     assert model.description == "A complex test protocol."  # Explicit description
   |     ^^^^^^ S101
98 |     assert model.is_top_level
99 |     assert model.category == "testing"
   |

tests/protocol_core_tests.py:98:5: S101 Use of `assert` detected
    |
 96 |     assert model.version == "1.1"
 97 |     assert model.description == "A complex test protocol."  # Explicit description
 98 |     assert model.is_top_level
    |     ^^^^^^ S101
 99 |     assert model.category == "testing"
100 |     assert model.tags == ["complex", "example"]
    |

tests/protocol_core_tests.py:99:5: S101 Use of `assert` detected
    |
 97 |     assert model.description == "A complex test protocol."  # Explicit description
 98 |     assert model.is_top_level
 99 |     assert model.category == "testing"
    |     ^^^^^^ S101
100 |     assert model.tags == ["complex", "example"]
    |

tests/protocol_core_tests.py:100:5: S101 Use of `assert` detected
    |
 98 |     assert model.is_top_level
 99 |     assert model.category == "testing"
100 |     assert model.tags == ["complex", "example"]
    |     ^^^^^^ S101
101 | 
102 |     assert len(model.parameters) == 3  # state, count, name
    |

tests/protocol_core_tests.py:102:5: S101 Use of `assert` detected
    |
100 |     assert model.tags == ["complex", "example"]
101 | 
102 |     assert len(model.parameters) == 3  # state, count, name
    |     ^^^^^^ S101
103 |     param_names = {p.name for p in model.parameters}
104 |     assert param_names == {"state", "count", "name"}
    |

tests/protocol_core_tests.py:102:37: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
100 |     assert model.tags == ["complex", "example"]
101 | 
102 |     assert len(model.parameters) == 3  # state, count, name
    |                                     ^ PLR2004
103 |     param_names = {p.name for p in model.parameters}
104 |     assert param_names == {"state", "count", "name"}
    |

tests/protocol_core_tests.py:104:5: S101 Use of `assert` detected
    |
102 |     assert len(model.parameters) == 3  # state, count, name
103 |     param_names = {p.name for p in model.parameters}
104 |     assert param_names == {"state", "count", "name"}
    |     ^^^^^^ S101
105 | 
106 |     count_param = next(p for p in model.parameters if p.name == "count")
    |

tests/protocol_core_tests.py:107:5: S101 Use of `assert` detected
    |
106 |     count_param = next(p for p in model.parameters if p.name == "count")
107 |     assert count_param.actual_type_str == "int"
    |     ^^^^^^ S101
108 |     assert count_param.optional  # Has default value
109 |     assert count_param.default_value_repr == "5"
    |

tests/protocol_core_tests.py:108:5: S101 Use of `assert` detected
    |
106 |     count_param = next(p for p in model.parameters if p.name == "count")
107 |     assert count_param.actual_type_str == "int"
108 |     assert count_param.optional  # Has default value
    |     ^^^^^^ S101
109 |     assert count_param.default_value_repr == "5"
110 |     assert count_param.description == "Number of times."
    |

tests/protocol_core_tests.py:109:5: S101 Use of `assert` detected
    |
107 |     assert count_param.actual_type_str == "int"
108 |     assert count_param.optional  # Has default value
109 |     assert count_param.default_value_repr == "5"
    |     ^^^^^^ S101
110 |     assert count_param.description == "Number of times."
111 |     assert count_param.ui_hints is not None
    |

tests/protocol_core_tests.py:110:5: S101 Use of `assert` detected
    |
108 |     assert count_param.optional  # Has default value
109 |     assert count_param.default_value_repr == "5"
110 |     assert count_param.description == "Number of times."
    |     ^^^^^^ S101
111 |     assert count_param.ui_hints is not None
112 |     assert count_param.ui_hints.widget_type == "slider"
    |

tests/protocol_core_tests.py:111:5: S101 Use of `assert` detected
    |
109 |     assert count_param.default_value_repr == "5"
110 |     assert count_param.description == "Number of times."
111 |     assert count_param.ui_hints is not None
    |     ^^^^^^ S101
112 |     assert count_param.ui_hints.widget_type == "slider"
113 |     assert count_param.ui_hints.min_value == 1
    |

tests/protocol_core_tests.py:112:5: S101 Use of `assert` detected
    |
110 |     assert count_param.description == "Number of times."
111 |     assert count_param.ui_hints is not None
112 |     assert count_param.ui_hints.widget_type == "slider"
    |     ^^^^^^ S101
113 |     assert count_param.ui_hints.min_value == 1
    |

tests/protocol_core_tests.py:113:5: S101 Use of `assert` detected
    |
111 |     assert count_param.ui_hints is not None
112 |     assert count_param.ui_hints.widget_type == "slider"
113 |     assert count_param.ui_hints.min_value == 1
    |     ^^^^^^ S101
114 | 
115 |     name_param = next(p for p in model.parameters if p.name == "name")
    |

tests/protocol_core_tests.py:116:5: S101 Use of `assert` detected
    |
115 |     name_param = next(p for p in model.parameters if p.name == "name")
116 |     assert "str" in name_param.actual_type_str  # Optional[str]
    |     ^^^^^^ S101
117 |     assert name_param.optional
118 |     assert name_param.default_value_repr is None  # Optional without explicit default
    |

tests/protocol_core_tests.py:117:5: S101 Use of `assert` detected
    |
115 |     name_param = next(p for p in model.parameters if p.name == "name")
116 |     assert "str" in name_param.actual_type_str  # Optional[str]
117 |     assert name_param.optional
    |     ^^^^^^ S101
118 |     assert name_param.default_value_repr is None  # Optional without explicit default
119 |     assert name_param.constraints_json == {"max_length": 50}
    |

tests/protocol_core_tests.py:118:5: S101 Use of `assert` detected
    |
116 |     assert "str" in name_param.actual_type_str  # Optional[str]
117 |     assert name_param.optional
118 |     assert name_param.default_value_repr is None  # Optional without explicit default
    |     ^^^^^^ S101
119 |     assert name_param.constraints_json == {"max_length": 50}
    |

tests/protocol_core_tests.py:119:5: S101 Use of `assert` detected
    |
117 |     assert name_param.optional
118 |     assert name_param.default_value_repr is None  # Optional without explicit default
119 |     assert name_param.constraints_json == {"max_length": 50}
    |     ^^^^^^ S101
120 | 
121 |     assert len(model.assets) == 2  # pipette, target_plate
    |

tests/protocol_core_tests.py:121:5: S101 Use of `assert` detected
    |
119 |     assert name_param.constraints_json == {"max_length": 50}
120 | 
121 |     assert len(model.assets) == 2  # pipette, target_plate
    |     ^^^^^^ S101
122 |     asset_names = {a.name for a in model.assets}
123 |     assert asset_names == {"pipette", "target_plate"}
    |

tests/protocol_core_tests.py:121:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
119 |     assert name_param.constraints_json == {"max_length": 50}
120 | 
121 |     assert len(model.assets) == 2  # pipette, target_plate
    |                                 ^ PLR2004
122 |     asset_names = {a.name for a in model.assets}
123 |     assert asset_names == {"pipette", "target_plate"}
    |

tests/protocol_core_tests.py:123:5: S101 Use of `assert` detected
    |
121 |     assert len(model.assets) == 2  # pipette, target_plate
122 |     asset_names = {a.name for a in model.assets}
123 |     assert asset_names == {"pipette", "target_plate"}
    |     ^^^^^^ S101
124 | 
125 |     pipette_asset = next(a for a in model.assets if a.name == "pipette")
    |

tests/protocol_core_tests.py:126:5: S101 Use of `assert` detected
    |
125 |     pipette_asset = next(a for a in model.assets if a.name == "pipette")
126 |     assert "DummyPipette" in pipette_asset.actual_type_str
    |     ^^^^^^ S101
127 |     assert not pipette_asset.optional
    |

tests/protocol_core_tests.py:127:5: S101 Use of `assert` detected
    |
125 |     pipette_asset = next(a for a in model.assets if a.name == "pipette")
126 |     assert "DummyPipette" in pipette_asset.actual_type_str
127 |     assert not pipette_asset.optional
    |     ^^^^^^ S101
128 | 
129 |     plate_asset = next(a for a in model.assets if a.name == "target_plate")
    |

tests/protocol_core_tests.py:130:5: S101 Use of `assert` detected
    |
129 |     plate_asset = next(a for a in model.assets if a.name == "target_plate")
130 |     assert "DummyPlate" in plate_asset.actual_type_str
    |     ^^^^^^ S101
131 |     assert plate_asset.optional
    |

tests/protocol_core_tests.py:131:5: S101 Use of `assert` detected
    |
129 |     plate_asset = next(a for a in model.assets if a.name == "target_plate")
130 |     assert "DummyPlate" in plate_asset.actual_type_str
131 |     assert plate_asset.optional
    |     ^^^^^^ S101
132 | 
133 |   def test_default_name_from_function(self):
    |

tests/protocol_core_tests.py:133:7: ANN201 Missing return type annotation for public function `test_default_name_from_function`
    |
131 |     assert plate_asset.optional
132 | 
133 |   def test_default_name_from_function(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
134 |     @protocol_function(version="0.1")  # Name not provided
135 |     def _my_actual_func_name(state: PraxisState):
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:133:7: D102 Missing docstring in public method
    |
131 |     assert plate_asset.optional
132 | 
133 |   def test_default_name_from_function(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
134 |     @protocol_function(version="0.1")  # Name not provided
135 |     def _my_actual_func_name(state: PraxisState):
    |

tests/protocol_core_tests.py:135:9: ANN202 Missing return type annotation for private function `_my_actual_func_name`
    |
133 |   def test_default_name_from_function(self):
134 |     @protocol_function(version="0.1")  # Name not provided
135 |     def _my_actual_func_name(state: PraxisState):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN202
136 |       pass
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:138:13: SLF001 Private member accessed: `_protocol_definition`
    |
136 |       pass
137 | 
138 |     model = _my_actual_func_name._protocol_definition
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
139 |     assert model.name == "_my_actual_func_name"
    |

tests/protocol_core_tests.py:139:5: S101 Use of `assert` detected
    |
138 |     model = _my_actual_func_name._protocol_definition
139 |     assert model.name == "_my_actual_func_name"
    |     ^^^^^^ S101
140 | 
141 |   def test_docstring_as_description(self):
    |

tests/protocol_core_tests.py:141:7: ANN201 Missing return type annotation for public function `test_docstring_as_description`
    |
139 |     assert model.name == "_my_actual_func_name"
140 | 
141 |   def test_docstring_as_description(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
142 |     @protocol_function()
143 |     def _func_with_docstring(state: PraxisState):
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:141:7: D102 Missing docstring in public method
    |
139 |     assert model.name == "_my_actual_func_name"
140 | 
141 |   def test_docstring_as_description(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
142 |     @protocol_function()
143 |     def _func_with_docstring(state: PraxisState):
    |

tests/protocol_core_tests.py:143:9: ANN202 Missing return type annotation for private function `_func_with_docstring`
    |
141 |   def test_docstring_as_description(self):
142 |     @protocol_function()
143 |     def _func_with_docstring(state: PraxisState):
    |         ^^^^^^^^^^^^^^^^^^^^ ANN202
144 |       """This is the docstring."""
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:144:7: D401 First line of docstring should be in imperative mood: "This is the docstring."
    |
142 |     @protocol_function()
143 |     def _func_with_docstring(state: PraxisState):
144 |       """This is the docstring."""
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
145 | 
146 |     model = _func_with_docstring._protocol_definition
    |

tests/protocol_core_tests.py:144:7: D404 First word of the docstring should not be "This"
    |
142 |     @protocol_function()
143 |     def _func_with_docstring(state: PraxisState):
144 |       """This is the docstring."""
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D404
145 | 
146 |     model = _func_with_docstring._protocol_definition
    |

tests/protocol_core_tests.py:146:13: SLF001 Private member accessed: `_protocol_definition`
    |
144 |       """This is the docstring."""
145 | 
146 |     model = _func_with_docstring._protocol_definition
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
147 |     assert model.description == "This is the docstring."
    |

tests/protocol_core_tests.py:147:5: S101 Use of `assert` detected
    |
146 |     model = _func_with_docstring._protocol_definition
147 |     assert model.description == "This is the docstring."
    |     ^^^^^^ S101
    |

tests/protocol_core_tests.py:150:7: D101 Missing docstring in public class
    |
150 | class TestProtocolFunctionWrapperInvocation:
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D101
151 |   def test_wrapper_calls_original_function(self, minimal_protocol_function_def):
152 |     # For unit testing the wrapper's basic call, mock the PraxisRunContext and db logging.
    |

tests/protocol_core_tests.py:151:7: ANN201 Missing return type annotation for public function `test_wrapper_calls_original_function`
    |
150 | class TestProtocolFunctionWrapperInvocation:
151 |   def test_wrapper_calls_original_function(self, minimal_protocol_function_def):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
152 |     # For unit testing the wrapper's basic call, mock the PraxisRunContext and db logging.
153 |     # This test focuses on the metadata part being mostly done.
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:151:7: D102 Missing docstring in public method
    |
150 | class TestProtocolFunctionWrapperInvocation:
151 |   def test_wrapper_calls_original_function(self, minimal_protocol_function_def):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
152 |     # For unit testing the wrapper's basic call, mock the PraxisRunContext and db logging.
153 |     # This test focuses on the metadata part being mostly done.
    |

tests/protocol_core_tests.py:151:50: ANN001 Missing type annotation for function argument `minimal_protocol_function_def`
    |
150 | class TestProtocolFunctionWrapperInvocation:
151 |   def test_wrapper_calls_original_function(self, minimal_protocol_function_def):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
152 |     # For unit testing the wrapper's basic call, mock the PraxisRunContext and db logging.
153 |     # This test focuses on the metadata part being mostly done.
    |

tests/protocol_core_tests.py:161:5: S101 Use of `assert` detected
    |
159 |     # So, calling without __praxis_run_context__ should still work.
160 |     result = minimal_protocol_function_def()  # Call without context
161 |     assert result == "done"
    |     ^^^^^^ S101
162 | 
163 |     # Test with a simplified dummy context (if needed for specific checks not covered by no-context call)
    |

tests/protocol_core_tests.py:167:7: D101 Missing docstring in public class
    |
167 | class TestPraxisRunContext:
    |       ^^^^^^^^^^^^^^^^^^^^ D101
168 |   def test_praxis_run_context_creation_and_attributes(self):
169 |     # Assuming PraxisState can be instantiated (even if it's the Redis-backed one, for type hint)
    |

tests/protocol_core_tests.py:168:7: ANN201 Missing return type annotation for public function `test_praxis_run_context_creation_and_attributes`
    |
167 | class TestPraxisRunContext:
168 |   def test_praxis_run_context_creation_and_attributes(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
169 |     # Assuming PraxisState can be instantiated (even if it's the Redis-backed one, for type hint)
170 |     # For unit test, we assume PraxisState from definitions is usable without full Redis.
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:168:7: D102 Missing docstring in public method
    |
167 | class TestPraxisRunContext:
168 |   def test_praxis_run_context_creation_and_attributes(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
169 |     # Assuming PraxisState can be instantiated (even if it's the Redis-backed one, for type hint)
170 |     # For unit test, we assume PraxisState from definitions is usable without full Redis.
    |

tests/protocol_core_tests.py:182:5: S101 Use of `assert` detected
    |
180 |       current_call_log_db_accession_id=None,
181 |     )
182 |     assert context.protocol_run_db_accession_id == 1
    |     ^^^^^^ S101
183 |     assert context.run_accession_id == "test-run-accession_id-ctx"
184 |     assert context.canonical_state is mock_state
    |

tests/protocol_core_tests.py:183:5: S101 Use of `assert` detected
    |
181 |     )
182 |     assert context.protocol_run_db_accession_id == 1
183 |     assert context.run_accession_id == "test-run-accession_id-ctx"
    |     ^^^^^^ S101
184 |     assert context.canonical_state is mock_state
185 |     assert context.current_db_session is mock_db_session
    |

tests/protocol_core_tests.py:184:5: S101 Use of `assert` detected
    |
182 |     assert context.protocol_run_db_accession_id == 1
183 |     assert context.run_accession_id == "test-run-accession_id-ctx"
184 |     assert context.canonical_state is mock_state
    |     ^^^^^^ S101
185 |     assert context.current_db_session is mock_db_session
186 |     assert context.current_call_log_db_accession_id is None
    |

tests/protocol_core_tests.py:185:5: S101 Use of `assert` detected
    |
183 |     assert context.run_accession_id == "test-run-accession_id-ctx"
184 |     assert context.canonical_state is mock_state
185 |     assert context.current_db_session is mock_db_session
    |     ^^^^^^ S101
186 |     assert context.current_call_log_db_accession_id is None
187 |     assert context._call_sequence_next_val == 1
    |

tests/protocol_core_tests.py:186:5: S101 Use of `assert` detected
    |
184 |     assert context.canonical_state is mock_state
185 |     assert context.current_db_session is mock_db_session
186 |     assert context.current_call_log_db_accession_id is None
    |     ^^^^^^ S101
187 |     assert context._call_sequence_next_val == 1
    |

tests/protocol_core_tests.py:187:5: S101 Use of `assert` detected
    |
185 |     assert context.current_db_session is mock_db_session
186 |     assert context.current_call_log_db_accession_id is None
187 |     assert context._call_sequence_next_val == 1
    |     ^^^^^^ S101
188 | 
189 |   def test_get_and_increment_sequence_val(self):
    |

tests/protocol_core_tests.py:187:12: SLF001 Private member accessed: `_call_sequence_next_val`
    |
185 |     assert context.current_db_session is mock_db_session
186 |     assert context.current_call_log_db_accession_id is None
187 |     assert context._call_sequence_next_val == 1
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
188 | 
189 |   def test_get_and_increment_sequence_val(self):
    |

tests/protocol_core_tests.py:189:7: ANN201 Missing return type annotation for public function `test_get_and_increment_sequence_val`
    |
187 |     assert context._call_sequence_next_val == 1
188 | 
189 |   def test_get_and_increment_sequence_val(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
190 |     context = PraxisRunContext(
191 |       1,
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:189:7: D102 Missing docstring in public method
    |
187 |     assert context._call_sequence_next_val == 1
188 | 
189 |   def test_get_and_increment_sequence_val(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
190 |     context = PraxisRunContext(
191 |       1,
    |

tests/protocol_core_tests.py:197:5: S101 Use of `assert` detected
    |
195 |       None,
196 |     )
197 |     assert context.get_and_increment_sequence_val() == 1
    |     ^^^^^^ S101
198 |     assert context.get_and_increment_sequence_val() == 2
199 |     assert context._call_sequence_next_val == 3
    |

tests/protocol_core_tests.py:198:5: S101 Use of `assert` detected
    |
196 |     )
197 |     assert context.get_and_increment_sequence_val() == 1
198 |     assert context.get_and_increment_sequence_val() == 2
    |     ^^^^^^ S101
199 |     assert context._call_sequence_next_val == 3
    |

tests/protocol_core_tests.py:198:56: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
196 |     )
197 |     assert context.get_and_increment_sequence_val() == 1
198 |     assert context.get_and_increment_sequence_val() == 2
    |                                                        ^ PLR2004
199 |     assert context._call_sequence_next_val == 3
    |

tests/protocol_core_tests.py:199:5: S101 Use of `assert` detected
    |
197 |     assert context.get_and_increment_sequence_val() == 1
198 |     assert context.get_and_increment_sequence_val() == 2
199 |     assert context._call_sequence_next_val == 3
    |     ^^^^^^ S101
200 | 
201 |   def test_create_context_for_nested_call(self):
    |

tests/protocol_core_tests.py:199:12: SLF001 Private member accessed: `_call_sequence_next_val`
    |
197 |     assert context.get_and_increment_sequence_val() == 1
198 |     assert context.get_and_increment_sequence_val() == 2
199 |     assert context._call_sequence_next_val == 3
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
200 | 
201 |   def test_create_context_for_nested_call(self):
    |

tests/protocol_core_tests.py:199:47: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
197 |     assert context.get_and_increment_sequence_val() == 1
198 |     assert context.get_and_increment_sequence_val() == 2
199 |     assert context._call_sequence_next_val == 3
    |                                               ^ PLR2004
200 | 
201 |   def test_create_context_for_nested_call(self):
    |

tests/protocol_core_tests.py:201:7: ANN201 Missing return type annotation for public function `test_create_context_for_nested_call`
    |
199 |     assert context._call_sequence_next_val == 3
200 | 
201 |   def test_create_context_for_nested_call(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
202 |     mock_state = PraxisState(run_accession_id="test-run-accession_id-parent")
203 |     mock_db_session = object()
    |
    = help: Add return type annotation: `None`

tests/protocol_core_tests.py:201:7: D102 Missing docstring in public method
    |
199 |     assert context._call_sequence_next_val == 3
200 | 
201 |   def test_create_context_for_nested_call(self):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
202 |     mock_state = PraxisState(run_accession_id="test-run-accession_id-parent")
203 |     mock_db_session = object()
    |

tests/protocol_core_tests.py:212:5: SLF001 Private member accessed: `_call_sequence_next_val`
    |
210 |       current_call_log_db_accession_id=100,  # Parent's own log ID (becomes parent_accession_id for nested)
211 |     )
212 |     parent_context._call_sequence_next_val = 5  # Simulate some calls happened
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
213 | 
214 |     # This new_parent_call_log_db_accession_id is the log ID of the function that is *creating* this nested context.
    |

tests/protocol_core_tests.py:220:5: S101 Use of `assert` detected
    |
218 |     )
219 | 
220 |     assert (
    |     ^^^^^^ S101
221 |       nested_context.protocol_run_db_accession_id
222 |       == parent_context.protocol_run_db_accession_id
    |

tests/protocol_core_tests.py:224:5: S101 Use of `assert` detected
    |
222 |       == parent_context.protocol_run_db_accession_id
223 |     )
224 |     assert nested_context.run_accession_id == parent_context.run_accession_id
    |     ^^^^^^ S101
225 |     assert nested_context.canonical_state == parent_context.canonical_state
226 |     assert nested_context.current_db_session == parent_context.current_db_session
    |

tests/protocol_core_tests.py:225:5: S101 Use of `assert` detected
    |
223 |     )
224 |     assert nested_context.run_accession_id == parent_context.run_accession_id
225 |     assert nested_context.canonical_state == parent_context.canonical_state
    |     ^^^^^^ S101
226 |     assert nested_context.current_db_session == parent_context.current_db_session
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
    |

tests/protocol_core_tests.py:226:5: S101 Use of `assert` detected
    |
224 |     assert nested_context.run_accession_id == parent_context.run_accession_id
225 |     assert nested_context.canonical_state == parent_context.canonical_state
226 |     assert nested_context.current_db_session == parent_context.current_db_session
    |     ^^^^^^ S101
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
    |

tests/protocol_core_tests.py:228:5: S101 Use of `assert` detected
    |
226 |     assert nested_context.current_db_session == parent_context.current_db_session
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
    |     ^^^^^^ S101
229 |     assert nested_context._call_sequence_next_val == 5  # Sequence counter continues
    |

tests/protocol_core_tests.py:228:63: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
226 |     assert nested_context.current_db_session == parent_context.current_db_session
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
    |                                                               ^^^ PLR2004
229 |     assert nested_context._call_sequence_next_val == 5  # Sequence counter continues
    |

tests/protocol_core_tests.py:229:5: S101 Use of `assert` detected
    |
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
229 |     assert nested_context._call_sequence_next_val == 5  # Sequence counter continues
    |     ^^^^^^ S101
    |

tests/protocol_core_tests.py:229:12: SLF001 Private member accessed: `_call_sequence_next_val`
    |
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
229 |     assert nested_context._call_sequence_next_val == 5  # Sequence counter continues
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
    |

tests/protocol_core_tests.py:229:54: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
227 |     # The 'current_call_log_db_accession_id' of the nested context IS the parent's log ID.
228 |     assert nested_context.current_call_log_db_accession_id == 100
229 |     assert nested_context._call_sequence_next_val == 5  # Sequence counter continues
    |                                                      ^ PLR2004
    |

tests/services/test_deck.py:1:1: INP001 File `tests/services/test_deck.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_deck.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/services/deck.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/services/test_deck.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/services/deck.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/services/test_deck.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/services/deck.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/services/test_deck.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/services/test_deck.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/services/test_deck.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/services/test_deck_instance.py:1:1: INP001 File `tests/services/test_deck_instance.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_deck_instance.py:1:1: D100 Missing docstring in public module
tests/services/test_deck_instance.py:28:11: ANN201 Missing return type annotation for public function `setup_test_data`
   |
27 | @pytest.fixture
28 | async def setup_test_data(db: AsyncSession):
   |           ^^^^^^^^^^^^^^^ ANN201
29 |   """Set up initial data required for deck instance tests."""
30 |   # 1. Create a resource definition for a deck
   |
   = help: Add return type annotation

tests/services/test_deck_instance.py:80:13: ANN201 Missing return type annotation for public function `test_create_deck_instance_success`
   |
78 |   """Test suite for deck instance service functions."""
79 | 
80 |   async def test_create_deck_instance_success(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
81 |     self,
82 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:98:5: S101 Use of `assert` detected
    |
 96 |     )
 97 | 
 98 |     assert created_deck is not None
    |     ^^^^^^ S101
 99 |     assert created_deck.name == deck_name
100 |     assert created_deck.fqn == fqn
    |

tests/services/test_deck_instance.py:99:5: S101 Use of `assert` detected
    |
 98 |     assert created_deck is not None
 99 |     assert created_deck.name == deck_name
    |     ^^^^^^ S101
100 |     assert created_deck.fqn == fqn
101 |     assert created_deck.deck_accession_id == deck_resource.accession_id
    |

tests/services/test_deck_instance.py:100:5: S101 Use of `assert` detected
    |
 98 |     assert created_deck is not None
 99 |     assert created_deck.name == deck_name
100 |     assert created_deck.fqn == fqn
    |     ^^^^^^ S101
101 |     assert created_deck.deck_accession_id == deck_resource.accession_id
102 |     assert created_deck.description == "A test description."
    |

tests/services/test_deck_instance.py:101:5: S101 Use of `assert` detected
    |
 99 |     assert created_deck.name == deck_name
100 |     assert created_deck.fqn == fqn
101 |     assert created_deck.deck_accession_id == deck_resource.accession_id
    |     ^^^^^^ S101
102 |     assert created_deck.description == "A test description."
103 |     assert len(created_deck.position_items) == 0
    |

tests/services/test_deck_instance.py:102:5: S101 Use of `assert` detected
    |
100 |     assert created_deck.fqn == fqn
101 |     assert created_deck.deck_accession_id == deck_resource.accession_id
102 |     assert created_deck.description == "A test description."
    |     ^^^^^^ S101
103 |     assert len(created_deck.position_items) == 0
    |

tests/services/test_deck_instance.py:103:5: S101 Use of `assert` detected
    |
101 |     assert created_deck.deck_accession_id == deck_resource.accession_id
102 |     assert created_deck.description == "A test description."
103 |     assert len(created_deck.position_items) == 0
    |     ^^^^^^ S101
104 | 
105 |   async def test_create_deck_instance_with_positions(
    |

tests/services/test_deck_instance.py:105:13: ANN201 Missing return type annotation for public function `test_create_deck_instance_with_positions`
    |
103 |     assert len(created_deck.position_items) == 0
104 | 
105 |   async def test_create_deck_instance_with_positions(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
106 |     self,
107 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:135:5: S101 Use of `assert` detected
    |
133 |     )
134 | 
135 |     assert created_deck is not None
    |     ^^^^^^ S101
136 |     assert len(created_deck.position_items) == 2
    |

tests/services/test_deck_instance.py:136:5: S101 Use of `assert` detected
    |
135 |     assert created_deck is not None
136 |     assert len(created_deck.position_items) == 2
    |     ^^^^^^ S101
137 | 
138 |     pos_a1 = next(
    |

tests/services/test_deck_instance.py:136:48: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
135 |     assert created_deck is not None
136 |     assert len(created_deck.position_items) == 2
    |                                                ^ PLR2004
137 | 
138 |     pos_a1 = next(
    |

tests/services/test_deck_instance.py:147:5: S101 Use of `assert` detected
    |
145 |     )
146 | 
147 |     assert pos_a1 is not None
    |     ^^^^^^ S101
148 |     assert pos_a1.resource_instance_accession_id == plate_resource.accession_id
149 |     assert pos_a1.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_instance.py:148:5: S101 Use of `assert` detected
    |
147 |     assert pos_a1 is not None
148 |     assert pos_a1.resource_instance_accession_id == plate_resource.accession_id
    |     ^^^^^^ S101
149 |     assert pos_a1.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_instance.py:149:5: S101 Use of `assert` detected
    |
147 |     assert pos_a1 is not None
148 |     assert pos_a1.resource_instance_accession_id == plate_resource.accession_id
149 |     assert pos_a1.expected_resource_definition_name == plate_def.name
    |     ^^^^^^ S101
150 | 
151 |     assert pos_b1 is not None
    |

tests/services/test_deck_instance.py:151:5: S101 Use of `assert` detected
    |
149 |     assert pos_a1.expected_resource_definition_name == plate_def.name
150 | 
151 |     assert pos_b1 is not None
    |     ^^^^^^ S101
152 |     assert pos_b1.resource_instance_accession_id is None
153 |     assert pos_b1.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_instance.py:152:5: S101 Use of `assert` detected
    |
151 |     assert pos_b1 is not None
152 |     assert pos_b1.resource_instance_accession_id is None
    |     ^^^^^^ S101
153 |     assert pos_b1.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_instance.py:153:5: S101 Use of `assert` detected
    |
151 |     assert pos_b1 is not None
152 |     assert pos_b1.resource_instance_accession_id is None
153 |     assert pos_b1.expected_resource_definition_name == plate_def.name
    |     ^^^^^^ S101
154 | 
155 |   async def test_create_deck_instance_duplicate_name_fails(
    |

tests/services/test_deck_instance.py:155:13: ANN201 Missing return type annotation for public function `test_create_deck_instance_duplicate_name_fails`
    |
153 |     assert pos_b1.expected_resource_definition_name == plate_def.name
154 | 
155 |   async def test_create_deck_instance_duplicate_name_fails(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
156 |     self,
157 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:179:13: ANN201 Missing return type annotation for public function `test_create_deck_instance_invalid_deck_id_fails`
    |
177 |       )
178 | 
179 |   async def test_create_deck_instance_invalid_deck_id_fails(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
180 |     """Test that creating a deck instance with a non-existent deck ID fails."""
181 |     non_existent_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:190:13: ANN201 Missing return type annotation for public function `test_read_deck`
    |
188 |       )
189 | 
190 |   async def test_read_deck(
    |             ^^^^^^^^^^^^^^ ANN201
191 |     self,
192 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:205:5: S101 Use of `assert` detected
    |
204 |     fetched_deck = await read_deck(db, deck.accession_id)
205 |     assert fetched_deck is not None
    |     ^^^^^^ S101
206 |     assert fetched_deck.accession_id == deck.accession_id
207 |     assert fetched_deck.name == "ReadableDeck"
    |

tests/services/test_deck_instance.py:206:5: S101 Use of `assert` detected
    |
204 |     fetched_deck = await read_deck(db, deck.accession_id)
205 |     assert fetched_deck is not None
206 |     assert fetched_deck.accession_id == deck.accession_id
    |     ^^^^^^ S101
207 |     assert fetched_deck.name == "ReadableDeck"
    |

tests/services/test_deck_instance.py:207:5: S101 Use of `assert` detected
    |
205 |     assert fetched_deck is not None
206 |     assert fetched_deck.accession_id == deck.accession_id
207 |     assert fetched_deck.name == "ReadableDeck"
    |     ^^^^^^ S101
208 | 
209 |   async def test_read_deck_not_found(self, db: AsyncSession):
    |

tests/services/test_deck_instance.py:209:13: ANN201 Missing return type annotation for public function `test_read_deck_not_found`
    |
207 |     assert fetched_deck.name == "ReadableDeck"
208 | 
209 |   async def test_read_deck_not_found(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
210 |     """Test that reading a non-existent deck instance returns None."""
211 |     non_existent_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:213:5: S101 Use of `assert` detected
    |
211 |     non_existent_id = uuid.uuid4()
212 |     fetched_deck = await read_deck(db, non_existent_id)
213 |     assert fetched_deck is None
    |     ^^^^^^ S101
214 | 
215 |   async def test_read_deck_by_name(
    |

tests/services/test_deck_instance.py:215:13: ANN201 Missing return type annotation for public function `test_read_deck_by_name`
    |
213 |     assert fetched_deck is None
214 | 
215 |   async def test_read_deck_by_name(
    |             ^^^^^^^^^^^^^^^^^^^^^^ ANN201
216 |     self,
217 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:231:5: S101 Use of `assert` detected
    |
230 |     fetched_deck = await read_deck_by_name(db, deck_name)
231 |     assert fetched_deck is not None
    |     ^^^^^^ S101
232 |     assert fetched_deck.name == deck_name
    |

tests/services/test_deck_instance.py:232:5: S101 Use of `assert` detected
    |
230 |     fetched_deck = await read_deck_by_name(db, deck_name)
231 |     assert fetched_deck is not None
232 |     assert fetched_deck.name == deck_name
    |     ^^^^^^ S101
233 | 
234 |   async def test_list_deck(
    |

tests/services/test_deck_instance.py:234:13: ANN201 Missing return type annotation for public function `test_list_deck`
    |
232 |     assert fetched_deck.name == deck_name
233 | 
234 |   async def test_list_deck(
    |             ^^^^^^^^^^^^^^ ANN201
235 |     self,
236 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:255:5: S101 Use of `assert` detected
    |
254 |     all_decks = await list_deck(db)
255 |     assert len(all_decks) >= 2  # GTE to account for other tests' data
    |     ^^^^^^ S101
256 | 
257 |     # Test filtering
    |

tests/services/test_deck_instance.py:255:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
254 |     all_decks = await list_deck(db)
255 |     assert len(all_decks) >= 2  # GTE to account for other tests' data
    |                              ^ PLR2004
256 | 
257 |     # Test filtering
    |

tests/services/test_deck_instance.py:262:5: S101 Use of `assert` detected
    |
260 |       deck_accession_id=deck_resource.accession_id,
261 |     )
262 |     assert len(filtered_decks) >= 2
    |     ^^^^^^ S101
263 | 
264 |     # Test limit
    |

tests/services/test_deck_instance.py:262:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
260 |       deck_accession_id=deck_resource.accession_id,
261 |     )
262 |     assert len(filtered_decks) >= 2
    |                                   ^ PLR2004
263 | 
264 |     # Test limit
    |

tests/services/test_deck_instance.py:266:5: S101 Use of `assert` detected
    |
264 |     # Test limit
265 |     limited_decks = await list_deck(db, limit=1)
266 |     assert len(limited_decks) == 1
    |     ^^^^^^ S101
267 | 
268 |     # Test offset
    |

tests/services/test_deck_instance.py:270:5: S101 Use of `assert` detected
    |
268 |     # Test offset
269 |     offset_decks = await list_deck(db, limit=1, offset=1)
270 |     assert len(offset_decks) == 1
    |     ^^^^^^ S101
271 |     assert offset_decks[0].name != limited_decks[0].name
    |

tests/services/test_deck_instance.py:271:5: S101 Use of `assert` detected
    |
269 |     offset_decks = await list_deck(db, limit=1, offset=1)
270 |     assert len(offset_decks) == 1
271 |     assert offset_decks[0].name != limited_decks[0].name
    |     ^^^^^^ S101
272 | 
273 |   async def test_update_deck_instance(
    |

tests/services/test_deck_instance.py:273:13: ANN201 Missing return type annotation for public function `test_update_deck_instance`
    |
271 |     assert offset_decks[0].name != limited_decks[0].name
272 | 
273 |   async def test_update_deck_instance(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
274 |     self,
275 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:299:5: S101 Use of `assert` detected
    |
297 |     )
298 | 
299 |     assert updated_deck is not None
    |     ^^^^^^ S101
300 |     assert updated_deck.name == updated_name
301 |     assert updated_deck.description == updated_description
    |

tests/services/test_deck_instance.py:300:5: S101 Use of `assert` detected
    |
299 |     assert updated_deck is not None
300 |     assert updated_deck.name == updated_name
    |     ^^^^^^ S101
301 |     assert updated_deck.description == updated_description
302 |     assert updated_deck.accession_id == deck.accession_id
    |

tests/services/test_deck_instance.py:301:5: S101 Use of `assert` detected
    |
299 |     assert updated_deck is not None
300 |     assert updated_deck.name == updated_name
301 |     assert updated_deck.description == updated_description
    |     ^^^^^^ S101
302 |     assert updated_deck.accession_id == deck.accession_id
    |

tests/services/test_deck_instance.py:302:5: S101 Use of `assert` detected
    |
300 |     assert updated_deck.name == updated_name
301 |     assert updated_deck.description == updated_description
302 |     assert updated_deck.accession_id == deck.accession_id
    |     ^^^^^^ S101
303 | 
304 |     # Test updating position items (replace all)
    |

tests/services/test_deck_instance.py:318:5: S101 Use of `assert` detected
    |
316 |     )
317 | 
318 |     assert final_deck is not None
    |     ^^^^^^ S101
319 |     assert len(final_deck.position_items) == 1
320 |     assert final_deck.position_items[0].position_name == "C3"
    |

tests/services/test_deck_instance.py:319:5: S101 Use of `assert` detected
    |
318 |     assert final_deck is not None
319 |     assert len(final_deck.position_items) == 1
    |     ^^^^^^ S101
320 |     assert final_deck.position_items[0].position_name == "C3"
321 |     assert final_deck.position_items[0].resource_instance_accession_id == plate_resource.accession_id
    |

tests/services/test_deck_instance.py:320:5: S101 Use of `assert` detected
    |
318 |     assert final_deck is not None
319 |     assert len(final_deck.position_items) == 1
320 |     assert final_deck.position_items[0].position_name == "C3"
    |     ^^^^^^ S101
321 |     assert final_deck.position_items[0].resource_instance_accession_id == plate_resource.accession_id
    |

tests/services/test_deck_instance.py:321:5: S101 Use of `assert` detected
    |
319 |     assert len(final_deck.position_items) == 1
320 |     assert final_deck.position_items[0].position_name == "C3"
321 |     assert final_deck.position_items[0].resource_instance_accession_id == plate_resource.accession_id
    |     ^^^^^^ S101
322 | 
323 |   async def test_update_deck_instance_not_found(self, db: AsyncSession):
    |

tests/services/test_deck_instance.py:323:13: ANN201 Missing return type annotation for public function `test_update_deck_instance_not_found`
    |
321 |     assert final_deck.position_items[0].resource_instance_accession_id == plate_resource.accession_id
322 | 
323 |   async def test_update_deck_instance_not_found(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
324 |     """Test that updating a non-existent deck instance returns None."""
325 |     non_existent_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:331:5: S101 Use of `assert` detected
    |
329 |       name="NewName",
330 |     )
331 |     assert result is None
    |     ^^^^^^ S101
332 | 
333 |   async def test_delete_deck_instance(
    |

tests/services/test_deck_instance.py:333:13: ANN201 Missing return type annotation for public function `test_delete_deck_instance`
    |
331 |     assert result is None
332 | 
333 |   async def test_delete_deck_instance(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
334 |     self,
335 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:359:5: S101 Use of `assert` detected
    |
358 |     # Ensure it's in the DB before deleting
359 |     assert await read_deck(db, deck_id) is not None
    |     ^^^^^^ S101
360 |     pos_item_result = await db.execute(
361 |       select(DeckPositionResourceOrm).filter_by(deck_accession_id=deck_id),
    |

tests/services/test_deck_instance.py:363:5: S101 Use of `assert` detected
    |
361 |       select(DeckPositionResourceOrm).filter_by(deck_accession_id=deck_id),
362 |     )
363 |     assert pos_item_result.scalar_one_or_none() is not None
    |     ^^^^^^ S101
364 | 
365 |     # Delete
    |

tests/services/test_deck_instance.py:367:5: S101 Use of `assert` detected
    |
365 |     # Delete
366 |     result = await delete_deck_instance(db, deck_id)
367 |     assert result is True
    |     ^^^^^^ S101
368 | 
369 |     # Verify it's gone
    |

tests/services/test_deck_instance.py:370:5: S101 Use of `assert` detected
    |
369 |     # Verify it's gone
370 |     assert await read_deck(db, deck_id) is None
    |     ^^^^^^ S101
371 | 
372 |     # Verify position items are also gone (due to cascade)
    |

tests/services/test_deck_instance.py:376:5: S101 Use of `assert` detected
    |
374 |       select(DeckPositionResourceOrm).filter_by(deck_accession_id=deck_id),
375 |     )
376 |     assert pos_item_result.scalar_one_or_none() is None
    |     ^^^^^^ S101
377 | 
378 |   async def test_delete_deck_instance_not_found(self, db: AsyncSession):
    |

tests/services/test_deck_instance.py:378:13: ANN201 Missing return type annotation for public function `test_delete_deck_instance_not_found`
    |
376 |     assert pos_item_result.scalar_one_or_none() is None
377 | 
378 |   async def test_delete_deck_instance_not_found(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
379 |     """Test that deleting a non-existent deck instance returns False."""
380 |     non_existent_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_instance.py:382:5: S101 Use of `assert` detected
    |
380 |     non_existent_id = uuid.uuid4()
381 |     result = await delete_deck_instance(db, non_existent_id)
382 |     assert result is False
    |     ^^^^^^ S101
    |

tests/services/test_deck_position.py:1:1: INP001 File `tests/services/test_deck_position.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_deck_position.py:1:1: D100 Missing docstring in public module
tests/services/test_deck_position.py:87:13: ANN201 Missing return type annotation for public function `test_create_deck_position_item_success`
   |
85 |   """Tests for functions managing DeckPositionResourceOrm (items on a deck)."""
86 | 
87 |   async def test_create_deck_position_item_success(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
88 |     self,
89 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_deck_position.py:105:5: S101 Use of `assert` detected
    |
103 |     )
104 | 
105 |     assert pos_item is not None
    |     ^^^^^^ S101
106 |     assert pos_item.deck_instance_accession_id == deck_instance.accession_id
107 |     assert pos_item.position_name == "A1"
    |

tests/services/test_deck_position.py:106:5: S101 Use of `assert` detected
    |
105 |     assert pos_item is not None
106 |     assert pos_item.deck_instance_accession_id == deck_instance.accession_id
    |     ^^^^^^ S101
107 |     assert pos_item.position_name == "A1"
108 |     assert pos_item.resource_instance_accession_id == plate_resource.accession_id
    |

tests/services/test_deck_position.py:107:5: S101 Use of `assert` detected
    |
105 |     assert pos_item is not None
106 |     assert pos_item.deck_instance_accession_id == deck_instance.accession_id
107 |     assert pos_item.position_name == "A1"
    |     ^^^^^^ S101
108 |     assert pos_item.resource_instance_accession_id == plate_resource.accession_id
109 |     assert pos_item.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_position.py:108:5: S101 Use of `assert` detected
    |
106 |     assert pos_item.deck_instance_accession_id == deck_instance.accession_id
107 |     assert pos_item.position_name == "A1"
108 |     assert pos_item.resource_instance_accession_id == plate_resource.accession_id
    |     ^^^^^^ S101
109 |     assert pos_item.expected_resource_definition_name == plate_def.name
    |

tests/services/test_deck_position.py:109:5: S101 Use of `assert` detected
    |
107 |     assert pos_item.position_name == "A1"
108 |     assert pos_item.resource_instance_accession_id == plate_resource.accession_id
109 |     assert pos_item.expected_resource_definition_name == plate_def.name
    |     ^^^^^^ S101
110 | 
111 |   async def test_create_deck_position_item_fails_for_bad_deck_id(
    |

tests/services/test_deck_position.py:111:13: ANN201 Missing return type annotation for public function `test_create_deck_position_item_fails_for_bad_deck_id`
    |
109 |     assert pos_item.expected_resource_definition_name == plate_def.name
110 | 
111 |   async def test_create_deck_position_item_fails_for_bad_deck_id(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
112 |     self,
113 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:120:13: ANN201 Missing return type annotation for public function `test_read_deck_position_item`
    |
118 |       await create_deck_position_item(db, deck_accession_id=bad_deck_id, name="A1")
119 | 
120 |   async def test_read_deck_position_item(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
121 |     self,
122 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:132:5: S101 Use of `assert` detected
    |
130 |       name="B2",
131 |     )
132 |     assert created_item is not None
    |     ^^^^^^ S101
133 | 
134 |     read_item = await read_deck_position_item(db, created_item.accession_id)
    |

tests/services/test_deck_position.py:135:5: S101 Use of `assert` detected
    |
134 |     read_item = await read_deck_position_item(db, created_item.accession_id)
135 |     assert read_item is not None
    |     ^^^^^^ S101
136 |     assert read_item.accession_id == created_item.accession_id
137 |     assert read_item.position_name == "B2"
    |

tests/services/test_deck_position.py:136:5: S101 Use of `assert` detected
    |
134 |     read_item = await read_deck_position_item(db, created_item.accession_id)
135 |     assert read_item is not None
136 |     assert read_item.accession_id == created_item.accession_id
    |     ^^^^^^ S101
137 |     assert read_item.position_name == "B2"
    |

tests/services/test_deck_position.py:137:5: S101 Use of `assert` detected
    |
135 |     assert read_item is not None
136 |     assert read_item.accession_id == created_item.accession_id
137 |     assert read_item.position_name == "B2"
    |     ^^^^^^ S101
138 | 
139 |   async def test_update_deck_position_item(
    |

tests/services/test_deck_position.py:139:13: ANN201 Missing return type annotation for public function `test_update_deck_position_item`
    |
137 |     assert read_item.position_name == "B2"
138 | 
139 |   async def test_update_deck_position_item(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
140 |     self,
141 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:152:5: S101 Use of `assert` detected
    |
150 |       name="C3",
151 |     )
152 |     assert created_item is not None
    |     ^^^^^^ S101
153 |     assert created_item.resource_instance_accession_id is None
    |

tests/services/test_deck_position.py:153:5: S101 Use of `assert` detected
    |
151 |     )
152 |     assert created_item is not None
153 |     assert created_item.resource_instance_accession_id is None
    |     ^^^^^^ S101
154 | 
155 |     updated_item = await update_deck_position_item(
    |

tests/services/test_deck_position.py:161:5: S101 Use of `assert` detected
    |
159 |     )
160 | 
161 |     assert updated_item is not None
    |     ^^^^^^ S101
162 |     assert updated_item.accession_id == created_item.accession_id
163 |     assert updated_item.resource_instance_accession_id == plate_resource.accession_id
    |

tests/services/test_deck_position.py:162:5: S101 Use of `assert` detected
    |
161 |     assert updated_item is not None
162 |     assert updated_item.accession_id == created_item.accession_id
    |     ^^^^^^ S101
163 |     assert updated_item.resource_instance_accession_id == plate_resource.accession_id
    |

tests/services/test_deck_position.py:163:5: S101 Use of `assert` detected
    |
161 |     assert updated_item is not None
162 |     assert updated_item.accession_id == created_item.accession_id
163 |     assert updated_item.resource_instance_accession_id == plate_resource.accession_id
    |     ^^^^^^ S101
164 | 
165 |   async def test_delete_deck_position_item(
    |

tests/services/test_deck_position.py:165:13: ANN201 Missing return type annotation for public function `test_delete_deck_position_item`
    |
163 |     assert updated_item.resource_instance_accession_id == plate_resource.accession_id
164 | 
165 |   async def test_delete_deck_position_item(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
166 |     self,
167 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:177:5: S101 Use of `assert` detected
    |
175 |       name="D4",
176 |     )
177 |     assert created_item is not None
    |     ^^^^^^ S101
178 | 
179 |     # Confirm it exists
    |

tests/services/test_deck_position.py:180:5: S101 Use of `assert` detected
    |
179 |     # Confirm it exists
180 |     assert await read_deck_position_item(db, created_item.accession_id) is not None
    |     ^^^^^^ S101
181 | 
182 |     # Delete it
    |

tests/services/test_deck_position.py:184:5: S101 Use of `assert` detected
    |
182 |     # Delete it
183 |     result = await delete_deck_position_item(db, created_item.accession_id)
184 |     assert result is True
    |     ^^^^^^ S101
185 | 
186 |     # Confirm it's gone
    |

tests/services/test_deck_position.py:187:5: S101 Use of `assert` detected
    |
186 |     # Confirm it's gone
187 |     assert await read_deck_position_item(db, created_item.accession_id) is None
    |     ^^^^^^ S101
188 | 
189 |   async def test_delete_non_existent_position_item(self, db: AsyncSession):
    |

tests/services/test_deck_position.py:189:13: ANN201 Missing return type annotation for public function `test_delete_non_existent_position_item`
    |
187 |     assert await read_deck_position_item(db, created_item.accession_id) is None
188 | 
189 |   async def test_delete_non_existent_position_item(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
190 |     """Test that deleting a non-existent position item returns False."""
191 |     bad_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:193:5: S101 Use of `assert` detected
    |
191 |     bad_id = uuid.uuid4()
192 |     result = await delete_deck_position_item(db, bad_id)
193 |     assert result is False
    |     ^^^^^^ S101
    |

tests/services/test_deck_position.py:199:13: ANN201 Missing return type annotation for public function `test_create_deck_position_definitions_success`
    |
197 |   """Tests for functions managing DeckPositionDefinitionOrm (definitions for a deck type)."""
198 | 
199 |   async def test_create_deck_position_definitions_success(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
200 |     self,
201 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:222:5: S101 Use of `assert` detected
    |
220 |     )
221 | 
222 |     assert len(created_defs) == 2
    |     ^^^^^^ S101
223 |     assert created_defs[0].name == "Slot1"
224 |     assert created_defs[0].nominal_x_mm == 10.0
    |

tests/services/test_deck_position.py:222:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
220 |     )
221 | 
222 |     assert len(created_defs) == 2
    |                                 ^ PLR2004
223 |     assert created_defs[0].name == "Slot1"
224 |     assert created_defs[0].nominal_x_mm == 10.0
    |

tests/services/test_deck_position.py:223:5: S101 Use of `assert` detected
    |
222 |     assert len(created_defs) == 2
223 |     assert created_defs[0].name == "Slot1"
    |     ^^^^^^ S101
224 |     assert created_defs[0].nominal_x_mm == 10.0
225 |     assert created_defs[1].name == "Trash"
    |

tests/services/test_deck_position.py:224:5: S101 Use of `assert` detected
    |
222 |     assert len(created_defs) == 2
223 |     assert created_defs[0].name == "Slot1"
224 |     assert created_defs[0].nominal_x_mm == 10.0
    |     ^^^^^^ S101
225 |     assert created_defs[1].name == "Trash"
226 |     assert created_defs[1].accepted_resource_categories_json == ["trash_bin"]
    |

tests/services/test_deck_position.py:224:44: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
    |
222 |     assert len(created_defs) == 2
223 |     assert created_defs[0].name == "Slot1"
224 |     assert created_defs[0].nominal_x_mm == 10.0
    |                                            ^^^^ PLR2004
225 |     assert created_defs[1].name == "Trash"
226 |     assert created_defs[1].accepted_resource_categories_json == ["trash_bin"]
    |

tests/services/test_deck_position.py:225:5: S101 Use of `assert` detected
    |
223 |     assert created_defs[0].name == "Slot1"
224 |     assert created_defs[0].nominal_x_mm == 10.0
225 |     assert created_defs[1].name == "Trash"
    |     ^^^^^^ S101
226 |     assert created_defs[1].accepted_resource_categories_json == ["trash_bin"]
    |

tests/services/test_deck_position.py:226:5: S101 Use of `assert` detected
    |
224 |     assert created_defs[0].nominal_x_mm == 10.0
225 |     assert created_defs[1].name == "Trash"
226 |     assert created_defs[1].accepted_resource_categories_json == ["trash_bin"]
    |     ^^^^^^ S101
227 | 
228 |   async def test_create_deck_position_definitions_fails_for_bad_deck_type(
    |

tests/services/test_deck_position.py:228:13: ANN201 Missing return type annotation for public function `test_create_deck_position_definitions_fails_for_bad_deck_type`
    |
226 |     assert created_defs[1].accepted_resource_categories_json == ["trash_bin"]
227 | 
228 |   async def test_create_deck_position_definitions_fails_for_bad_deck_type(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
229 |     self,
230 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:237:13: ANN201 Missing return type annotation for public function `test_read_position_definitions_for_deck_type`
    |
235 |       await create_deck_position_definitions(db, bad_deck_type_id, [{"name": "Slot1"}])
236 | 
237 |   async def test_read_position_definitions_for_deck_type(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
238 |     self,
239 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:256:5: S101 Use of `assert` detected
    |
254 |     )
255 | 
256 |     assert len(read_defs) == 2
    |     ^^^^^^ S101
257 |     assert {d.name for d in read_defs} == {"PosA", "PosB"}
    |

tests/services/test_deck_position.py:256:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
254 |     )
255 | 
256 |     assert len(read_defs) == 2
    |                              ^ PLR2004
257 |     assert {d.name for d in read_defs} == {"PosA", "PosB"}
    |

tests/services/test_deck_position.py:257:5: S101 Use of `assert` detected
    |
256 |     assert len(read_defs) == 2
257 |     assert {d.name for d in read_defs} == {"PosA", "PosB"}
    |     ^^^^^^ S101
258 | 
259 |   async def test_update_deck_position_definition(
    |

tests/services/test_deck_position.py:259:13: ANN201 Missing return type annotation for public function `test_update_deck_position_definition`
    |
257 |     assert {d.name for d in read_defs} == {"PosA", "PosB"}
258 | 
259 |   async def test_update_deck_position_definition(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
260 |     self,
261 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:280:5: S101 Use of `assert` detected
    |
278 |     )
279 | 
280 |     assert updated_def is not None
    |     ^^^^^^ S101
281 |     assert updated_def.name == "UpdatableSlot"
282 |     assert updated_def.nominal_z_mm == 5.5
    |

tests/services/test_deck_position.py:281:5: S101 Use of `assert` detected
    |
280 |     assert updated_def is not None
281 |     assert updated_def.name == "UpdatableSlot"
    |     ^^^^^^ S101
282 |     assert updated_def.nominal_z_mm == 5.5
283 |     assert updated_def.position_specific_details_json is not None
    |

tests/services/test_deck_position.py:282:5: S101 Use of `assert` detected
    |
280 |     assert updated_def is not None
281 |     assert updated_def.name == "UpdatableSlot"
282 |     assert updated_def.nominal_z_mm == 5.5
    |     ^^^^^^ S101
283 |     assert updated_def.position_specific_details_json is not None
284 |     assert updated_def.position_specific_details_json.get("notes") == "This slot has been updated."
    |

tests/services/test_deck_position.py:282:40: PLR2004 Magic value used in comparison, consider replacing `5.5` with a constant variable
    |
280 |     assert updated_def is not None
281 |     assert updated_def.name == "UpdatableSlot"
282 |     assert updated_def.nominal_z_mm == 5.5
    |                                        ^^^ PLR2004
283 |     assert updated_def.position_specific_details_json is not None
284 |     assert updated_def.position_specific_details_json.get("notes") == "This slot has been updated."
    |

tests/services/test_deck_position.py:283:5: S101 Use of `assert` detected
    |
281 |     assert updated_def.name == "UpdatableSlot"
282 |     assert updated_def.nominal_z_mm == 5.5
283 |     assert updated_def.position_specific_details_json is not None
    |     ^^^^^^ S101
284 |     assert updated_def.position_specific_details_json.get("notes") == "This slot has been updated."
    |

tests/services/test_deck_position.py:284:5: S101 Use of `assert` detected
    |
282 |     assert updated_def.nominal_z_mm == 5.5
283 |     assert updated_def.position_specific_details_json is not None
284 |     assert updated_def.position_specific_details_json.get("notes") == "This slot has been updated."
    |     ^^^^^^ S101
285 | 
286 |   async def test_update_non_existent_position_definition_fails(
    |

tests/services/test_deck_position.py:286:13: ANN201 Missing return type annotation for public function `test_update_non_existent_position_definition_fails`
    |
284 |     assert updated_def.position_specific_details_json.get("notes") == "This slot has been updated."
285 | 
286 |   async def test_update_non_existent_position_definition_fails(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
287 |     self,
288 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:301:13: ANN201 Missing return type annotation for public function `test_delete_deck_position_definition`
    |
299 |       )
300 | 
301 |   async def test_delete_deck_position_definition(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
302 |     self,
303 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_position.py:319:5: S101 Use of `assert` detected
    |
317 |       deck_type.accession_id,
318 |     )
319 |     assert len(defs_before) == 1
    |     ^^^^^^ S101
320 | 
321 |     # Delete it
    |

tests/services/test_deck_position.py:329:5: S101 Use of `assert` detected
    |
327 |       deck_type.accession_id,
328 |     )
329 |     assert len(defs_after) == 0
    |     ^^^^^^ S101
330 | 
331 |   async def test_delete_non_existent_position_definition_fails(
    |

tests/services/test_deck_position.py:331:13: ANN201 Missing return type annotation for public function `test_delete_non_existent_position_definition_fails`
    |
329 |     assert len(defs_after) == 0
330 | 
331 |   async def test_delete_non_existent_position_definition_fails(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
332 |     self,
333 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:1:1: INP001 File `tests/services/test_deck_type_definition.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_deck_type_definition.py:1:1: D100 Missing docstring in public module
tests/services/test_deck_type_definition.py:23:3: D401 First line of docstring should be in imperative mood: "Provides a base dictionary of valid data for creating a deck type definition."
   |
21 | @pytest.fixture
22 | def base_deck_type_data() -> dict[str, Any]:
23 |   """Provides a base dictionary of valid data for creating a deck type definition."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
24 |   return {
25 |     "fqn": f"pylabrobot.resources.hamilton.STARDeck_{uuid.uuid4()}",
   |

tests/services/test_deck_type_definition.py:42:3: D401 First line of docstring should be in imperative mood: "Creates a DeckTypeDefinitionOrm in the DB for tests that need a pre-existing record."
   |
40 |   base_deck_type_data: dict[str, Any],
41 | ) -> DeckTypeDefinitionOrm:
42 |   """Creates a DeckTypeDefinitionOrm in the DB for tests that need a pre-existing record."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
43 |   deck_type = await create_deck_type_definition(db=db, **base_deck_type_data)
44 |   return deck_type
   |

tests/services/test_deck_type_definition.py:44:10: RET504 Unnecessary assignment to `deck_type` before `return` statement
   |
42 |   """Creates a DeckTypeDefinitionOrm in the DB for tests that need a pre-existing record."""
43 |   deck_type = await create_deck_type_definition(db=db, **base_deck_type_data)
44 |   return deck_type
   |          ^^^^^^^^^ RET504
   |
   = help: Remove unnecessary assignment

tests/services/test_deck_type_definition.py:50:13: ANN201 Missing return type annotation for public function `test_create_deck_type_definition_success`
   |
48 |   """Test suite for deck type definition service functions."""
49 | 
50 |   async def test_create_deck_type_definition_success(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
51 |     self,
52 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:62:5: S101 Use of `assert` detected
   |
60 |     )
61 | 
62 |     assert created_deck_type is not None
   |     ^^^^^^ S101
63 |     assert created_deck_type.pylabrobot_deck_fqn == base_deck_type_data["fqn"]
64 |     assert created_deck_type.display_name == base_deck_type_data["deck_type"]
   |

tests/services/test_deck_type_definition.py:63:5: S101 Use of `assert` detected
   |
62 |     assert created_deck_type is not None
63 |     assert created_deck_type.pylabrobot_deck_fqn == base_deck_type_data["fqn"]
   |     ^^^^^^ S101
64 |     assert created_deck_type.display_name == base_deck_type_data["deck_type"]
65 |     assert created_deck_type.accession_id is not None
   |

tests/services/test_deck_type_definition.py:64:5: S101 Use of `assert` detected
   |
62 |     assert created_deck_type is not None
63 |     assert created_deck_type.pylabrobot_deck_fqn == base_deck_type_data["fqn"]
64 |     assert created_deck_type.display_name == base_deck_type_data["deck_type"]
   |     ^^^^^^ S101
65 |     assert created_deck_type.accession_id is not None
   |

tests/services/test_deck_type_definition.py:65:5: S101 Use of `assert` detected
   |
63 |     assert created_deck_type.pylabrobot_deck_fqn == base_deck_type_data["fqn"]
64 |     assert created_deck_type.display_name == base_deck_type_data["deck_type"]
65 |     assert created_deck_type.accession_id is not None
   |     ^^^^^^ S101
66 | 
67 |   async def test_create_deck_type_with_all_args_and_positions(
   |

tests/services/test_deck_type_definition.py:67:13: ANN201 Missing return type annotation for public function `test_create_deck_type_with_all_args_and_positions`
   |
65 |     assert created_deck_type.accession_id is not None
66 | 
67 |   async def test_create_deck_type_with_all_args_and_positions(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     self,
69 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:89:5: S101 Use of `assert` detected
   |
87 |     created_deck_type = await create_deck_type_definition(db=db, **base_deck_type_data)
88 | 
89 |     assert created_deck_type is not None
   |     ^^^^^^ S101
90 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
91 |     assert created_deck_type.additional_properties_json is not None
   |

tests/services/test_deck_type_definition.py:91:5: S101 Use of `assert` detected
   |
89 |     assert created_deck_type is not None
90 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
91 |     assert created_deck_type.additional_properties_json is not None
   |     ^^^^^^ S101
92 |     assert created_deck_type.additional_properties_json["manufacturer"] == "Hamilton"
93 |     assert created_deck_type.positioning_config_json is not None
   |

tests/services/test_deck_type_definition.py:92:5: S101 Use of `assert` detected
   |
90 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
91 |     assert created_deck_type.additional_properties_json is not None
92 |     assert created_deck_type.additional_properties_json["manufacturer"] == "Hamilton"
   |     ^^^^^^ S101
93 |     assert created_deck_type.positioning_config_json is not None
94 |     assert created_deck_type.positioning_config_json["method_name"] == "get_slot"
   |

tests/services/test_deck_type_definition.py:93:5: S101 Use of `assert` detected
   |
91 |     assert created_deck_type.additional_properties_json is not None
92 |     assert created_deck_type.additional_properties_json["manufacturer"] == "Hamilton"
93 |     assert created_deck_type.positioning_config_json is not None
   |     ^^^^^^ S101
94 |     assert created_deck_type.positioning_config_json["method_name"] == "get_slot"
95 |     assert len(created_deck_type.position_definitions) == 2
   |

tests/services/test_deck_type_definition.py:94:5: S101 Use of `assert` detected
   |
92 |     assert created_deck_type.additional_properties_json["manufacturer"] == "Hamilton"
93 |     assert created_deck_type.positioning_config_json is not None
94 |     assert created_deck_type.positioning_config_json["method_name"] == "get_slot"
   |     ^^^^^^ S101
95 |     assert len(created_deck_type.position_definitions) == 2
96 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
   |

tests/services/test_deck_type_definition.py:95:5: S101 Use of `assert` detected
   |
93 |     assert created_deck_type.positioning_config_json is not None
94 |     assert created_deck_type.positioning_config_json["method_name"] == "get_slot"
95 |     assert len(created_deck_type.position_definitions) == 2
   |     ^^^^^^ S101
96 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
97 |     assert {p.name for p in created_deck_type.position_definitions} == {
   |

tests/services/test_deck_type_definition.py:95:59: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
93 |     assert created_deck_type.positioning_config_json is not None
94 |     assert created_deck_type.positioning_config_json["method_name"] == "get_slot"
95 |     assert len(created_deck_type.position_definitions) == 2
   |                                                           ^ PLR2004
96 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
97 |     assert {p.name for p in created_deck_type.position_definitions} == {
   |

tests/services/test_deck_type_definition.py:97:5: S101 Use of `assert` detected
   |
95 |     assert len(created_deck_type.position_definitions) == 2
96 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
97 |     assert {p.name for p in created_deck_type.position_definitions} == {
   |     ^^^^^^ S101
98 |       "Slot1",
99 |       "Slot2",
   |

tests/services/test_deck_type_definition.py:102:13: ANN201 Missing return type annotation for public function `test_create_deck_type_fails_on_duplicate_fqn`
    |
100 |     }
101 | 
102 |   async def test_create_deck_type_fails_on_duplicate_fqn(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
103 |     self,
104 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:115:13: ANN201 Missing return type annotation for public function `test_read_deck_type_definition`
    |
113 |       )
114 | 
115 |   async def test_read_deck_type_definition(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
116 |     self,
117 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:122:5: S101 Use of `assert` detected
    |
120 |     """Test reading a deck type definition by its ID."""
121 |     read_deck = await read_deck_type_definition(db, existing_deck_type.accession_id)
122 |     assert read_deck is not None
    |     ^^^^^^ S101
123 |     assert read_deck.accession_id == existing_deck_type.accession_id
124 |     assert read_deck.display_name == existing_deck_type.display_name
    |

tests/services/test_deck_type_definition.py:123:5: S101 Use of `assert` detected
    |
121 |     read_deck = await read_deck_type_definition(db, existing_deck_type.accession_id)
122 |     assert read_deck is not None
123 |     assert read_deck.accession_id == existing_deck_type.accession_id
    |     ^^^^^^ S101
124 |     assert read_deck.display_name == existing_deck_type.display_name
    |

tests/services/test_deck_type_definition.py:124:5: S101 Use of `assert` detected
    |
122 |     assert read_deck is not None
123 |     assert read_deck.accession_id == existing_deck_type.accession_id
124 |     assert read_deck.display_name == existing_deck_type.display_name
    |     ^^^^^^ S101
125 | 
126 |   async def test_read_deck_type_definition_by_fqn(
    |

tests/services/test_deck_type_definition.py:126:13: ANN201 Missing return type annotation for public function `test_read_deck_type_definition_by_fqn`
    |
124 |     assert read_deck.display_name == existing_deck_type.display_name
125 | 
126 |   async def test_read_deck_type_definition_by_fqn(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
127 |     self,
128 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:136:5: S101 Use of `assert` detected
    |
134 |       existing_deck_type.pylabrobot_deck_fqn,
135 |     )
136 |     assert read_deck is not None
    |     ^^^^^^ S101
137 |     assert read_deck.pylabrobot_deck_fqn == existing_deck_type.pylabrobot_deck_fqn
    |

tests/services/test_deck_type_definition.py:137:5: S101 Use of `assert` detected
    |
135 |     )
136 |     assert read_deck is not None
137 |     assert read_deck.pylabrobot_deck_fqn == existing_deck_type.pylabrobot_deck_fqn
    |     ^^^^^^ S101
138 | 
139 |   async def test_read_non_existent_deck_type(self, db: AsyncSession):
    |

tests/services/test_deck_type_definition.py:139:13: ANN201 Missing return type annotation for public function `test_read_non_existent_deck_type`
    |
137 |     assert read_deck.pylabrobot_deck_fqn == existing_deck_type.pylabrobot_deck_fqn
138 | 
139 |   async def test_read_non_existent_deck_type(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
140 |     """Test that reading a non-existent deck type returns None."""
141 |     bad_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:142:5: S101 Use of `assert` detected
    |
140 |     """Test that reading a non-existent deck type returns None."""
141 |     bad_id = uuid.uuid4()
142 |     assert await read_deck_type_definition(db, bad_id) is None
    |     ^^^^^^ S101
143 |     assert await read_deck_type_definition_by_fqn(db, "non.existent.fqn") is None
    |

tests/services/test_deck_type_definition.py:143:5: S101 Use of `assert` detected
    |
141 |     bad_id = uuid.uuid4()
142 |     assert await read_deck_type_definition(db, bad_id) is None
143 |     assert await read_deck_type_definition_by_fqn(db, "non.existent.fqn") is None
    |     ^^^^^^ S101
144 | 
145 |   async def test_update_deck_type_definition(
    |

tests/services/test_deck_type_definition.py:145:13: ANN201 Missing return type annotation for public function `test_update_deck_type_definition`
    |
143 |     assert await read_deck_type_definition_by_fqn(db, "non.existent.fqn") is None
144 | 
145 |   async def test_update_deck_type_definition(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
146 |     self,
147 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:160:5: S101 Use of `assert` detected
    |
158 |     updated_deck = await update_deck_type_definition(db=db, **updated_data)
159 | 
160 |     assert updated_deck is not None
    |     ^^^^^^ S101
161 |     assert updated_deck.display_name == "Updated Deck Name"
162 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
    |

tests/services/test_deck_type_definition.py:161:5: S101 Use of `assert` detected
    |
160 |     assert updated_deck is not None
161 |     assert updated_deck.display_name == "Updated Deck Name"
    |     ^^^^^^ S101
162 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
163 |     assert updated_deck.additional_properties_json is not None
    |

tests/services/test_deck_type_definition.py:163:5: S101 Use of `assert` detected
    |
161 |     assert updated_deck.display_name == "Updated Deck Name"
162 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
163 |     assert updated_deck.additional_properties_json is not None
    |     ^^^^^^ S101
164 |     assert updated_deck.additional_properties_json["notes"] == "These are updated notes."
165 |     assert existing_deck_type.additional_properties_json is not None
    |

tests/services/test_deck_type_definition.py:164:5: S101 Use of `assert` detected
    |
162 |     # FIX: Assert the json blob is not None before accessing, and access via subscript.
163 |     assert updated_deck.additional_properties_json is not None
164 |     assert updated_deck.additional_properties_json["notes"] == "These are updated notes."
    |     ^^^^^^ S101
165 |     assert existing_deck_type.additional_properties_json is not None
166 |     assert (
    |

tests/services/test_deck_type_definition.py:165:5: S101 Use of `assert` detected
    |
163 |     assert updated_deck.additional_properties_json is not None
164 |     assert updated_deck.additional_properties_json["notes"] == "These are updated notes."
165 |     assert existing_deck_type.additional_properties_json is not None
    |     ^^^^^^ S101
166 |     assert (
167 |       updated_deck.additional_properties_json["manufacturer"]
    |

tests/services/test_deck_type_definition.py:166:5: S101 Use of `assert` detected
    |
164 |     assert updated_deck.additional_properties_json["notes"] == "These are updated notes."
165 |     assert existing_deck_type.additional_properties_json is not None
166 |     assert (
    |     ^^^^^^ S101
167 |       updated_deck.additional_properties_json["manufacturer"]
168 |       == existing_deck_type.additional_properties_json["manufacturer"]
    |

tests/services/test_deck_type_definition.py:171:13: ANN201 Missing return type annotation for public function `test_update_deck_type_replaces_positions`
    |
169 |     )
170 | 
171 |   async def test_update_deck_type_replaces_positions(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
172 |     self,
173 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:191:5: S101 Use of `assert` detected
    |
189 |     )
190 |     # FIX: Add assertion to guard against None type.
191 |     assert refreshed_deck is not None
    |     ^^^^^^ S101
192 |     assert len(refreshed_deck.position_definitions) == 1
193 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
    |

tests/services/test_deck_type_definition.py:192:5: S101 Use of `assert` detected
    |
190 |     # FIX: Add assertion to guard against None type.
191 |     assert refreshed_deck is not None
192 |     assert len(refreshed_deck.position_definitions) == 1
    |     ^^^^^^ S101
193 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
194 |     assert refreshed_deck.position_definitions[0].name == "OldSlot"
    |

tests/services/test_deck_type_definition.py:194:5: S101 Use of `assert` detected
    |
192 |     assert len(refreshed_deck.position_definitions) == 1
193 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
194 |     assert refreshed_deck.position_definitions[0].name == "OldSlot"
    |     ^^^^^^ S101
195 | 
196 |     # Update with new positions
    |

tests/services/test_deck_type_definition.py:211:5: S101 Use of `assert` detected
    |
209 |     final_deck = await read_deck_type_definition(db, existing_deck_type.accession_id)
210 |     # FIX: Add assertion to guard against None type.
211 |     assert final_deck is not None
    |     ^^^^^^ S101
212 |     assert len(final_deck.position_definitions) == 2
213 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
    |

tests/services/test_deck_type_definition.py:212:5: S101 Use of `assert` detected
    |
210 |     # FIX: Add assertion to guard against None type.
211 |     assert final_deck is not None
212 |     assert len(final_deck.position_definitions) == 2
    |     ^^^^^^ S101
213 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
214 |     assert {p.name for p in final_deck.position_definitions} == {
    |

tests/services/test_deck_type_definition.py:212:52: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
210 |     # FIX: Add assertion to guard against None type.
211 |     assert final_deck is not None
212 |     assert len(final_deck.position_definitions) == 2
    |                                                    ^ PLR2004
213 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
214 |     assert {p.name for p in final_deck.position_definitions} == {
    |

tests/services/test_deck_type_definition.py:214:5: S101 Use of `assert` detected
    |
212 |     assert len(final_deck.position_definitions) == 2
213 |     # FIX: The attribute on the ORM model is 'name', not 'position_name'.
214 |     assert {p.name for p in final_deck.position_definitions} == {
    |     ^^^^^^ S101
215 |       "NewSlot1",
216 |       "NewSlot2",
    |

tests/services/test_deck_type_definition.py:219:13: ANN201 Missing return type annotation for public function `test_update_fails_on_fqn_conflict`
    |
217 |     }
218 | 
219 |   async def test_update_fails_on_fqn_conflict(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
220 |     self,
221 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:240:13: ANN201 Missing return type annotation for public function `test_list_deck_type_definitions`
    |
238 |       )
239 | 
240 |   async def test_list_deck_type_definitions(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
241 |     self,
242 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:252:5: S101 Use of `assert` detected
    |
251 |     all_defs = await list_deck_type_definitions(db, limit=10)
252 |     assert len(all_defs) >= 2
    |     ^^^^^^ S101
253 | 
254 |     limited_defs = await list_deck_type_definitions(db, limit=1)
    |

tests/services/test_deck_type_definition.py:252:29: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
251 |     all_defs = await list_deck_type_definitions(db, limit=10)
252 |     assert len(all_defs) >= 2
    |                             ^ PLR2004
253 | 
254 |     limited_defs = await list_deck_type_definitions(db, limit=1)
    |

tests/services/test_deck_type_definition.py:255:5: S101 Use of `assert` detected
    |
254 |     limited_defs = await list_deck_type_definitions(db, limit=1)
255 |     assert len(limited_defs) == 1
    |     ^^^^^^ S101
256 | 
257 |     offset_defs = await list_deck_type_definitions(db, limit=1, offset=1)
    |

tests/services/test_deck_type_definition.py:258:5: S101 Use of `assert` detected
    |
257 |     offset_defs = await list_deck_type_definitions(db, limit=1, offset=1)
258 |     assert len(offset_defs) == 1
    |     ^^^^^^ S101
259 |     assert offset_defs[0].accession_id != limited_defs[0].accession_id
    |

tests/services/test_deck_type_definition.py:259:5: S101 Use of `assert` detected
    |
257 |     offset_defs = await list_deck_type_definitions(db, limit=1, offset=1)
258 |     assert len(offset_defs) == 1
259 |     assert offset_defs[0].accession_id != limited_defs[0].accession_id
    |     ^^^^^^ S101
260 | 
261 |   async def test_delete_deck_type_definition(
    |

tests/services/test_deck_type_definition.py:261:13: ANN201 Missing return type annotation for public function `test_delete_deck_type_definition`
    |
259 |     assert offset_defs[0].accession_id != limited_defs[0].accession_id
260 | 
261 |   async def test_delete_deck_type_definition(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
262 |     self,
263 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_deck_type_definition.py:270:5: S101 Use of `assert` detected
    |
269 |     # Confirm it exists
270 |     assert await read_deck_type_definition(db, deck_type_id) is not None
    |     ^^^^^^ S101
271 | 
272 |     # Delete it
    |

tests/services/test_deck_type_definition.py:276:5: S101 Use of `assert` detected
    |
275 |     # Confirm it's gone
276 |     assert await read_deck_type_definition(db, deck_type_id) is None
    |     ^^^^^^ S101
277 | 
278 |   async def test_delete_non_existent_deck_type_fails(self, db: AsyncSession):
    |

tests/services/test_deck_type_definition.py:278:13: ANN201 Missing return type annotation for public function `test_delete_non_existent_deck_type_fails`
    |
276 |     assert await read_deck_type_definition(db, deck_type_id) is None
277 | 
278 |   async def test_delete_non_existent_deck_type_fails(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
279 |     """Test that deleting a non-existent deck type raises ValueError."""
280 |     bad_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/services/test_discovery_service.py:1:1: INP001 File `tests/services/test_discovery_service.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_discovery_service.py:23:3: D401 First line of docstring should be in imperative mood: "Provides a ProtocolDiscoveryService instance with a mocked DB session factory."
   |
21 | @pytest.fixture
22 | def discovery_service() -> ProtocolDiscoveryService:
23 |   """Provides a ProtocolDiscoveryService instance with a mocked DB session factory."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
24 |   mock_session_factory = MagicMock()
25 |   # The session factory itself returns an async context manager
   |

tests/services/test_discovery_service.py:32:5: ANN201 Missing return type annotation for public function `clear_protocol_registry`
   |
31 | @pytest.fixture(autouse=True)
32 | def clear_protocol_registry():
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
33 |   """Fixture to clear the global PROTOCOL_REGISTRY before and after each test."""
34 |   PROTOCOL_REGISTRY.clear()
   |
   = help: Add return type annotation

tests/services/test_discovery_service.py:41:3: D401 First line of docstring should be in imperative mood: "Creates a temporary directory with dummy protocol files for discovery."
   |
39 | @pytest.fixture
40 | def protocol_files(tmp_path: Path) -> Generator[Path, None, None]:
41 |   """Creates a temporary directory with dummy protocol files for discovery."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
42 |   protocols_dir = tmp_path / "protocols"
43 |   protocols_dir.mkdir()
   |

tests/services/test_discovery_service.py:110:7: ANN201 Missing return type annotation for public function `test_extract_from_paths_finds_protocols`
    |
108 |   """Test suite for the ProtocolDiscoveryService."""
109 | 
110 |   def test_extract_from_paths_finds_protocols(self, discovery_service, protocol_files):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |     """Test that _extract_protocol_definitions_from_paths finds all valid protocols."""
112 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |
    = help: Add return type annotation: `None`

tests/services/test_discovery_service.py:110:53: ANN001 Missing type annotation for function argument `discovery_service`
    |
108 |   """Test suite for the ProtocolDiscoveryService."""
109 | 
110 |   def test_extract_from_paths_finds_protocols(self, discovery_service, protocol_files):
    |                                                     ^^^^^^^^^^^^^^^^^ ANN001
111 |     """Test that _extract_protocol_definitions_from_paths finds all valid protocols."""
112 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |

tests/services/test_discovery_service.py:110:72: ANN001 Missing type annotation for function argument `protocol_files`
    |
108 |   """Test suite for the ProtocolDiscoveryService."""
109 | 
110 |   def test_extract_from_paths_finds_protocols(self, discovery_service, protocol_files):
    |                                                                        ^^^^^^^^^^^^^^ ANN001
111 |     """Test that _extract_protocol_definitions_from_paths finds all valid protocols."""
112 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |

tests/services/test_discovery_service.py:112:19: SLF001 Private member accessed: `_extract_protocol_definitions_from_paths`
    |
110 |   def test_extract_from_paths_finds_protocols(self, discovery_service, protocol_files):
111 |     """Test that _extract_protocol_definitions_from_paths finds all valid protocols."""
112 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
113 |       str(protocol_files),
114 |     )
    |

tests/services/test_discovery_service.py:115:5: S101 Use of `assert` detected
    |
113 |       str(protocol_files),
114 |     )
115 |     assert len(definitions) == 2
    |     ^^^^^^ S101
116 |     names = {model.name for model, func in definitions}
117 |     assert "decorated_transfer" in names
    |

tests/services/test_discovery_service.py:115:32: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
113 |       str(protocol_files),
114 |     )
115 |     assert len(definitions) == 2
    |                                ^ PLR2004
116 |     names = {model.name for model, func in definitions}
117 |     assert "decorated_transfer" in names
    |

tests/services/test_discovery_service.py:117:5: S101 Use of `assert` detected
    |
115 |     assert len(definitions) == 2
116 |     names = {model.name for model, func in definitions}
117 |     assert "decorated_transfer" in names
    |     ^^^^^^ S101
118 |     assert "my_inferred_protocol" in names
    |

tests/services/test_discovery_service.py:118:5: S101 Use of `assert` detected
    |
116 |     names = {model.name for model, func in definitions}
117 |     assert "decorated_transfer" in names
118 |     assert "my_inferred_protocol" in names
    |     ^^^^^^ S101
119 | 
120 |   def test_decorated_protocol_is_parsed_correctly(
    |

tests/services/test_discovery_service.py:120:7: ANN201 Missing return type annotation for public function `test_decorated_protocol_is_parsed_correctly`
    |
118 |     assert "my_inferred_protocol" in names
119 | 
120 |   def test_decorated_protocol_is_parsed_correctly(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
121 |     self, discovery_service, protocol_files,
122 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_discovery_service.py:121:11: ANN001 Missing type annotation for function argument `discovery_service`
    |
120 |   def test_decorated_protocol_is_parsed_correctly(
121 |     self, discovery_service, protocol_files,
    |           ^^^^^^^^^^^^^^^^^ ANN001
122 |   ):
123 |     """Verify the content of a protocol definition from a decorator."""
    |

tests/services/test_discovery_service.py:121:30: ANN001 Missing type annotation for function argument `protocol_files`
    |
120 |   def test_decorated_protocol_is_parsed_correctly(
121 |     self, discovery_service, protocol_files,
    |                              ^^^^^^^^^^^^^^ ANN001
122 |   ):
123 |     """Verify the content of a protocol definition from a decorator."""
    |

tests/services/test_discovery_service.py:124:19: SLF001 Private member accessed: `_extract_protocol_definitions_from_paths`
    |
122 |   ):
123 |     """Verify the content of a protocol definition from a decorator."""
124 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
125 |       str(protocol_files),
126 |     )
    |

tests/services/test_discovery_service.py:130:5: S101 Use of `assert` detected
    |
128 |       d for d in definitions if d[0].name == "decorated_transfer"
129 |     )
130 |     assert isinstance(decorated_def, FunctionProtocolDefinitionModel)
    |     ^^^^^^ S101
131 |     assert decorated_def.name == "decorated_transfer"
132 |     assert decorated_def.version == "1.1.0"
    |

tests/services/test_discovery_service.py:131:5: S101 Use of `assert` detected
    |
129 |     )
130 |     assert isinstance(decorated_def, FunctionProtocolDefinitionModel)
131 |     assert decorated_def.name == "decorated_transfer"
    |     ^^^^^^ S101
132 |     assert decorated_def.version == "1.1.0"
133 |     param_names = {p.name for p in decorated_def.parameters}
    |

tests/services/test_discovery_service.py:132:5: S101 Use of `assert` detected
    |
130 |     assert isinstance(decorated_def, FunctionProtocolDefinitionModel)
131 |     assert decorated_def.name == "decorated_transfer"
132 |     assert decorated_def.version == "1.1.0"
    |     ^^^^^^ S101
133 |     param_names = {p.name for p in decorated_def.parameters}
134 |     assert param_names == {"source_plate", "dest_plate", "volume"}
    |

tests/services/test_discovery_service.py:134:5: S101 Use of `assert` detected
    |
132 |     assert decorated_def.version == "1.1.0"
133 |     param_names = {p.name for p in decorated_def.parameters}
134 |     assert param_names == {"source_plate", "dest_plate", "volume"}
    |     ^^^^^^ S101
135 |     asset_names = {a.name for a in decorated_def.assets}
136 |     assert "tips" in asset_names
    |

tests/services/test_discovery_service.py:136:5: S101 Use of `assert` detected
    |
134 |     assert param_names == {"source_plate", "dest_plate", "volume"}
135 |     asset_names = {a.name for a in decorated_def.assets}
136 |     assert "tips" in asset_names
    |     ^^^^^^ S101
137 | 
138 |   def test_inferred_protocol_is_parsed_correctly(
    |

tests/services/test_discovery_service.py:138:7: ANN201 Missing return type annotation for public function `test_inferred_protocol_is_parsed_correctly`
    |
136 |     assert "tips" in asset_names
137 | 
138 |   def test_inferred_protocol_is_parsed_correctly(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
139 |     self, discovery_service, protocol_files,
140 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_discovery_service.py:139:11: ANN001 Missing type annotation for function argument `discovery_service`
    |
138 |   def test_inferred_protocol_is_parsed_correctly(
139 |     self, discovery_service, protocol_files,
    |           ^^^^^^^^^^^^^^^^^ ANN001
140 |   ):
141 |     """Verify the content of an inferred protocol definition."""
    |

tests/services/test_discovery_service.py:139:30: ANN001 Missing type annotation for function argument `protocol_files`
    |
138 |   def test_inferred_protocol_is_parsed_correctly(
139 |     self, discovery_service, protocol_files,
    |                              ^^^^^^^^^^^^^^ ANN001
140 |   ):
141 |     """Verify the content of an inferred protocol definition."""
    |

tests/services/test_discovery_service.py:142:19: SLF001 Private member accessed: `_extract_protocol_definitions_from_paths`
    |
140 |   ):
141 |     """Verify the content of an inferred protocol definition."""
142 |     definitions = discovery_service._extract_protocol_definitions_from_paths(
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
143 |       str(protocol_files),
144 |     )
    |

tests/services/test_discovery_service.py:148:5: S101 Use of `assert` detected
    |
146 |       d for d in definitions if d[0].name == "my_inferred_protocol"
147 |     )
148 |     assert isinstance(inferred_def, FunctionProtocolDefinitionModel)
    |     ^^^^^^ S101
149 |     params = {p.name: p for p in inferred_def.parameters}
150 |     assert "num_transfers" in params
    |

tests/services/test_discovery_service.py:150:5: S101 Use of `assert` detected
    |
148 |     assert isinstance(inferred_def, FunctionProtocolDefinitionModel)
149 |     params = {p.name: p for p in inferred_def.parameters}
150 |     assert "num_transfers" in params
    |     ^^^^^^ S101
151 |     assets = {a.name: a for a in inferred_def.assets}
152 |     assert "p" in assets
    |

tests/services/test_discovery_service.py:152:5: S101 Use of `assert` detected
    |
150 |     assert "num_transfers" in params
151 |     assets = {a.name: a for a in inferred_def.assets}
152 |     assert "p" in assets
    |     ^^^^^^ S101
153 |     # FIX: Check the 'fqn' attribute instead of 'actual_type_str'
154 |     assert assets["p"].fqn == "pylabrobot.resources.Plate"
    |

tests/services/test_discovery_service.py:154:5: S101 Use of `assert` detected
    |
152 |     assert "p" in assets
153 |     # FIX: Check the 'fqn' attribute instead of 'actual_type_str'
154 |     assert assets["p"].fqn == "pylabrobot.resources.Plate"
    |     ^^^^^^ S101
155 |     assert assets["p"].optional is False
    |

tests/services/test_discovery_service.py:155:5: S101 Use of `assert` detected
    |
153 |     # FIX: Check the 'fqn' attribute instead of 'actual_type_str'
154 |     assert assets["p"].fqn == "pylabrobot.resources.Plate"
155 |     assert assets["p"].optional is False
    |     ^^^^^^ S101
156 | 
157 |   async def test_discover_and_upsert_happy_path(
    |

tests/services/test_discovery_service.py:157:13: ANN201 Missing return type annotation for public function `test_discover_and_upsert_happy_path`
    |
155 |     assert assets["p"].optional is False
156 | 
157 |   async def test_discover_and_upsert_happy_path(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
158 |     self, discovery_service, protocol_files,
159 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_discovery_service.py:158:11: ANN001 Missing type annotation for function argument `discovery_service`
    |
157 |   async def test_discover_and_upsert_happy_path(
158 |     self, discovery_service, protocol_files,
    |           ^^^^^^^^^^^^^^^^^ ANN001
159 |   ):
160 |     """Test the full discover and upsert flow, including registry updates."""
    |

tests/services/test_discovery_service.py:158:30: ANN001 Missing type annotation for function argument `protocol_files`
    |
157 |   async def test_discover_and_upsert_happy_path(
158 |     self, discovery_service, protocol_files,
    |                              ^^^^^^^^^^^^^^ ANN001
159 |   ):
160 |     """Test the full discover and upsert flow, including registry updates."""
    |

tests/services/test_discovery_service.py:184:7: S101 Use of `assert` detected
    |
182 |         str(protocol_files),
183 |       )
184 |       assert len(result_orms) == 2
    |       ^^^^^^ S101
185 |       registry_entry = PROTOCOL_REGISTRY.get("decorated_transfer_v1.1.0")
186 |       assert registry_entry is not None
    |

tests/services/test_discovery_service.py:184:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
182 |         str(protocol_files),
183 |       )
184 |       assert len(result_orms) == 2
    |                                  ^ PLR2004
185 |       registry_entry = PROTOCOL_REGISTRY.get("decorated_transfer_v1.1.0")
186 |       assert registry_entry is not None
    |

tests/services/test_discovery_service.py:186:7: S101 Use of `assert` detected
    |
184 |       assert len(result_orms) == 2
185 |       registry_entry = PROTOCOL_REGISTRY.get("decorated_transfer_v1.1.0")
186 |       assert registry_entry is not None
    |       ^^^^^^ S101
187 |       assert registry_entry["db_accession_id"] == mock_orm.accession_id
    |

tests/services/test_discovery_service.py:187:7: S101 Use of `assert` detected
    |
185 |       registry_entry = PROTOCOL_REGISTRY.get("decorated_transfer_v1.1.0")
186 |       assert registry_entry is not None
187 |       assert registry_entry["db_accession_id"] == mock_orm.accession_id
    |       ^^^^^^ S101
    |

tests/services/test_entity_linking.py:1:1: INP001 File `tests/services/test_entity_linking.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_entity_linking.py:62:5: SyntaxError: Duplicate keyword argument "name"
   |
60 |   resource = ResourceOrm(
61 |     name="TestResource1",
62 |     name=resource_def.name,
   |     ^
63 |   )
64 |   db.add(resource)
   |

tests/services/test_function_output_data.py:1:1: INP001 File `tests/services/test_function_output_data.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_function_output_data.py:49:5: SyntaxError: Duplicate keyword argument "name"
   |
47 |   resource_instance = ResourceOrm(
48 |     name="Test Resource",
49 |     name="test_resource_def",
   |     ^
50 |   )
51 |   deck_instance = DeckOrm(
   |

tests/services/test_machine.py:1:1: INP001 File `tests/services/test_machine.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_machine.py:70:5: SyntaxError: Duplicate keyword argument "name"
   |
68 |   resource = ResourceOrm(
69 |     name="ExistingResourceForLinking",
70 |     name=resource_def.name,
   |     ^
71 |   )
72 |   db.add(resource)
   |

tests/services/test_plate_parsing.py:1:1: INP001 File `tests/services/test_plate_parsing.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_plate_parsing.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/services/plate_parsing.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/services/test_plate_parsing.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/services/plate_parsing.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/services/test_plate_parsing.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/services/plate_parsing.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/services/test_plate_parsing.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/services/test_plate_parsing.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/services/test_plate_parsing.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/services/test_plate_viz.py:1:1: INP001 File `tests/services/test_plate_viz.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_plate_viz.py:29:5: SyntaxError: Duplicate keyword argument "name"
   |
27 |   plate_resource = ResourceOrm(
28 |     name="TestPlate1",
29 |     name="corning_96_wellplate_360ul_flat",
   |     ^
30 |   )
   |

tests/services/test_praxis_orm_service.py:1:1: INP001 File `tests/services/test_praxis_orm_service.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_praxis_orm_service.py:1:1: D100 Missing docstring in public module
tests/services/test_praxis_orm_service.py:20:5: ANN201 Missing return type annotation for public function `cleanup_singleton`
   |
19 | @pytest.fixture(autouse=True)
20 | def cleanup_singleton():
   |     ^^^^^^^^^^^^^^^^^ ANN201
21 |   """Fixture to reset the singleton instance before and after each test."""
22 |   # Reset before test
   |
   = help: Add return type annotation

tests/services/test_praxis_orm_service.py:23:6: SLF001 Private member accessed: `_instance`
   |
21 |   """Fixture to reset the singleton instance before and after each test."""
22 |   # Reset before test
23 |   if PraxisDBService._instance:
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
24 |     PraxisDBService._instance._keycloak_pool = None
25 |   PraxisDBService._instance = None
   |

tests/services/test_praxis_orm_service.py:24:5: SLF001 Private member accessed: `_instance`
   |
22 |   # Reset before test
23 |   if PraxisDBService._instance:
24 |     PraxisDBService._instance._keycloak_pool = None
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
25 |   PraxisDBService._instance = None
26 |   yield
   |

tests/services/test_praxis_orm_service.py:24:5: SLF001 Private member accessed: `_keycloak_pool`
   |
22 |   # Reset before test
23 |   if PraxisDBService._instance:
24 |     PraxisDBService._instance._keycloak_pool = None
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
25 |   PraxisDBService._instance = None
26 |   yield
   |

tests/services/test_praxis_orm_service.py:25:3: SLF001 Private member accessed: `_instance`
   |
23 |   if PraxisDBService._instance:
24 |     PraxisDBService._instance._keycloak_pool = None
25 |   PraxisDBService._instance = None
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
26 |   yield
27 |   # Reset after test
   |

tests/services/test_praxis_orm_service.py:28:6: SLF001 Private member accessed: `_instance`
   |
26 |   yield
27 |   # Reset after test
28 |   if PraxisDBService._instance:
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
29 |     PraxisDBService._instance._keycloak_pool = None
30 |   PraxisDBService._instance = None
   |

tests/services/test_praxis_orm_service.py:29:5: SLF001 Private member accessed: `_instance`
   |
27 |   # Reset after test
28 |   if PraxisDBService._instance:
29 |     PraxisDBService._instance._keycloak_pool = None
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
30 |   PraxisDBService._instance = None
   |

tests/services/test_praxis_orm_service.py:29:5: SLF001 Private member accessed: `_keycloak_pool`
   |
27 |   # Reset after test
28 |   if PraxisDBService._instance:
29 |     PraxisDBService._instance._keycloak_pool = None
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
30 |   PraxisDBService._instance = None
   |

tests/services/test_praxis_orm_service.py:30:3: SLF001 Private member accessed: `_instance`
   |
28 |   if PraxisDBService._instance:
29 |     PraxisDBService._instance._keycloak_pool = None
30 |   PraxisDBService._instance = None
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ SLF001
   |

tests/services/test_praxis_orm_service.py:36:7: ANN201 Missing return type annotation for public function `test_singleton_pattern`
   |
34 |   """Test suite for the PraxisDBService class."""
35 | 
36 |   def test_singleton_pattern(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^ ANN201
37 |     """Test that the singleton pattern is correctly implemented."""
38 |     instance1 = PraxisDBService()
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:40:5: S101 Use of `assert` detected
   |
38 |     instance1 = PraxisDBService()
39 |     instance2 = PraxisDBService()
40 |     assert instance1 is instance2
   |     ^^^^^^ S101
41 | 
42 |   async def test_initialize_no_keycloak(self):
   |

tests/services/test_praxis_orm_service.py:42:13: ANN201 Missing return type annotation for public function `test_initialize_no_keycloak`
   |
40 |     assert instance1 is instance2
41 | 
42 |   async def test_initialize_no_keycloak(self):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
43 |     """Test initialization without a Keycloak DSN."""
44 |     service = await PraxisDBService.initialize()
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:45:5: S101 Use of `assert` detected
   |
43 |     """Test initialization without a Keycloak DSN."""
44 |     service = await PraxisDBService.initialize()
45 |     assert service._keycloak_pool is None
   |     ^^^^^^ S101
46 | 
47 |   async def test_initialize_invalid_dsn_raises_value_error(self):
   |

tests/services/test_praxis_orm_service.py:45:12: SLF001 Private member accessed: `_keycloak_pool`
   |
43 |     """Test initialization without a Keycloak DSN."""
44 |     service = await PraxisDBService.initialize()
45 |     assert service._keycloak_pool is None
   |            ^^^^^^^^^^^^^^^^^^^^^^ SLF001
46 | 
47 |   async def test_initialize_invalid_dsn_raises_value_error(self):
   |

tests/services/test_praxis_orm_service.py:47:13: ANN201 Missing return type annotation for public function `test_initialize_invalid_dsn_raises_value_error`
   |
45 |     assert service._keycloak_pool is None
46 | 
47 |   async def test_initialize_invalid_dsn_raises_value_error(self):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
48 |     """Test that initialization with an invalid DSN format raises ValueError."""
49 |     with pytest.raises(ValueError, match="must start with postgresql://"):
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:53:13: ANN201 Missing return type annotation for public function `test_initialize_keycloak_success`
   |
52 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
53 |   async def test_initialize_keycloak_success(self, mock_create_pool):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |     """Test successful initialization with a mocked Keycloak connection pool."""
55 |     mock_pool = AsyncMock()
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:53:52: ANN001 Missing type annotation for function argument `mock_create_pool`
   |
52 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
53 |   async def test_initialize_keycloak_success(self, mock_create_pool):
   |                                                    ^^^^^^^^^^^^^^^^ ANN001
54 |     """Test successful initialization with a mocked Keycloak connection pool."""
55 |     mock_pool = AsyncMock()
   |

tests/services/test_praxis_orm_service.py:63:5: S101 Use of `assert` detected
   |
62 |     mock_create_pool.assert_called_once()
63 |     assert service._keycloak_pool is not None
   |     ^^^^^^ S101
64 |     # Test that initializing again does not create a new pool
65 |     await PraxisDBService.initialize(keycloak_dsn="postgresql://user:pass@host/db")
   |

tests/services/test_praxis_orm_service.py:63:12: SLF001 Private member accessed: `_keycloak_pool`
   |
62 |     mock_create_pool.assert_called_once()
63 |     assert service._keycloak_pool is not None
   |            ^^^^^^^^^^^^^^^^^^^^^^ SLF001
64 |     # Test that initializing again does not create a new pool
65 |     await PraxisDBService.initialize(keycloak_dsn="postgresql://user:pass@host/db")
   |

tests/services/test_praxis_orm_service.py:73:13: ANN201 Missing return type annotation for public function `test_initialize_keycloak_connection_fails`
   |
71 |     side_effect=ConnectionRefusedError("Test refuse"),
72 |   )
73 |   async def test_initialize_keycloak_connection_fails(self, mock_create_pool):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |     """Test that initialization raises ConnectionError after retries."""
75 |     # Patch sleep to speed up the test
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:73:61: ANN001 Missing type annotation for function argument `mock_create_pool`
   |
71 |     side_effect=ConnectionRefusedError("Test refuse"),
72 |   )
73 |   async def test_initialize_keycloak_connection_fails(self, mock_create_pool):
   |                                                             ^^^^^^^^^^^^^^^^ ANN001
74 |     """Test that initialization raises ConnectionError after retries."""
75 |     # Patch sleep to speed up the test
   |

tests/services/test_praxis_orm_service.py:76:5: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   |
74 |       """Test that initialization raises ConnectionError after retries."""
75 |       # Patch sleep to speed up the test
76 |       with patch("asyncio.sleep", new_callable=AsyncMock):
   |  _____^
77 | |       with pytest.raises(
78 | |         ConnectionError, match="Could not establish Keycloak database connection",
79 | |       ):
   | |________^ SIM117
80 |           await PraxisDBService.initialize(keycloak_dsn="postgresql://user:pass@host/db")
81 |       assert mock_create_pool.call_count == 3  # _max_retries = 3
   |
   = help: Combine `with` statements

tests/services/test_praxis_orm_service.py:81:5: S101 Use of `assert` detected
   |
79 |       ):
80 |         await PraxisDBService.initialize(keycloak_dsn="postgresql://user:pass@host/db")
81 |     assert mock_create_pool.call_count == 3  # _max_retries = 3
   |     ^^^^^^ S101
82 | 
83 |   async def test_get_praxis_session_commit_and_rollback(self, db_session_factory):
   |

tests/services/test_praxis_orm_service.py:81:43: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
79 |       ):
80 |         await PraxisDBService.initialize(keycloak_dsn="postgresql://user:pass@host/db")
81 |     assert mock_create_pool.call_count == 3  # _max_retries = 3
   |                                           ^ PLR2004
82 | 
83 |   async def test_get_praxis_session_commit_and_rollback(self, db_session_factory):
   |

tests/services/test_praxis_orm_service.py:83:13: ANN201 Missing return type annotation for public function `test_get_praxis_session_commit_and_rollback`
   |
81 |     assert mock_create_pool.call_count == 3  # _max_retries = 3
82 | 
83 |   async def test_get_praxis_session_commit_and_rollback(self, db_session_factory):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |     """Test the get_praxis_session context manager for commit and rollback."""
85 |     service = PraxisDBService()
   |
   = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:83:63: ANN001 Missing type annotation for function argument `db_session_factory`
   |
81 |     assert mock_create_pool.call_count == 3  # _max_retries = 3
82 | 
83 |   async def test_get_praxis_session_commit_and_rollback(self, db_session_factory):
   |                                                               ^^^^^^^^^^^^^^^^^^ ANN001
84 |     """Test the get_praxis_session context manager for commit and rollback."""
85 |     service = PraxisDBService()
   |

tests/services/test_praxis_orm_service.py:103:9: S101 Use of `assert` detected
    |
101 |           select(UserOrm).where(UserOrm.username == "test_commit"),
102 |         )
103 |         assert result.scalar_one_or_none() is not None
    |         ^^^^^^ S101
104 | 
105 |       # Test rollback on exception
    |

tests/services/test_praxis_orm_service.py:114:11: TRY301 Abstract `raise` to an inner function
    |
112 |           )
113 |           session.add(user_rollback)
114 |           raise ValueError("Test Rollback")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
115 |       except ValueError:
116 |         pass  # Expected
    |

tests/services/test_praxis_orm_service.py:114:17: TRY003 Avoid specifying long messages outside the exception class
    |
112 |           )
113 |           session.add(user_rollback)
114 |           raise ValueError("Test Rollback")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
115 |       except ValueError:
116 |         pass  # Expected
    |

tests/services/test_praxis_orm_service.py:114:28: EM101 Exception must not use a string literal, assign to variable first
    |
112 |           )
113 |           session.add(user_rollback)
114 |           raise ValueError("Test Rollback")
    |                            ^^^^^^^^^^^^^^^ EM101
115 |       except ValueError:
116 |         pass  # Expected
    |
    = help: Assign to variable; remove string literal

tests/services/test_praxis_orm_service.py:123:9: S101 Use of `assert` detected
    |
121 |           select(UserOrm).where(UserOrm.username == "test_rollback"),
122 |         )
123 |         assert result.scalar_one_or_none() is None
    |         ^^^^^^ S101
124 | 
125 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
    |

tests/services/test_praxis_orm_service.py:126:13: ANN201 Missing return type annotation for public function `test_get_all_users_success`
    |
125 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
126 |   async def test_get_all_users_success(self, mock_create_pool):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
127 |     """Test fetching all users from a mocked Keycloak DB."""
128 |     # Mock the connection and its fetch method
    |
    = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:126:46: ANN001 Missing type annotation for function argument `mock_create_pool`
    |
125 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
126 |   async def test_get_all_users_success(self, mock_create_pool):
    |                                              ^^^^^^^^^^^^^^^^ ANN001
127 |     """Test fetching all users from a mocked Keycloak DB."""
128 |     # Mock the connection and its fetch method
    |

tests/services/test_praxis_orm_service.py:157:5: S101 Use of `assert` detected
    |
156 |     users = await service.get_all_users()
157 |     assert len(users) == 2
    |     ^^^^^^ S101
158 |     assert "user1" in users
159 |     assert users["user2"]["email"] == "u2@test.com"
    |

tests/services/test_praxis_orm_service.py:157:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
156 |     users = await service.get_all_users()
157 |     assert len(users) == 2
    |                          ^ PLR2004
158 |     assert "user1" in users
159 |     assert users["user2"]["email"] == "u2@test.com"
    |

tests/services/test_praxis_orm_service.py:158:5: S101 Use of `assert` detected
    |
156 |     users = await service.get_all_users()
157 |     assert len(users) == 2
158 |     assert "user1" in users
    |     ^^^^^^ S101
159 |     assert users["user2"]["email"] == "u2@test.com"
160 |     assert users["user1"]["is_active"] is True
    |

tests/services/test_praxis_orm_service.py:159:5: S101 Use of `assert` detected
    |
157 |     assert len(users) == 2
158 |     assert "user1" in users
159 |     assert users["user2"]["email"] == "u2@test.com"
    |     ^^^^^^ S101
160 |     assert users["user1"]["is_active"] is True
    |

tests/services/test_praxis_orm_service.py:160:5: S101 Use of `assert` detected
    |
158 |     assert "user1" in users
159 |     assert users["user2"]["email"] == "u2@test.com"
160 |     assert users["user1"]["is_active"] is True
    |     ^^^^^^ S101
161 | 
162 |   async def test_get_all_users_no_pool(self):
    |

tests/services/test_praxis_orm_service.py:162:13: ANN201 Missing return type annotation for public function `test_get_all_users_no_pool`
    |
160 |     assert users["user1"]["is_active"] is True
161 | 
162 |   async def test_get_all_users_no_pool(self):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
163 |     """Test that get_all_users returns an empty dict if pool is not initialized."""
164 |     service = PraxisDBService()
    |
    = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:166:5: S101 Use of `assert` detected
    |
164 |     service = PraxisDBService()
165 |     users = await service.get_all_users()
166 |     assert users == {}
    |     ^^^^^^ S101
167 | 
168 |   async def test_raw_sql_methods(self, db_session_factory):
    |

tests/services/test_praxis_orm_service.py:168:13: ANN201 Missing return type annotation for public function `test_raw_sql_methods`
    |
166 |     assert users == {}
167 | 
168 |   async def test_raw_sql_methods(self, db_session_factory):
    |             ^^^^^^^^^^^^^^^^^^^^ ANN201
169 |     """Test execute, fetch_all, fetch_one, and fetch_val SQL methods."""
170 |     service = PraxisDBService()
    |
    = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:168:40: ANN001 Missing type annotation for function argument `db_session_factory`
    |
166 |     assert users == {}
167 | 
168 |   async def test_raw_sql_methods(self, db_session_factory):
    |                                        ^^^^^^^^^^^^^^^^^^ ANN001
169 |     """Test execute, fetch_all, fetch_one, and fetch_val SQL methods."""
170 |     service = PraxisDBService()
    |

tests/services/test_praxis_orm_service.py:185:7: S101 Use of `assert` detected
    |
183 |       # Test fetch_all
184 |       rows = await service.fetch_all_sql("SELECT * FROM sql_test ORDER BY id")
185 |       assert len(rows) == 2
    |       ^^^^^^ S101
186 |       assert rows[0]["name"] == "alpha"
    |

tests/services/test_praxis_orm_service.py:185:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
183 |       # Test fetch_all
184 |       rows = await service.fetch_all_sql("SELECT * FROM sql_test ORDER BY id")
185 |       assert len(rows) == 2
    |                           ^ PLR2004
186 |       assert rows[0]["name"] == "alpha"
    |

tests/services/test_praxis_orm_service.py:186:7: S101 Use of `assert` detected
    |
184 |       rows = await service.fetch_all_sql("SELECT * FROM sql_test ORDER BY id")
185 |       assert len(rows) == 2
186 |       assert rows[0]["name"] == "alpha"
    |       ^^^^^^ S101
187 | 
188 |       # Test fetch_one
    |

tests/services/test_praxis_orm_service.py:192:7: S101 Use of `assert` detected
    |
190 |         "SELECT * FROM sql_test WHERE id = :id", params={"id": 2},
191 |       )
192 |       assert row is not None
    |       ^^^^^^ S101
193 |       assert row["name"] == "beta"
    |

tests/services/test_praxis_orm_service.py:193:7: S101 Use of `assert` detected
    |
191 |       )
192 |       assert row is not None
193 |       assert row["name"] == "beta"
    |       ^^^^^^ S101
194 | 
195 |       # Test fetch_val
    |

tests/services/test_praxis_orm_service.py:197:7: S101 Use of `assert` detected
    |
195 |       # Test fetch_val
196 |       count = await service.fetch_val_sql("SELECT COUNT(*) FROM sql_test")
197 |       assert count == 2
    |       ^^^^^^ S101
198 | 
199 |       # Test execute
    |

tests/services/test_praxis_orm_service.py:197:23: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
195 |       # Test fetch_val
196 |       count = await service.fetch_val_sql("SELECT COUNT(*) FROM sql_test")
197 |       assert count == 2
    |                       ^ PLR2004
198 | 
199 |       # Test execute
    |

tests/services/test_praxis_orm_service.py:202:7: S101 Use of `assert` detected
    |
200 |       await service.execute_sql("UPDATE sql_test SET name = 'gamma' WHERE id = 1")
201 |       new_name = await service.fetch_val_sql("SELECT name FROM sql_test WHERE id = 1")
202 |       assert new_name == "gamma"
    |       ^^^^^^ S101
203 | 
204 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
    |

tests/services/test_praxis_orm_service.py:205:13: ANN201 Missing return type annotation for public function `test_close`
    |
204 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
205 |   async def test_close(self, mock_create_pool):
    |             ^^^^^^^^^^ ANN201
206 |     """Test that the close method closes the Keycloak pool."""
207 |     mock_pool = AsyncMock()
    |
    = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:205:30: ANN001 Missing type annotation for function argument `mock_create_pool`
    |
204 |   @patch("asyncpg.create_pool", new_callable=AsyncMock)
205 |   async def test_close(self, mock_create_pool):
    |                              ^^^^^^^^^^^^^^^^ ANN001
206 |     """Test that the close method closes the Keycloak pool."""
207 |     mock_pool = AsyncMock()
    |

tests/services/test_praxis_orm_service.py:208:5: SLF001 Private member accessed: `_closed`
    |
206 |     """Test that the close method closes the Keycloak pool."""
207 |     mock_pool = AsyncMock()
208 |     mock_pool._closed = False  # Simulate it's open
    |     ^^^^^^^^^^^^^^^^^ SLF001
209 |     mock_create_pool.return_value = mock_pool
    |

tests/services/test_praxis_orm_service.py:217:5: ANN201 Missing return type annotation for public function `test_get_keycloak_dsn_from_config`
    |
217 | def test_get_keycloak_dsn_from_config(mocker):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
218 |   """Test the helper function for reading Keycloak DSN from praxis.ini."""
219 |   # Mock file system and config parser
    |
    = help: Add return type annotation: `None`

tests/services/test_praxis_orm_service.py:217:39: ANN001 Missing type annotation for function argument `mocker`
    |
217 | def test_get_keycloak_dsn_from_config(mocker):
    |                                       ^^^^^^ ANN001
218 |   """Test the helper function for reading Keycloak DSN from praxis.ini."""
219 |   # Mock file system and config parser
    |

tests/services/test_praxis_orm_service.py:237:3: S101 Use of `assert` detected
    |
235 |   )
236 |   dsn = _get_keycloak_dsn_from_config()
237 |   assert dsn == "postgresql://testuser:testpassword@localhost:5432/keycloak_db"
    |   ^^^^^^ S101
238 | 
239 |   # Test with env var override
    |

tests/services/test_praxis_orm_service.py:245:3: S101 Use of `assert` detected
    |
243 |   )
244 |   dsn_env = _get_keycloak_dsn_from_config()
245 |   assert dsn_env == "postgresql://env_user:env_password@localhost:5432/keycloak_db"
    |   ^^^^^^ S101
246 | 
247 |   # Test file not found
    |

tests/services/test_praxis_orm_service.py:249:3: S101 Use of `assert` detected
    |
247 |   # Test file not found
248 |   mocker.patch("pathlib.Path.exists", return_value=False)
249 |   assert _get_keycloak_dsn_from_config() is None
    |   ^^^^^^ S101
    |

tests/services/test_protocol_output_data.py:1:1: INP001 File `tests/services/test_protocol_output_data.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_protocol_output_data.py:43:5: SyntaxError: Duplicate keyword argument "name"
   |
41 |   resource = ResourceOrm(
42 |     name="SummaryResource",
43 |     name="summary_resource_def",
   |     ^
44 |   )
   |

tests/services/test_protocols.py:1:1: INP001 File `tests/services/test_protocols.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_protocols.py:1:1: D100 Missing docstring in public module
tests/services/test_protocols.py:52:56: S108 Probable insecure usage of temporary file or directory: "/tmp/protocols"
   |
50 |   """Fixture for a filesystem protocol source."""
51 |   return await create_file_system_protocol_source(
52 |     db, name=f"TestFSSource_{uuid.uuid4()}", base_path="/tmp/protocols",
   |                                                        ^^^^^^^^^^^^^^^^ S108
53 |   )
   |

tests/services/test_protocols.py:120:13: ANN201 Missing return type annotation for public function `test_create_and_read_git_repo`
    |
118 |   """Tests for Git-based protocol source repositories."""
119 | 
120 |   async def test_create_and_read_git_repo(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
121 |     name = f"MyGitRepo_{uuid.uuid4()}"
122 |     repo = await create_protocol_source_repository(
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:120:13: D102 Missing docstring in public method
    |
118 |   """Tests for Git-based protocol source repositories."""
119 | 
120 |   async def test_create_and_read_git_repo(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
121 |     name = f"MyGitRepo_{uuid.uuid4()}"
122 |     repo = await create_protocol_source_repository(
    |

tests/services/test_protocols.py:125:5: S101 Use of `assert` detected
    |
123 |       db, name=name, git_url="http://git.test/repo",
124 |     )
125 |     assert repo.name == name
    |     ^^^^^^ S101
126 | 
127 |     read_repo = await read_protocol_source_repository(db, repo.accession_id)
    |

tests/services/test_protocols.py:128:5: S101 Use of `assert` detected
    |
127 |     read_repo = await read_protocol_source_repository(db, repo.accession_id)
128 |     assert read_repo is not None
    |     ^^^^^^ S101
129 |     assert read_repo.name == name
    |

tests/services/test_protocols.py:129:5: S101 Use of `assert` detected
    |
127 |     read_repo = await read_protocol_source_repository(db, repo.accession_id)
128 |     assert read_repo is not None
129 |     assert read_repo.name == name
    |     ^^^^^^ S101
130 | 
131 |   async def test_update_git_repo(
    |

tests/services/test_protocols.py:131:13: ANN201 Missing return type annotation for public function `test_update_git_repo`
    |
129 |     assert read_repo.name == name
130 | 
131 |   async def test_update_git_repo(
    |             ^^^^^^^^^^^^^^^^^^^^ ANN201
132 |     self, db: AsyncSession, git_source: ProtocolSourceRepositoryOrm,
133 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:131:13: D102 Missing docstring in public method
    |
129 |     assert read_repo.name == name
130 | 
131 |   async def test_update_git_repo(
    |             ^^^^^^^^^^^^^^^^^^^^ D102
132 |     self, db: AsyncSession, git_source: ProtocolSourceRepositoryOrm,
133 |   ):
    |

tests/services/test_protocols.py:138:5: S101 Use of `assert` detected
    |
136 |       db, source_accession_id=git_source.accession_id, default_ref=new_ref,
137 |     )
138 |     assert updated_repo.default_ref == new_ref
    |     ^^^^^^ S101
139 | 
140 |   async def test_list_git_repos_by_sync_status(
    |

tests/services/test_protocols.py:140:13: ANN201 Missing return type annotation for public function `test_list_git_repos_by_sync_status`
    |
138 |     assert updated_repo.default_ref == new_ref
139 | 
140 |   async def test_list_git_repos_by_sync_status(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
141 |     self, db: AsyncSession, git_source: ProtocolSourceRepositoryOrm,
142 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:154:5: S101 Use of `assert` detected
    |
152 |     # Default is True, so git_source should be in this list
153 |     synced_repos = await list_protocol_source_repositories(db, auto_sync_enabled=True)
154 |     assert len(synced_repos) >= 1
    |     ^^^^^^ S101
155 |     assert any(r.accession_id == git_source.accession_id for r in synced_repos)
    |

tests/services/test_protocols.py:155:5: S101 Use of `assert` detected
    |
153 |     synced_repos = await list_protocol_source_repositories(db, auto_sync_enabled=True)
154 |     assert len(synced_repos) >= 1
155 |     assert any(r.accession_id == git_source.accession_id for r in synced_repos)
    |     ^^^^^^ S101
156 | 
157 |     # Test for non-synced repos
    |

tests/services/test_protocols.py:161:5: S101 Use of `assert` detected
    |
159 |       db, auto_sync_enabled=False,
160 |     )
161 |     assert len(not_synced_repos) == 1
    |     ^^^^^^ S101
162 |     assert not any(r.accession_id == git_source.accession_id for r in not_synced_repos)
    |

tests/services/test_protocols.py:162:5: S101 Use of `assert` detected
    |
160 |     )
161 |     assert len(not_synced_repos) == 1
162 |     assert not any(r.accession_id == git_source.accession_id for r in not_synced_repos)
    |     ^^^^^^ S101
    |

tests/services/test_protocols.py:168:13: ANN201 Missing return type annotation for public function `test_upsert_protocol_create`
    |
166 |   """Tests for creating and managing protocol definitions."""
167 | 
168 |   async def test_upsert_protocol_create(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
169 |     self,
170 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:181:5: S101 Use of `assert` detected
    |
179 |       commit_hash="def123",
180 |     )
181 |     assert created_def is not None
    |     ^^^^^^ S101
182 |     assert created_def.name == "TestUpsertProtocol"
183 |     assert len(created_def.parameters) == 1
    |

tests/services/test_protocols.py:182:5: S101 Use of `assert` detected
    |
180 |     )
181 |     assert created_def is not None
182 |     assert created_def.name == "TestUpsertProtocol"
    |     ^^^^^^ S101
183 |     assert len(created_def.parameters) == 1
184 |     assert created_def.parameters[0].name == "param1"
    |

tests/services/test_protocols.py:183:5: S101 Use of `assert` detected
    |
181 |     assert created_def is not None
182 |     assert created_def.name == "TestUpsertProtocol"
183 |     assert len(created_def.parameters) == 1
    |     ^^^^^^ S101
184 |     assert created_def.parameters[0].name == "param1"
185 |     assert len(created_def.assets) == 1
    |

tests/services/test_protocols.py:184:5: S101 Use of `assert` detected
    |
182 |     assert created_def.name == "TestUpsertProtocol"
183 |     assert len(created_def.parameters) == 1
184 |     assert created_def.parameters[0].name == "param1"
    |     ^^^^^^ S101
185 |     assert len(created_def.assets) == 1
186 |     assert created_def.assets[0].name == "plate1"
    |

tests/services/test_protocols.py:185:5: S101 Use of `assert` detected
    |
183 |     assert len(created_def.parameters) == 1
184 |     assert created_def.parameters[0].name == "param1"
185 |     assert len(created_def.assets) == 1
    |     ^^^^^^ S101
186 |     assert created_def.assets[0].name == "plate1"
    |

tests/services/test_protocols.py:186:5: S101 Use of `assert` detected
    |
184 |     assert created_def.parameters[0].name == "param1"
185 |     assert len(created_def.assets) == 1
186 |     assert created_def.assets[0].name == "plate1"
    |     ^^^^^^ S101
187 | 
188 |   async def test_upsert_protocol_update_and_sync(
    |

tests/services/test_protocols.py:188:13: ANN201 Missing return type annotation for public function `test_upsert_protocol_update_and_sync`
    |
186 |     assert created_def.assets[0].name == "plate1"
187 | 
188 |   async def test_upsert_protocol_update_and_sync(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
189 |     self,
190 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:214:5: S101 Use of `assert` detected
    |
212 |     )
213 | 
214 |     assert updated_def.accession_id == protocol_def.accession_id
    |     ^^^^^^ S101
215 |     assert len(updated_def.parameters) == 2
216 |     assert updated_def.parameters[0].description == "Updated description"
    |

tests/services/test_protocols.py:215:5: S101 Use of `assert` detected
    |
214 |     assert updated_def.accession_id == protocol_def.accession_id
215 |     assert len(updated_def.parameters) == 2
    |     ^^^^^^ S101
216 |     assert updated_def.parameters[0].description == "Updated description"
217 |     assert len(updated_def.assets) == 1
    |

tests/services/test_protocols.py:215:43: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
214 |     assert updated_def.accession_id == protocol_def.accession_id
215 |     assert len(updated_def.parameters) == 2
    |                                           ^ PLR2004
216 |     assert updated_def.parameters[0].description == "Updated description"
217 |     assert len(updated_def.assets) == 1
    |

tests/services/test_protocols.py:216:5: S101 Use of `assert` detected
    |
214 |     assert updated_def.accession_id == protocol_def.accession_id
215 |     assert len(updated_def.parameters) == 2
216 |     assert updated_def.parameters[0].description == "Updated description"
    |     ^^^^^^ S101
217 |     assert len(updated_def.assets) == 1
218 |     assert updated_def.assets[0].name == "tip_rack"
    |

tests/services/test_protocols.py:217:5: S101 Use of `assert` detected
    |
215 |     assert len(updated_def.parameters) == 2
216 |     assert updated_def.parameters[0].description == "Updated description"
217 |     assert len(updated_def.assets) == 1
    |     ^^^^^^ S101
218 |     assert updated_def.assets[0].name == "tip_rack"
    |

tests/services/test_protocols.py:218:5: S101 Use of `assert` detected
    |
216 |     assert updated_def.parameters[0].description == "Updated description"
217 |     assert len(updated_def.assets) == 1
218 |     assert updated_def.assets[0].name == "tip_rack"
    |     ^^^^^^ S101
    |

tests/services/test_protocols.py:224:13: ANN201 Missing return type annotation for public function `test_create_and_read_protocol_run`
    |
222 |   """Tests for creating and managing protocol runs."""
223 | 
224 |   async def test_create_and_read_protocol_run(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
225 |     self, db: AsyncSession, protocol_def: FunctionProtocolDefinitionOrm,
226 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:229:5: S101 Use of `assert` detected
    |
227 |     """Test creating a new protocol run and reading it back."""
228 |     run = await create_protocol_run(db, protocol_def.accession_id)
229 |     assert run is not None
    |     ^^^^^^ S101
230 |     assert run.status == ProtocolRunStatusEnum.PENDING
    |

tests/services/test_protocols.py:230:5: S101 Use of `assert` detected
    |
228 |     run = await create_protocol_run(db, protocol_def.accession_id)
229 |     assert run is not None
230 |     assert run.status == ProtocolRunStatusEnum.PENDING
    |     ^^^^^^ S101
231 | 
232 |     read_run = await read_protocol_run(db, run.run_accession_id)
    |

tests/services/test_protocols.py:233:5: S101 Use of `assert` detected
    |
232 |     read_run = await read_protocol_run(db, run.run_accession_id)
233 |     assert read_run is not None
    |     ^^^^^^ S101
234 |     assert read_run.accession_id == run.accession_id
    |

tests/services/test_protocols.py:234:5: S101 Use of `assert` detected
    |
232 |     read_run = await read_protocol_run(db, run.run_accession_id)
233 |     assert read_run is not None
234 |     assert read_run.accession_id == run.accession_id
    |     ^^^^^^ S101
235 | 
236 |   async def test_update_protocol_run_status(
    |

tests/services/test_protocols.py:236:13: ANN201 Missing return type annotation for public function `test_update_protocol_run_status`
    |
234 |     assert read_run.accession_id == run.accession_id
235 | 
236 |   async def test_update_protocol_run_status(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
237 |     self, db: AsyncSession, protocol_run: ProtocolRunOrm,
238 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:240:5: S101 Use of `assert` detected
    |
238 |   ):
239 |     """Test updating the status of a protocol run through its lifecycle."""
240 |     assert protocol_run.start_time is None
    |     ^^^^^^ S101
241 | 
242 |     await update_protocol_run_status(
    |

tests/services/test_protocols.py:246:5: S101 Use of `assert` detected
    |
244 |     )
245 |     await db.refresh(protocol_run)
246 |     assert protocol_run.status == ProtocolRunStatusEnum.RUNNING
    |     ^^^^^^ S101
247 |     assert protocol_run.start_time is not None
    |

tests/services/test_protocols.py:247:5: S101 Use of `assert` detected
    |
245 |     await db.refresh(protocol_run)
246 |     assert protocol_run.status == ProtocolRunStatusEnum.RUNNING
247 |     assert protocol_run.start_time is not None
    |     ^^^^^^ S101
248 | 
249 |     await asyncio.sleep(0.01)
    |

tests/services/test_protocols.py:255:5: S101 Use of `assert` detected
    |
253 |     )
254 |     await db.refresh(protocol_run)
255 |     assert protocol_run.status == ProtocolRunStatusEnum.COMPLETED
    |     ^^^^^^ S101
256 |     assert protocol_run.end_time is not None
257 |     assert protocol_run.duration_ms is not None and protocol_run.duration_ms > 0
    |

tests/services/test_protocols.py:256:5: S101 Use of `assert` detected
    |
254 |     await db.refresh(protocol_run)
255 |     assert protocol_run.status == ProtocolRunStatusEnum.COMPLETED
256 |     assert protocol_run.end_time is not None
    |     ^^^^^^ S101
257 |     assert protocol_run.duration_ms is not None and protocol_run.duration_ms > 0
    |

tests/services/test_protocols.py:257:5: S101 Use of `assert` detected
    |
255 |     assert protocol_run.status == ProtocolRunStatusEnum.COMPLETED
256 |     assert protocol_run.end_time is not None
257 |     assert protocol_run.duration_ms is not None and protocol_run.duration_ms > 0
    |     ^^^^^^ S101
258 | 
259 |   async def test_list_protocol_runs(
    |

tests/services/test_protocols.py:257:5: PT018 Assertion should be broken down into multiple parts
    |
255 |     assert protocol_run.status == ProtocolRunStatusEnum.COMPLETED
256 |     assert protocol_run.end_time is not None
257 |     assert protocol_run.duration_ms is not None and protocol_run.duration_ms > 0
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
258 | 
259 |   async def test_list_protocol_runs(
    |
    = help: Break down assertion into multiple parts

tests/services/test_protocols.py:259:13: ANN201 Missing return type annotation for public function `test_list_protocol_runs`
    |
257 |     assert protocol_run.duration_ms is not None and protocol_run.duration_ms > 0
258 | 
259 |   async def test_list_protocol_runs(
    |             ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
260 |     self, db: AsyncSession, protocol_run: ProtocolRunOrm,
261 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:260:29: ARG002 Unused method argument: `protocol_run`
    |
259 |   async def test_list_protocol_runs(
260 |     self, db: AsyncSession, protocol_run: ProtocolRunOrm,
    |                             ^^^^^^^^^^^^ ARG002
261 |   ):
262 |     """Test listing protocol runs with filters."""
    |

tests/services/test_protocols.py:264:5: S101 Use of `assert` detected
    |
262 |     """Test listing protocol runs with filters."""
263 |     pending_runs = await list_protocol_runs(db, status=ProtocolRunStatusEnum.PENDING)
264 |     assert len(pending_runs) >= 1
    |     ^^^^^^ S101
265 | 
266 |     completed_runs = await list_protocol_runs(
    |

tests/services/test_protocols.py:269:5: S101 Use of `assert` detected
    |
267 |       db, status=ProtocolRunStatusEnum.COMPLETED,
268 |     )
269 |     assert len(completed_runs) == 0
    |     ^^^^^^ S101
270 | 
271 |     runs_by_name = await list_protocol_runs(db, protocol_name="TestUpsertProtocol")
    |

tests/services/test_protocols.py:272:5: S101 Use of `assert` detected
    |
271 |     runs_by_name = await list_protocol_runs(db, protocol_name="TestUpsertProtocol")
272 |     assert len(runs_by_name) >= 1
    |     ^^^^^^ S101
    |

tests/services/test_protocols.py:278:13: ANN201 Missing return type annotation for public function `test_log_start_and_end`
    |
276 |   """Tests for logging function calls within a protocol run."""
277 | 
278 |   async def test_log_start_and_end(
    |             ^^^^^^^^^^^^^^^^^^^^^^ ANN201
279 |     self,
280 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:292:5: S101 Use of `assert` detected
    |
290 |       input_args_json=json.dumps({"param1": 10}),
291 |     )
292 |     assert start_log is not None
    |     ^^^^^^ S101
293 |     assert start_log.status == FunctionCallStatusEnum.SUCCESS
294 |     assert start_log.end_time is None
    |

tests/services/test_protocols.py:293:5: S101 Use of `assert` detected
    |
291 |     )
292 |     assert start_log is not None
293 |     assert start_log.status == FunctionCallStatusEnum.SUCCESS
    |     ^^^^^^ S101
294 |     assert start_log.end_time is None
    |

tests/services/test_protocols.py:294:5: S101 Use of `assert` detected
    |
292 |     assert start_log is not None
293 |     assert start_log.status == FunctionCallStatusEnum.SUCCESS
294 |     assert start_log.end_time is None
    |     ^^^^^^ S101
295 | 
296 |     return_val = {"result": "ok"}
    |

tests/services/test_protocols.py:303:5: S101 Use of `assert` detected
    |
301 |       return_value_json=json.dumps(return_val),
302 |     )
303 |     assert end_log is not None
    |     ^^^^^^ S101
304 |     assert end_log.status == FunctionCallStatusEnum.SUCCESS
305 |     assert end_log.end_time is not None
    |

tests/services/test_protocols.py:304:5: S101 Use of `assert` detected
    |
302 |     )
303 |     assert end_log is not None
304 |     assert end_log.status == FunctionCallStatusEnum.SUCCESS
    |     ^^^^^^ S101
305 |     assert end_log.end_time is not None
306 |     assert end_log.return_value_json == return_val
    |

tests/services/test_protocols.py:305:5: S101 Use of `assert` detected
    |
303 |     assert end_log is not None
304 |     assert end_log.status == FunctionCallStatusEnum.SUCCESS
305 |     assert end_log.end_time is not None
    |     ^^^^^^ S101
306 |     assert end_log.return_value_json == return_val
    |

tests/services/test_protocols.py:306:5: S101 Use of `assert` detected
    |
304 |     assert end_log.status == FunctionCallStatusEnum.SUCCESS
305 |     assert end_log.end_time is not None
306 |     assert end_log.return_value_json == return_val
    |     ^^^^^^ S101
307 | 
308 |   async def test_read_function_call_logs_for_run(
    |

tests/services/test_protocols.py:308:13: ANN201 Missing return type annotation for public function `test_read_function_call_logs_for_run`
    |
306 |     assert end_log.return_value_json == return_val
307 | 
308 |   async def test_read_function_call_logs_for_run(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
309 |     self,
310 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_protocols.py:323:5: S101 Use of `assert` detected
    |
322 |     logs = await read_function_call_logs_for_run(db, protocol_run.accession_id)
323 |     assert len(logs) == 2
    |     ^^^^^^ S101
324 |     assert logs[0].sequence_in_run == 1
325 |     assert logs[1].sequence_in_run == 2
    |

tests/services/test_protocols.py:323:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
322 |     logs = await read_function_call_logs_for_run(db, protocol_run.accession_id)
323 |     assert len(logs) == 2
    |                         ^ PLR2004
324 |     assert logs[0].sequence_in_run == 1
325 |     assert logs[1].sequence_in_run == 2
    |

tests/services/test_protocols.py:324:5: S101 Use of `assert` detected
    |
322 |     logs = await read_function_call_logs_for_run(db, protocol_run.accession_id)
323 |     assert len(logs) == 2
324 |     assert logs[0].sequence_in_run == 1
    |     ^^^^^^ S101
325 |     assert logs[1].sequence_in_run == 2
    |

tests/services/test_protocols.py:325:5: S101 Use of `assert` detected
    |
323 |     assert len(logs) == 2
324 |     assert logs[0].sequence_in_run == 1
325 |     assert logs[1].sequence_in_run == 2
    |     ^^^^^^ S101
    |

tests/services/test_protocols.py:325:39: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
323 |     assert len(logs) == 2
324 |     assert logs[0].sequence_in_run == 1
325 |     assert logs[1].sequence_in_run == 2
    |                                       ^ PLR2004
    |

tests/services/test_resource.py:1:1: INP001 File `tests/services/test_resource.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_resource.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/services/resource.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/services/test_resource.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/services/resource.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/services/test_resource.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/services/resource.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/services/test_resource.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/services/test_resource.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/services/test_resource.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/services/test_resource_instance.py:1:1: INP001 File `tests/services/test_resource_instance.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_resource_instance.py:1:1: D100 Missing docstring in public module
tests/services/test_resource_instance.py:83:13: ANN201 Missing return type annotation for public function `test_create_and_read_resource`
   |
81 |   """Test suite for the Resource  service layer."""
82 | 
83 |   async def test_create_and_read_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |     self,
85 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:98:5: S101 Use of `assert` detected
    |
 96 |       properties_json={"color": "blue"},
 97 |     )
 98 |     assert resource is not None
    |     ^^^^^^ S101
 99 |     assert resource.name == name
100 |     assert resource.lot_number == "L123"
    |

tests/services/test_resource_instance.py:99:5: S101 Use of `assert` detected
    |
 97 |     )
 98 |     assert resource is not None
 99 |     assert resource.name == name
    |     ^^^^^^ S101
100 |     assert resource.lot_number == "L123"
101 |     assert resource.properties_json is not None
    |

tests/services/test_resource_instance.py:100:5: S101 Use of `assert` detected
    |
 98 |     assert resource is not None
 99 |     assert resource.name == name
100 |     assert resource.lot_number == "L123"
    |     ^^^^^^ S101
101 |     assert resource.properties_json is not None
102 |     assert resource.properties_json.get("color") == "blue"
    |

tests/services/test_resource_instance.py:101:5: S101 Use of `assert` detected
    |
 99 |     assert resource.name == name
100 |     assert resource.lot_number == "L123"
101 |     assert resource.properties_json is not None
    |     ^^^^^^ S101
102 |     assert resource.properties_json.get("color") == "blue"
    |

tests/services/test_resource_instance.py:102:5: S101 Use of `assert` detected
    |
100 |     assert resource.lot_number == "L123"
101 |     assert resource.properties_json is not None
102 |     assert resource.properties_json.get("color") == "blue"
    |     ^^^^^^ S101
103 | 
104 |     # Read back by ID
    |

tests/services/test_resource_instance.py:106:5: S101 Use of `assert` detected
    |
104 |     # Read back by ID
105 |     read_by_id = await read_resource(db, resource.accession_id)
106 |     assert read_by_id is not None
    |     ^^^^^^ S101
107 |     assert read_by_id.name == name
    |

tests/services/test_resource_instance.py:107:5: S101 Use of `assert` detected
    |
105 |     read_by_id = await read_resource(db, resource.accession_id)
106 |     assert read_by_id is not None
107 |     assert read_by_id.name == name
    |     ^^^^^^ S101
108 | 
109 |     # Read back by name
    |

tests/services/test_resource_instance.py:111:5: S101 Use of `assert` detected
    |
109 |     # Read back by name
110 |     read_by_name = await read_resource_by_name(db, name)
111 |     assert read_by_name is not None
    |     ^^^^^^ S101
112 |     assert read_by_name.accession_id == resource.accession_id
    |

tests/services/test_resource_instance.py:112:5: S101 Use of `assert` detected
    |
110 |     read_by_name = await read_resource_by_name(db, name)
111 |     assert read_by_name is not None
112 |     assert read_by_name.accession_id == resource.accession_id
    |     ^^^^^^ S101
113 | 
114 |   async def test_create_resource_as_new_machine(
    |

tests/services/test_resource_instance.py:114:13: ANN201 Missing return type annotation for public function `test_create_resource_as_new_machine`
    |
112 |     assert read_by_name.accession_id == resource.accession_id
113 | 
114 |   async def test_create_resource_as_new_machine(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
115 |     self,
116 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:130:5: S101 Use of `assert` detected
    |
128 |       machine_name=name,
129 |     )
130 |     assert resource.is_machine is True
    |     ^^^^^^ S101
131 |     assert resource.machine_counterpart is not None
132 |     assert resource.machine_counterpart.name == name
    |

tests/services/test_resource_instance.py:131:5: S101 Use of `assert` detected
    |
129 |     )
130 |     assert resource.is_machine is True
131 |     assert resource.machine_counterpart is not None
    |     ^^^^^^ S101
132 |     assert resource.machine_counterpart.name == name
    |

tests/services/test_resource_instance.py:132:5: S101 Use of `assert` detected
    |
130 |     assert resource.is_machine is True
131 |     assert resource.machine_counterpart is not None
132 |     assert resource.machine_counterpart.name == name
    |     ^^^^^^ S101
133 | 
134 |   async def test_create_resource_fails_with_bad_definition(self, db: AsyncSession):
    |

tests/services/test_resource_instance.py:134:13: ANN201 Missing return type annotation for public function `test_create_resource_fails_with_bad_definition`
    |
132 |     assert resource.machine_counterpart.name == name
133 | 
134 |   async def test_create_resource_fails_with_bad_definition(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
135 |     """Test that creating a resource fails if the definition FQN does not exist."""
136 |     with pytest.raises(ValueError, match="not found in catalog"):
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:144:13: ANN201 Missing return type annotation for public function `test_update_resource_instance`
    |
142 |       )
143 | 
144 |   async def test_update_resource_instance(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
145 |     self,
146 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:156:5: S101 Use of `assert` detected
    |
154 |       physical_location_description="Shelf A",
155 |     )
156 |     assert updated_resource is not None
    |     ^^^^^^ S101
157 |     assert updated_resource.lot_number == "L456"
158 |     assert updated_resource.physical_location_description == "Shelf A"
    |

tests/services/test_resource_instance.py:157:5: S101 Use of `assert` detected
    |
155 |     )
156 |     assert updated_resource is not None
157 |     assert updated_resource.lot_number == "L456"
    |     ^^^^^^ S101
158 |     assert updated_resource.physical_location_description == "Shelf A"
    |

tests/services/test_resource_instance.py:158:5: S101 Use of `assert` detected
    |
156 |     assert updated_resource is not None
157 |     assert updated_resource.lot_number == "L456"
158 |     assert updated_resource.physical_location_description == "Shelf A"
    |     ^^^^^^ S101
159 | 
160 |   async def test_read_resources_with_filters(
    |

tests/services/test_resource_instance.py:160:13: ANN201 Missing return type annotation for public function `test_read_resources_with_filters`
    |
158 |     assert updated_resource.physical_location_description == "Shelf A"
159 | 
160 |   async def test_read_resources_with_filters(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
161 |     self,
162 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:164:5: ARG002 Unused method argument: `machine`
    |
162 |     db: AsyncSession,
163 |     resource_def: ResourceDefinitionOrm,
164 |     machine: MachineOrm,
    |     ^^^^^^^ ARG002
165 |   ):
166 |     """Test filtering capabilities of the read_resources function."""
    |

tests/services/test_resource_instance.py:190:5: S101 Use of `assert` detected
    |
188 |       status=ResourceStatusEnum.IN_USE,
189 |     )
190 |     assert len(in_use_resources) == 1
    |     ^^^^^^ S101
191 |     assert in_use_resources[0].current_status == ResourceStatusEnum.IN_USE
    |

tests/services/test_resource_instance.py:191:5: S101 Use of `assert` detected
    |
189 |     )
190 |     assert len(in_use_resources) == 1
191 |     assert in_use_resources[0].current_status == ResourceStatusEnum.IN_USE
    |     ^^^^^^ S101
192 | 
193 |     # Filter by FQN
    |

tests/services/test_resource_instance.py:195:5: S101 Use of `assert` detected
    |
193 |     # Filter by FQN
194 |     by_fqn = await read_resources(db, fqn=resource_def.fqn)
195 |     assert len(by_fqn) >= 2
    |     ^^^^^^ S101
196 | 
197 |     # Filter by properties
    |

tests/services/test_resource_instance.py:195:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
193 |     # Filter by FQN
194 |     by_fqn = await read_resources(db, fqn=resource_def.fqn)
195 |     assert len(by_fqn) >= 2
    |                           ^ PLR2004
196 | 
197 |     # Filter by properties
    |

tests/services/test_resource_instance.py:199:5: S101 Use of `assert` detected
    |
197 |     # Filter by properties
198 |     assay_plates = await read_resources(db, property_filters={"type": "assay"})
199 |     assert len(assay_plates) == 1
    |     ^^^^^^ S101
200 |     assert assay_plates[0].properties_json is not None
201 |     assert assay_plates[0].properties_json.get("type") == "assay"
    |

tests/services/test_resource_instance.py:200:5: S101 Use of `assert` detected
    |
198 |     assay_plates = await read_resources(db, property_filters={"type": "assay"})
199 |     assert len(assay_plates) == 1
200 |     assert assay_plates[0].properties_json is not None
    |     ^^^^^^ S101
201 |     assert assay_plates[0].properties_json.get("type") == "assay"
    |

tests/services/test_resource_instance.py:201:5: S101 Use of `assert` detected
    |
199 |     assert len(assay_plates) == 1
200 |     assert assay_plates[0].properties_json is not None
201 |     assert assay_plates[0].properties_json.get("type") == "assay"
    |     ^^^^^^ S101
202 | 
203 |   async def test_update_resource_location_and_status(
    |

tests/services/test_resource_instance.py:203:13: ANN201 Missing return type annotation for public function `test_update_resource_location_and_status`
    |
201 |     assert assay_plates[0].properties_json.get("type") == "assay"
202 | 
203 |   async def test_update_resource_location_and_status(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
204 |     self,
205 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:211:5: S101 Use of `assert` detected
    |
209 |   ):
210 |     """Test the dedicated function for updating location, status, and properties."""
211 |     assert existing_resource.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
    |     ^^^^^^ S101
212 |     assert existing_resource.properties_json is None
    |

tests/services/test_resource_instance.py:212:5: S101 Use of `assert` detected
    |
210 |     """Test the dedicated function for updating location, status, and properties."""
211 |     assert existing_resource.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
212 |     assert existing_resource.properties_json is None
    |     ^^^^^^ S101
213 | 
214 |     # Move to machine, set to IN_USE, and update properties
    |

tests/services/test_resource_instance.py:225:5: S101 Use of `assert` detected
    |
223 |     )
224 | 
225 |     assert updated_resource is not None
    |     ^^^^^^ S101
226 |     assert updated_resource.current_status == ResourceStatusEnum.IN_USE
227 |     assert updated_resource.location_machine_accession_id == machine.accession_id
    |

tests/services/test_resource_instance.py:226:5: S101 Use of `assert` detected
    |
225 |     assert updated_resource is not None
226 |     assert updated_resource.current_status == ResourceStatusEnum.IN_USE
    |     ^^^^^^ S101
227 |     assert updated_resource.location_machine_accession_id == machine.accession_id
228 |     assert updated_resource.current_deck_position_name == "A1"
    |

tests/services/test_resource_instance.py:227:5: S101 Use of `assert` detected
    |
225 |     assert updated_resource is not None
226 |     assert updated_resource.current_status == ResourceStatusEnum.IN_USE
227 |     assert updated_resource.location_machine_accession_id == machine.accession_id
    |     ^^^^^^ S101
228 |     assert updated_resource.current_deck_position_name == "A1"
229 |     assert updated_resource.properties_json is not None
    |

tests/services/test_resource_instance.py:228:5: S101 Use of `assert` detected
    |
226 |     assert updated_resource.current_status == ResourceStatusEnum.IN_USE
227 |     assert updated_resource.location_machine_accession_id == machine.accession_id
228 |     assert updated_resource.current_deck_position_name == "A1"
    |     ^^^^^^ S101
229 |     assert updated_resource.properties_json is not None
230 |     assert updated_resource.properties_json["content"] == "reagent_X"
    |

tests/services/test_resource_instance.py:229:5: S101 Use of `assert` detected
    |
227 |     assert updated_resource.location_machine_accession_id == machine.accession_id
228 |     assert updated_resource.current_deck_position_name == "A1"
229 |     assert updated_resource.properties_json is not None
    |     ^^^^^^ S101
230 |     assert updated_resource.properties_json["content"] == "reagent_X"
231 |     assert updated_resource.current_protocol_run_accession_id == protocol_run.run_accession_id
    |

tests/services/test_resource_instance.py:230:5: S101 Use of `assert` detected
    |
228 |     assert updated_resource.current_deck_position_name == "A1"
229 |     assert updated_resource.properties_json is not None
230 |     assert updated_resource.properties_json["content"] == "reagent_X"
    |     ^^^^^^ S101
231 |     assert updated_resource.current_protocol_run_accession_id == protocol_run.run_accession_id
    |

tests/services/test_resource_instance.py:231:5: S101 Use of `assert` detected
    |
229 |     assert updated_resource.properties_json is not None
230 |     assert updated_resource.properties_json["content"] == "reagent_X"
231 |     assert updated_resource.current_protocol_run_accession_id == protocol_run.run_accession_id
    |     ^^^^^^ S101
232 | 
233 |     # Now, move it back to storage and merge properties
    |

tests/services/test_resource_instance.py:244:5: S101 Use of `assert` detected
    |
242 |     )
243 | 
244 |     assert back_to_storage is not None
    |     ^^^^^^ S101
245 |     assert back_to_storage.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
246 |     assert back_to_storage.location_machine_accession_id is None
    |

tests/services/test_resource_instance.py:245:5: S101 Use of `assert` detected
    |
244 |     assert back_to_storage is not None
245 |     assert back_to_storage.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
    |     ^^^^^^ S101
246 |     assert back_to_storage.location_machine_accession_id is None
247 |     assert back_to_storage.current_protocol_run_accession_id is None
    |

tests/services/test_resource_instance.py:246:5: S101 Use of `assert` detected
    |
244 |     assert back_to_storage is not None
245 |     assert back_to_storage.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
246 |     assert back_to_storage.location_machine_accession_id is None
    |     ^^^^^^ S101
247 |     assert back_to_storage.current_protocol_run_accession_id is None
248 |     assert back_to_storage.properties_json is not None
    |

tests/services/test_resource_instance.py:247:5: S101 Use of `assert` detected
    |
245 |     assert back_to_storage.current_status == ResourceStatusEnum.AVAILABLE_IN_STORAGE
246 |     assert back_to_storage.location_machine_accession_id is None
247 |     assert back_to_storage.current_protocol_run_accession_id is None
    |     ^^^^^^ S101
248 |     assert back_to_storage.properties_json is not None
249 |     assert back_to_storage.properties_json["content"] == "reagent_X"
    |

tests/services/test_resource_instance.py:248:5: S101 Use of `assert` detected
    |
246 |     assert back_to_storage.location_machine_accession_id is None
247 |     assert back_to_storage.current_protocol_run_accession_id is None
248 |     assert back_to_storage.properties_json is not None
    |     ^^^^^^ S101
249 |     assert back_to_storage.properties_json["content"] == "reagent_X"
250 |     assert back_to_storage.properties_json["concentration"] == "10mM"
    |

tests/services/test_resource_instance.py:249:5: S101 Use of `assert` detected
    |
247 |     assert back_to_storage.current_protocol_run_accession_id is None
248 |     assert back_to_storage.properties_json is not None
249 |     assert back_to_storage.properties_json["content"] == "reagent_X"
    |     ^^^^^^ S101
250 |     assert back_to_storage.properties_json["concentration"] == "10mM"
    |

tests/services/test_resource_instance.py:250:5: S101 Use of `assert` detected
    |
248 |     assert back_to_storage.properties_json is not None
249 |     assert back_to_storage.properties_json["content"] == "reagent_X"
250 |     assert back_to_storage.properties_json["concentration"] == "10mM"
    |     ^^^^^^ S101
251 | 
252 |   async def test_delete_resource_instance(
    |

tests/services/test_resource_instance.py:252:13: ANN201 Missing return type annotation for public function `test_delete_resource_instance`
    |
250 |     assert back_to_storage.properties_json["concentration"] == "10mM"
251 | 
252 |   async def test_delete_resource_instance(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
253 |     self,
254 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_instance.py:261:5: S101 Use of `assert` detected
    |
259 |     resource_id = existing_resource.accession_id
260 |     result = await delete_resource_instance(db, resource_id)
261 |     assert result is True
    |     ^^^^^^ S101
262 |     assert await read_resource(db, resource_id) is None
    |

tests/services/test_resource_instance.py:262:5: S101 Use of `assert` detected
    |
260 |     result = await delete_resource_instance(db, resource_id)
261 |     assert result is True
262 |     assert await read_resource(db, resource_id) is None
    |     ^^^^^^ S101
    |

tests/services/test_resource_type_definition.py:1:1: INP001 File `tests/services/test_resource_type_definition.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_resource_type_definition.py:1:1: D100 Missing docstring in public module
tests/services/test_resource_type_definition.py:44:13: ANN201 Missing return type annotation for public function `test_create_and_read_resource_definition`
   |
42 |   """Test suite for the Resource Definition service layer."""
43 | 
44 |   async def test_create_and_read_resource_definition(self, db: AsyncSession):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
45 |     """Test creating a resource definition and reading it back by name and FQN."""
46 |     name = f"plate_96_deep_well_{uuid.uuid4()}"
   |
   = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:59:5: S101 Use of `assert` detected
   |
57 |       nominal_volume_ul=2000.0,
58 |     )
59 |     assert created_def is not None
   |     ^^^^^^ S101
60 |     assert created_def.name == name
61 |     assert created_def.manufacturer == "Corning"
   |

tests/services/test_resource_type_definition.py:60:5: S101 Use of `assert` detected
   |
58 |     )
59 |     assert created_def is not None
60 |     assert created_def.name == name
   |     ^^^^^^ S101
61 |     assert created_def.manufacturer == "Corning"
   |

tests/services/test_resource_type_definition.py:61:5: S101 Use of `assert` detected
   |
59 |     assert created_def is not None
60 |     assert created_def.name == name
61 |     assert created_def.manufacturer == "Corning"
   |     ^^^^^^ S101
62 | 
63 |     # Test reading by name
   |

tests/services/test_resource_type_definition.py:65:5: S101 Use of `assert` detected
   |
63 |     # Test reading by name
64 |     read_by_name = await read_resource_definition(db, name)
65 |     assert read_by_name is not None
   |     ^^^^^^ S101
66 |     assert read_by_name.accession_id == created_def.accession_id
   |

tests/services/test_resource_type_definition.py:66:5: S101 Use of `assert` detected
   |
64 |     read_by_name = await read_resource_definition(db, name)
65 |     assert read_by_name is not None
66 |     assert read_by_name.accession_id == created_def.accession_id
   |     ^^^^^^ S101
67 | 
68 |     # Test reading by FQN
   |

tests/services/test_resource_type_definition.py:70:5: S101 Use of `assert` detected
   |
68 |     # Test reading by FQN
69 |     read_by_fqn = await read_resource_definition_by_fqn(db, fqn)
70 |     assert read_by_fqn is not None
   |     ^^^^^^ S101
71 |     assert read_by_fqn.accession_id == created_def.accession_id
   |

tests/services/test_resource_type_definition.py:71:5: S101 Use of `assert` detected
   |
69 |     read_by_fqn = await read_resource_definition_by_fqn(db, fqn)
70 |     assert read_by_fqn is not None
71 |     assert read_by_fqn.accession_id == created_def.accession_id
   |     ^^^^^^ S101
72 | 
73 |   async def test_create_definition_fails_on_duplicate_name(
   |

tests/services/test_resource_type_definition.py:73:13: ANN201 Missing return type annotation for public function `test_create_definition_fails_on_duplicate_name`
   |
71 |     assert read_by_fqn.accession_id == created_def.accession_id
72 | 
73 |   async def test_create_definition_fails_on_duplicate_name(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |     self,
75 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:86:13: ANN201 Missing return type annotation for public function `test_update_resource_definition`
   |
84 |       )
85 | 
86 |   async def test_update_resource_definition(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
87 |     self,
88 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:103:5: S101 Use of `assert` detected
    |
101 |     )
102 | 
103 |     assert updated_def is not None
    |     ^^^^^^ S101
104 |     assert updated_def.accession_id == existing_def.accession_id
105 |     assert updated_def.description == new_description
    |

tests/services/test_resource_type_definition.py:104:5: S101 Use of `assert` detected
    |
103 |     assert updated_def is not None
104 |     assert updated_def.accession_id == existing_def.accession_id
    |     ^^^^^^ S101
105 |     assert updated_def.description == new_description
106 |     assert updated_def.is_consumable is False
    |

tests/services/test_resource_type_definition.py:105:5: S101 Use of `assert` detected
    |
103 |     assert updated_def is not None
104 |     assert updated_def.accession_id == existing_def.accession_id
105 |     assert updated_def.description == new_description
    |     ^^^^^^ S101
106 |     assert updated_def.is_consumable is False
107 |     assert updated_def.plr_definition_details_json is not None
    |

tests/services/test_resource_type_definition.py:106:5: S101 Use of `assert` detected
    |
104 |     assert updated_def.accession_id == existing_def.accession_id
105 |     assert updated_def.description == new_description
106 |     assert updated_def.is_consumable is False
    |     ^^^^^^ S101
107 |     assert updated_def.plr_definition_details_json is not None
108 |     assert updated_def.plr_definition_details_json.get("tip_length") == 95.5
    |

tests/services/test_resource_type_definition.py:107:5: S101 Use of `assert` detected
    |
105 |     assert updated_def.description == new_description
106 |     assert updated_def.is_consumable is False
107 |     assert updated_def.plr_definition_details_json is not None
    |     ^^^^^^ S101
108 |     assert updated_def.plr_definition_details_json.get("tip_length") == 95.5
    |

tests/services/test_resource_type_definition.py:108:5: S101 Use of `assert` detected
    |
106 |     assert updated_def.is_consumable is False
107 |     assert updated_def.plr_definition_details_json is not None
108 |     assert updated_def.plr_definition_details_json.get("tip_length") == 95.5
    |     ^^^^^^ S101
109 | 
110 |   async def test_update_non_existent_definition_fails(self, db: AsyncSession):
    |

tests/services/test_resource_type_definition.py:108:73: PLR2004 Magic value used in comparison, consider replacing `95.5` with a constant variable
    |
106 |     assert updated_def.is_consumable is False
107 |     assert updated_def.plr_definition_details_json is not None
108 |     assert updated_def.plr_definition_details_json.get("tip_length") == 95.5
    |                                                                         ^^^^ PLR2004
109 | 
110 |   async def test_update_non_existent_definition_fails(self, db: AsyncSession):
    |

tests/services/test_resource_type_definition.py:110:13: ANN201 Missing return type annotation for public function `test_update_non_existent_definition_fails`
    |
108 |     assert updated_def.plr_definition_details_json.get("tip_length") == 95.5
109 | 
110 |   async def test_update_non_existent_definition_fails(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
111 |     """Test that updating a non-existent definition raises ValueError."""
112 |     with pytest.raises(ValueError, match="not found for update"):
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:119:13: ANN201 Missing return type annotation for public function `test_read_resources_definitions_with_filters`
    |
117 |       )
118 | 
119 |   async def test_read_resources_definitions_with_filters(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
120 |     self,
121 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:136:5: S101 Use of `assert` detected
    |
134 |     # Filter by manufacturer (case-insensitive partial)
135 |     praxis_defs = await read_resources_definitions(db, manufacturer="praxistest")
136 |     assert len(praxis_defs) == 1
    |     ^^^^^^ S101
137 |     assert praxis_defs[0].name == existing_def.name
    |

tests/services/test_resource_type_definition.py:137:5: S101 Use of `assert` detected
    |
135 |     praxis_defs = await read_resources_definitions(db, manufacturer="praxistest")
136 |     assert len(praxis_defs) == 1
137 |     assert praxis_defs[0].name == existing_def.name
    |     ^^^^^^ S101
138 | 
139 |     # Filter by is_consumable=True
    |

tests/services/test_resource_type_definition.py:141:5: S101 Use of `assert` detected
    |
139 |     # Filter by is_consumable=True
140 |     consumables = await read_resources_definitions(db, is_consumable=True)
141 |     assert len(consumables) == 1
    |     ^^^^^^ S101
142 |     assert consumables[0].is_consumable is True
    |

tests/services/test_resource_type_definition.py:142:5: S101 Use of `assert` detected
    |
140 |     consumables = await read_resources_definitions(db, is_consumable=True)
141 |     assert len(consumables) == 1
142 |     assert consumables[0].is_consumable is True
    |     ^^^^^^ S101
143 | 
144 |     # Filter by is_consumable=False
    |

tests/services/test_resource_type_definition.py:146:5: S101 Use of `assert` detected
    |
144 |     # Filter by is_consumable=False
145 |     non_consumables = await read_resources_definitions(db, is_consumable=False)
146 |     assert len(non_consumables) == 1
    |     ^^^^^^ S101
147 |     assert non_consumables[0].manufacturer == "Axygen"
    |

tests/services/test_resource_type_definition.py:147:5: S101 Use of `assert` detected
    |
145 |     non_consumables = await read_resources_definitions(db, is_consumable=False)
146 |     assert len(non_consumables) == 1
147 |     assert non_consumables[0].manufacturer == "Axygen"
    |     ^^^^^^ S101
148 | 
149 |     # Test pagination
    |

tests/services/test_resource_type_definition.py:151:5: S101 Use of `assert` detected
    |
149 |     # Test pagination
150 |     all_defs = await read_resources_definitions(db, limit=1)
151 |     assert len(all_defs) == 1
    |     ^^^^^^ S101
152 | 
153 |   async def test_delete_resource_definition_success(self, db: AsyncSession):
    |

tests/services/test_resource_type_definition.py:153:13: ANN201 Missing return type annotation for public function `test_delete_resource_definition_success`
    |
151 |     assert len(all_defs) == 1
152 | 
153 |   async def test_delete_resource_definition_success(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
154 |     """Test successfully deleting an unused resource definition."""
155 |     def_to_delete = await create_resource_definition(
    |
    = help: Add return type annotation: `None`

tests/services/test_resource_type_definition.py:162:5: S101 Use of `assert` detected
    |
161 |     result = await delete_resource_definition(db, def_to_delete.name)
162 |     assert result is True
    |     ^^^^^^ S101
163 | 
164 |     # Verify it's gone
    |

tests/services/test_resource_type_definition.py:165:5: S101 Use of `assert` detected
    |
164 |     # Verify it's gone
165 |     assert await read_resource_definition(db, def_to_delete.name) is None
    |     ^^^^^^ S101
166 | 
167 |   async def test_delete_resource_definition_fails_if_in_use(
    |

tests/services/test_resource_type_definition.py:167:13: ANN201 Missing return type annotation for public function `test_delete_resource_definition_fails_if_in_use`
    |
165 |     assert await read_resource_definition(db, def_to_delete.name) is None
166 | 
167 |   async def test_delete_resource_definition_fails_if_in_use(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
168 |     self,
169 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:1:1: INP001 File `tests/services/test_scheduler.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_scheduler.py:1:1: D100 Missing docstring in public module
tests/services/test_scheduler.py:60:13: ANN201 Missing return type annotation for public function `test_create_and_read_schedule_entry`
   |
58 |   """Tests for schedule entry management."""
59 | 
60 |   async def test_create_and_read_schedule_entry(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
61 |     self, db: AsyncSession, protocol_run: ProtocolRunOrm,
62 |   ):
   |
   = help: Add return type annotation: `None`

tests/services/test_scheduler.py:67:5: S101 Use of `assert` detected
   |
65 |       db, protocol_run_accession_id=protocol_run.accession_id, priority=10,
66 |     )
67 |     assert entry.protocol_run_accession_id == protocol_run.accession_id
   |     ^^^^^^ S101
68 |     assert entry.status == ScheduleStatusEnum.QUEUED
69 |     assert entry.priority == 10
   |

tests/services/test_scheduler.py:68:5: S101 Use of `assert` detected
   |
66 |     )
67 |     assert entry.protocol_run_accession_id == protocol_run.accession_id
68 |     assert entry.status == ScheduleStatusEnum.QUEUED
   |     ^^^^^^ S101
69 |     assert entry.priority == 10
   |

tests/services/test_scheduler.py:69:5: S101 Use of `assert` detected
   |
67 |     assert entry.protocol_run_accession_id == protocol_run.accession_id
68 |     assert entry.status == ScheduleStatusEnum.QUEUED
69 |     assert entry.priority == 10
   |     ^^^^^^ S101
70 | 
71 |     # Test read by ID
   |

tests/services/test_scheduler.py:69:30: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
67 |     assert entry.protocol_run_accession_id == protocol_run.accession_id
68 |     assert entry.status == ScheduleStatusEnum.QUEUED
69 |     assert entry.priority == 10
   |                              ^^ PLR2004
70 | 
71 |     # Test read by ID
   |

tests/services/test_scheduler.py:73:5: S101 Use of `assert` detected
   |
71 |     # Test read by ID
72 |     read_by_id = await read_schedule_entry(db, entry.accession_id)
73 |     assert read_by_id is not None
   |     ^^^^^^ S101
74 |     assert read_by_id.priority == 10
   |

tests/services/test_scheduler.py:74:5: S101 Use of `assert` detected
   |
72 |     read_by_id = await read_schedule_entry(db, entry.accession_id)
73 |     assert read_by_id is not None
74 |     assert read_by_id.priority == 10
   |     ^^^^^^ S101
75 | 
76 |     # Test read by protocol run ID
   |

tests/services/test_scheduler.py:74:35: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
72 |     read_by_id = await read_schedule_entry(db, entry.accession_id)
73 |     assert read_by_id is not None
74 |     assert read_by_id.priority == 10
   |                                   ^^ PLR2004
75 | 
76 |     # Test read by protocol run ID
   |

tests/services/test_scheduler.py:80:5: S101 Use of `assert` detected
   |
78 |       db, protocol_run.accession_id,
79 |     )
80 |     assert read_by_run is not None
   |     ^^^^^^ S101
81 |     assert read_by_run.accession_id == entry.accession_id
   |

tests/services/test_scheduler.py:81:5: S101 Use of `assert` detected
   |
79 |     )
80 |     assert read_by_run is not None
81 |     assert read_by_run.accession_id == entry.accession_id
   |     ^^^^^^ S101
82 | 
83 |   async def test_create_duplicate_schedule_entry_fails(
   |

tests/services/test_scheduler.py:83:13: ANN201 Missing return type annotation for public function `test_create_duplicate_schedule_entry_fails`
   |
81 |     assert read_by_run.accession_id == entry.accession_id
82 | 
83 |   async def test_create_duplicate_schedule_entry_fails(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
85 |   ):
   |
   = help: Add return type annotation: `None`

tests/services/test_scheduler.py:90:13: ANN201 Missing return type annotation for public function `test_update_schedule_entry_status`
   |
88 |       await create_schedule_entry(db, schedule_entry.protocol_run_accession_id)
89 | 
90 |   async def test_update_schedule_entry_status(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
91 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
92 |   ):
   |
   = help: Add return type annotation: `None`

tests/services/test_scheduler.py:97:5: S101 Use of `assert` detected
   |
95 |       db, schedule_entry.accession_id, new_status=ScheduleStatusEnum.RUNNING,
96 |     )
97 |     assert updated_entry is not None
   |     ^^^^^^ S101
98 |     assert updated_entry.status == ScheduleStatusEnum.RUNNING
   |

tests/services/test_scheduler.py:98:5: S101 Use of `assert` detected
    |
 96 |     )
 97 |     assert updated_entry is not None
 98 |     assert updated_entry.status == ScheduleStatusEnum.RUNNING
    |     ^^^^^^ S101
 99 | 
100 |   async def test_list_schedule_entries_with_filters(
    |

tests/services/test_scheduler.py:100:13: ANN201 Missing return type annotation for public function `test_list_schedule_entries_with_filters`
    |
 98 |     assert updated_entry.status == ScheduleStatusEnum.RUNNING
 99 | 
100 |   async def test_list_schedule_entries_with_filters(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
101 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
102 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:112:5: S101 Use of `assert` detected
    |
110 |     # Filter by priority
111 |     high_prio_entries = await list_schedule_entries(db, priority_min=5)
112 |     assert len(high_prio_entries) == 1
    |     ^^^^^^ S101
113 |     assert high_prio_entries[0].accession_id == schedule_entry.accession_id
    |

tests/services/test_scheduler.py:113:5: S101 Use of `assert` detected
    |
111 |     high_prio_entries = await list_schedule_entries(db, priority_min=5)
112 |     assert len(high_prio_entries) == 1
113 |     assert high_prio_entries[0].accession_id == schedule_entry.accession_id
    |     ^^^^^^ S101
114 | 
115 |     # Test ordering
    |

tests/services/test_scheduler.py:119:5: S101 Use of `assert` detected
    |
117 |       db, order_by="priority", order_desc=False,
118 |     )
119 |     assert len(all_entries_prio_asc) == 2
    |     ^^^^^^ S101
120 |     assert all_entries_prio_asc[0].priority == 1
121 |     assert all_entries_prio_asc[1].priority == 5
    |

tests/services/test_scheduler.py:119:41: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
117 |       db, order_by="priority", order_desc=False,
118 |     )
119 |     assert len(all_entries_prio_asc) == 2
    |                                         ^ PLR2004
120 |     assert all_entries_prio_asc[0].priority == 1
121 |     assert all_entries_prio_asc[1].priority == 5
    |

tests/services/test_scheduler.py:120:5: S101 Use of `assert` detected
    |
118 |     )
119 |     assert len(all_entries_prio_asc) == 2
120 |     assert all_entries_prio_asc[0].priority == 1
    |     ^^^^^^ S101
121 |     assert all_entries_prio_asc[1].priority == 5
    |

tests/services/test_scheduler.py:121:5: S101 Use of `assert` detected
    |
119 |     assert len(all_entries_prio_asc) == 2
120 |     assert all_entries_prio_asc[0].priority == 1
121 |     assert all_entries_prio_asc[1].priority == 5
    |     ^^^^^^ S101
122 | 
123 |   async def test_delete_schedule_entry(
    |

tests/services/test_scheduler.py:121:48: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
119 |     assert len(all_entries_prio_asc) == 2
120 |     assert all_entries_prio_asc[0].priority == 1
121 |     assert all_entries_prio_asc[1].priority == 5
    |                                                ^ PLR2004
122 | 
123 |   async def test_delete_schedule_entry(
    |

tests/services/test_scheduler.py:123:13: ANN201 Missing return type annotation for public function `test_delete_schedule_entry`
    |
121 |     assert all_entries_prio_asc[1].priority == 5
122 | 
123 |   async def test_delete_schedule_entry(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
124 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
125 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:129:5: S101 Use of `assert` detected
    |
127 |     entry_id = schedule_entry.accession_id
128 |     result = await delete_schedule_entry(db, entry_id)
129 |     assert result is True
    |     ^^^^^^ S101
130 |     assert await read_schedule_entry(db, entry_id) is None
    |

tests/services/test_scheduler.py:130:5: S101 Use of `assert` detected
    |
128 |     result = await delete_schedule_entry(db, entry_id)
129 |     assert result is True
130 |     assert await read_schedule_entry(db, entry_id) is None
    |     ^^^^^^ S101
    |

tests/services/test_scheduler.py:136:13: ANN201 Missing return type annotation for public function `test_create_and_read_asset_reservation`
    |
134 |   """Tests for asset reservation management."""
135 | 
136 |   async def test_create_and_read_asset_reservation(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
137 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
138 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:146:5: S101 Use of `assert` detected
    |
144 |       asset_name="Hamilton_STAR_1",
145 |     )
146 |     assert reservation.schedule_entry_accession_id == schedule_entry.accession_id
    |     ^^^^^^ S101
147 |     assert reservation.status == AssetReservationStatusEnum.PENDING
    |

tests/services/test_scheduler.py:147:5: S101 Use of `assert` detected
    |
145 |     )
146 |     assert reservation.schedule_entry_accession_id == schedule_entry.accession_id
147 |     assert reservation.status == AssetReservationStatusEnum.PENDING
    |     ^^^^^^ S101
148 | 
149 |     read_res = await read_asset_reservation(db, reservation.accession_id)
    |

tests/services/test_scheduler.py:150:5: S101 Use of `assert` detected
    |
149 |     read_res = await read_asset_reservation(db, reservation.accession_id)
150 |     assert read_res is not None
    |     ^^^^^^ S101
151 |     assert read_res.asset_name == "Hamilton_STAR_1"
    |

tests/services/test_scheduler.py:151:5: S101 Use of `assert` detected
    |
149 |     read_res = await read_asset_reservation(db, reservation.accession_id)
150 |     assert read_res is not None
151 |     assert read_res.asset_name == "Hamilton_STAR_1"
    |     ^^^^^^ S101
152 | 
153 |   async def test_update_asset_reservation_status(
    |

tests/services/test_scheduler.py:153:13: ANN201 Missing return type annotation for public function `test_update_asset_reservation_status`
    |
151 |     assert read_res.asset_name == "Hamilton_STAR_1"
152 | 
153 |   async def test_update_asset_reservation_status(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
154 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
155 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:163:5: S101 Use of `assert` detected
    |
161 |       db, reservation.accession_id, new_status=AssetReservationStatusEnum.RESERVED,
162 |     )
163 |     assert updated_res is not None
    |     ^^^^^^ S101
164 |     assert updated_res.status == AssetReservationStatusEnum.RESERVED
    |

tests/services/test_scheduler.py:164:5: S101 Use of `assert` detected
    |
162 |     )
163 |     assert updated_res is not None
164 |     assert updated_res.status == AssetReservationStatusEnum.RESERVED
    |     ^^^^^^ S101
165 | 
166 |   async def test_cleanup_expired_reservations(
    |

tests/services/test_scheduler.py:166:13: ANN201 Missing return type annotation for public function `test_cleanup_expired_reservations`
    |
164 |     assert updated_res.status == AssetReservationStatusEnum.RESERVED
165 | 
166 |   async def test_cleanup_expired_reservations(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
167 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
168 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:190:5: S101 Use of `assert` detected
    |
188 |     cleaned_count = await cleanup_expired_reservations(db)
189 |     await db.commit()
190 |     assert cleaned_count == 1
    |     ^^^^^^ S101
191 | 
192 |     reservations = await list_asset_reservations(
    |

tests/services/test_scheduler.py:199:9: S101 Use of `assert` detected
    |
197 |     for res in reservations:
198 |       if res.asset_name == "asset1":
199 |         assert res.status == AssetReservationStatusEnum.EXPIRED
    |         ^^^^^^ S101
200 |         expired_found = True
201 |       elif res.asset_name == "asset2":
    |

tests/services/test_scheduler.py:202:9: S101 Use of `assert` detected
    |
200 |         expired_found = True
201 |       elif res.asset_name == "asset2":
202 |         assert res.status == AssetReservationStatusEnum.PENDING
    |         ^^^^^^ S101
203 |         active_found = True
204 |     assert expired_found and active_found
    |

tests/services/test_scheduler.py:204:5: S101 Use of `assert` detected
    |
202 |         assert res.status == AssetReservationStatusEnum.PENDING
203 |         active_found = True
204 |     assert expired_found and active_found
    |     ^^^^^^ S101
    |

tests/services/test_scheduler.py:204:5: PT018 Assertion should be broken down into multiple parts
    |
202 |         assert res.status == AssetReservationStatusEnum.PENDING
203 |         active_found = True
204 |     assert expired_found and active_found
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PT018
    |
    = help: Break down assertion into multiple parts

tests/services/test_scheduler.py:210:13: ANN201 Missing return type annotation for public function `test_log_schedule_event_and_get_history`
    |
208 |   """Tests for schedule history and metrics."""
209 | 
210 |   async def test_log_schedule_event_and_get_history(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
211 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
212 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:221:5: S101 Use of `assert` detected
    |
220 |     history = await get_schedule_history(db, schedule_entry.accession_id)
221 |     assert len(history) == 2
    |     ^^^^^^ S101
222 |     # Check ordering (most recent first)
223 |     assert history[0].event_type == "TEST_EVENT"
    |

tests/services/test_scheduler.py:221:28: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
220 |     history = await get_schedule_history(db, schedule_entry.accession_id)
221 |     assert len(history) == 2
    |                            ^ PLR2004
222 |     # Check ordering (most recent first)
223 |     assert history[0].event_type == "TEST_EVENT"
    |

tests/services/test_scheduler.py:223:5: S101 Use of `assert` detected
    |
221 |     assert len(history) == 2
222 |     # Check ordering (most recent first)
223 |     assert history[0].event_type == "TEST_EVENT"
    |     ^^^^^^ S101
224 |     assert history[1].event_type == "SCHEDULE_CREATED"
    |

tests/services/test_scheduler.py:224:5: S101 Use of `assert` detected
    |
222 |     # Check ordering (most recent first)
223 |     assert history[0].event_type == "TEST_EVENT"
224 |     assert history[1].event_type == "SCHEDULE_CREATED"
    |     ^^^^^^ S101
225 | 
226 |   async def test_get_scheduling_metrics(
    |

tests/services/test_scheduler.py:226:13: ANN201 Missing return type annotation for public function `test_get_scheduling_metrics`
    |
224 |     assert history[1].event_type == "SCHEDULE_CREATED"
225 | 
226 |   async def test_get_scheduling_metrics(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
227 |     self, db: AsyncSession, schedule_entry: ScheduleEntryOrm,
228 |   ):
    |
    = help: Add return type annotation: `None`

tests/services/test_scheduler.py:251:5: S101 Use of `assert` detected
    |
249 |     metrics = await get_scheduling_metrics(db, start_time, end_time)
250 | 
251 |     assert metrics is not None
    |     ^^^^^^ S101
252 |     # status_counts includes the initial create, plus the 2 updates
253 |     assert metrics["status_counts"]["QUEUED"] == 1
    |

tests/services/test_scheduler.py:253:5: S101 Use of `assert` detected
    |
251 |     assert metrics is not None
252 |     # status_counts includes the initial create, plus the 2 updates
253 |     assert metrics["status_counts"]["QUEUED"] == 1
    |     ^^^^^^ S101
254 |     assert metrics["status_counts"]["DISPATCHED"] == 1
255 |     assert metrics["status_counts"]["FAILED"] == 1
    |

tests/services/test_scheduler.py:254:5: S101 Use of `assert` detected
    |
252 |     # status_counts includes the initial create, plus the 2 updates
253 |     assert metrics["status_counts"]["QUEUED"] == 1
254 |     assert metrics["status_counts"]["DISPATCHED"] == 1
    |     ^^^^^^ S101
255 |     assert metrics["status_counts"]["FAILED"] == 1
256 |     assert metrics["total_events"] == 3
    |

tests/services/test_scheduler.py:255:5: S101 Use of `assert` detected
    |
253 |     assert metrics["status_counts"]["QUEUED"] == 1
254 |     assert metrics["status_counts"]["DISPATCHED"] == 1
255 |     assert metrics["status_counts"]["FAILED"] == 1
    |     ^^^^^^ S101
256 |     assert metrics["total_events"] == 3
257 |     assert metrics["error_count"] == 1
    |

tests/services/test_scheduler.py:256:5: S101 Use of `assert` detected
    |
254 |     assert metrics["status_counts"]["DISPATCHED"] == 1
255 |     assert metrics["status_counts"]["FAILED"] == 1
256 |     assert metrics["total_events"] == 3
    |     ^^^^^^ S101
257 |     assert metrics["error_count"] == 1
258 |     assert metrics["avg_duration_ms"] == 150
    |

tests/services/test_scheduler.py:256:39: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
254 |     assert metrics["status_counts"]["DISPATCHED"] == 1
255 |     assert metrics["status_counts"]["FAILED"] == 1
256 |     assert metrics["total_events"] == 3
    |                                       ^ PLR2004
257 |     assert metrics["error_count"] == 1
258 |     assert metrics["avg_duration_ms"] == 150
    |

tests/services/test_scheduler.py:257:5: S101 Use of `assert` detected
    |
255 |     assert metrics["status_counts"]["FAILED"] == 1
256 |     assert metrics["total_events"] == 3
257 |     assert metrics["error_count"] == 1
    |     ^^^^^^ S101
258 |     assert metrics["avg_duration_ms"] == 150
    |

tests/services/test_scheduler.py:258:5: S101 Use of `assert` detected
    |
256 |     assert metrics["total_events"] == 3
257 |     assert metrics["error_count"] == 1
258 |     assert metrics["avg_duration_ms"] == 150
    |     ^^^^^^ S101
    |

tests/services/test_scheduler.py:258:42: PLR2004 Magic value used in comparison, consider replacing `150` with a constant variable
    |
256 |     assert metrics["total_events"] == 3
257 |     assert metrics["error_count"] == 1
258 |     assert metrics["avg_duration_ms"] == 150
    |                                          ^^^ PLR2004
    |

tests/services/test_state.py:1:1: INP001 File `tests/services/test_state.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_state.py:1:1: D100 Missing docstring in public module
tests/services/test_state.py:12:5: ANN201 Missing return type annotation for public function `mock_redis_client`
   |
11 | @pytest.fixture
12 | def mock_redis_client(mocker):
   |     ^^^^^^^^^^^^^^^^^ ANN201
13 |   """Fixture that patches redis.Redis to use a FakeRedis client.
14 |   This provides a clean, in-memory redis for each test.
   |
   = help: Add return type annotation

tests/services/test_state.py:12:23: ANN001 Missing type annotation for function argument `mocker`
   |
11 | @pytest.fixture
12 | def mock_redis_client(mocker):
   |                       ^^^^^^ ANN001
13 |   """Fixture that patches redis.Redis to use a FakeRedis client.
14 |   This provides a clean, in-memory redis for each test.
   |

tests/services/test_state.py:13:3: D205 1 blank line required between summary line and description
   |
11 |   @pytest.fixture
12 |   def mock_redis_client(mocker):
13 |     """Fixture that patches redis.Redis to use a FakeRedis client.
   |  ___^
14 | |   This provides a clean, in-memory redis for each test.
15 | |   """
   | |_____^ D205
16 |     # Instantiate the fake client
17 |     fake_client = fakeredis.FakeRedis(decode_responses=False)
   |
   = help: Insert single blank line

tests/services/test_state.py:31:3: D401 First line of docstring should be in imperative mood: "Provides a consistent UUID for a test run."
   |
29 | @pytest.fixture
30 | def run_id() -> uuid.UUID:
31 |   """Provides a consistent UUID for a test run."""
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D401
32 |   return uuid.uuid4()
   |

tests/services/test_state.py:38:7: ANN201 Missing return type annotation for public function `test_initialization_success`
   |
36 |   """Test suite for the PraxisState class."""
37 | 
38 |   def test_initialization_success(self, mock_redis_client, run_id):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
39 |     """Test successful initialization of the PraxisState object."""
40 |     state = PraxisState(run_accession_id=run_id)
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:38:41: ANN001 Missing type annotation for function argument `mock_redis_client`
   |
36 |   """Test suite for the PraxisState class."""
37 | 
38 |   def test_initialization_success(self, mock_redis_client, run_id):
   |                                         ^^^^^^^^^^^^^^^^^ ANN001
39 |     """Test successful initialization of the PraxisState object."""
40 |     state = PraxisState(run_accession_id=run_id)
   |

tests/services/test_state.py:38:60: ANN001 Missing type annotation for function argument `run_id`
   |
36 |   """Test suite for the PraxisState class."""
37 | 
38 |   def test_initialization_success(self, mock_redis_client, run_id):
   |                                                            ^^^^^^ ANN001
39 |     """Test successful initialization of the PraxisState object."""
40 |     state = PraxisState(run_accession_id=run_id)
   |

tests/services/test_state.py:42:5: S101 Use of `assert` detected
   |
40 |     state = PraxisState(run_accession_id=run_id)
41 | 
42 |     assert state.run_accession_id == run_id
   |     ^^^^^^ S101
43 |     assert state.redis_key == f"praxis_state:{run_id}"
44 |     assert state.redis_client is mock_redis_client
   |

tests/services/test_state.py:43:5: S101 Use of `assert` detected
   |
42 |     assert state.run_accession_id == run_id
43 |     assert state.redis_key == f"praxis_state:{run_id}"
   |     ^^^^^^ S101
44 |     assert state.redis_client is mock_redis_client
45 |     assert state.to_dict() == {}
   |

tests/services/test_state.py:44:5: S101 Use of `assert` detected
   |
42 |     assert state.run_accession_id == run_id
43 |     assert state.redis_key == f"praxis_state:{run_id}"
44 |     assert state.redis_client is mock_redis_client
   |     ^^^^^^ S101
45 |     assert state.to_dict() == {}
   |

tests/services/test_state.py:45:5: S101 Use of `assert` detected
   |
43 |     assert state.redis_key == f"praxis_state:{run_id}"
44 |     assert state.redis_client is mock_redis_client
45 |     assert state.to_dict() == {}
   |     ^^^^^^ S101
46 | 
47 |   def test_initialization_with_existing_redis_data(self, mock_redis_client, run_id):
   |

tests/services/test_state.py:47:7: ANN201 Missing return type annotation for public function `test_initialization_with_existing_redis_data`
   |
45 |     assert state.to_dict() == {}
46 | 
47 |   def test_initialization_with_existing_redis_data(self, mock_redis_client, run_id):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
48 |     """Test that state is loaded from Redis on initialization."""
49 |     redis_key = f"praxis_state:{run_id}"
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:47:58: ANN001 Missing type annotation for function argument `mock_redis_client`
   |
45 |     assert state.to_dict() == {}
46 | 
47 |   def test_initialization_with_existing_redis_data(self, mock_redis_client, run_id):
   |                                                          ^^^^^^^^^^^^^^^^^ ANN001
48 |     """Test that state is loaded from Redis on initialization."""
49 |     redis_key = f"praxis_state:{run_id}"
   |

tests/services/test_state.py:47:77: ANN001 Missing type annotation for function argument `run_id`
   |
45 |     assert state.to_dict() == {}
46 | 
47 |   def test_initialization_with_existing_redis_data(self, mock_redis_client, run_id):
   |                                                                             ^^^^^^ ANN001
48 |     """Test that state is loaded from Redis on initialization."""
49 |     redis_key = f"praxis_state:{run_id}"
   |

tests/services/test_state.py:55:5: S101 Use of `assert` detected
   |
53 |     state = PraxisState(run_accession_id=run_id)
54 | 
55 |     assert state.to_dict() == existing_data
   |     ^^^^^^ S101
56 |     assert state["key1"] == "value1"
   |

tests/services/test_state.py:56:5: S101 Use of `assert` detected
   |
55 |     assert state.to_dict() == existing_data
56 |     assert state["key1"] == "value1"
   |     ^^^^^^ S101
57 | 
58 |   def test_initialization_with_invalid_json_in_redis(self, mock_redis_client, run_id):
   |

tests/services/test_state.py:58:7: ANN201 Missing return type annotation for public function `test_initialization_with_invalid_json_in_redis`
   |
56 |     assert state["key1"] == "value1"
57 | 
58 |   def test_initialization_with_invalid_json_in_redis(self, mock_redis_client, run_id):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
59 |     """Test graceful handling of malformed JSON data in Redis."""
60 |     redis_key = f"praxis_state:{run_id}"
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:58:60: ANN001 Missing type annotation for function argument `mock_redis_client`
   |
56 |     assert state["key1"] == "value1"
57 | 
58 |   def test_initialization_with_invalid_json_in_redis(self, mock_redis_client, run_id):
   |                                                            ^^^^^^^^^^^^^^^^^ ANN001
59 |     """Test graceful handling of malformed JSON data in Redis."""
60 |     redis_key = f"praxis_state:{run_id}"
   |

tests/services/test_state.py:58:79: ANN001 Missing type annotation for function argument `run_id`
   |
56 |     assert state["key1"] == "value1"
57 | 
58 |   def test_initialization_with_invalid_json_in_redis(self, mock_redis_client, run_id):
   |                                                                               ^^^^^^ ANN001
59 |     """Test graceful handling of malformed JSON data in Redis."""
60 |     redis_key = f"praxis_state:{run_id}"
   |

tests/services/test_state.py:66:5: S101 Use of `assert` detected
   |
65 |     # Should log an error and return an empty state, not crash
66 |     assert state.to_dict() == {}
   |     ^^^^^^ S101
67 | 
68 |   def test_initialization_fails_with_invalid_uuid(self):
   |

tests/services/test_state.py:68:7: ANN201 Missing return type annotation for public function `test_initialization_fails_with_invalid_uuid`
   |
66 |     assert state.to_dict() == {}
67 | 
68 |   def test_initialization_fails_with_invalid_uuid(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
69 |     """Test that initialization raises ValueError for a non-UUID run_accession_id."""
70 |     with pytest.raises(ValueError, match="run_accession_id must be a valid UUID"):
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:73:7: ANN201 Missing return type annotation for public function `test_initialization_connection_error`
   |
71 |       PraxisState(run_accession_id="not-a-uuid")  # type: ignore[arg-type]
72 | 
73 |   def test_initialization_connection_error(self, mocker):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
74 |     """Test that a ConnectionError is raised if Redis connection fails."""
75 |     # Patch redis.Redis to raise a ConnectionError on ping
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:73:50: ANN001 Missing type annotation for function argument `mocker`
   |
71 |       PraxisState(run_accession_id="not-a-uuid")  # type: ignore[arg-type]
72 | 
73 |   def test_initialization_connection_error(self, mocker):
   |                                                  ^^^^^^ ANN001
74 |     """Test that a ConnectionError is raised if Redis connection fails."""
75 |     # Patch redis.Redis to raise a ConnectionError on ping
   |

tests/services/test_state.py:85:7: ANN201 Missing return type annotation for public function `test_dict_interface_set_get_del`
   |
83 |       PraxisState()
84 | 
85 |   def test_dict_interface_set_get_del(self, mock_redis_client, run_id):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     """Test the dictionary-style __setitem__, __getitem__, and __delitem__ methods."""
87 |     state = PraxisState(run_accession_id=run_id)
   |
   = help: Add return type annotation: `None`

tests/services/test_state.py:85:45: ANN001 Missing type annotation for function argument `mock_redis_client`
   |
83 |       PraxisState()
84 | 
85 |   def test_dict_interface_set_get_del(self, mock_redis_client, run_id):
   |                                             ^^^^^^^^^^^^^^^^^ ANN001
86 |     """Test the dictionary-style __setitem__, __getitem__, and __delitem__ methods."""
87 |     state = PraxisState(run_accession_id=run_id)
   |

tests/services/test_state.py:85:64: ANN001 Missing type annotation for function argument `run_id`
   |
83 |       PraxisState()
84 | 
85 |   def test_dict_interface_set_get_del(self, mock_redis_client, run_id):
   |                                                                ^^^^^^ ANN001
86 |     """Test the dictionary-style __setitem__, __getitem__, and __delitem__ methods."""
87 |     state = PraxisState(run_accession_id=run_id)
   |

tests/services/test_state.py:93:5: S101 Use of `assert` detected
   |
91 |     state["number"] = 123
92 | 
93 |     assert state._data == {"message": "hello", "number": 123}
   |     ^^^^^^ S101
94 |     # Verify it was saved to Redis
95 |     redis_data = json.loads(mock_redis_client.get(state.redis_key))
   |

tests/services/test_state.py:93:12: SLF001 Private member accessed: `_data`
   |
91 |     state["number"] = 123
92 | 
93 |     assert state._data == {"message": "hello", "number": 123}
   |            ^^^^^^^^^^^ SLF001
94 |     # Verify it was saved to Redis
95 |     redis_data = json.loads(mock_redis_client.get(state.redis_key))
   |

tests/services/test_state.py:96:5: S101 Use of `assert` detected
   |
94 |     # Verify it was saved to Redis
95 |     redis_data = json.loads(mock_redis_client.get(state.redis_key))
96 |     assert redis_data == {"message": "hello", "number": 123}
   |     ^^^^^^ S101
97 | 
98 |     # Test __getitem__
   |

tests/services/test_state.py:99:5: S101 Use of `assert` detected
    |
 98 |     # Test __getitem__
 99 |     assert state["message"] == "hello"
    |     ^^^^^^ S101
100 | 
101 |     # Test __delitem__
    |

tests/services/test_state.py:103:5: S101 Use of `assert` detected
    |
101 |     # Test __delitem__
102 |     del state["message"]
103 |     assert "message" not in state.to_dict()
    |     ^^^^^^ S101
104 |     with pytest.raises(KeyError):
105 |       _ = state["message"]
    |

tests/services/test_state.py:109:5: S101 Use of `assert` detected
    |
107 |     # Verify deletion in Redis
108 |     redis_data_after_del = json.loads(mock_redis_client.get(state.redis_key))
109 |     assert redis_data_after_del == {"number": 123}
    |     ^^^^^^ S101
110 | 
111 |   def test_get_method(self, run_id):
    |

tests/services/test_state.py:111:7: ANN201 Missing return type annotation for public function `test_get_method`
    |
109 |     assert redis_data_after_del == {"number": 123}
110 | 
111 |   def test_get_method(self, run_id):
    |       ^^^^^^^^^^^^^^^ ANN201
112 |     """Test the get() method for retrieving keys with a default value."""
113 |     state = PraxisState(run_accession_id=run_id)
    |
    = help: Add return type annotation: `None`

tests/services/test_state.py:111:29: ANN001 Missing type annotation for function argument `run_id`
    |
109 |     assert redis_data_after_del == {"number": 123}
110 | 
111 |   def test_get_method(self, run_id):
    |                             ^^^^^^ ANN001
112 |     """Test the get() method for retrieving keys with a default value."""
113 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:116:5: S101 Use of `assert` detected
    |
114 |     state["existing_key"] = "exists"
115 | 
116 |     assert state.get("existing_key") == "exists"
    |     ^^^^^^ S101
117 |     assert state.get("non_existent_key") is None
118 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |

tests/services/test_state.py:117:5: S101 Use of `assert` detected
    |
116 |     assert state.get("existing_key") == "exists"
117 |     assert state.get("non_existent_key") is None
    |     ^^^^^^ S101
118 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |

tests/services/test_state.py:118:5: S101 Use of `assert` detected
    |
116 |     assert state.get("existing_key") == "exists"
117 |     assert state.get("non_existent_key") is None
118 |     assert state.get("non_existent_key", "default_val") == "default_val"
    |     ^^^^^^ S101
119 | 
120 |   def test_update_method(self, run_id):
    |

tests/services/test_state.py:120:7: ANN201 Missing return type annotation for public function `test_update_method`
    |
118 |     assert state.get("non_existent_key", "default_val") == "default_val"
119 | 
120 |   def test_update_method(self, run_id):
    |       ^^^^^^^^^^^^^^^^^^ ANN201
121 |     """Test updating the state with a dictionary."""
122 |     state = PraxisState(run_accession_id=run_id)
    |
    = help: Add return type annotation: `None`

tests/services/test_state.py:120:32: ANN001 Missing type annotation for function argument `run_id`
    |
118 |     assert state.get("non_existent_key", "default_val") == "default_val"
119 | 
120 |   def test_update_method(self, run_id):
    |                                ^^^^^^ ANN001
121 |     """Test updating the state with a dictionary."""
122 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:128:5: S101 Use of `assert` detected
    |
126 |     state.update({"b": 3, "c": 4})
127 | 
128 |     assert state.to_dict() == {"a": 1, "b": 3, "c": 4}
    |     ^^^^^^ S101
129 | 
130 |   def test_attribute_access(self, mock_redis_client, run_id):
    |

tests/services/test_state.py:130:7: ANN201 Missing return type annotation for public function `test_attribute_access`
    |
128 |     assert state.to_dict() == {"a": 1, "b": 3, "c": 4}
129 | 
130 |   def test_attribute_access(self, mock_redis_client, run_id):
    |       ^^^^^^^^^^^^^^^^^^^^^ ANN201
131 |     """Test getting and setting state via attribute access."""
132 |     state = PraxisState(run_accession_id=run_id)
    |
    = help: Add return type annotation: `None`

tests/services/test_state.py:130:35: ANN001 Missing type annotation for function argument `mock_redis_client`
    |
128 |     assert state.to_dict() == {"a": 1, "b": 3, "c": 4}
129 | 
130 |   def test_attribute_access(self, mock_redis_client, run_id):
    |                                   ^^^^^^^^^^^^^^^^^ ANN001
131 |     """Test getting and setting state via attribute access."""
132 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:130:54: ANN001 Missing type annotation for function argument `run_id`
    |
128 |     assert state.to_dict() == {"a": 1, "b": 3, "c": 4}
129 | 
130 |   def test_attribute_access(self, mock_redis_client, run_id):
    |                                                      ^^^^^^ ANN001
131 |     """Test getting and setting state via attribute access."""
132 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:139:5: S101 Use of `assert` detected
    |
138 |     # Verify with __getattr__
139 |     assert state.foo == "bar"
    |     ^^^^^^ S101
140 | 
141 |     # Verify with dict access
    |

tests/services/test_state.py:142:5: S101 Use of `assert` detected
    |
141 |     # Verify with dict access
142 |     assert state["count"] == 99
    |     ^^^^^^ S101
143 | 
144 |     # Verify in Redis
    |

tests/services/test_state.py:142:30: PLR2004 Magic value used in comparison, consider replacing `99` with a constant variable
    |
141 |     # Verify with dict access
142 |     assert state["count"] == 99
    |                              ^^ PLR2004
143 | 
144 |     # Verify in Redis
    |

tests/services/test_state.py:146:5: S101 Use of `assert` detected
    |
144 |     # Verify in Redis
145 |     redis_data = json.loads(mock_redis_client.get(state.redis_key))
146 |     assert redis_data == {"foo": "bar", "count": 99}
    |     ^^^^^^ S101
147 | 
148 |     # Test that accessing a non-existent attribute raises AttributeError
    |

tests/services/test_state.py:152:7: ANN201 Missing return type annotation for public function `test_clear_method`
    |
150 |       _ = state.non_existent_attr
151 | 
152 |   def test_clear_method(self, mock_redis_client, run_id):
    |       ^^^^^^^^^^^^^^^^^ ANN201
153 |     """Test that clear() removes all data from the object and Redis."""
154 |     state = PraxisState(run_accession_id=run_id)
    |
    = help: Add return type annotation: `None`

tests/services/test_state.py:152:31: ANN001 Missing type annotation for function argument `mock_redis_client`
    |
150 |       _ = state.non_existent_attr
151 | 
152 |   def test_clear_method(self, mock_redis_client, run_id):
    |                               ^^^^^^^^^^^^^^^^^ ANN001
153 |     """Test that clear() removes all data from the object and Redis."""
154 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:152:50: ANN001 Missing type annotation for function argument `run_id`
    |
150 |       _ = state.non_existent_attr
151 | 
152 |   def test_clear_method(self, mock_redis_client, run_id):
    |                                                  ^^^^^^ ANN001
153 |     """Test that clear() removes all data from the object and Redis."""
154 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_state.py:158:5: S101 Use of `assert` detected
    |
157 |     # Verify data exists
158 |     assert state.to_dict() == {"a": 1}
    |     ^^^^^^ S101
159 |     assert mock_redis_client.exists(state.redis_key)
    |

tests/services/test_state.py:159:5: S101 Use of `assert` detected
    |
157 |     # Verify data exists
158 |     assert state.to_dict() == {"a": 1}
159 |     assert mock_redis_client.exists(state.redis_key)
    |     ^^^^^^ S101
160 | 
161 |     state.clear()
    |

tests/services/test_state.py:164:5: S101 Use of `assert` detected
    |
163 |     # Verify data is cleared
164 |     assert state.to_dict() == {}
    |     ^^^^^^ S101
165 |     assert not mock_redis_client.exists(state.redis_key)
    |

tests/services/test_state.py:165:5: S101 Use of `assert` detected
    |
163 |     # Verify data is cleared
164 |     assert state.to_dict() == {}
165 |     assert not mock_redis_client.exists(state.redis_key)
    |     ^^^^^^ S101
166 | 
167 |   def test_setitem_type_validation(self, run_id):
    |

tests/services/test_state.py:167:7: ANN201 Missing return type annotation for public function `test_setitem_type_validation`
    |
165 |     assert not mock_redis_client.exists(state.redis_key)
166 | 
167 |   def test_setitem_type_validation(self, run_id):
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
168 |     """Test that __setitem__ raises TypeError for non-serializable values."""
169 |     state = PraxisState(run_accession_id=run_id)
    |
    = help: Add return type annotation: `None`

tests/services/test_state.py:167:42: ANN001 Missing type annotation for function argument `run_id`
    |
165 |     assert not mock_redis_client.exists(state.redis_key)
166 | 
167 |   def test_setitem_type_validation(self, run_id):
    |                                          ^^^^^^ ANN001
168 |     """Test that __setitem__ raises TypeError for non-serializable values."""
169 |     state = PraxisState(run_accession_id=run_id)
    |

tests/services/test_well_data_output.py:1:1: INP001 File `tests/services/test_well_data_output.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_well_data_output.py:54:49: SyntaxError: Duplicate keyword argument "name"
   |
52 | async def plate_resource(db: AsyncSession) -> ResourceOrm:
53 |   """Fixture for a plate ResourceOrm."""
54 |   plate = ResourceOrm(name="TestPlateForWells", name="plate_def")
   |                                                 ^
55 |   db.add(plate)
56 |   await db.commit()
   |

tests/services/test_well_data_output.py:144:10: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
142 |     assert (
143 |       read_well.well_name == "B2"
144 |     )  # TODO: decide if we want an error if name is unaligned with position
    |          ^^^^ TD002
145 | 
146 |   async def test_create_well_data_outputs_batch(
    |

tests/services/test_well_data_output.py:144:10: TD003 Missing issue link on the line following this TODO
    |
142 |     assert (
143 |       read_well.well_name == "B2"
144 |     )  # TODO: decide if we want an error if name is unaligned with position
    |          ^^^^ TD003
145 | 
146 |   async def test_create_well_data_outputs_batch(
    |

tests/services/test_well_data_output.py:144:10: FIX002 Line contains TODO, consider resolving the issue
    |
142 |     assert (
143 |       read_well.well_name == "B2"
144 |     )  # TODO: decide if we want an error if name is unaligned with position
    |          ^^^^ FIX002
145 | 
146 |   async def test_create_well_data_outputs_batch(
    |

tests/services/test_well_outputs.py:1:1: INP001 File `tests/services/test_well_outputs.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_well_outputs.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/services/well_outputs.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/services/test_well_outputs.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/services/well_outputs.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/services/test_well_outputs.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/services/well_outputs.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/services/test_well_outputs.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/services/test_well_outputs.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/services/test_well_outputs.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/services/test_workcell.py:1:1: INP001 File `tests/services/test_workcell.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/services/test_workcell.py:61:13: ANN201 Missing return type annotation for public function `test_create_and_read_workcell`
   |
59 |   """Test suite for the Workcell service layer."""
60 | 
61 |   async def test_create_and_read_workcell(self, db: AsyncSession):
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
62 |     """Test creating a workcell and reading it back by ID and name."""
63 |     name = f"MyWorkcell_{uuid.uuid4()}"
   |
   = help: Add return type annotation: `None`

tests/services/test_workcell.py:73:5: S101 Use of `assert` detected
   |
71 |       physical_location=location,
72 |     )
73 |     assert created_wc is not None
   |     ^^^^^^ S101
74 |     assert created_wc.name == name
75 |     assert created_wc.description == description
   |

tests/services/test_workcell.py:74:5: S101 Use of `assert` detected
   |
72 |     )
73 |     assert created_wc is not None
74 |     assert created_wc.name == name
   |     ^^^^^^ S101
75 |     assert created_wc.description == description
76 |     assert created_wc.physical_location == location
   |

tests/services/test_workcell.py:75:5: S101 Use of `assert` detected
   |
73 |     assert created_wc is not None
74 |     assert created_wc.name == name
75 |     assert created_wc.description == description
   |     ^^^^^^ S101
76 |     assert created_wc.physical_location == location
   |

tests/services/test_workcell.py:76:5: S101 Use of `assert` detected
   |
74 |     assert created_wc.name == name
75 |     assert created_wc.description == description
76 |     assert created_wc.physical_location == location
   |     ^^^^^^ S101
77 | 
78 |     # Read back by ID
   |

tests/services/test_workcell.py:80:5: S101 Use of `assert` detected
   |
78 |     # Read back by ID
79 |     read_by_id = await read_workcell(db, created_wc.accession_id)
80 |     assert read_by_id is not None
   |     ^^^^^^ S101
81 |     assert read_by_id.name == name
   |

tests/services/test_workcell.py:81:5: S101 Use of `assert` detected
   |
79 |     read_by_id = await read_workcell(db, created_wc.accession_id)
80 |     assert read_by_id is not None
81 |     assert read_by_id.name == name
   |     ^^^^^^ S101
82 | 
83 |     # Read back by name
   |

tests/services/test_workcell.py:85:5: S101 Use of `assert` detected
   |
83 |     # Read back by name
84 |     read_by_name = await read_workcell_by_name(db, name)
85 |     assert read_by_name is not None
   |     ^^^^^^ S101
86 |     assert read_by_name.accession_id == created_wc.accession_id
   |

tests/services/test_workcell.py:86:5: S101 Use of `assert` detected
   |
84 |     read_by_name = await read_workcell_by_name(db, name)
85 |     assert read_by_name is not None
86 |     assert read_by_name.accession_id == created_wc.accession_id
   |     ^^^^^^ S101
87 | 
88 |   async def test_create_workcell_fails_on_duplicate_name(
   |

tests/services/test_workcell.py:88:13: ANN201 Missing return type annotation for public function `test_create_workcell_fails_on_duplicate_name`
   |
86 |     assert read_by_name.accession_id == created_wc.accession_id
87 | 
88 |   async def test_create_workcell_fails_on_duplicate_name(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
89 |     self,
90 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_workcell.py:97:13: ANN201 Missing return type annotation for public function `test_update_workcell`
   |
95 |       await create_workcell(db, name=existing_workcell.name)
96 | 
97 |   async def test_update_workcell(
   |             ^^^^^^^^^^^^^^^^^^^^ ANN201
98 |     self,
99 |     db: AsyncSession,
   |
   = help: Add return type annotation: `None`

tests/services/test_workcell.py:113:5: S101 Use of `assert` detected
    |
111 |     )
112 | 
113 |     assert updated_wc is not None
    |     ^^^^^^ S101
114 |     assert updated_wc.accession_id == existing_workcell.accession_id
115 |     assert updated_wc.description == new_desc
    |

tests/services/test_workcell.py:114:5: S101 Use of `assert` detected
    |
113 |     assert updated_wc is not None
114 |     assert updated_wc.accession_id == existing_workcell.accession_id
    |     ^^^^^^ S101
115 |     assert updated_wc.description == new_desc
116 |     assert updated_wc.physical_location == new_loc
    |

tests/services/test_workcell.py:115:5: S101 Use of `assert` detected
    |
113 |     assert updated_wc is not None
114 |     assert updated_wc.accession_id == existing_workcell.accession_id
115 |     assert updated_wc.description == new_desc
    |     ^^^^^^ S101
116 |     assert updated_wc.physical_location == new_loc
    |

tests/services/test_workcell.py:116:5: S101 Use of `assert` detected
    |
114 |     assert updated_wc.accession_id == existing_workcell.accession_id
115 |     assert updated_wc.description == new_desc
116 |     assert updated_wc.physical_location == new_loc
    |     ^^^^^^ S101
117 | 
118 |   async def test_list_workcells(self, db: AsyncSession, existing_workcell: WorkcellOrm):
    |

tests/services/test_workcell.py:118:13: ANN201 Missing return type annotation for public function `test_list_workcells`
    |
116 |     assert updated_wc.physical_location == new_loc
117 | 
118 |   async def test_list_workcells(self, db: AsyncSession, existing_workcell: WorkcellOrm):
    |             ^^^^^^^^^^^^^^^^^^^ ANN201
119 |     """Test listing workcells with pagination."""
120 |     # Create a second workcell
    |
    = help: Add return type annotation: `None`

tests/services/test_workcell.py:118:57: ARG002 Unused method argument: `existing_workcell`
    |
116 |     assert updated_wc.physical_location == new_loc
117 | 
118 |   async def test_list_workcells(self, db: AsyncSession, existing_workcell: WorkcellOrm):
    |                                                         ^^^^^^^^^^^^^^^^^ ARG002
119 |     """Test listing workcells with pagination."""
120 |     # Create a second workcell
    |

tests/services/test_workcell.py:124:5: S101 Use of `assert` detected
    |
123 |     all_wcs = await list_workcells(db, limit=10)
124 |     assert len(all_wcs) >= 2
    |     ^^^^^^ S101
125 | 
126 |     # Test pagination
    |

tests/services/test_workcell.py:124:28: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
123 |     all_wcs = await list_workcells(db, limit=10)
124 |     assert len(all_wcs) >= 2
    |                            ^ PLR2004
125 | 
126 |     # Test pagination
    |

tests/services/test_workcell.py:128:5: S101 Use of `assert` detected
    |
126 |     # Test pagination
127 |     paginated_wcs = await list_workcells(db, limit=1, offset=0)
128 |     assert len(paginated_wcs) == 1
    |     ^^^^^^ S101
129 | 
130 |     next_page_wcs = await list_workcells(db, limit=1, offset=1)
    |

tests/services/test_workcell.py:131:5: S101 Use of `assert` detected
    |
130 |     next_page_wcs = await list_workcells(db, limit=1, offset=1)
131 |     assert len(next_page_wcs) == 1
    |     ^^^^^^ S101
132 |     assert paginated_wcs[0].accession_id != next_page_wcs[0].accession_id
    |

tests/services/test_workcell.py:132:5: S101 Use of `assert` detected
    |
130 |     next_page_wcs = await list_workcells(db, limit=1, offset=1)
131 |     assert len(next_page_wcs) == 1
132 |     assert paginated_wcs[0].accession_id != next_page_wcs[0].accession_id
    |     ^^^^^^ S101
133 | 
134 |   async def test_delete_workcell_success(self, db: AsyncSession):
    |

tests/services/test_workcell.py:134:13: ANN201 Missing return type annotation for public function `test_delete_workcell_success`
    |
132 |     assert paginated_wcs[0].accession_id != next_page_wcs[0].accession_id
133 | 
134 |   async def test_delete_workcell_success(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
135 |     """Test successfully deleting an empty workcell."""
136 |     wc_to_delete = await create_workcell(db, name=f"ToDelete_{uuid.uuid4()}")
    |
    = help: Add return type annotation: `None`

tests/services/test_workcell.py:140:5: S101 Use of `assert` detected
    |
139 |     result = await delete_workcell(db, wc_id)
140 |     assert result is True
    |     ^^^^^^ S101
141 | 
142 |     # Verify it's gone
    |

tests/services/test_workcell.py:143:5: S101 Use of `assert` detected
    |
142 |     # Verify it's gone
143 |     assert await read_workcell(db, wc_id) is None
    |     ^^^^^^ S101
144 | 
145 |   async def test_delete_workcell_fails_if_in_use(
    |

tests/services/test_workcell.py:145:13: ANN201 Missing return type annotation for public function `test_delete_workcell_fails_if_in_use`
    |
143 |     assert await read_workcell(db, wc_id) is None
144 | 
145 |   async def test_delete_workcell_fails_if_in_use(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
146 |     self,
147 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_workcell.py:149:5: ARG002 Unused method argument: `machine_in_workcell`
    |
147 |     db: AsyncSession,
148 |     existing_workcell: WorkcellOrm,
149 |     machine_in_workcell: MachineOrm,
    |     ^^^^^^^^^^^^^^^^^^^ ARG002
150 |   ):
151 |     """Test that deleting a workcell with linked machines fails gracefully."""
    |

tests/services/test_workcell.py:156:5: S101 Use of `assert` detected
    |
154 |     result = await delete_workcell(db, existing_workcell.accession_id)
155 |     # The service function catches the IntegrityError and returns False
156 |     assert result is False
    |     ^^^^^^ S101
157 | 
158 |   async def test_read_and_update_workcell_state(
    |

tests/services/test_workcell.py:158:13: ANN201 Missing return type annotation for public function `test_read_and_update_workcell_state`
    |
156 |     assert result is False
157 | 
158 |   async def test_read_and_update_workcell_state(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
159 |     self,
160 |     db: AsyncSession,
    |
    = help: Add return type annotation: `None`

tests/services/test_workcell.py:166:5: S101 Use of `assert` detected
    |
164 |     # Test reading the initial state
165 |     initial_state = await read_workcell_state(db, existing_workcell.accession_id)
166 |     assert initial_state == {"status": "idle"}
    |     ^^^^^^ S101
167 | 
168 |     # Test updating the state
    |

tests/services/test_workcell.py:175:5: S101 Use of `assert` detected
    |
173 |       new_state,
174 |     )
175 |     assert updated_wc is not None
    |     ^^^^^^ S101
176 |     assert updated_wc.latest_state_json == new_state
177 |     assert updated_wc.last_state_update_time is not None
    |

tests/services/test_workcell.py:176:5: S101 Use of `assert` detected
    |
174 |     )
175 |     assert updated_wc is not None
176 |     assert updated_wc.latest_state_json == new_state
    |     ^^^^^^ S101
177 |     assert updated_wc.last_state_update_time is not None
178 |     assert existing_workcell.last_state_update_time is not None
    |

tests/services/test_workcell.py:177:5: S101 Use of `assert` detected
    |
175 |     assert updated_wc is not None
176 |     assert updated_wc.latest_state_json == new_state
177 |     assert updated_wc.last_state_update_time is not None
    |     ^^^^^^ S101
178 |     assert existing_workcell.last_state_update_time is not None
179 |     assert updated_wc.last_state_update_time > existing_workcell.last_state_update_time
    |

tests/services/test_workcell.py:178:5: S101 Use of `assert` detected
    |
176 |     assert updated_wc.latest_state_json == new_state
177 |     assert updated_wc.last_state_update_time is not None
178 |     assert existing_workcell.last_state_update_time is not None
    |     ^^^^^^ S101
179 |     assert updated_wc.last_state_update_time > existing_workcell.last_state_update_time
    |

tests/services/test_workcell.py:179:5: S101 Use of `assert` detected
    |
177 |     assert updated_wc.last_state_update_time is not None
178 |     assert existing_workcell.last_state_update_time is not None
179 |     assert updated_wc.last_state_update_time > existing_workcell.last_state_update_time
    |     ^^^^^^ S101
180 | 
181 |     # Test reading the new state
    |

tests/services/test_workcell.py:183:5: S101 Use of `assert` detected
    |
181 |     # Test reading the new state
182 |     read_new_state = await read_workcell_state(db, existing_workcell.accession_id)
183 |     assert read_new_state == new_state
    |     ^^^^^^ S101
184 | 
185 |   async def test_update_state_fails_for_non_existent_workcell(self, db: AsyncSession):
    |

tests/services/test_workcell.py:185:13: ANN201 Missing return type annotation for public function `test_update_state_fails_for_non_existent_workcell`
    |
183 |     assert read_new_state == new_state
184 | 
185 |   async def test_update_state_fails_for_non_existent_workcell(self, db: AsyncSession):
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
186 |     """Test that updating state for a non-existent workcell raises ValueError."""
187 |     non_existent_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

tests/state_tests.py:1:1: INP001 File `tests/state_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/state_tests.py:1:1: D100 Missing docstring in public module
tests/state_tests.py:12:7: D101 Missing docstring in public class
   |
12 | class TestState(unittest.TestCase):
   |       ^^^^^^^^^ D101
13 | 
14 |   def setUp(self):
   |

tests/state_tests.py:14:7: ANN201 Missing return type annotation for public function `setUp`
   |
12 | class TestState(unittest.TestCase):
13 | 
14 |   def setUp(self):
   |       ^^^^^ ANN201
15 |     self.tempdir = tempfile.mkdtemp()
16 |     self.temp_file = os.path.join(self.tempdir, "test_state")
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:14:7: D102 Missing docstring in public method
   |
12 | class TestState(unittest.TestCase):
13 | 
14 |   def setUp(self):
   |       ^^^^^ D102
15 |     self.tempdir = tempfile.mkdtemp()
16 |     self.temp_file = os.path.join(self.tempdir, "test_state")
   |

tests/state_tests.py:16:22: PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   |
14 |   def setUp(self):
15 |     self.tempdir = tempfile.mkdtemp()
16 |     self.temp_file = os.path.join(self.tempdir, "test_state")
   |                      ^^^^^^^^^^^^ PTH118
17 |     self.persistent_state: DbfilenameShelf = DbfilenameShelf(self.temp_file)
18 |     fd = os.open(self.temp_file, os.O_CREAT | os.O_RDWR)
   |

tests/state_tests.py:17:46: S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
   |
15 |     self.tempdir = tempfile.mkdtemp()
16 |     self.temp_file = os.path.join(self.tempdir, "test_state")
17 |     self.persistent_state: DbfilenameShelf = DbfilenameShelf(self.temp_file)
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S301
18 |     fd = os.open(self.temp_file, os.O_CREAT | os.O_RDWR)
19 |     os.close(fd)
   |

tests/state_tests.py:21:7: ANN201 Missing return type annotation for public function `tearDown`
   |
19 |     os.close(fd)
20 | 
21 |   def tearDown(self):
   |       ^^^^^^^^ ANN201
22 |     os.remove(self.temp_file)
23 |     try:
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:21:7: D102 Missing docstring in public method
   |
19 |     os.close(fd)
20 | 
21 |   def tearDown(self):
   |       ^^^^^^^^ D102
22 |     os.remove(self.temp_file)
23 |     try:
   |

tests/state_tests.py:22:5: PTH107 `os.remove()` should be replaced by `Path.unlink()`
   |
21 |   def tearDown(self):
22 |     os.remove(self.temp_file)
   |     ^^^^^^^^^ PTH107
23 |     try:
24 |         shutil.rmtree(self.tempdir)  # delete directory
   |

tests/state_tests.py:29:7: ANN201 Missing return type annotation for public function `test_runtime_state_init`
   |
27 |             raise  # re-raise exception
28 | 
29 |   def test_runtime_state_init(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |     with self.persistent_state as s:
31 |       s["key"] = "value"
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:29:7: D102 Missing docstring in public method
   |
27 |             raise  # re-raise exception
28 | 
29 |   def test_runtime_state_init(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^ D102
30 |     with self.persistent_state as s:
31 |       s["key"] = "value"
   |

tests/state_tests.py:33:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
31 |       s["key"] = "value"
32 |     runtime_state = RuntimeState(self.temp_file)
33 |     self.assertEqual(runtime_state["key"], "value")
   |     ^^^^^^^^^^^^^^^^ PT009
34 | 
35 |   def test_runtime_state_set_get_item(self):
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:35:7: ANN201 Missing return type annotation for public function `test_runtime_state_set_get_item`
   |
33 |     self.assertEqual(runtime_state["key"], "value")
34 | 
35 |   def test_runtime_state_set_get_item(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
36 |     with self.persistent_state as s:
37 |       s["key"] = "value"
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:35:7: D102 Missing docstring in public method
   |
33 |     self.assertEqual(runtime_state["key"], "value")
34 | 
35 |   def test_runtime_state_set_get_item(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
36 |     with self.persistent_state as s:
37 |       s["key"] = "value"
   |

tests/state_tests.py:40:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
38 |     runtime_state = RuntimeState(self.temp_file)
39 |     runtime_state["key2"] = "value2"
40 |     self.assertEqual(runtime_state["key2"], "value2")
   |     ^^^^^^^^^^^^^^^^ PT009
41 |     s2: DbfilenameShelf
42 |     with DbfilenameShelf(self.temp_file) as s2:
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:42:10: S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
   |
40 |     self.assertEqual(runtime_state["key2"], "value2")
41 |     s2: DbfilenameShelf
42 |     with DbfilenameShelf(self.temp_file) as s2:
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S301
43 |       self.assertEqual(s2["key2"], "value2")
   |

tests/state_tests.py:43:7: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
41 |     s2: DbfilenameShelf
42 |     with DbfilenameShelf(self.temp_file) as s2:
43 |       self.assertEqual(s2["key2"], "value2")
   |       ^^^^^^^^^^^^^^^^ PT009
44 | 
45 |   def test_runtime_state_del_item(self):
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:45:7: ANN201 Missing return type annotation for public function `test_runtime_state_del_item`
   |
43 |       self.assertEqual(s2["key2"], "value2")
44 | 
45 |   def test_runtime_state_del_item(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
46 |     with self.persistent_state as s:
47 |       s["key"] = "value"
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:45:7: D102 Missing docstring in public method
   |
43 |       self.assertEqual(s2["key2"], "value2")
44 | 
45 |   def test_runtime_state_del_item(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
46 |     with self.persistent_state as s:
47 |       s["key"] = "value"
   |

tests/state_tests.py:50:5: PT009 Use a regular `assert` instead of unittest-style `assertNotIn`
   |
48 |     runtime_state = RuntimeState(self.temp_file)
49 |     del runtime_state["key"]
50 |     self.assertNotIn("key", runtime_state)
   |     ^^^^^^^^^^^^^^^^ PT009
51 |     s2: DbfilenameShelf
52 |     with DbfilenameShelf(self.temp_file) as s2:
   |
   = help: Replace `assertNotIn(...)` with `assert ...`

tests/state_tests.py:52:10: S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
   |
50 |     self.assertNotIn("key", runtime_state)
51 |     s2: DbfilenameShelf
52 |     with DbfilenameShelf(self.temp_file) as s2:
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S301
53 |       self.assertNotIn("key", s2)
   |

tests/state_tests.py:53:7: PT009 Use a regular `assert` instead of unittest-style `assertNotIn`
   |
51 |     s2: DbfilenameShelf
52 |     with DbfilenameShelf(self.temp_file) as s2:
53 |       self.assertNotIn("key", s2)
   |       ^^^^^^^^^^^^^^^^ PT009
54 | 
55 |   def test_runtime_state_reinitialization(self):
   |
   = help: Replace `assertNotIn(...)` with `assert ...`

tests/state_tests.py:55:7: ANN201 Missing return type annotation for public function `test_runtime_state_reinitialization`
   |
53 |       self.assertNotIn("key", s2)
54 | 
55 |   def test_runtime_state_reinitialization(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
56 |     with self.persistent_state as s:
57 |       s["key"] = "value"
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:55:7: D102 Missing docstring in public method
   |
53 |       self.assertNotIn("key", s2)
54 | 
55 |   def test_runtime_state_reinitialization(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
56 |     with self.persistent_state as s:
57 |       s["key"] = "value"
   |

tests/state_tests.py:59:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
57 |       s["key"] = "value"
58 |     runtime_state = RuntimeState(self.temp_file)
59 |     self.assertEqual(runtime_state["key"], "value")
   |     ^^^^^^^^^^^^^^^^ PT009
60 |     self.assertNotIn("key2", runtime_state)
61 |     runtime_state["key2"] = "value2"
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:60:5: PT009 Use a regular `assert` instead of unittest-style `assertNotIn`
   |
58 |     runtime_state = RuntimeState(self.temp_file)
59 |     self.assertEqual(runtime_state["key"], "value")
60 |     self.assertNotIn("key2", runtime_state)
   |     ^^^^^^^^^^^^^^^^ PT009
61 |     runtime_state["key2"] = "value2"
62 |     del runtime_state
   |
   = help: Replace `assertNotIn(...)` with `assert ...`

tests/state_tests.py:65:5: PT009 Use a regular `assert` instead of unittest-style `assertIn`
   |
63 |     time.sleep(1)
64 |     runtime_state = RuntimeState(self.temp_file)
65 |     self.assertIn("key", runtime_state)
   |     ^^^^^^^^^^^^^ PT009
66 |     self.assertIn("key2", runtime_state)
67 |     self.assertEqual(runtime_state["key"], "value")
   |
   = help: Replace `assertIn(...)` with `assert ...`

tests/state_tests.py:66:5: PT009 Use a regular `assert` instead of unittest-style `assertIn`
   |
64 |     runtime_state = RuntimeState(self.temp_file)
65 |     self.assertIn("key", runtime_state)
66 |     self.assertIn("key2", runtime_state)
   |     ^^^^^^^^^^^^^ PT009
67 |     self.assertEqual(runtime_state["key"], "value")
68 |     self.assertEqual(runtime_state["key2"], "value2")
   |
   = help: Replace `assertIn(...)` with `assert ...`

tests/state_tests.py:67:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
65 |     self.assertIn("key", runtime_state)
66 |     self.assertIn("key2", runtime_state)
67 |     self.assertEqual(runtime_state["key"], "value")
   |     ^^^^^^^^^^^^^^^^ PT009
68 |     self.assertEqual(runtime_state["key2"], "value2")
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:68:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
66 |     self.assertIn("key2", runtime_state)
67 |     self.assertEqual(runtime_state["key"], "value")
68 |     self.assertEqual(runtime_state["key2"], "value2")
   |     ^^^^^^^^^^^^^^^^ PT009
69 | 
70 |   def test_runtime_state_iter_len(self):
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:70:7: ANN201 Missing return type annotation for public function `test_runtime_state_iter_len`
   |
68 |     self.assertEqual(runtime_state["key2"], "value2")
69 | 
70 |   def test_runtime_state_iter_len(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
71 |     runtime_state = RuntimeState(self.persistent_state)
72 |     runtime_state["key1"] = "value1"
   |
   = help: Add return type annotation: `None`

tests/state_tests.py:70:7: D102 Missing docstring in public method
   |
68 |     self.assertEqual(runtime_state["key2"], "value2")
69 | 
70 |   def test_runtime_state_iter_len(self):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ D102
71 |     runtime_state = RuntimeState(self.persistent_state)
72 |     runtime_state["key1"] = "value1"
   |

tests/state_tests.py:74:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
72 |     runtime_state["key1"] = "value1"
73 |     runtime_state["key2"] = "value2"
74 |     self.assertEqual(len(runtime_state), 2)
   |     ^^^^^^^^^^^^^^^^ PT009
75 |     self.assertEqual(set(runtime_state), {"key1", "key2"})
76 |     runtime_state.close()
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/state_tests.py:75:5: PT009 Use a regular `assert` instead of unittest-style `assertEqual`
   |
73 |     runtime_state["key2"] = "value2"
74 |     self.assertEqual(len(runtime_state), 2)
75 |     self.assertEqual(set(runtime_state), {"key1", "key2"})
   |     ^^^^^^^^^^^^^^^^ PT009
76 |     runtime_state.close()
   |
   = help: Replace `assertEqual(...)` with `assert ...`

tests/utils/test_accession_resolver.py:1:1: INP001 File `tests/utils/test_accession_resolver.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_accession_resolver.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/accession_resolver.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_accession_resolver.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/accession_resolver.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_accession_resolver.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/accession_resolver.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_accession_resolver.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_accession_resolver.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_accession_resolver.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_db.py:1:1: INP001 File `tests/utils/test_db.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_db.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/db.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_db.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/db.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_db.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/db.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_db.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_db.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_db.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_errors.py:1:1: INP001 File `tests/utils/test_errors.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_errors.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/errors.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_errors.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/errors.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_errors.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/errors.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_errors.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_errors.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_errors.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_logging.py:1:1: INP001 File `tests/utils/test_logging.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_logging.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/logging.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_logging.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/logging.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_logging.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/logging.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_logging.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_logging.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_logging.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_notify.py:1:1: INP001 File `tests/utils/test_notify.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_notify.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/notify.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_notify.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/notify.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_notify.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/notify.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_notify.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_notify.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_notify.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_plr_inspection.py:1:1: INP001 File `tests/utils/test_plr_inspection.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_plr_inspection.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/plr_inspection.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_plr_inspection.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/plr_inspection.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_plr_inspection.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/plr_inspection.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_plr_inspection.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_plr_inspection.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_plr_inspection.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_redis_lock.py:1:1: INP001 File `tests/utils/test_redis_lock.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_redis_lock.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/redis_lock.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_redis_lock.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/redis_lock.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_redis_lock.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/redis_lock.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_redis_lock.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_redis_lock.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_redis_lock.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_run_control.py:1:1: INP001 File `tests/utils/test_run_control.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_run_control.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/run_control.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_run_control.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/run_control.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_run_control.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/run_control.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_run_control.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_run_control.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_run_control.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_sanitation.py:1:1: INP001 File `tests/utils/test_sanitation.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_sanitation.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/sanitation.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_sanitation.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/sanitation.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_sanitation.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/sanitation.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_sanitation.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_sanitation.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_sanitation.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_type_inspection.py:1:1: INP001 File `tests/utils/test_type_inspection.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_type_inspection.py:1:1: D200 One-line docstring should fit on one line
  |
1 | / """Placeholder test file for praxis/backend/utils/type_inspection.py
2 | | """
  | |___^ D200
3 |   
4 |   def test_placeholder():
  |
  = help: Reformat to one line

tests/utils/test_type_inspection.py:1:1: D400 First line should end with a period
  |
1 | / """Placeholder test file for praxis/backend/utils/type_inspection.py
2 | | """
  | |___^ D400
3 |   
4 |   def test_placeholder():
  |
  = help: Add period

tests/utils/test_type_inspection.py:1:1: D415 First line should end with a period, question mark, or exclamation point
  |
1 | / """Placeholder test file for praxis/backend/utils/type_inspection.py
2 | | """
  | |___^ D415
3 |   
4 |   def test_placeholder():
  |
  = help: Add closing punctuation

tests/utils/test_type_inspection.py:4:5: ANN201 Missing return type annotation for public function `test_placeholder`
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ ANN201
5 |     assert True
  |
  = help: Add return type annotation: `None`

tests/utils/test_type_inspection.py:4:5: D103 Missing docstring in public function
  |
2 | """
3 | 
4 | def test_placeholder():
  |     ^^^^^^^^^^^^^^^^ D103
5 |     assert True
  |

tests/utils/test_type_inspection.py:5:5: S101 Use of `assert` detected
  |
4 | def test_placeholder():
5 |     assert True
  |     ^^^^^^ S101
  |

tests/utils/test_uuid.py:1:1: INP001 File `tests/utils/test_uuid.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/utils/test_uuid.py:9:5: ANN201 Missing return type annotation for public function `test_uuid7_generation`
   |
 9 | def test_uuid7_generation():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
10 |   """Test that uuid7() generates a valid UUID object with version 7."""
11 |   test_uuid_str = "018f3d6c-72e8-7a28-97a3-2def368c0759"
   |
   = help: Add return type annotation: `None`

tests/utils/test_uuid.py:18:3: S101 Use of `assert` detected
   |
16 |   mock_lib_uuid7.assert_called_once()
17 | 
18 |   assert isinstance(generated_uuid, uuid.UUID)
   |   ^^^^^^ S101
19 | 
20 |   assert str(generated_uuid) == test_uuid_str
   |

tests/utils/test_uuid.py:20:3: S101 Use of `assert` detected
   |
18 |   assert isinstance(generated_uuid, uuid.UUID)
19 | 
20 |   assert str(generated_uuid) == test_uuid_str
   |   ^^^^^^ S101
21 | 
22 |   assert generated_uuid.version == 7
   |

tests/utils/test_uuid.py:22:3: S101 Use of `assert` detected
   |
20 |   assert str(generated_uuid) == test_uuid_str
21 | 
22 |   assert generated_uuid.version == 7
   |   ^^^^^^ S101
   |

tests/utils/test_uuid.py:22:36: PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   |
20 |   assert str(generated_uuid) == test_uuid_str
21 | 
22 |   assert generated_uuid.version == 7
   |                                    ^ PLR2004
   |

tests/utils/test_uuid.py:25:5: ANN201 Missing return type annotation for public function `test_uuid4_generation`
   |
25 | def test_uuid4_generation():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
26 |   """Test that uuid4() generates a valid UUID object with version 4."""
27 |   generated_uuid = praxis_uuid.uuid4()
   |
   = help: Add return type annotation: `None`

tests/utils/test_uuid.py:29:3: S101 Use of `assert` detected
   |
27 |   generated_uuid = praxis_uuid.uuid4()
28 | 
29 |   assert isinstance(generated_uuid, uuid.UUID)
   |   ^^^^^^ S101
30 | 
31 |   assert generated_uuid.version == 4
   |

tests/utils/test_uuid.py:31:3: S101 Use of `assert` detected
   |
29 |   assert isinstance(generated_uuid, uuid.UUID)
30 | 
31 |   assert generated_uuid.version == 4
   |   ^^^^^^ S101
   |

tests/utils/test_uuid.py:31:36: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
29 |   assert isinstance(generated_uuid, uuid.UUID)
30 | 
31 |   assert generated_uuid.version == 4
   |                                    ^ PLR2004
   |

tests/workcell_runtime_tests.py:1:1: INP001 File `tests/workcell_runtime_tests.py` is part of an implicit namespace package. Add an `__init__.py`.
tests/workcell_runtime_tests.py:1:15: PGH003 Use specific rule codes when ignoring type issues
  |
1 | import pytest # type: ignore
  |               ^^^^^^^^^^^^^^ PGH003
2 | from unittest.mock import MagicMock, patch, call
3 | from typing import Dict, Any, Optional
  |

tests/workcell_runtime_tests.py:14:48: COM812 Trailing comma missing
   |
12 | # Enums
13 | from praxis.backend.database_models.asset_management_orm import (
14 |     ManagedDeviceStatusEnum, ResourceStatusEnum
   |                                                 COM812
15 | )
   |
   = help: Add trailing comma

tests/workcell_runtime_tests.py:21:71: PLR2044 Line with empty comment
   |
19 | def mock_plr_resource_class():
20 |     klass = MagicMock()
21 |     klass.return_value = MagicMock(name="mock_plr_resource_instance") #
   |                                                                       ^ PLR2044
22 |     return klass
   |
   = help: Delete the empty comment

tests/workcell_runtime_tests.py:84:75: COM812 Trailing comma missing
   |
82 |     def test_initialize_machine_backend_success(
83 |         self, mock_get_class: MagicMock, mock_plr_machine_backend_class: MagicMock,
84 |         workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock
   |                                                                            COM812
85 |     ):
86 |         mock_get_class.return_value = mock_plr_machine_backend_class
   |
   = help: Add trailing comma

tests/workcell_runtime_tests.py:87:121: E501 Line too long (124 > 120)
   |
85 |     ):
86 |         mock_get_class.return_value = mock_plr_machine_backend_class
87 |         machine_orm = ManagedDeviceOrmMock(id=1, name="Device1", fqn="some.DeviceClass", properties_json={"param": "value"})
   |                                                                                                                         ^^^^ E501
88 | 
89 |         backend_instance = workcell_runtime.initialize_machine_backend(machine_orm)
   |

tests/workcell_runtime_tests.py:95:121: E501 Line too long (137 > 120)
   |
93 |         # This depends on how _get_class_from_fqn and constructor inspection work.
94 |         # For now, assume it's called. A more specific check would be on mock_plr_machine_backend_class.
95 |         mock_plr_machine_backend_class.assert_called_with(name="Device1", param="value") # Assuming name is passed, and param from config
   |                                                                                                                         ^^^^^^^^^^^^^^^^^ E501
96 | 
97 |         assert backend_instance is not None
   |

tests/workcell_runtime_tests.py:101:102: COM812 Trailing comma missing
    |
 99 |         assert workcell_runtime._active_machine_backends[1] is backend_instance
100 |         mock_ads_service_wcr.update_managed_machine_status.assert_called_once_with(
101 |             workcell_runtime.db_session, 1, ManagedDeviceStatusEnum.AVAILABLE, "Backend initialized."
    |                                                                                                       COM812
102 |         )
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:107:75: COM812 Trailing comma missing
    |
105 |     def test_initialize_machine_backend_is_deck(
106 |         self, mock_get_class: MagicMock, mock_plr_deck_class: MagicMock, # Use deck-specific mock
107 |         workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock
    |                                                                            COM812
108 |     ):
109 |         # For this test, we need _get_class_from_fqn to return a class that, when instantiated,
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:125:121: E501 Line too long (122 > 120)
    |
123 |             # The worker's report on WCR v3 said "isinstance(backend_instance, Deck)" is used.
124 |             # To make isinstance(mock_plr_deck_class.return_value, ActualDeckClassMocked) true:
125 |             mock_plr_deck_class.return_value.__class__ = ActualDeckClassMocked # Make the instance's class the mocked Deck
    |                                                                                                                         ^^ E501
126 | 
127 |             machine_orm = ManagedDeviceOrmMock(id=2, name="MainDeck", fqn="pylabrobot.resources.deck.Deck", properties_json={})
    |

tests/workcell_runtime_tests.py:127:121: E501 Line too long (127 > 120)
    |
125 |             mock_plr_deck_class.return_value.__class__ = ActualDeckClassMocked # Make the instance's class the mocked Deck
126 | 
127 |             machine_orm = ManagedDeviceOrmMock(id=2, name="MainDeck", fqn="pylabrobot.resources.deck.Deck", properties_json={})
    |                                                                                                                         ^^^^^^^ E501
128 | 
129 |             backend_instance = workcell_runtime.initialize_machine_backend(machine_orm)
    |

tests/workcell_runtime_tests.py:137:108: COM812 Trailing comma missing
    |
135 |     @patch('praxis.backend.core.workcell_runtime._get_class_from_fqn')
136 |     def test_initialize_machine_backend_failure(
137 |         self, mock_get_class: MagicMock, workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock
    |                                                                                                             COM812
138 |     ):
139 |         mock_get_class.side_effect = ImportError("Module not found")
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:147:115: COM812 Trailing comma missing
    |
145 |         assert 3 not in workcell_runtime._active_machine_backends
146 |         mock_ads_service_wcr.update_managed_machine_status.assert_called_once_with(
147 |             workcell_runtime.db_session, 3, ManagedDeviceStatusEnum.ERROR, "Backend init failed: Module not found"
    |                                                                                                                    COM812
148 |         )
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:160:98: COM812 Trailing comma missing
    |
158 |         mock_backend_instance.stop.assert_called_once()
159 |         mock_ads_service_wcr.update_managed_machine_status.assert_called_once_with(
160 |             workcell_runtime.db_session, 1, ManagedDeviceStatusEnum.OFFLINE, "Backend shut down."
    |                                                                                                   COM812
161 |         )
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:168:75: COM812 Trailing comma missing
    |
166 |     def test_create_or_get_resource_plr_object_success(
167 |         self, mock_get_class: MagicMock, mock_plr_resource_class: MagicMock,
168 |         workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock # Added ads mock
    |                                                                            COM812
169 |     ):
170 |         mock_get_class.return_value = mock_plr_resource_class
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:171:61: SyntaxError: Duplicate keyword argument "name"
    |
169 |     ):
170 |         mock_get_class.return_value = mock_plr_resource_class
171 |         resource_orm = ResourceOrmMock(id=1, name="Plate1", name="some.ResourceFQN") # Name used for instance
    |                                                             ^
172 | 
173 |         plr_object = workcell_runtime.create_or_get_resource_plr_object(resource_orm, "some.ResourceFQN") # Pass FQN
    |

tests/workcell_runtime_tests.py:182:108: COM812 Trailing comma missing
    |
180 |     @patch('praxis.backend.core.workcell_runtime._get_class_from_fqn')
181 |     def test_create_or_get_resource_plr_object_failure_sets_status_error(
182 |         self, mock_get_class: MagicMock, workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock
    |                                                                                                             COM812
183 |     ):
184 |         mock_get_class.side_effect = ImportError("Cannot import resource class")
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:185:63: SyntaxError: Duplicate keyword argument "name"
    |
183 |     ):
184 |         mock_get_class.side_effect = ImportError("Cannot import resource class")
185 |         resource_orm = ResourceOrmMock(id=2, name="BadPlate", name="bad.fqn.Resource")
    |                                                               ^
186 | 
187 |         plr_object = workcell_runtime.create_or_get_resource_plr_object(resource_orm, "bad.fqn.Resource")
    |

tests/workcell_runtime_tests.py:196:121: E501 Line too long (130 > 120)
    |
194 |             resource_instance_accession_id=2,
195 |             new_status=ResourceStatusEnum.ERROR,
196 |             status_details="Failed to create PLR object for 'BadPlate' using FQN 'bad.fqn.Resource': Cannot import resource class"
    |                                                                                                                         ^^^^^^^^^^ E501
197 |         )
    |

tests/workcell_runtime_tests.py:196:131: COM812 Trailing comma missing
    |
194 |             resource_instance_accession_id=2,
195 |             new_status=ResourceStatusEnum.ERROR,
196 |             status_details="Failed to create PLR object for 'BadPlate' using FQN 'bad.fqn.Resource': Cannot import resource class"
    |                                                                                                                                    COM812
197 |         )
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:203:75: COM812 Trailing comma missing
    |
201 |     def test_assign_resource_to_deck_slot(
202 |         self, MockActualDeck: MagicMock, # This is the mocked Deck class from the patch
203 |         workcell_runtime: WorkcellRuntime, mock_ads_service_wcr: MagicMock
    |                                                                            COM812
204 |     ):
205 |         # Setup a mock deck object that is an instance of the (mocked) Deck
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:220:74: COM812 Trailing comma missing
    |
218 |         mock_ads_service_wcr.update_resource_instance_location_and_status.assert_called_once_with(
219 |             workcell_runtime.db_session, resource_instance_accession_id, ResourceStatusEnum.AVAILABLE_ON_DECK,
220 |             location_machine_accession_id=10, current_deck_slot_name="A1"
    |                                                                           COM812
221 |         )
    |
    = help: Add trailing comma

tests/workcell_runtime_tests.py:223:3: TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
    |
221 |         )
222 | 
223 | # TODO: More tests:
    |   ^^^^ TD002
224 | # - get_active_machine_backend, get_active_resource_plr_object
225 | # - clear_deck_slot
    |

tests/workcell_runtime_tests.py:223:3: TD003 Missing issue link on the line following this TODO
    |
221 |         )
222 | 
223 | # TODO: More tests:
    |   ^^^^ TD003
224 | # - get_active_machine_backend, get_active_resource_plr_object
225 | # - clear_deck_slot
    |

tests/workcell_runtime_tests.py:223:3: FIX002 Line contains TODO, consider resolving the issue
    |
221 |         )
222 | 
223 | # TODO: More tests:
    |   ^^^^ FIX002
224 | # - get_active_machine_backend, get_active_resource_plr_object
225 | # - clear_deck_slot
    |

tests/workcell_runtime_tests.py:230:1: SyntaxError: Got unexpected token `
    |
228 | # - get_main_deck_plr_object (interaction with ads if deck not active)
229 | # - Complex constructor inspection in initialize_machine_backend
230 | ```
    | ^
    |

tests/workcell_runtime_tests.py:230:2: SyntaxError: Got unexpected token `
    |
228 | # - get_main_deck_plr_object (interaction with ads if deck not active)
229 | # - Complex constructor inspection in initialize_machine_backend
230 | ```
    |  ^
    |

tests/workcell_runtime_tests.py:230:3: SyntaxError: Got unexpected token `
    |
228 | # - get_main_deck_plr_object (interaction with ads if deck not active)
229 | # - Complex constructor inspection in initialize_machine_backend
230 | ```
    |   ^
    |

tests/workcell_runtime_tests.py:230:4: SyntaxError: Expected a statement
    |
228 | # - get_main_deck_plr_object (interaction with ads if deck not active)
229 | # - Complex constructor inspection in initialize_machine_backend
230 | ```
    |    ^
    |

Found 4177 errors (115 fixed, 4062 remaining).
No fixes available (967 hidden fixes can be enabled with the `--unsafe-fixes` option).
