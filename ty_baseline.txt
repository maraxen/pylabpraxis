error[unresolved-import]: Module `alembic` has no member `context`
 --> alembic/env.py:5:21
  |
3 | from sqlalchemy import engine_from_config, pool
4 |
5 | from alembic import context
  |                     ^^^^^^^
6 | from praxis.backend.utils.db import Base as PraxisBase
  |
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Module `alembic` has no member `op`
  --> alembic/versions/3a1fe0851e06_make_resourceorm_resource_definition_.py:13:21
   |
11 | import sqlalchemy as sa
12 |
13 | from alembic import op
   |                     ^^
14 |
15 | # revision identifiers, used by Alembic.
   |
info: rule `unresolved-import` is enabled by default

warning[possibly-missing-attribute]: Attribute `add` may be missing on object of type `set[Unknown] | list[Unknown] | Unknown`
   --> dependency_analysis.py:98:5
    |
 97 |   def dfs(node):
 98 |     path.add(node)
    |     ^^^^^^^^
 99 |     visited.add(node)
100 |     for neighbor in graph.get(node, []):
    |
info: rule `possibly-missing-attribute` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> main.py:99:7
    |
 97 |       name="test_workcell",
 98 |       save_file="test_workcell.json",
 99 |       file_system=FileSystem(),
    |       ^^^^^^^^^^^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
100 |     )
101 |     async with AsyncSessionLocal() as db_session:
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `add_middleware` is incorrect
   --> main.py:203:3
    |
201 | # CORS Middleware Configuration
202 | app.add_middleware(
203 |   CORSMiddleware,
    |   ^^^^^^^^^^^^^^ Expected `_MiddlewareFactory[(...)]`, found `<class 'CORSMiddleware'>`
204 |   allow_origins=[
205 |     "http://localhost:5173",
    |
info: Method defined here
   --> .venv/lib/python3.13/site-packages/starlette/applications.py:124:9
    |
122 |         self.router.host(host, app=app, name=name)  # pragma: no cover
123 |
124 |     def add_middleware(
    |         ^^^^^^^^^^^^^^
125 |         self,
126 |         middleware_class: _MiddlewareFactory[P],
    |         --------------------------------------- Parameter declared here
127 |         *args: P.args,
128 |         **kwargs: P.kwargs,
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-type-form]: Variable of type `type[Unknown]` is not allowed in a type expression
  --> praxis/backend/api/utils/crud_router_factory.py:50:43
   |
48 |     return await service.create(db=db, obj_in=obj_in)
49 |
50 |   @router.get(prefix, response_model=list[response_schema], tags=tags)
   |                                           ^^^^^^^^^^^^^^^
51 |   async def get_multi(
52 |     db: Annotated[AsyncSession, Depends(get_db)],
   |
info: rule `invalid-type-form` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
 --> praxis/backend/celery_app.py:1:6
  |
1 | from celery import Celery
  |      ^^^^^^
2 |
3 | celery_app = Celery("praxis")
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils.errors`
 --> praxis/backend/commons/dilution.py:3:6
  |
1 | from typing import Literal
2 |
3 | from praxis.utils.errors import ExperimentError
  |      ^^^^^^^^^^^^^^^^^^^
4 | from praxis.utils.sanitation import (
5 |   check_list_length,
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils.sanitation`
 --> praxis/backend/commons/dilution.py:4:6
  |
3 | from praxis.utils.errors import ExperimentError
4 | from praxis.utils.sanitation import (
  |      ^^^^^^^^^^^^^^^^^^^^^^^
5 |   check_list_length,
6 |   coerce_to_list,
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `int` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:9
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |         ^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `float` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:9
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |         ^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `int` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:30
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |                              ^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `float` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:30
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |                              ^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `int` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:51
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |                                                   ^^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `float` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:466:51
    |
464 |     if constant_dilution:
465 |       buffer_transfer_volumes = [
466 |         antigen_volumes[i] - antigen_volumes[i] / dilution_factors[i],
    |                                                   ^^^^^^^^^^^^^^^^^^^
467 |       ] * n_dilutions
468 |     else:
    |
info: rule `non-subscriptable` is enabled by default

error[missing-argument]: No arguments provided for required parameters `buffer_transfer_volumes`, `buffer_wells` of function `transfer_buffer`
   --> praxis/backend/commons/dilution.py:477:11
    |
475 |         tip_spots=buffer_tips[column_index : column_index + n_dilutions],
476 |       )
477 |       await transfer_buffer(
    |  ___________^
478 | |       liquid_handler=liquid_handler,
479 | |       buffer_reservoir=buffer_reservoir,
480 | |       target_wells=dilution_wells,
481 | |       target_plate=dilution_plate,
482 | |       buffer_volumes=buffer_transfer_volumes,
483 | |       buffer_total_volume=buffer_total_volume,
484 | |     )
    | |_____^
485 |       await liquid_handler.drop_tips(
486 |         tip_spots=buffer_tips[column_index : column_index + n_dilutions],
    |
info: Parameters declared here
   --> praxis/backend/commons/dilution.py:501:26
    |
501 |   async def transfer_buffer(
    |  __________________________^
502 | |   liquid_handler: LiquidHandler,
503 | |   buffer_reservoir: Plate,  # TODO: allow for reservoir
504 | |   target_plate: Plate,
505 | |   target_wells: int | str | list[int] | list[str] | list[Well],
506 | |   buffer_transfer_volumes: float | list[float],
507 | |   buffer_total_volume: float | list[float],
508 | |   buffer_wells: int | str | list[int] | list[str] | list[Well],
509 | |   mix_cycles: int = 0,
510 | |   mix_proportion: float = 0.5,
511 | |   mix_volumes: float | list[float] | None = None,
512 | |   single_buffer: bool = True,
513 | | ):
    | |_^
514 |     if single_buffer:
515 |       if isinstance(buffer_total_volume, list):
    |
info: rule `missing-argument` is enabled by default

error[unknown-argument]: Argument `buffer_volumes` does not match any known parameter of function `transfer_buffer`
   --> praxis/backend/commons/dilution.py:482:7
    |
480 |       target_wells=dilution_wells,
481 |       target_plate=dilution_plate,
482 |       buffer_volumes=buffer_transfer_volumes,
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
483 |       buffer_total_volume=buffer_total_volume,
484 |     )
    |
info: Function signature here
   --> praxis/backend/commons/dilution.py:501:11
    |
501 |   async def transfer_buffer(
    |  ___________^
502 | |   liquid_handler: LiquidHandler,
503 | |   buffer_reservoir: Plate,  # TODO: allow for reservoir
504 | |   target_plate: Plate,
505 | |   target_wells: int | str | list[int] | list[str] | list[Well],
506 | |   buffer_transfer_volumes: float | list[float],
507 | |   buffer_total_volume: float | list[float],
508 | |   buffer_wells: int | str | list[int] | list[str] | list[Well],
509 | |   mix_cycles: int = 0,
510 | |   mix_proportion: float = 0.5,
511 | |   mix_volumes: float | list[float] | None = None,
512 | |   single_buffer: bool = True,
513 | | ):
    | |_^
514 |     if single_buffer:
515 |       if isinstance(buffer_total_volume, list):
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `n_replicates` does not match any known parameter of function `dilution_series`
   --> praxis/backend/commons/dilution.py:494:5
    |
492 |     dilution_factors=dilution_factors,
493 |     source_plate=dilution_plate,
494 |     n_replicates=n_replicates,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
495 |     mix_cycles=mix_cycles,
496 |     source_volumes=antigen_volumes,
    |
info: Function signature here
   --> praxis/backend/commons/dilution.py:553:11
    |
553 |   async def dilution_series(
    |  ___________^
554 | |   liquid_handler: LiquidHandler,
555 | |   tips: TipRack,
556 | |   n_dilutions: int,
557 | |   dilution_factors: float | list[float],
558 | |   source_plate: Plate,  # TODO: allow for reservoir
559 | |   mix_cycles: int = 10,
560 | |   source_volumes: int | list[int] | None = None,
561 | |   target_plate: Plate | None = None,
562 | | ):
    | |_^
563 |     """Completes a dilution series. If using replicates, these are treated as separate dilution series.
564 |     Function assumes you are diluting from the top row of the source plate and diluting down the
    |
info: rule `unknown-argument` is enabled by default

error[invalid-argument-type]: Argument to function `dilution_series` is incorrect
   --> praxis/backend/commons/dilution.py:496:5
    |
494 |     n_replicates=n_replicates,
495 |     mix_cycles=mix_cycles,
496 |     source_volumes=antigen_volumes,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `int | list[int] | None`, found `int | float | list[int | float]`
497 |     target_plate=dilution_plate,
498 |   )
    |
info: Union elements `float` and `list[int | float]` are not assignable to `int | list[int] | None`
info: Function defined here
   --> praxis/backend/commons/dilution.py:553:11
    |
553 | async def dilution_series(
    |           ^^^^^^^^^^^^^^^
554 |   liquid_handler: LiquidHandler,
555 |   tips: TipRack,
    |
   ::: praxis/backend/commons/dilution.py:560:3
    |
558 |   source_plate: Plate,  # TODO: allow for reservoir
559 |   mix_cycles: int = 10,
560 |   source_volumes: int | list[int] | None = None,
    |   --------------------------------------------- Parameter declared here
561 |   target_plate: Plate | None = None,
562 | ):
    |
info: rule `invalid-argument-type` is enabled by default

error[no-matching-overload]: No overload of function `sum` matches arguments
   --> praxis/backend/commons/dilution.py:520:8
    |
518 |           "Total buffer volume variable list, but single buffer specified",
519 |         )
520 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |       raise Value("Buffer volume insufficient")
522 |   await liquid_handler.aspirate(
    |
info: First overload defined here
    --> stdlib/builtins.pyi:4337:5
     |
4335 | # Instead, we special-case the most common examples of this: bool and literal integers.
4336 | @overload
4337 | def sum(iterable: Iterable[bool | _LiteralInteger], /, start: int = 0) -> int:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4338 |     """Return the sum of a 'start' value (default: 0) plus an iterable of numbers
     |
info: Possible overloads for function `sum`:
info:   (iterable: Iterable[bool | Literal[1, 2, 3, 4, 5, ... omitted 41 literals]], /, start: int = Literal[0]) -> int
info:   (iterable: Iterable[_SupportsSumNoDefaultT@sum], /) -> _SupportsSumNoDefaultT@sum | Literal[0]
info:   (iterable: Iterable[_AddableT1@sum], /, start: _AddableT2@sum) -> _AddableT1@sum | _AddableT2@sum
info: rule `no-matching-overload` is enabled by default

error[unresolved-reference]: Name `Value` used when not defined
   --> praxis/backend/commons/dilution.py:521:13
    |
519 |         )
520 |     if sum(buffer_transfer_volumes) > buffer_total_volume:
521 |       raise Value("Buffer volume insufficient")
    |             ^^^^^
522 |   await liquid_handler.aspirate(
523 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |
info: rule `unresolved-reference` is enabled by default

error[invalid-argument-type]: Method `__getitem__` of type `bound method Plate.__getitem__(identifier: Sequence[str] | int | Sequence[int] | slice[Any, Any, Any]) -> list[Well]` cannot be called with key of type `int | str | list[int] | list[str] | list[Well]` on object of type `Plate`
   --> praxis/backend/commons/dilution.py:523:15
    |
521 |       raise Value("Buffer volume insufficient")
522 |   await liquid_handler.aspirate(
523 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |               ^^^^^^^^^^^^^^^^
524 |   )
525 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-reference]: Name `buffer_volumes` used when not defined
   --> praxis/backend/commons/dilution.py:523:52
    |
521 |       raise Value("Buffer volume insufficient")
522 |   await liquid_handler.aspirate(
523 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
    |                                                    ^^^^^^^^^^^^^^
524 |   )
525 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |
info: rule `unresolved-reference` is enabled by default

error[invalid-argument-type]: Method `__getitem__` of type `bound method Plate.__getitem__(identifier: Sequence[str] | int | Sequence[int] | slice[Any, Any, Any]) -> list[Well]` cannot be called with key of type `int | str | list[int] | list[str] | list[Well]` on object of type `Plate`
   --> praxis/backend/commons/dilution.py:525:33
    |
523 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
524 |   )
525 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |                                 ^^^^^^^^^^^^
    |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-reference]: Name `buffer_volumes` used when not defined
   --> praxis/backend/commons/dilution.py:525:66
    |
523 |     resources=buffer_reservoir[buffer_wells], vols=buffer_volumes,
524 |   )
525 |   await liquid_handler.dispense(target_plate[target_wells], vols=buffer_volumes)
    |                                                                  ^^^^^^^^^^^^^^
    |
info: rule `unresolved-reference` is enabled by default

error[missing-argument]: No arguments provided for required parameters `source`, `targets` of bound method `transfer`
   --> praxis/backend/commons/dilution.py:543:11
    |
541 |     for i in range(n_columns):
542 |       liquid_handler.pick_up_tips(tip_spots=tips[i * n_columns])
543 |       await liquid_handler.transfer(
    |  ___________^
544 | |       source_plate=source_plate,
545 | |       source_well=i,
546 | |       target_plate=target_plate,
547 | |       target_well=i,
548 | |       volume=source_plate.well_volume(i),
549 | |     )
    | |_____^
550 |       liquid_handler.drop_tips(tip_spots=tips[i * n_columns])
    |
info: Parameters declared here
    --> .venv/lib/python3.13/site-packages/pylabrobot/liquid_handling/liquid_handler.py:1247:21
     |
1245 |         raise error
1246 |
1247 |     async def transfer(
     |  _____________________^
1248 | |     self,
1249 | |     source: Well,
1250 | |     targets: List[Well],
1251 | |     source_vol: Optional[float] = None,
1252 | |     ratios: Optional[List[float]] = None,
1253 | |     target_vols: Optional[List[float]] = None,
1254 | |     aspiration_flow_rate: Optional[float] = None,
1255 | |     dispense_flow_rates: Optional[List[Optional[float]]] = None,
1256 | |     **backend_kwargs,
1257 | |   ):
     | |___^
1258 |       """Transfer liquid from one well to another.
     |
info: rule `missing-argument` is enabled by default

error[unresolved-attribute]: Object of type `Plate` has no attribute `well_volume`
   --> praxis/backend/commons/dilution.py:548:14
    |
546 |       target_plate=target_plate,
547 |       target_well=i,
548 |       volume=source_plate.well_volume(i),
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
549 |     )
550 |     liquid_handler.drop_tips(tip_spots=tips[i * n_columns])
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-reference]: Name `n_replicates` used when not defined
   --> praxis/backend/commons/dilution.py:579:70
    |
578 |   """
579 |   if isinstance(dilution_factors, list) and len(dilution_factors) != n_replicates:
    |                                                                      ^^^^^^^^^^^^
580 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
581 |   if isinstance(source_volumes, int):
    |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `n_replicates` used when not defined
   --> praxis/backend/commons/dilution.py:582:41
    |
580 |     raise ExperimentError("Number of dilutions does not match with dilution factors.")
581 |   if isinstance(source_volumes, int):
582 |     source_volumes = [source_volumes] * n_replicates
    |                                         ^^^^^^^^^^^^
583 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
584 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
    |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `n_replicates` used when not defined
   --> praxis/backend/commons/dilution.py:583:66
    |
581 |   if isinstance(source_volumes, int):
582 |     source_volumes = [source_volumes] * n_replicates
583 |   if isinstance(source_volumes, list) and len(source_volumes) != n_replicates:
    |                                                                  ^^^^^^^^^^^^
584 |     raise ExperimentError("Number of dilutions does not match with source volumes.")
585 |   if not liquid_handler.setup_finished:
    |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `n_replicates` used when not defined
   --> praxis/backend/commons/dilution.py:591:6
    |
589 |       "Number of dilutions exceeds number of wells per column in plate.",
590 |     )
591 |   if n_replicates > source_plate.num_items_x:
    |      ^^^^^^^^^^^^
592 |     raise ExperimentError(
593 |       "Number of replicates exceeds number of wells per row in plate.",
    |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `n_replicates` used when not defined
   --> praxis/backend/commons/dilution.py:604:18
    |
602 |       target_plate=target_plate,
603 |     )
604 |   for i in range(n_replicates):
    |                  ^^^^^^^^^^^^
605 |     well_number = i * target_plate.num_items_y
606 |     if source_volumes:
    |
info: rule `unresolved-reference` is enabled by default

error[unresolved-attribute]: Object of type `Plate` has no attribute `well_volume`
   --> praxis/backend/commons/dilution.py:609:23
    |
607 |       source_volume = source_volumes[i]
608 |     else:
609 |       source_volume = source_plate.well_volume(i * source_plate.num_items_y)
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^
610 |     await liquid_handler.pick_up_tips(tips[well_number])
611 |     for j in range(n_dilutions):
    |
info: rule `unresolved-attribute` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `int` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:613:41
    |
611 |     for j in range(n_dilutions):
612 |       well_number = well_number + j
613 |       transfer_volume = source_volume / dilution_factors[i]
    |                                         ^^^^^^^^^^^^^^^^^^^
614 |       await liquid_handler.aspirate(
615 |         target_plate[well_number],
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `float` with no `__getitem__` method
   --> praxis/backend/commons/dilution.py:613:41
    |
611 |     for j in range(n_dilutions):
612 |       well_number = well_number + j
613 |       transfer_volume = source_volume / dilution_factors[i]
    |                                         ^^^^^^^^^^^^^^^^^^^
614 |       await liquid_handler.aspirate(
615 |         target_plate[well_number],
    |
info: rule `non-subscriptable` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils`
 --> praxis/backend/commons/liquid_handling.py:4:6
  |
2 | from typing import Literal
3 |
4 | from praxis.utils import (
  |      ^^^^^^^^^^^^
5 |   check_list_length,
6 |   coerce_to_list,
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> praxis/backend/commons/liquid_handling.py:36:18
   |
34 |     raise ValueError("Invalid well type.")
35 |   if all(isinstance(resource, Plate) for resource in resources):
36 |     return [list(resource) for resource in resources]
   |                  ^^^^^^^^ Expected `Iterable[Unknown]`, found `Container`
37 |   if all(isinstance(resource, Well) for resource in resources):
38 |     columns = [(await parse_well_name(well))[0] for well in wells]
   |
info: Matching overload defined here
    --> stdlib/builtins.pyi:2812:9
     |
2810 |     def __init__(self) -> None: ...
2811 |     @overload
2812 |     def __init__(self, iterable: Iterable[_T], /) -> None: ...
     |         ^^^^^^^^       ---------------------- Parameter declared here
2813 |     def copy(self) -> list[_T]:
2814 |         """Return a shallow copy of the list."""
     |
info: Non-matching overloads for bound method `__init__`:
info:   (self) -> None
info: rule `invalid-argument-type` is enabled by default

error[unresolved-reference]: Name `parse_well_name` used when not defined
  --> praxis/backend/commons/liquid_handling.py:38:23
   |
36 |     return [list(resource) for resource in resources]
37 |   if all(isinstance(resource, Well) for resource in resources):
38 |     columns = [(await parse_well_name(well))[0] for well in wells]
   |                       ^^^^^^^^^^^^^^^
39 |   return [
40 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `wells` used when not defined
  --> praxis/backend/commons/liquid_handling.py:38:61
   |
36 |     return [list(resource) for resource in resources]
37 |   if all(isinstance(resource, Well) for resource in resources):
38 |     columns = [(await parse_well_name(well))[0] for well in wells]
   |                                                             ^^^^^
39 |   return [
40 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `wells` used when not defined
  --> praxis/backend/commons/liquid_handling.py:40:44
   |
38 |     columns = [(await parse_well_name(well))[0] for well in wells]
39 |   return [
40 |     [well for column, well in zip(columns, wells, strict=False) if column == i]
   |                                            ^^^^^
41 |     for i in range(max(columns) + 1)
42 |   ]
   |
info: rule `unresolved-reference` is enabled by default

error[missing-argument]: No arguments provided for required parameters `resources`, `vols`
   --> praxis/backend/commons/liquid_handling.py:228:9
    |
226 |     resource=source, volume=volume,
227 |   )  # TODO: add mix_cycles to aspirate96 and dispense96 and allow for resource to be any container of appropriate size
228 |   await liquid_handler.dispense(resource=target, volume=volume)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |   if return_tips:
230 |     await liquid_handler.drop_tips(tip_spots=transfer_tips)
    |
info: Union variant `(resources: Sequence[Container], vols: list[int | float], use_channels: list[int] | None = None, flow_rates: list[int | float | None] | None = None, offsets: list[Coordinate] | None = None, liquid_height: list[int | float | None] | None = None, blow_out_air_volume: list[int | float | None] | None = None, spread: Literal["wide", "tight", "custom"] = Literal["wide"], mix: list[Mix] | None = None, **backend_kwargs) -> Unknown` is incompatible with this call site
info: Attempted to call union type `((resources: Sequence[Container], vols: list[int | float], use_channels: list[int] | None = None, flow_rates: list[int | float | None] | None = None, offsets: list[Coordinate] | None = None, liquid_height: list[int | float | None] | None = None, blow_out_air_volume: list[int | float | None] | None = None, spread: Literal["wide", "tight", "custom"] = Literal["wide"], mix: list[Mix] | None = None, **backend_kwargs) -> Unknown) | ((resources: Divergent, vols: Divergent, use_channels: Divergent = Divergent, flow_rates: Divergent = Divergent, offsets: Divergent = Divergent, liquid_height: Divergent = Divergent, blow_out_air_volume: Divergent = Divergent, spread: Divergent = Divergent, mix: Divergent = Divergent, **backend_kwargs) -> Unknown)`
info: rule `missing-argument` is enabled by default

error[missing-argument]: No arguments provided for required parameters `resources`, `vols`
   --> praxis/backend/commons/liquid_handling.py:228:9
    |
226 |     resource=source, volume=volume,
227 |   )  # TODO: add mix_cycles to aspirate96 and dispense96 and allow for resource to be any container of appropriate size
228 |   await liquid_handler.dispense(resource=target, volume=volume)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |   if return_tips:
230 |     await liquid_handler.drop_tips(tip_spots=transfer_tips)
    |
info: Union variant `(resources: Divergent, vols: Divergent, use_channels: Divergent = Divergent, flow_rates: Divergent = Divergent, offsets: Divergent = Divergent, liquid_height: Divergent = Divergent, blow_out_air_volume: Divergent = Divergent, spread: Divergent = Divergent, mix: Divergent = Divergent, **backend_kwargs) -> Unknown` is incompatible with this call site
info: Attempted to call union type `((resources: Sequence[Container], vols: list[int | float], use_channels: list[int] | None = None, flow_rates: list[int | float | None] | None = None, offsets: list[Coordinate] | None = None, liquid_height: list[int | float | None] | None = None, blow_out_air_volume: list[int | float | None] | None = None, spread: Literal["wide", "tight", "custom"] = Literal["wide"], mix: list[Mix] | None = None, **backend_kwargs) -> Unknown) | ((resources: Divergent, vols: Divergent, use_channels: Divergent = Divergent, flow_rates: Divergent = Divergent, offsets: Divergent = Divergent, liquid_height: Divergent = Divergent, blow_out_air_volume: Divergent = Divergent, spread: Divergent = Divergent, mix: Divergent = Divergent, **backend_kwargs) -> Unknown)`
info: rule `missing-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/commons/liquid_handling.py:230:36
    |
228 |   await liquid_handler.dispense(resource=target, volume=volume)
229 |   if return_tips:
230 |     await liquid_handler.drop_tips(tip_spots=transfer_tips)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^ Expected `Sequence[TipSpot | Trash]`, found `TipRack`
    |
info: Union variant `(tip_spots: Sequence[TipSpot | Trash], use_channels: list[int] | None = None, offsets: list[Coordinate] | None = None, allow_nonzero_volume: bool = Literal[False], **backend_kwargs) -> Unknown` is incompatible with this call site
info: Attempted to call union type `((tip_spots: Sequence[TipSpot | Trash], use_channels: list[int] | None = None, offsets: list[Coordinate] | None = None, allow_nonzero_volume: bool = Literal[False], **backend_kwargs) -> Unknown) | ((tip_spots: Divergent, use_channels: Divergent = Divergent, offsets: Divergent = Divergent, allow_nonzero_volume: Divergent = Divergent, **backend_kwargs) -> Unknown)`
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.protocol.standalone_task`
 --> praxis/backend/commons/plate_reading.py:3:6
  |
1 | import datetime
2 |
3 | from praxis.protocol.standalone_task import (
  |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 |   StandaloneTask,
5 | )  # Assuming it's in the same protocol submodule
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-reference]: Name `asyncio` used when not defined
  --> praxis/backend/commons/plate_reading.py:58:11
   |
56 |       f"Performing {self.measurement_type} on plate {self.plate_name} for wells {self.wells}.",
57 |     )
58 |     await asyncio.sleep(self.estimated_duration)  # Simulate time taken for operation
   |           ^^^^^^^
59 |     print(f"Finished {self.measurement_type} on plate {self.plate_name}.")
   |
info: An attribute `asyncio` is available: consider using `self.asyncio`
info: rule `unresolved-reference` is enabled by default

error[unresolved-reference]: Name `json` used when not defined
  --> praxis/backend/commons/plate_reading.py:73:11
   |
71 |           self.plate_name,
72 |           self.measurement_type,
73 |           json.dumps(self.wells),
   |           ^^^^
74 |           datetime.datetime.now(),
75 |         ),
   |
info: An attribute `json` is available: consider using `self.json`
info: rule `unresolved-reference` is enabled by default

error[unresolved-import]: Cannot resolve imported module `numpy`
 --> praxis/backend/commons/plate_staging.py:3:8
  |
1 | from typing import Literal
2 |
3 | import numpy as np
  |        ^^^^^^^^^^^
4 | from praxis.utils.errors import ExperimentError
5 | from praxis.utils.sanitation import liquid_handler_setup_check, parse_well_name
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils.errors`
 --> praxis/backend/commons/plate_staging.py:4:6
  |
3 | import numpy as np
4 | from praxis.utils.errors import ExperimentError
  |      ^^^^^^^^^^^^^^^^^^^
5 | from praxis.utils.sanitation import liquid_handler_setup_check, parse_well_name
6 | from pylabrobot.liquid_handling import LiquidHandler
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils.sanitation`
 --> praxis/backend/commons/plate_staging.py:5:6
  |
3 | import numpy as np
4 | from praxis.utils.errors import ExperimentError
5 | from praxis.utils.sanitation import liquid_handler_setup_check, parse_well_name
  |      ^^^^^^^^^^^^^^^^^^^^^^^
6 | from pylabrobot.liquid_handling import LiquidHandler
7 | from pylabrobot.liquid_handling.standard import GripDirection
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Module `pylabrobot.resources` has no member `CarrierSite`
  --> praxis/backend/commons/plate_staging.py:9:34
   |
 7 | from pylabrobot.liquid_handling.standard import GripDirection
 8 | from pylabrobot.plate_reading import PlateReader
 9 | from pylabrobot.resources import CarrierSite, Coordinate, Plate, TipRack, Well
   |                                  ^^^^^^^^^^^
10 | from pylabrobot.resources.errors import ResourceNotFoundError
   |
info: rule `unresolved-import` is enabled by default

error[invalid-argument-type]: Argument to bound method `get_quadrant` is incorrect
   --> praxis/backend/commons/plate_staging.py:148:50
    |
146 |         await liquid_handler.pick_up_tips96(tip_rack=tips)
147 |       for i in range(n_replicates):
148 |         target_wells = target_plate.get_quadrant(i + 1)
    |                                                  ^^^^^ Expected `Literal["tl", "top_left", "tr", "top_right", "bl", ... omitted 3 literals]`, found `int`
149 |         await liquid_handler.aspirate96(resource=source_plate, volume=transfer_volume)
150 |         await liquid_handler.dispense96(resource=target_wells, volume=transfer_volume)
    |
info: Method defined here
   --> .venv/lib/python3.13/site-packages/pylabrobot/resources/plate.py:226:7
    |
224 |         well.tracker.enable()
225 |
226 |     def get_quadrant(
    |         ^^^^^^^^^^^^
227 |       self,
228 | /     quadrant: Literal[
229 | |       "tl", "top_left", "tr", "top_right", "bl", "bottom_left", "br", "bottom_right"
230 | |     ],
    | |_____- Parameter declared here
231 |       quadrant_type: Literal["block", "checkerboard"] = "checkerboard",
232 |       quadrant_internal_fill_order: Literal["column-major", "row-major"] = "column-major",
    |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `praxis.utils.sanitation`
 --> praxis/backend/commons/tip_staging.py:1:6
  |
1 | from praxis.utils.sanitation import parse_well_name
  |      ^^^^^^^^^^^^^^^^^^^^^^^
2 | from pylabrobot.liquid_handling import LiquidHandler
3 | from pylabrobot.resources import Plate, TipRack, Well
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
 --> praxis/backend/core/celery.py:7:6
  |
5 | """
6 |
7 | from celery import Celery
  |      ^^^^^^
8 |
9 | # Global, unconfigured Celery app instance for decorators
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
 --> praxis/backend/core/celery_base.py:5:6
  |
3 | from typing import TYPE_CHECKING
4 |
5 | from celery import Task
  |      ^^^^^^
6 |
7 | if TYPE_CHECKING:
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery.utils.log`
  --> praxis/backend/core/celery_tasks.py:16:6
   |
14 | from typing import TYPE_CHECKING, Any
15 |
16 | from celery.utils.log import get_task_logger
   |      ^^^^^^^^^^^^^^^^
17 | from dependency_injector.wiring import Provide, inject
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
  --> praxis/backend/core/celery_tasks.py:28:8
   |
26 |   import uuid
27 |
28 |   from celery import Task
   |        ^^^^^^
29 |   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis.asyncio`
  --> praxis/backend/core/container.py:10:8
   |
 8 | """
 9 |
10 | import redis.asyncio as redis
   |        ^^^^^^^^^^^^^^^^^^^^^^
11 | from celery import Celery
12 | from dependency_injector import containers, providers
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
  --> praxis/backend/core/container.py:11:6
   |
10 | import redis.asyncio as redis
11 | from celery import Celery
   |      ^^^^^^
12 | from dependency_injector import containers, providers
13 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

warning[invalid-ignore-comment]: Invalid `type: ignore` comment: no whitespace after `ignore`
   --> praxis/backend/core/container.py:132:30
    |
130 |   # as a context manager to create and close the session.
131 |   # `pyright` struggles to infer the provided type from the Resource provider,
132 |   # so we use `# type: ignore` to suppress the incorrect error.
    |                              ^
133 |   db_session: providers.Provider[AsyncSession] = providers.Resource(
134 |     db_session_factory,
    |

error[unresolved-attribute]: Object of type `(...) -> Unknown` has no attribute `__name__`
  --> praxis/backend/core/decorators/definition_builder.py:20:32
   |
18 | ) -> tuple[FunctionProtocolDefinitionCreate, dict[str, Any] | None]:
19 |   """Parse a function signature and decorator args to create a protocol definition."""
20 |   resolved_name = data.name or data.func.__name__
   |                                ^^^^^^^^^^^^^^^^^^
21 |   if not resolved_name:
22 |     msg = (
   |
info: rule `unresolved-attribute` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> praxis/backend/core/decorators/definition_builder.py:73:5
   |
72 |   protocol_definition = FunctionProtocolDefinitionCreate(
73 |     accession_id=uuid7(),
   |     ^^^^^^^^^^^^^^^^^^^^
74 |     name=resolved_name,
75 |     version=data.version,
   |
info: rule `unknown-argument` is enabled by default

error[unresolved-attribute]: Object of type `(...) -> Unknown` has no attribute `__name__`
  --> praxis/backend/core/decorators/definition_builder.py:80:19
   |
78 |     source_file_path=inspect.getfile(data.func),
79 |     module_name=data.func.__module__,
80 |     function_name=data.func.__name__,
   |                   ^^^^^^^^^^^^^^^^^^
81 |     is_top_level=data.is_top_level,
82 |     solo_execution=data.solo,
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `(...) -> Unknown` has no attribute `__qualname__`
  --> praxis/backend/core/decorators/models.py:81:31
   |
80 |   """
81 |   return f"{func.__module__}.{func.__qualname__}"
   |                               ^^^^^^^^^^^^^^^^^
   |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `UUID`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `str`, and 4 more union elements, are not assignable to `UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 4 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 4 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 4 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `bool`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 4 more union elements, are not assignable to `bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 3 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 3 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `AssetConstraintsModel`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 5 more union elements, are not assignable to `AssetConstraintsModel`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:63:46
   |
61 |       "ui_hints": p_ui_hints,
62 |     }
63 |     assets_list.append(AssetRequirementModel(**asset_args))
   |                                              ^^^^^^^^^^^^ Expected `LocationConstraintsModel`, found `Unknown | UUID | str | ... omitted 4 union elements`
64 |   else:
65 |     param_args = {
   |
info: Union element `UUID`, and 5 more union elements, are not assignable to `LocationConstraintsModel`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `bool`, and 3 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `bool`, and 3 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `bool`, and 3 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `bool`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `str`, and 3 more union elements, are not assignable to `bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `bool`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `str`, and 3 more union elements, are not assignable to `bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `str | None`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `str | None`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `ParameterConstraintsModel`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `str`, and 4 more union elements, are not assignable to `ParameterConstraintsModel`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> praxis/backend/core/decorators/parameter_processor.py:91:51
   |
89 |         "expects_dict": is_dict_type_match,
90 |       }
91 |     parameters_list.append(ParameterMetadataModel(**param_args))
   |                                                   ^^^^^^^^^^^^ Expected `UIHint | None`, found `Unknown | str | bool | ... omitted 3 union elements`
92 |
93 |   return parameters_list, assets_list, found_deck_param, found_state_param_details
   |
info: Union element `str`, and 2 more union elements, are not assignable to `UIHint | None`
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Object of type `(...) -> Unknown` has no attribute `__code__`
  --> praxis/backend/core/decorators/protocol_decorator.py:70:41
   |
68 |   if (
69 |     "__praxis_run_context__" in processed_kwargs_for_call
70 |     and "__praxis_run_context__" not in func.__code__.co_varnames
   |                                         ^^^^^^^^^^^^^
71 |     and not any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig_check.parameters.values())
72 |   ):
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `(...) -> Unknown` has no attribute `_protocol_runtime_info`
   --> praxis/backend/core/decorators/protocol_decorator.py:233:22
    |
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |       protocol_unique_key = (
235 |         f"{current_meta.pydantic_definition.name}_v{current_meta.pydantic_definition.version}"
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-overload]: Overloaded function `open` requires at least two overloads
  --> praxis/backend/core/filesystem.py:24:7
   |
22 |   ) -> IO[Any]: ...
23 |
24 |   def open(self, *args: Any, **kwargs: Any) -> IO[Any]:
   |       ^^^^
25 |     """Open a file and return a file object."""
26 |     return open(*args, **kwargs)  # noqa: SIM115
   |
  ::: praxis/backend/core/filesystem.py:12:7
   |
11 |   @overload
12 |   def open(
   |       ---- Only one overload defined here
13 |     self,
14 |     file: str | bytes | int,
   |
info: rule `invalid-overload` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:30:17
   |
28 |   def exists(self, path: str | bytes | int) -> bool:
29 |     """Return True if path refers to an existing path."""
30 |     return Path(path).exists()
   |                 ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
31 |
32 |   def isdir(self, path: str | bytes | int) -> bool:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:34:17
   |
32 |   def isdir(self, path: str | bytes | int) -> bool:
33 |     """Return True if path is an existing directory."""
34 |     return Path(path).is_dir()
   |                 ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
35 |
36 |   def listdir(self, path: str | bytes | int | None = None) -> list[str]:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:40:40
   |
38 |     if path is None:
39 |       path = "."
40 |     return [item.name for item in Path(path).iterdir()]
   |                                        ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
41 |
42 |   def mkdir(self, path: str | bytes | int, mode: int = 0o777) -> None:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:44:10
   |
42 |   def mkdir(self, path: str | bytes | int, mode: int = 0o777) -> None:
43 |     """Create a directory named path with numeric mode mode."""
44 |     Path(path).mkdir(mode=mode)
   |          ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
45 |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:48:10
   |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
47 |     """Create a directory named path with numeric mode mode."""
48 |     Path(path).mkdir(mode=mode, parents=True, exist_ok=exist_ok)
   |          ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
49 |
50 |   def remove(self, path: str | bytes | int) -> None:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:52:10
   |
50 |   def remove(self, path: str | bytes | int) -> None:
51 |     """Remove (delete) the file path."""
52 |     Path(path).unlink()
   |          ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
53 |
54 |   def rmdir(self, path: str | bytes | int) -> None:
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --> praxis/backend/core/filesystem.py:56:10
   |
54 |   def rmdir(self, path: str | bytes | int) -> None:
55 |     """Remove (delete) the directory path."""
56 |     Path(path).rmdir()
   |          ^^^^ Expected `str | PathLike[str]`, found `str | bytes | int`
   |
info: Union elements `bytes` and `int` are not assignable to `str | PathLike[str]`
info: Function defined here
   --> stdlib/pathlib/__init__.pyi:299:13
    |
297 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]
298 |     else:
299 |         def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...
    |             ^^^^^^^      -------------- Parameter declared here
300 |
301 |     @classmethod
    |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `read_deck_by_name`
   --> praxis/backend/core/orchestrator/asset_acquisition.py:125:35
    |
123 |         deck_config_orm_accession_id_to_apply: uuid.UUID | None = None
124 |         if isinstance(deck_accession_identifier_from_user, str):
125 |           deck_config_orm = await svc.read_deck_by_name(
    |                                   ^^^^^^^^^^^^^^^^^^^^^
126 |             db_session,
127 |             deck_accession_identifier_from_user,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/error_handling.py:115:11
    |
113 |       )
114 |
115 |     await svc.update_run_status(
    |           ^^^^^^^^^^^^^^^^^^^^^
116 |       db_session,
117 |       run_accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
  --> praxis/backend/core/orchestrator/execution.py:59:13
   |
57 |       logger.info("ORCH: Run %s PAUSED before execution.", run_accession_id)
58 |       await clear_control_command(run_accession_id)
59 |       await svc.update_run_status(
   |             ^^^^^^^^^^^^^^^^^^^^^
60 |         db_session,
61 |         protocol_run_orm.accession_id,
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
  --> praxis/backend/core/orchestrator/execution.py:71:17
   |
69 |           logger.info("ORCH: Run %s RESUMING.", run_accession_id)
70 |           await clear_control_command(run_accession_id)
71 |           await svc.update_run_status(
   |                 ^^^^^^^^^^^^^^^^^^^^^
72 |             db_session,
73 |             protocol_run_orm.accession_id,
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
  --> praxis/backend/core/orchestrator/execution.py:81:17
   |
79 |           logger.info("ORCH: Run %s CANCELLED during pause.", run_accession_id)
80 |           await clear_control_command(run_accession_id)
81 |           await svc.update_run_status(
   |                 ^^^^^^^^^^^^^^^^^^^^^
82 |             db_session,
83 |             protocol_run_orm.accession_id,
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
  --> praxis/backend/core/orchestrator/execution.py:93:13
   |
91 |       logger.info("ORCH: Run %s CANCELLED before execution.", run_accession_id)
92 |       await clear_control_command(run_accession_id)
93 |       await svc.update_run_status(
   |             ^^^^^^^^^^^^^^^^^^^^^
94 |         db_session,
95 |         protocol_run_orm.accession_id,
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `create_protocol_run`
   --> praxis/backend/core/orchestrator/execution.py:222:35
    |
221 |       # Create protocol run record
222 |       protocol_run_db_obj = await svc.create_protocol_run(
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^
223 |         db=db_session,
224 |         run_accession_id=run_accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/execution.py:247:15
    |
245 |       await db_session.refresh(protocol_run_db_obj)
246 |       if protocol_run_db_obj.status == ProtocolRunStatusEnum.PREPARING:
247 |         await svc.update_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^
248 |           db_session,
249 |           protocol_run_db_obj.accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/execution.py:266:15
    |
264 |           db_session,
265 |         )
266 |         await svc.update_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^
267 |           db_session,
268 |           protocol_run_db_obj.accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/execution.py:333:15
    |
331 |         error_msg = f"Protocol definition not found for run {run_accession_id}"
332 |         logger.error(error_msg)
333 |         await svc.update_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^
334 |           db_session,
335 |           run_accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/execution.py:366:15
    |
364 |         ProtocolRunStatusEnum.QUEUED,
365 |       ]:
366 |         await svc.update_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^
367 |           db_session,
368 |           protocol_run_orm.accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `update_run_status`
   --> praxis/backend/core/orchestrator/execution.py:385:15
    |
383 |           db_session,
384 |         )
385 |         await svc.update_run_status(
    |               ^^^^^^^^^^^^^^^^^^^^^
386 |           db_session,
387 |           protocol_run_orm.accession_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Module `praxis.backend.services` has no member `read_protocol_definition_by_name`
  --> praxis/backend/core/orchestrator/protocol_preparation.py:48:18
   |
46 |       source_name,
47 |     )
48 |     return await svc.read_protocol_definition_by_name(
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |       db=db_session,
50 |       name=protocol_name,
   |
info: rule `unresolved-attribute` is enabled by default

error[invalid-await]: `None` is not awaitable
   --> praxis/backend/core/orchestrator/protocol_preparation.py:86:11
    |
 85 |       current_workcell_snapshot = self.workcell_runtime.get_state_snapshot()
 86 |       await praxis_state.set(
    |  ___________^
 87 | |       "workcell_last_successful_snapshot",
 88 | |       current_workcell_snapshot,
 89 | |     )
    | |_____^
 90 |       logger.debug(
 91 |         "Workcell state snapshot captured and stored in PraxisState for run %s.",
    |
   ::: stdlib/types.pyi:950:11
    |
948 |   if sys.version_info >= (3, 10):
949 |       @final
950 |       class NoneType:
    |             -------- type defined here
951 |           """The type of the None singleton."""
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:131:9
    |
129 |       process = await asyncio.to_thread(
130 |         subprocess.run,
131 |         command,
    |         ^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `list[str]`
132 |         cwd=cwd,
133 |         check=True,
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                            -------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:132:9
    |
130 |         subprocess.run,
131 |         command,
132 |         cwd=cwd,
    |         ^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `str`
133 |         check=True,
134 |         capture_output=True,
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                                            ------------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:133:9
    |
131 |         command,
132 |         cwd=cwd,
133 |         check=True,
    |         ^^^^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `Literal[True]`
134 |         capture_output=True,
135 |         text=True,
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                                            ------------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:134:9
    |
132 |         cwd=cwd,
133 |         check=True,
134 |         capture_output=True,
    |         ^^^^^^^^^^^^^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `Literal[True]`
135 |         text=True,
136 |         timeout=timeout,
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                                            ------------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:135:9
    |
133 |         check=True,
134 |         capture_output=True,
135 |         text=True,
    |         ^^^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `Literal[True]`
136 |         timeout=timeout,
137 |       )
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                                            ------------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `to_thread` is incorrect
   --> praxis/backend/core/protocol_code_manager.py:136:9
    |
134 |         capture_output=True,
135 |         text=True,
136 |         timeout=timeout,
    |         ^^^^^^^^^^^^^^^ Expected `Overload[(args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: Literal[True], timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, *, universal_newlines: Literal[True], startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: Literal[False] | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: None = None, errors: None = None, input: Buffer | None = None, text: Literal[False] | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown, (args: Sequence[str | bytes | PathLike[str] | PathLike[bytes]] | bytes | PathLike[str] | PathLike[bytes], bufsize: int = Literal[-1], executable: str | bytes | PathLike[str] | PathLike[bytes] | None = None, stdin: None | int | IO[Any] = None, stdout: None | int | IO[Any] = None, stderr: None | int | IO[Any] = None, preexec_fn: (() -> Any) | None = None, close_fds: bool = Literal[True], shell: bool = Literal[False], cwd: str | bytes | PathLike[str] | PathLike[bytes] | None = None, env: Mapping[bytes, str | bytes | PathLike[str] | PathLike[bytes]] | Mapping[str, str | bytes | PathLike[str] | PathLike[bytes]] | None = None, universal_newlines: bool | None = None, startupinfo: Any = None, creationflags: int = Literal[0], restore_signals: bool = Literal[True], start_new_session: bool = Literal[False], pass_fds: Collection[int] = tuple[()], *, capture_output: bool = Literal[False], check: bool = Literal[False], encoding: str | None = None, errors: str | None = None, input: Buffer | str | None = None, text: bool | None = None, timeout: int | float | None = None, user: str | int | None = None, group: str | int | None = None, extra_groups: Iterable[str | int] | None = None, umask: int = Literal[-1], pipesize: int = Literal[-1]) -> Unknown]`, found `int`
137 |       )
138 |       if not suppress_output:
    |
info: Function defined here
  --> stdlib/asyncio/threads.pyi:12:11
   |
10 | _R = TypeVar("_R")
11 |
12 | async def to_thread(func: Callable[_P, _R], /, *args: _P.args, **kwargs: _P.kwargs) -> _R:
   |           ^^^^^^^^^                                            ------------------- Parameter declared here
13 |     """Asynchronously run function *func* in a separate thread.
   |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Object of type `FunctionProtocolDefinitionCreate` has no attribute `accession_id`
   --> praxis/backend/core/protocol_code_manager.py:498:13
    |
497 |       if protocol_def_orm.accession_id and (
498 |         not pydantic_def.accession_id or pydantic_def.accession_id != protocol_def_orm.accession_id
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^
499 |       ):
500 |         pydantic_def.accession_id = protocol_def_orm.accession_id
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `FunctionProtocolDefinitionCreate` has no attribute `accession_id`
   --> praxis/backend/core/protocol_code_manager.py:498:42
    |
497 |       if protocol_def_orm.accession_id and (
498 |         not pydantic_def.accession_id or pydantic_def.accession_id != protocol_def_orm.accession_id
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
499 |       ):
500 |         pydantic_def.accession_id = protocol_def_orm.accession_id
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Unresolved attribute `accession_id` on type `FunctionProtocolDefinitionCreate`.
   --> praxis/backend/core/protocol_code_manager.py:500:9
    |
498 |         not pydantic_def.accession_id or pydantic_def.accession_id != protocol_def_orm.accession_id
499 |       ):
500 |         pydantic_def.accession_id = protocol_def_orm.accession_id
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
501 |         logger.debug(
502 |           "Updated Pydantic definition DB ID for '%s' to %s",
    |
info: rule `unresolved-attribute` is enabled by default

error[unknown-argument]: Argument `source_name` does not match any known parameter of bound method `get_by_name`
   --> praxis/backend/core/protocol_execution_service.py:100:9
    |
 98 |         name=protocol_name,
 99 |         version=protocol_version,
100 |         source_name=source_name,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
101 |         commit_hash=commit_hash,
102 |       )
    |
info: Union variant `bound method ProtocolDefinitionCRUDService.get_by_name(db: AsyncSession, name: str, version: str | None = None, commit_hash: str | None = None) -> CoroutineType[Any, Any, FunctionProtocolDefinitionOrm | None]` is incompatible with this call site
info: Attempted to call union type `Unknown | (bound method ProtocolDefinitionCRUDService.get_by_name(db: AsyncSession, name: str, version: str | None = None, commit_hash: str | None = None) -> CoroutineType[Any, Any, FunctionProtocolDefinitionOrm | None])`
info: rule `unknown-argument` is enabled by default

warning[redundant-cast]: Value is already of type `UUID`
  --> praxis/backend/core/workcell_runtime/deck_manager.py:92:33
   |
90 |     match inferred_target_type:
91 |       case "deck_orm_accession_id":
92 |         deck_orm_accession_id = cast("uuid.UUID", target)
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
93 |         target_deck = runtime.get_active_deck(deck_orm_accession_id)
94 |       case "machine_orm_accession_id":
   |
info: rule `redundant-cast` is enabled by default

warning[redundant-cast]: Value is already of type `UUID`
  --> praxis/backend/core/workcell_runtime/deck_manager.py:95:36
   |
93 |         target_deck = runtime.get_active_deck(deck_orm_accession_id)
94 |       case "machine_orm_accession_id":
95 |         machine_orm_accession_id = cast("uuid.UUID", target)
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
96 |         target_machine = runtime.get_active_machine(machine_orm_accession_id)
97 |         target_deck = getattr(target_machine, "deck", None)
   |
info: rule `redundant-cast` is enabled by default

error[unresolved-attribute]: Object of type `ResourceOrm & ~AlwaysFalsy` has no attribute `machine_counterpart_accession_id`
  --> praxis/backend/core/workcell_runtime/machine_manager.py:60:11
   |
58 |       and machine_orm.resource_counterpart
59 |       and machine_orm.resource_counterpart.is_machine
60 |       and machine_orm.resource_counterpart.machine_counterpart_accession_id
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |       == machine_orm.accession_id
62 |     ):
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `ResourceOrm & ~AlwaysFalsy` has no attribute `machine_counterpart_accession_id`
   --> praxis/backend/core/workcell_runtime/machine_manager.py:188:11
    |
186 |       and machine_orm.resource_counterpart
187 |       and machine_orm.resource_counterpart.is_machine
188 |       and machine_orm.resource_counterpart.machine_counterpart_accession_id
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
189 |       == machine_orm.accession_id
190 |     ):
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `MachineOrm & ~AlwaysFalsy` has no attribute `machine_counterpart_accession_id`
  --> praxis/backend/core/workcell_runtime/resource_manager.py:58:11
   |
56 |       and resource_orm.machine_counterpart
57 |       and resource_orm.machine_counterpart.is_resource
58 |       and resource_orm.machine_counterpart.machine_counterpart_accession_id
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
59 |       == resource_orm.accession_id
60 |     ):
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `MachineOrm & ~AlwaysFalsy` has no attribute `machine_counterpart_accession_id`
   --> praxis/backend/core/workcell_runtime/resource_manager.py:133:11
    |
131 |       and resource_orm.machine_counterpart
132 |       and resource_orm.machine_counterpart.is_resource
133 |       and resource_orm.machine_counterpart.machine_counterpart_accession_id
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
134 |       == resource_orm.accession_id
135 |     ):
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `Path` has no attribute `endswith`
   --> praxis/backend/services/discovery_service.py:142:14
    |
140 |       for root, _, files in os.walk(abs_path_item):
141 |         for file in files:
142 |           if file.endswith(".py") and not file.startswith("_"):
    |              ^^^^^^^^^^^^^
143 |             module_file_path = Path(root) / file
144 |             module_name = ".".join(
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `Path` has no attribute `startswith`
   --> praxis/backend/services/discovery_service.py:142:43
    |
140 |       for root, _, files in os.walk(abs_path_item):
141 |         for file in files:
142 |           if file.endswith(".py") and not file.startswith("_"):
    |                                           ^^^^^^^^^^^^^^^
143 |             module_file_path = Path(root) / file
144 |             module_name = ".".join(
    |
info: rule `unresolved-attribute` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
  --> praxis/backend/services/machine_type_definition.py:55:11
   |
53 |         update_data = MachineDefinitionUpdate(
54 |           fqn=fqn,
55 |           name=plr_class_obj.__name__,
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |           description=inspect.getdoc(plr_class_obj),
57 |         )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
  --> praxis/backend/services/machine_type_definition.py:65:11
   |
63 |       else:
64 |         create_data = MachineDefinitionCreate(
65 |           name=plr_class_obj.__name__,
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |           fqn=fqn,
67 |           description=inspect.getdoc(plr_class_obj),
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> praxis/backend/services/protocols.py:349:5
    |
347 |   call_id = uuid7()
348 |   db_obj = FunctionCallLogOrm(
349 |     accession_id=call_id,
    |     ^^^^^^^^^^^^^^^^^^^^
350 |     name=f"call_{call_id}",  # kw_only from Base
351 |     protocol_run_accession_id=protocol_run_orm_accession_id,
    |
info: rule `unknown-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union element `ResourceStatusEnum`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union element `ResourceStatusEnum`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union element `ResourceStatusEnum`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `ResourceStatusEnum | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `str` and `UUID` are not assignable to `ResourceStatusEnum | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `str` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `str` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `str` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `list[UUID] | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union element `ResourceStatusEnum`, and 2 more union elements, are not assignable to `list[UUID] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `AssetType | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union element `ResourceStatusEnum`, and 2 more union elements, are not assignable to `AssetType | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `str` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `str` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> praxis/backend/services/resource.py:271:29
    |
269 |       db,
270 |       db_obj=resource,
271 |       obj_in=ResourceUpdate(**update_data),
    |                             ^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | ResourceStatusEnum | str | UUID`
272 |     )
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-parameter-default]: Default value of type `<module 'pylabrobot'>` is not assignable to annotated parameter type `type[Any]`
   --> praxis/backend/services/resource_type_definition.py:134:5
    |
132 |   async def discover_and_synchronize_type_definitions(
133 |     self,
134 |     plr_resources_package: type[Any] = pylabrobot,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |   ) -> list[ResourceDefinitionOrm]:
136 |     """Discover all pylabrobot resource type definitions and synchronize them with the database."""
    |
info: rule `invalid-parameter-default` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis`
 --> praxis/backend/services/state.py:8:8
  |
6 | from typing import Any, TypeVar
7 |
8 | import redis
  |        ^^^^^
9 | from redis.exceptions import ConnectionError as RedisConnectionError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis.exceptions`
  --> praxis/backend/services/state.py:9:6
   |
 8 | import redis
 9 | from redis.exceptions import ConnectionError as RedisConnectionError
   |      ^^^^^^^^^^^^^^^^
10 |
11 | from praxis.backend.configure import PraxisConfiguration
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-return-type]: Return type does not match returned value
  --> praxis/backend/utils/accession_resolver.py:59:14
   |
57 |     if obj and hasattr(obj, "accession_id"):
58 |       # The object was found by name, return its ID.
59 |       return obj.accession_id
   |              ^^^^^^^^^^^^^^^^ expected `UUID`, found `object`
60 |   else:
61 |     # This case should not be hit if using FastAPI's type hints correctly,
   |
  ::: praxis/backend/utils/accession_resolver.py:22:6
   |
20 |   get_by_name_func: Callable[[AsyncSession, str], Awaitable[T | None]],
21 |   entity_type_name: str,
22 | ) -> UUID:
   |      ---- Expected `UUID` because of return type
23 |   """Resolve a string or UUID accession to a specific entity's UUID.
   |
info: rule `invalid-return-type` is enabled by default

error[no-matching-overload]: No overload of bound method `replace` matches arguments
   --> praxis/backend/utils/db.py:212:5
    |
210 |   logger.info(
211 |     "Initializing Praxis database tables at %s...",
212 |     str(engine.url).replace(engine.url.password, "****"),
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |   )
214 |   try:
    |
info: First overload defined here
    --> stdlib/builtins.pyi:1175:13
     |
1173 |     else:
1174 |         @overload
1175 |         def replace(self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = -1, /) -> LiteralString:
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1176 |             """Return a copy with all occurrences of substring old replaced by new.
     |
info: Possible overloads for bound method `replace`:
info:   (self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = Literal[-1], /) -> LiteralString
info:   (self, old: str, new: str, count: SupportsIndex = Literal[-1], /) -> str
info: rule `no-matching-overload` is enabled by default

warning[possibly-missing-attribute]: Attribute `append` may be missing on object of type `Unknown | str | dict[str, Any] | list[Unknown] | None`
   --> praxis/backend/utils/plr_inspection.py:582:7
    |
580 |         for pname, param in sig.parameters.items()
581 |       ]
582 |       details["assignment_methods"].append(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
583 |         {
584 |           "name": name,
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis`
 --> praxis/backend/utils/redis_lock.py:5:8
  |
3 | from typing import cast
4 |
5 | import redis
  |        ^^^^^
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis`
 --> praxis/backend/utils/run_control.py:5:8
  |
3 | import uuid
4 |
5 | import redis
  |        ^^^^^
6 | from redis.exceptions import RedisError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis.exceptions`
 --> praxis/backend/utils/run_control.py:6:6
  |
5 | import redis
6 | from redis.exceptions import RedisError
  |      ^^^^^^^^^^^^^^^^
7 |
8 | from praxis.backend.configure import PraxisConfiguration
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/api/conftest.py:3:8
  |
1 | from collections.abc import AsyncGenerator
2 |
3 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
4 | from httpx import ASGITransport, AsyncClient
5 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/conftest.py:4:6
  |
3 | import pytest_asyncio
4 | from httpx import ASGITransport, AsyncClient
  |      ^^^^^
5 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_deck_type_definitions.py:3:6
  |
1 | """Tests for the deck type definitions API."""
2 | import pytest
3 | from httpx import AsyncClient
  |      ^^^^^
4 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-attribute]: Object of type `object` has no attribute `lower`
  --> tests/api/test_deck_type_definitions.py:29:53
   |
27 |     print("DEBUG: Available routes:")
28 |     for route in main_app.routes:
29 |         if hasattr(route, "path") and "workcell" in route.path.lower():
   |                                                     ^^^^^^^^^^^^^^^^
30 |             print(f"  {route.path} - {route.methods if hasattr(route, 'methods') else 'N/A'}")
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_decks.py:3:6
  |
1 | """Tests for the decks API, covering the full CRUD lifecycle."""
2 | import pytest
3 | from httpx import AsyncClient
  |      ^^^^^
4 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
  --> tests/api/test_e2e_flow.py:12:6
   |
11 | import pytest
12 | from httpx import AsyncClient
   |      ^^^^^
13 | from sqlalchemy.ext.asyncio import AsyncSession
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-return-type]: Return type does not match returned value
  --> tests/api/test_e2e_flow.py:20:29
   |
19 | @pytest.fixture
20 | def temp_protocol_file() -> AsyncGenerator[str, None]:
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncGenerator[str, None]`, found `types.GeneratorType`
21 |     """Create a temporary protocol file for testing."""
22 |     content = """
   |
info: Function is inferred as returning `types.GeneratorType` because it is a generator function
info: See https://docs.python.org/3/glossary.html#term-generator for more details
info: rule `invalid-return-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_function_data_outputs.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_protocol_definitions.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_protocol_runs.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_resource_definitions.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_resources.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_route_debug.py:3:6
  |
1 | """Debug test to check if routes are registered."""
2 | import pytest
3 | from httpx import AsyncClient
  |      ^^^^^
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-attribute]: Object of type `BaseRoute & <Protocol with members 'methods'>` has no attribute `path`
  --> tests/api/test_route_debug.py:14:38
   |
12 |     for route in app.routes:
13 |         if hasattr(route, "methods"):
14 |             print(f"{route.methods} {route.path}")
   |                                      ^^^^^^^^^^
15 |         else:
16 |             print(f"MOUNT {route.path}")
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `BaseRoute & ~<Protocol with members 'methods'>` has no attribute `path`
  --> tests/api/test_route_debug.py:16:28
   |
14 |             print(f"{route.methods} {route.path}")
15 |         else:
16 |             print(f"MOUNT {route.path}")
   |                            ^^^^^^^^^^
17 |
18 |     # Try to access the route
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_smoke.py:3:6
  |
1 | """Smoke test to ensure the API can start and respond."""
2 | import pytest
3 | from httpx import AsyncClient
  |      ^^^^^
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_well_data_outputs.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `httpx`
 --> tests/api/test_workcells.py:6:6
  |
4 | """
5 | import pytest
6 | from httpx import AsyncClient
  |      ^^^^^
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
  --> tests/conftest.py:8:8
   |
 7 | import pytest
 8 | import pytest_asyncio
   |        ^^^^^^^^^^^^^^
 9 | from sqlalchemy.ext.asyncio import (
10 |     AsyncSession,
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unsupported-operator]: Unsupported `in` operation
  --> tests/core/decorators/test_definition_builder.py:42:16
   |
40 |         assert protocol_def.name == "test_protocol"
41 |         assert protocol_def.version == "1.0"
42 |         assert "Test protocol docstring" in protocol_def.description
   |                -------------------------^^^^------------------------
   |                |                            |
   |                |                            Has type `str | None`
   |                Has type `Literal["Test protocol docstring"]`
43 |         assert protocol_def.is_top_level is False
44 |         assert state_details is None
   |
info: Operation fails because operator `in` is not supported between objects of type `Literal["Test protocol docstring"]` and `None`
info: rule `unsupported-operator` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/core/decorators/test_models.py:60:13
   |
59 |         pydantic_def = FunctionProtocolDefinitionCreate(
60 |             accession_id=uuid7(),
   |             ^^^^^^^^^^^^^^^^^^^^
61 |             name="test_protocol",
62 |             fqn="test.test_protocol",
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/core/decorators/test_models.py:90:13
   |
89 |         pydantic_def = FunctionProtocolDefinitionCreate(
90 |             accession_id=uuid7(),
   |             ^^^^^^^^^^^^^^^^^^^^
91 |             name="test_protocol",
92 |             fqn="test.test_protocol",
   |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `protocol_run_id` may be missing on object of type `AcquireAssetLock | None`
   --> tests/core/test_asset_lock_manager.py:405:16
    |
403 |         # Check it's the new lock
404 |         status = await manager.get_lock_status("MACHINE", "machine1")
405 |         assert status.protocol_run_id == protocol_run_id2
    |                ^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `possibly-missing-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
  --> tests/core/test_asset_manager.py:82:9
   |
80 |         mock_def_orm.fqn = "test.Deck"
81 |
82 |         manager.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
   |         ^^^^^^^^^^^^^^^^^^^^
83 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource_orm)
84 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def_orm)
   |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
  --> tests/core/test_asset_manager.py:83:9
   |
82 |         manager.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
83 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource_orm)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
84 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def_orm)
   |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
  --> tests/core/test_asset_manager.py:84:9
   |
82 |         manager.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
83 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource_orm)
84 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def_orm)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |
86 |         deck_orm, resource_orm, def_orm = await manager._get_and_validate_deck_orms(deck_id)
   |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:106:9
    |
105 |         deck_id = uuid7()
106 |         manager.deck_svc.get = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^
107 |
108 |         with pytest.raises(AssetAcquisitionError, match="not found"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:129:9
    |
127 |         mock_deck_orm.name = "test_deck"
128 |
129 |         manager.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
    |         ^^^^^^^^^^^^^^^^^^^^
130 |         manager.resource_svc.get = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:130:9
    |
129 |         manager.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
130 |         manager.resource_svc.get = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
131 |
132 |         with pytest.raises(AssetAcquisitionError, match="Deck Resource ID"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:166:9
    |
164 |         mock_live_machine = Mock()
165 |
166 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |         manager.machine_svc.get_multi = AsyncMock(side_effect=[[], [mock_machine]])
168 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_multi`
   --> tests/core/test_asset_manager.py:167:9
    |
166 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
167 |         manager.machine_svc.get_multi = AsyncMock(side_effect=[[], [mock_machine]])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
169 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=mock_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `initialize_machine`
   --> tests/core/test_asset_manager.py:168:9
    |
166 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
167 |         manager.machine_svc.get_multi = AsyncMock(side_effect=[[], [mock_machine]])
168 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=mock_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update_machine_status`
   --> tests/core/test_asset_manager.py:169:9
    |
167 |         manager.machine_svc.get_multi = AsyncMock(side_effect=[[], [mock_machine]])
168 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
169 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=mock_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |
171 |         result, machine_accession_id, asset_type = await manager.acquire_machine(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:196:9
    |
194 |         run_id = uuid7()
195 |
196 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 |         manager.machine_svc.get_multi = AsyncMock(return_value=[])
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_multi`
   --> tests/core/test_asset_manager.py:197:9
    |
196 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
197 |         manager.machine_svc.get_multi = AsyncMock(return_value=[])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
198 |
199 |         with pytest.raises(AssetAcquisitionError, match="No machine found"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:226:9
    |
224 |         mock_live_machine = Mock()
225 |
226 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
227 |         manager.machine_svc.get_multi = AsyncMock(return_value=[mock_machine])
228 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_multi`
   --> tests/core/test_asset_manager.py:227:9
    |
226 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
227 |         manager.machine_svc.get_multi = AsyncMock(return_value=[mock_machine])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
228 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `initialize_machine`
   --> tests/core/test_asset_manager.py:228:9
    |
226 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
227 |         manager.machine_svc.get_multi = AsyncMock(return_value=[mock_machine])
228 |         manager.workcell_runtime.initialize_machine = AsyncMock(return_value=mock_live_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |
230 |         result, _, _ = await manager.acquire_machine(run_id, "test_asset", "test.Machine")
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_find_resource_to_acquire`
   --> tests/core/test_asset_manager.py:270:9
    |
269 |         # Mock the helper methods
270 |         manager._find_resource_to_acquire = AsyncMock(return_value=mock_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
271 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
272 |         manager.workcell_runtime.create_or_get_resource = AsyncMock(return_value=mock_live_resource)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:271:9
    |
269 |         # Mock the helper methods
270 |         manager._find_resource_to_acquire = AsyncMock(return_value=mock_resource)
271 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
272 |         manager.workcell_runtime.create_or_get_resource = AsyncMock(return_value=mock_live_resource)
273 |         manager._handle_location_constraints = AsyncMock(return_value=(None, None, "In use"))
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `create_or_get_resource`
   --> tests/core/test_asset_manager.py:272:9
    |
270 |         manager._find_resource_to_acquire = AsyncMock(return_value=mock_resource)
271 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
272 |         manager.workcell_runtime.create_or_get_resource = AsyncMock(return_value=mock_live_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
273 |         manager._handle_location_constraints = AsyncMock(return_value=(None, None, "In use"))
274 |         manager._update_resource_acquisition_status = AsyncMock(return_value=mock_resource)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_handle_location_constraints`
   --> tests/core/test_asset_manager.py:273:9
    |
271 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
272 |         manager.workcell_runtime.create_or_get_resource = AsyncMock(return_value=mock_live_resource)
273 |         manager._handle_location_constraints = AsyncMock(return_value=(None, None, "In use"))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
274 |         manager._update_resource_acquisition_status = AsyncMock(return_value=mock_resource)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_update_resource_acquisition_status`
   --> tests/core/test_asset_manager.py:274:9
    |
272 |         manager.workcell_runtime.create_or_get_resource = AsyncMock(return_value=mock_live_resource)
273 |         manager._handle_location_constraints = AsyncMock(return_value=(None, None, "In use"))
274 |         manager._update_resource_acquisition_status = AsyncMock(return_value=mock_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
275 |
276 |         resource_data = AcquireAsset(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_find_resource_to_acquire`
   --> tests/core/test_asset_manager.py:303:9
    |
301 |         run_id = uuid7()
302 |
303 |         manager._find_resource_to_acquire = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
304 |
305 |         resource_data = AcquireAsset(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:342:9
    |
340 |         updated_machine.name = "test_machine"
341 |
342 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^
343 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
344 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=updated_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `shutdown_machine`
   --> tests/core/test_asset_manager.py:343:9
    |
342 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
343 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
344 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=updated_machine)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update_machine_status`
   --> tests/core/test_asset_manager.py:344:9
    |
342 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
343 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
344 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=updated_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
345 |
346 |         await manager.release_machine(machine_id)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method IWorkcellRuntime.shutdown_machine(machine_orm_accession_id: UUID) -> CoroutineType[Any, Any, None]` has no attribute `assert_called_once_with`
   --> tests/core/test_asset_manager.py:348:9
    |
346 |         await manager.release_machine(machine_id)
347 |
348 |         manager.workcell_runtime.shutdown_machine.assert_called_once_with(machine_id)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
349 |         manager.machine_svc.update_machine_status.assert_called_once()
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `bound method MachineService.update_machine_status(db: AsyncSession, machine_accession_id: UUID, new_status: MachineStatusEnum, status_details: str | None = None, current_protocol_run_accession_id: UUID | None = None) -> CoroutineType[Any, Any, MachineOrm | None]` has no attribute `assert_called_once`
   --> tests/core/test_asset_manager.py:349:9
    |
348 |         manager.workcell_runtime.shutdown_machine.assert_called_once_with(machine_id)
349 |         manager.machine_svc.update_machine_status.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
350 |
351 |     @pytest.mark.asyncio
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:365:9
    |
364 |         machine_id = uuid7()
365 |         manager.machine_svc.get = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^
366 |
367 |         # Should not raise, just log warning
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:390:9
    |
388 |         mock_machine.fqn = "test.Machine"
389 |
390 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
    |         ^^^^^^^^^^^^^^^^^^^^^^^
391 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
392 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `shutdown_machine`
   --> tests/core/test_asset_manager.py:391:9
    |
390 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
391 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
392 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update_machine_status`
   --> tests/core/test_asset_manager.py:392:9
    |
390 |         manager.machine_svc.get = AsyncMock(return_value=mock_machine)
391 |         manager.workcell_runtime.shutdown_machine = AsyncMock()
392 |         manager.machine_svc.update_machine_status = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
393 |
394 |         with pytest.raises(AssetReleaseError, match="Failed to update DB status"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:429:9
    |
427 |         updated_resource.name = "test_resource"
428 |
429 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
430 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
431 |         manager._is_deck_resource = Mock(return_value=False)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:430:9
    |
429 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
430 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
431 |         manager._is_deck_resource = Mock(return_value=False)
432 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_is_deck_resource`
   --> tests/core/test_asset_manager.py:431:9
    |
429 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
430 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
431 |         manager._is_deck_resource = Mock(return_value=False)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
432 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
433 |         manager.resource_svc.update = AsyncMock(return_value=updated_resource)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_handle_resource_release_location`
   --> tests/core/test_asset_manager.py:432:9
    |
430 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
431 |         manager._is_deck_resource = Mock(return_value=False)
432 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
433 |         manager.resource_svc.update = AsyncMock(return_value=updated_resource)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update`
   --> tests/core/test_asset_manager.py:433:9
    |
431 |         manager._is_deck_resource = Mock(return_value=False)
432 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
433 |         manager.resource_svc.update = AsyncMock(return_value=updated_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
434 |
435 |         await manager.release_resource(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method ResourceService.update(db: AsyncSession, *, db_obj: ResourceOrm, obj_in: ResourceUpdate | dict[Unknown, Unknown]) -> CoroutineType[Any, Any, ResourceOrm]` has no attribute `assert_called_once`
   --> tests/core/test_asset_manager.py:440:9
    |
438 |         )
439 |
440 |         manager.resource_svc.update.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
441 |
442 |     @pytest.mark.asyncio
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:456:9
    |
455 |         resource_id = uuid7()
456 |         manager.resource_svc.get = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
457 |
458 |         # Should not raise, just log warning
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:485:9
    |
483 |         mock_def.fqn = "test.Resource"
484 |
485 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
486 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
487 |         manager._is_deck_resource = Mock(return_value=False)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:486:9
    |
485 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
486 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
487 |         manager._is_deck_resource = Mock(return_value=False)
488 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_is_deck_resource`
   --> tests/core/test_asset_manager.py:487:9
    |
485 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
486 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
487 |         manager._is_deck_resource = Mock(return_value=False)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
488 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
489 |         manager.resource_svc.update = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_handle_resource_release_location`
   --> tests/core/test_asset_manager.py:488:9
    |
486 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
487 |         manager._is_deck_resource = Mock(return_value=False)
488 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
489 |         manager.resource_svc.update = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update`
   --> tests/core/test_asset_manager.py:489:9
    |
487 |         manager._is_deck_resource = Mock(return_value=False)
488 |         manager._handle_resource_release_location = AsyncMock(return_value=(None, None))
489 |         manager.resource_svc.update = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
490 |
491 |         with pytest.raises(AssetReleaseError, match="Failed to update DB"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:518:9
    |
516 |         mock_def.fqn = "test.Resource"
517 |
518 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
519 |         manager.acquire_resource = AsyncMock(return_value=(Mock(), uuid7(), "resource"))
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `acquire_resource`
   --> tests/core/test_asset_manager.py:519:9
    |
518 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_def)
519 |         manager.acquire_resource = AsyncMock(return_value=(Mock(), uuid7(), "resource"))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
520 |
521 |         asset_req = AssetRequirementModel(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method AssetManager.acquire_resource(resource_data: AcquireAsset) -> CoroutineType[Any, Any, tuple[Any, UUID, str]]` has no attribute `assert_called_once`
   --> tests/core/test_asset_manager.py:530:9
    |
528 |         await manager.acquire_asset(run_id, asset_req)
529 |
530 |         manager.acquire_resource.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
531 |
532 |     @pytest.mark.asyncio
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:548:9
    |
547 |         # Mock that this is NOT a cataloged resource
548 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
549 |         manager.acquire_machine = AsyncMock(return_value=(Mock(), uuid7(), "machine"))
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `acquire_machine`
   --> tests/core/test_asset_manager.py:549:9
    |
547 |         # Mock that this is NOT a cataloged resource
548 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=None)
549 |         manager.acquire_machine = AsyncMock(return_value=(Mock(), uuid7(), "machine"))
    |         ^^^^^^^^^^^^^^^^^^^^^^^
550 |
551 |         asset_req = AssetRequirementModel(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method AssetManager.acquire_machine(protocol_run_accession_id: UUID, requested_asset_name_in_protocol: str, fqn_constraint: str) -> CoroutineType[Any, Any, tuple[Any, UUID, str]]` has no attribute `assert_called_once`
   --> tests/core/test_asset_manager.py:560:9
    |
558 |         await manager.acquire_asset(run_id, asset_req)
559 |
560 |         manager.acquire_machine.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `acquire_asset_lock` on type `Unknown | IAssetLockManager`
   --> tests/core/test_asset_manager.py:583:9
    |
581 |         reservation_id = uuid7()
582 |
583 |         manager.asset_lock_manager.acquire_asset_lock = AsyncMock(return_value=True)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
584 |
585 |         result = await manager.lock_asset(
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `release_asset_lock` on type `Unknown | IAssetLockManager`
   --> tests/core/test_asset_manager.py:611:9
    |
609 |         reservation_id = uuid7()
610 |
611 |         manager.asset_lock_manager.release_asset_lock = AsyncMock(return_value=True)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
612 |
613 |         result = await manager.unlock_asset(
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get`
   --> tests/core/test_asset_manager.py:715:9
    |
713 |         mock_resource.status = ResourceStatusEnum.AVAILABLE_IN_STORAGE
714 |
715 |         manager.resource_svc.get = AsyncMock(return_value=mock_resource)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
716 |
717 |         result = await manager._find_resource_to_acquire(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_multi`
   --> tests/core/test_asset_manager.py:746:9
    |
744 |         mock_resource.current_protocol_run_accession_id = run_id
745 |
746 |         manager.resource_svc.get_multi = AsyncMock(return_value=[mock_resource])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
747 |
748 |         result = await manager._find_resource_to_acquire(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_multi`
   --> tests/core/test_asset_manager.py:777:9
    |
776 |         # First call returns empty (no in-use), second call returns resource on deck
777 |         manager.resource_svc.get_multi = AsyncMock(side_effect=[[], [mock_resource]])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
778 |
779 |         result = await manager._find_resource_to_acquire(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:844:9
    |
842 |         mock_deck_def.plr_category = "Deck"
843 |
844 |         manager.resource_svc.get_by_name = AsyncMock(return_value=mock_deck)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
845 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_deck_def)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_by_name`
   --> tests/core/test_asset_manager.py:845:9
    |
844 |         manager.resource_svc.get_by_name = AsyncMock(return_value=mock_deck)
845 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_deck_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
846 |
847 |         manager.workcell_runtime.assign_resource_to_deck = AsyncMock()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `assign_resource_to_deck`
   --> tests/core/test_asset_manager.py:847:9
    |
845 |         manager.resource_type_definition_svc.get_by_name = AsyncMock(return_value=mock_deck_def)
846 |
847 |         manager.workcell_runtime.assign_resource_to_deck = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
848 |
849 |         constraints = {"deck_name": "main_deck", "position_name": "1"}
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method IWorkcellRuntime.assign_resource_to_deck(resource_orm_accession_id: UUID, target: UUID, location: Coordinate | tuple[int | float, int | float, int | float] | None = None, position_accession_id: str | int | UUID | None = None) -> CoroutineType[Any, Any, None]` has no attribute `assert_called_once_with`
   --> tests/core/test_asset_manager.py:860:9
    |
858 |         assert deck_res_id == deck_id
859 |         assert pos_name == "1"
860 |         manager.workcell_runtime.assign_resource_to_deck.assert_called_once_with(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
861 |             resource_orm_accession_id=mock_resource.accession_id,
862 |             target=deck_id,
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
  --> tests/core/test_celery.py:8:6
   |
 7 | import pytest
 8 | from celery import Celery
   |      ^^^^^^
 9 | from kombu.serialization import registry
10 | from pydantic import BaseModel
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `kombu.serialization`
  --> tests/core/test_celery.py:9:6
   |
 7 | import pytest
 8 | from celery import Celery
 9 | from kombu.serialization import registry
   |      ^^^^^^^^^^^^^^^^^^^
10 | from pydantic import BaseModel
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `celery`
 --> tests/core/test_celery_base.py:5:6
  |
3 | from unittest.mock import Mock
4 |
5 | from celery import Task
  |      ^^^^^^
6 |
7 | from praxis.backend.core.celery_base import PraxisTask
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `acquire_asset`
   --> tests/core/test_orchestrator.py:282:9
    |
281 |         mock_live_obj = Mock()
282 |         orchestrator.asset_manager.acquire_asset = AsyncMock(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
283 |             return_value=(mock_live_obj, asset_id, "resource"),
284 |         )
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `acquire_asset`
   --> tests/core/test_orchestrator.py:320:9
    |
318 |         run_id = uuid7()
319 |
320 |         orchestrator.asset_manager.acquire_asset = AsyncMock(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
321 |             side_effect=AssetAcquisitionError("Asset not available"),
322 |         )
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `acquire_asset`
   --> tests/core/test_orchestrator.py:357:9
    |
355 |         run_id = uuid7()
356 |
357 |         orchestrator.asset_manager.acquire_asset = AsyncMock(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
358 |             side_effect=AssetAcquisitionError("Asset not available"),
359 |         )
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `get_state_snapshot`
   --> tests/core/test_orchestrator.py:448:9
    |
446 |         initial_state_data = {"key": "value"}
447 |
448 |         orchestrator.workcell_runtime.get_state_snapshot = Mock(return_value={"snapshot": "data"})
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
449 |
450 |         # Mock PraxisState to avoid Redis
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `apply_state_snapshot`
   --> tests/core/test_orchestrator.py:550:9
    |
548 |         mock_db_session = AsyncMock()
549 |
550 |         orchestrator.workcell_runtime.apply_state_snapshot = Mock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
551 |         orchestrator._validate_praxis_state = Mock()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_validate_praxis_state`
   --> tests/core/test_orchestrator.py:551:9
    |
550 |         orchestrator.workcell_runtime.apply_state_snapshot = Mock()
551 |         orchestrator._validate_praxis_state = Mock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
552 |
553 |         test_error = ValueError("Test error")
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method WorkcellRuntime.apply_state_snapshot(snapshot_json: dict[str, Any]) -> None` has no attribute `assert_called_once`
   --> tests/core/test_orchestrator.py:564:9
    |
563 |         # Should have attempted rollback
564 |         orchestrator.workcell_runtime.apply_state_snapshot.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:203:9
    |
201 |             return ""
202 |
203 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
204 |
205 |         with patch("os.path.exists", return_value=True):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:224:9
    |
222 |             return ""
223 |
224 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
225 |
226 |         with patch("os.path.exists", return_value=True):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:245:9
    |
243 |             return ""
244 |
245 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
246 |
247 |         with patch("os.path.exists", return_value=False), patch("os.makedirs"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:270:9
    |
268 |             return ""
269 |
270 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
271 |
272 |         with pytest.raises(ValueError, match="not empty"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:300:9
    |
298 |             return ""
299 |
300 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
301 |
302 |         await manager._checkout_specific_commit(
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_run_git_command`
   --> tests/core/test_protocol_code_manager.py:324:9
    |
322 |             return ""
323 |
324 |         manager._run_git_command = mock_run_git_command
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
325 |
326 |         with pytest.raises(RuntimeError, match="Failed to checkout commit"):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_ensure_git_repo_and_fetch`
   --> tests/core/test_protocol_code_manager.py:544:9
    |
543 |         # Mock Git operations
544 |         manager._ensure_git_repo_and_fetch = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
545 |         manager._checkout_specific_commit = AsyncMock()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_checkout_specific_commit`
   --> tests/core/test_protocol_code_manager.py:545:9
    |
543 |         # Mock Git operations
544 |         manager._ensure_git_repo_and_fetch = AsyncMock()
545 |         manager._checkout_specific_commit = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
546 |
547 |         # Mock function loading with same accession_id
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_load_protocol_function`
   --> tests/core/test_protocol_code_manager.py:567:9
    |
565 |             return mock_function, mock_pydantic_def
566 |
567 |         manager._load_protocol_function = mock_load_protocol_function
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
568 |
569 |         func, pydantic_def = await manager.prepare_protocol_code(mock_protocol_def_orm)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method ProtocolCodeManager._ensure_git_repo_and_fetch(git_url: str, checkout_path: str, repo_name_for_logging: str) -> CoroutineType[Any, Any, None]` has no attribute `assert_called_once`
   --> tests/core/test_protocol_code_manager.py:573:9
    |
571 |         assert func == mock_function
572 |         assert isinstance(pydantic_def, FunctionProtocolDefinitionCreate)
573 |         manager._ensure_git_repo_and_fetch.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
574 |         manager._checkout_specific_commit.assert_called_once()
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `bound method ProtocolCodeManager._checkout_specific_commit(checkout_path: str, commit_hash: str, repo_name_for_logging: str) -> CoroutineType[Any, Any, None]` has no attribute `assert_called_once`
   --> tests/core/test_protocol_code_manager.py:574:9
    |
572 |         assert isinstance(pydantic_def, FunctionProtocolDefinitionCreate)
573 |         manager._ensure_git_repo_and_fetch.assert_called_once()
574 |         manager._checkout_specific_commit.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
575 |
576 |     @pytest.mark.asyncio
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_load_protocol_function`
   --> tests/core/test_protocol_code_manager.py:619:9
    |
617 |             return mock_function, mock_pydantic_def
618 |
619 |         manager._load_protocol_function = mock_load_protocol_function
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
620 |
621 |         with patch("os.path.isdir", return_value=True):
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `_load_protocol_function`
   --> tests/core/test_protocol_code_manager.py:704:9
    |
702 |             return mock_function, mock_pydantic_def
703 |
704 |         manager._load_protocol_function = mock_load_protocol_function
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
705 |
706 |         func, pydantic_def = await manager.prepare_protocol_code(mock_protocol_def_orm)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `FunctionProtocolDefinitionCreate` has no attribute `accession_id`
   --> tests/core/test_protocol_code_manager.py:709:16
    |
708 |         # Should return with same accession_id
709 |         assert pydantic_def.accession_id == shared_accession_id
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
710 |         assert func == mock_function
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `execute_protocol` on type `Unknown | IOrchestrator`
  --> tests/core/test_protocol_execution_service.py:65:9
   |
63 |         mock_protocol_run.accession_id = uuid7()
64 |
65 |         service.orchestrator.execute_protocol = AsyncMock(return_value=mock_protocol_run)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |
67 |         result = await service.execute_protocol_immediately(
   |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `execute_protocol` on type `Unknown | IOrchestrator`
  --> tests/core/test_protocol_execution_service.py:97:9
   |
96 |         mock_protocol_run = Mock()
97 |         service.orchestrator.execute_protocol = AsyncMock(return_value=mock_protocol_run)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
98 |
99 |         result = await service.execute_protocol_immediately(
   |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_by_name` on type `Unknown | ProtocolDefinitionCRUDService`
   --> tests/core/test_protocol_execution_service.py:147:9
    |
145 |         mock_protocol_run.accession_id = uuid7()
146 |
147 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
149 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=True)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `create` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:148:9
    |
147 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
148 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=True)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `schedule_protocol_execution` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:149:9
    |
147 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
148 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
149 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=True)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
150 |
151 |         result = await service.schedule_protocol_execution(
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_by_name` on type `Unknown | ProtocolDefinitionCRUDService`
   --> tests/core/test_protocol_execution_service.py:179:9
    |
177 |         )
178 |
179 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
180 |
181 |         with pytest.raises(ValueError, match="not found"):
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_by_name` on type `Unknown | ProtocolDefinitionCRUDService`
   --> tests/core/test_protocol_execution_service.py:211:9
    |
209 |         mock_protocol_run.accession_id = uuid7()
210 |
211 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
212 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
213 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=False)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `create` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:212:9
    |
211 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
212 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=False)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `schedule_protocol_execution` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:213:9
    |
211 |         service.protocol_definition_service.get_by_name = AsyncMock(return_value=mock_protocol_def)
212 |         service.protocol_run_service.create = AsyncMock(return_value=mock_protocol_run)
213 |         service.scheduler.schedule_protocol_execution = AsyncMock(return_value=False)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 |
215 |         with pytest.raises(RuntimeError, match="Failed to schedule"):
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_schedule_status` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:258:9
    |
256 |         mock_protocol_run.top_level_protocol_definition.name = "test_protocol"
257 |
258 |         service.scheduler.get_schedule_status = AsyncMock(return_value={"status": "scheduled"})
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
259 |         service.protocol_run_service.get = AsyncMock(return_value=mock_protocol_run)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:259:9
    |
258 |         service.scheduler.get_schedule_status = AsyncMock(return_value={"status": "scheduled"})
259 |         service.protocol_run_service.get = AsyncMock(return_value=mock_protocol_run)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 |
261 |         result = await service.get_protocol_run_status(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_schedule_status` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:290:9
    |
288 |         run_id = uuid7()
289 |
290 |         service.scheduler.get_schedule_status = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
291 |         service.protocol_run_service.get = AsyncMock(return_value=None)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:291:9
    |
290 |         service.scheduler.get_schedule_status = AsyncMock(return_value=None)
291 |         service.protocol_run_service.get = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
292 |
293 |         result = await service.get_protocol_run_status(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_schedule_status` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:329:9
    |
327 |         mock_protocol_run.top_level_protocol_definition.name = "test_protocol"
328 |
329 |         service.scheduler.get_schedule_status = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
330 |         service.protocol_run_service.get = AsyncMock(return_value=mock_protocol_run)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:330:9
    |
329 |         service.scheduler.get_schedule_status = AsyncMock(return_value=None)
330 |         service.protocol_run_service.get = AsyncMock(return_value=mock_protocol_run)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
331 |
332 |         result = await service.get_protocol_run_status(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `cancel_scheduled_run` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:365:9
    |
363 |         run_id = uuid7()
364 |
365 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=True)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
366 |         service.protocol_run_service.update_run_status = AsyncMock()
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `update_run_status` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:366:9
    |
365 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=True)
366 |         service.protocol_run_service.update_run_status = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
367 |
368 |         result = await service.cancel_protocol_run(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `cancel_scheduled_run` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:395:9
    |
393 |         run_id = uuid7()
394 |
395 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=False)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
396 |         service.protocol_run_service.update_run_status = AsyncMock()
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `update_run_status` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:396:9
    |
395 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=False)
396 |         service.protocol_run_service.update_run_status = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
397 |
398 |         result = await service.cancel_protocol_run(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `cancel_scheduled_run` on type `Unknown | IProtocolScheduler`
   --> tests/core/test_protocol_execution_service.py:423:9
    |
421 |         run_id = uuid7()
422 |
423 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=True)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
424 |         service.protocol_run_service.update_run_status = AsyncMock(side_effect=Exception("DB error"))
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `update_run_status` on type `Unknown | ProtocolRunService`
   --> tests/core/test_protocol_execution_service.py:424:9
    |
423 |         service.scheduler.cancel_scheduled_run = AsyncMock(return_value=True)
424 |         service.protocol_run_service.update_run_status = AsyncMock(side_effect=Exception("DB error"))
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
425 |
426 |         result = await service.cancel_protocol_run(run_id)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> tests/core/test_workcell.py:29:13
   |
27 |             name="test_workcell",
28 |             save_file=save_file,
29 |             file_system=fs,
   |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
30 |         )
   |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> tests/core/test_workcell.py:44:17
   |
42 |                 name="test_workcell",
43 |                 save_file="/path/to/state.txt",
44 |                 file_system=fs,
   |                 ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
45 |             )
   |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> tests/core/test_workcell.py:55:13
   |
53 |             name="test_workcell",
54 |             save_file=save_file,
55 |             file_system=fs,
   |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
56 |         )
   |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> tests/core/test_workcell.py:70:13
   |
68 |             name="test_workcell",
69 |             save_file=save_file,
70 |             file_system=fs,
   |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
71 |             backup_interval=120,
72 |             num_backups=5,
   |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --> tests/core/test_workcell.py:86:13
   |
84 |             name="test_workcell",
85 |             save_file=save_file,
86 |             file_system=fs,
   |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
87 |         )
   |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:106:13
    |
104 |             name="test_workcell",
105 |             save_file=save_file,
106 |             file_system=fs,
    |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
107 |         )
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:122:13
    |
120 |             name="test_workcell",
121 |             save_file=save_file,
122 |             file_system=fs,
    |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
123 |         )
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:138:13
    |
136 |             name="test_workcell",
137 |             save_file=save_file,
138 |             file_system=fs,
    |             ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
139 |         )
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:154:72
    |
152 |         save_file = str(tmp_path / "state.json")
153 |         fs = FileSystem()
154 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
155 |
156 |         result = workcell.all_machines
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:164:72
    |
162 |         save_file = str(tmp_path / "state.json")
163 |         fs = FileSystem()
164 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
165 |
166 |         # Add mock machines to different categories
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:189:72
    |
187 |         save_file = str(tmp_path / "state.json")
188 |         fs = FileSystem()
189 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
190 |
191 |         result = workcell.asset_keys
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:199:72
    |
197 |         save_file = str(tmp_path / "state.json")
198 |         fs = FileSystem()
199 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
200 |
201 |         mock_asset1 = Mock()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:222:72
    |
220 |         save_file = str(tmp_path / "state.json")
221 |         fs = FileSystem()
222 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
223 |
224 |         mock_asset = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:237:72
    |
235 |         save_file = str(tmp_path / "state.json")
236 |         fs = FileSystem()
237 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
238 |
239 |         mock_asset = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Object of type `Workcell` has no attribute `plates`
   --> tests/core/test_workcell.py:245:32
    |
243 |         workcell.add_asset(mock_asset)
244 |
245 |         assert "test_plate" in workcell.plates
    |                                ^^^^^^^^^^^^^^^
246 |         assert workcell.plates["test_plate"] is mock_asset
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `Workcell` has no attribute `plates`
   --> tests/core/test_workcell.py:246:16
    |
245 |         assert "test_plate" in workcell.plates
246 |         assert workcell.plates["test_plate"] is mock_asset
    |                ^^^^^^^^^^^^^^^
247 |
248 |     def test_add_asset_with_no_category_logs_warning(self, tmp_path: Path) -> None:
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:252:72
    |
250 |         save_file = str(tmp_path / "state.json")
251 |         fs = FileSystem()
252 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
253 |
254 |         mock_asset = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:271:72
    |
269 |         save_file = str(tmp_path / "state.json")
270 |         fs = FileSystem()
271 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
272 |
273 |         result = workcell.get_all_children()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:281:72
    |
279 |         save_file = str(tmp_path / "state.json")
280 |         fs = FileSystem()
281 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
282 |
283 |         mock_asset = Mock(spec=Machine)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:296:72
    |
294 |         save_file = str(tmp_path / "state.json")
295 |         fs = FileSystem()
296 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
297 |
298 |         # Create mock resource with nested children
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:319:72
    |
317 |         save_file = str(tmp_path / "state.json")
318 |         fs = FileSystem()
319 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
320 |
321 |         mock_lh = Mock()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:334:72
    |
332 |         save_file = str(tmp_path / "state.json")
333 |         fs = FileSystem()
334 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
335 |
336 |         mock_deck = Mock(spec=Deck)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:350:72
    |
348 |         save_file = str(tmp_path / "state.json")
349 |         fs = FileSystem()
350 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
351 |
352 |         result = workcell.serialize_all_state()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:360:72
    |
358 |         save_file = str(tmp_path / "state.json")
359 |         fs = FileSystem()
360 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
361 |
362 |         mock_resource = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:378:72
    |
376 |         save_file = str(tmp_path / "state.json")
377 |         fs = FileSystem()
378 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
379 |
380 |         mock_resource = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:395:72
    |
393 |         save_file = str(tmp_path / "state.json")
394 |         fs = FileSystem()
395 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
396 |
397 |         mock_resource = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:419:72
    |
417 |         output_file = str(tmp_path / "output.json")
418 |         fs = FileSystem()
419 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
420 |
421 |         mock_resource = Mock(spec=Resource)
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:443:72
    |
441 |         input_file = str(tmp_path / "input.json")
442 |         fs = FileSystem()
443 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
444 |
445 |         # Create input file
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:469:72
    |
467 |         save_file = str(tmp_path / "state.json")
468 |         fs = FileSystem()
469 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
470 |
471 |         mock_asset = Mock()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:481:72
    |
479 |         save_file = str(tmp_path / "state.json")
480 |         fs = FileSystem()
481 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
482 |
483 |         assert "nonexistent" not in workcell
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:489:72
    |
487 |         save_file = str(tmp_path / "state.json")
488 |         fs = FileSystem()
489 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
490 |
491 |         result = workcell["plates"]
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:498:72
    |
496 |         save_file = str(tmp_path / "state.json")
497 |         fs = FileSystem()
498 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
499 |
500 |         with pytest.raises(KeyError, match="'invalid' is not a valid asset category"):
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:512:72
    |
510 |         save_file = str(tmp_path / "state.json")
511 |         fs = FileSystem()
512 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
513 |
514 |         required_assets = [
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:540:72
    |
538 |         save_file = str(tmp_path / "state.json")
539 |         fs = FileSystem()
540 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
541 |
542 |         required_assets = [
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:565:72
    |
563 |         save_file = str(tmp_path / "state.json")
564 |         fs = FileSystem()
565 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
566 |
567 |         required_assets = [
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:583:72
    |
581 |         save_file = str(tmp_path / "state.json")
582 |         fs = FileSystem()
583 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
584 |
585 |         required_assets = [
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:606:72
    |
604 |         save_file = str(tmp_path / "state.json")
605 |         fs = FileSystem()
606 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
607 |
608 |         mock_asset = Mock()
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Unresolved attribute `test_asset` on type `Workcell`.
   --> tests/core/test_workcell.py:609:9
    |
608 |         mock_asset = Mock()
609 |         workcell.test_asset = mock_asset
    |         ^^^^^^^^^^^^^^^^^^^
610 |
611 |         required_assets = [
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:630:72
    |
628 |         save_file = str(tmp_path / "state.json")
629 |         fs = FileSystem()
630 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
631 |
632 |         required_assets = [
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:652:72
    |
650 |         save_file = str(tmp_path / "state.json")
651 |         fs = FileSystem()
652 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
653 |
654 |         required_assets = []
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:671:72
    |
669 |         output_file = str(tmp_path / "output.json")
670 |         fs = FileSystem()
671 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
672 |
673 |         # Add mock resource
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Object of type `Workcell` has no attribute `plates`
   --> tests/core/test_workcell.py:684:35
    |
682 |         # Verify asset was added
683 |         assert "test_resource" in workcell
684 |         assert "test_resource" in workcell.plates
    |                                   ^^^^^^^^^^^^^^^
685 |
686 |         # Save state
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:690:74
    |
689 |         # Create new workcell and load state
690 |         workcell2 = Workcell(name="test_workcell2", save_file=save_file, file_system=fs)
    |                                                                          ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
691 |         mock_resource2 = Mock(spec=Resource)
692 |         mock_resource2.name = "test_resource"
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
   --> tests/core/test_workcell.py:705:72
    |
703 |         save_file = str(tmp_path / "state.json")
704 |         fs = FileSystem()
705 |         workcell = Workcell(name="test_workcell", save_file=save_file, file_system=fs)
    |                                                                        ^^^^^^^^^^^^^^ Expected `IFileSystem`, found `FileSystem`
706 |
707 |         # Add assets to workcell
    |
info: Method defined here
  --> praxis/backend/core/workcell.py:47:7
   |
45 |   """
46 |
47 |   def __init__(
   |       ^^^^^^^^
48 |     self,
49 |     name: str,
50 |     save_file: str,
51 |     file_system: IFileSystem,
   |     ------------------------ Parameter declared here
52 |     backup_interval: int = 60,
53 |     num_backups: int = 3,
   |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-attribute]: Unresolved attribute `allowed_asset` on type `Workcell`.
   --> tests/core/test_workcell.py:708:9
    |
707 |         # Add assets to workcell
708 |         workcell.allowed_asset = Mock()
    |         ^^^^^^^^^^^^^^^^^^^^^^
709 |         workcell.forbidden_asset = Mock()
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Unresolved attribute `forbidden_asset` on type `Workcell`.
   --> tests/core/test_workcell.py:709:9
    |
707 |         # Add assets to workcell
708 |         workcell.allowed_asset = Mock()
709 |         workcell.forbidden_asset = Mock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
710 |
711 |         # Create view with limited access
    |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `Workcell` has no attribute `allowed_asset`
   --> tests/core/test_workcell.py:724:26
    |
722 |         # Should allow access to declared asset
723 |         result = view.allowed_asset
724 |         assert result is workcell.allowed_asset
    |                          ^^^^^^^^^^^^^^^^^^^^^^
725 |
726 |         # Should deny access to undeclared asset
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Object of type `None` is not assignable to attribute `_main_workcell` of type `IWorkcell`
   --> tests/core/test_workcell_runtime.py:113:9
    |
112 |         # Set to None to simulate not initialized
113 |         runtime._main_workcell = None
    |         ^^^^^^^^^^^^^^^^^^^^^^
114 |
115 |         with pytest.raises(WorkcellRuntimeError, match="not initialized"):
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `create`
   --> tests/core/test_workcell_runtime.py:195:9
    |
193 |         )
194 |
195 |         runtime.workcell_svc.create = AsyncMock(return_value=mock_workcell_orm)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 |         runtime.workcell_svc.read_workcell_state = AsyncMock(return_value={"db_state": "data"})
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `read_workcell_state`
   --> tests/core/test_workcell_runtime.py:196:9
    |
195 |         runtime.workcell_svc.create = AsyncMock(return_value=mock_workcell_orm)
196 |         runtime.workcell_svc.read_workcell_state = AsyncMock(return_value={"db_state": "data"})
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 |
198 |         await runtime._link_workcell_to_db()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method WorkcellService.create(db: AsyncSession, *, obj_in: WorkcellCreate) -> CoroutineType[Any, Any, WorkcellOrm]` has no attribute `assert_called_once`
   --> tests/core/test_workcell_runtime.py:201:9
    |
200 |         assert runtime._workcell_db_accession_id == mock_workcell_orm.accession_id
201 |         runtime.workcell_svc.create.assert_called_once()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
202 |         mock_workcell.load_all_state.assert_called_once()
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `create`
   --> tests/core/test_workcell_runtime.py:222:9
    |
220 |         # Already linked
221 |         runtime._workcell_db_accession_id = uuid7()
222 |         runtime.workcell_svc.create = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |
224 |         await runtime._link_workcell_to_db()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[unresolved-attribute]: Object of type `bound method WorkcellService.create(db: AsyncSession, *, obj_in: WorkcellCreate) -> CoroutineType[Any, Any, WorkcellOrm]` has no attribute `assert_not_called`
   --> tests/core/test_workcell_runtime.py:227:9
    |
226 |         # Should not create a new entry
227 |         runtime.workcell_svc.create.assert_not_called()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `create`
   --> tests/core/test_workcell_runtime.py:260:9
    |
258 |         )
259 |
260 |         runtime.workcell_svc.create = AsyncMock(return_value=mock_workcell_orm)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
261 |         runtime.workcell_svc.read_workcell_state = AsyncMock(return_value=None)
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `read_workcell_state`
   --> tests/core/test_workcell_runtime.py:261:9
    |
260 |         runtime.workcell_svc.create = AsyncMock(return_value=mock_workcell_orm)
261 |         runtime.workcell_svc.read_workcell_state = AsyncMock(return_value=None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
262 |
263 |         await runtime.start_workcell_state_sync()
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Implicit shadowing of function `update_workcell_state`
   --> tests/core/test_workcell_runtime.py:299:9
    |
298 |         runtime._workcell_db_accession_id = uuid7()
299 |         runtime.workcell_svc.update_workcell_state = AsyncMock()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
300 |
301 |         # Create a proper async task
    |
info: Annotate to make it explicit if this is intentional
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | DeckTypeDefinitionService`
   --> tests/core/test_workcell_runtime.py:398:9
    |
396 |         mock_deck_type_def.positions = [mock_position_def]
397 |
398 |         runtime.deck_type_definition_svc.get = AsyncMock(return_value=mock_deck_type_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
399 |
400 |         result = await runtime._get_calculated_location(
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | DeckTypeDefinitionService`
   --> tests/core/test_workcell_runtime.py:441:9
    |
439 |         mock_deck_type_def.positions = []
440 |
441 |         runtime.deck_type_definition_svc.get = AsyncMock(return_value=mock_deck_type_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
442 |
443 |         with pytest.raises(WorkcellRuntimeError, match="Position.*not found"):
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get_multi` on type `Unknown | ResourceService`
   --> tests/core/test_workcell_runtime.py:501:9
    |
499 |         mock_existing_resource = Mock()
500 |         mock_existing_resource.name = "existing_resource"
501 |         runtime.resource_svc.get_multi = AsyncMock(return_value=[mock_existing_resource])
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
502 |
503 |         mock_deck_orm = Mock()
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | DeckService`
   --> tests/core/test_workcell_runtime.py:506:9
    |
504 |         mock_deck_orm.accession_id = deck_id
505 |         mock_deck_orm.deck_type_id = uuid7()
506 |         runtime.deck_svc.get = AsyncMock(return_value=mock_deck_orm)
    |         ^^^^^^^^^^^^^^^^^^^^
507 |
508 |         mock_deck_def = Mock()
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-assignment]: Object of type `AsyncMock` is not assignable to attribute `get` on type `Unknown | DeckTypeDefinitionService`
   --> tests/core/test_workcell_runtime.py:510:9
    |
508 |         mock_deck_def = Mock()
509 |         mock_deck_def.positioning_config_json = {}
510 |         runtime.deck_type_definition_svc.get = AsyncMock(return_value=mock_deck_def)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
511 |
512 |         runtime._get_calculated_location = AsyncMock(return_value=Coordinate(0, 0, 0))
    |
info: rule `invalid-assignment` is enabled by default

error[unresolved-import]: Cannot resolve imported module `factory`
 --> tests/factories.py:6:8
  |
4 | import uuid
5 |
6 | import factory
  |        ^^^^^^^
7 | from factory.alchemy import SQLAlchemyModelFactory
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unresolved-import]: Cannot resolve imported module `factory.alchemy`
 --> tests/factories.py:7:6
  |
6 | import factory
7 | from factory.alchemy import SQLAlchemyModelFactory
  |      ^^^^^^^^^^^^^^^
8 |
9 | from praxis.backend.models.orm.deck import DeckDefinitionOrm, DeckOrm
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 3 more union elements, are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `str` and `bool` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `str` and `bool` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union elements `bool` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[list[ParameterDefinitionOrm]] | list[ParameterDefinitionOrm]`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 3 more union elements, are not assignable to `SQLCoreOperations[list[ParameterDefinitionOrm]] | list[ParameterDefinitionOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetRequirementOrm]] | list[AssetRequirementOrm]`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 3 more union elements, are not assignable to `SQLCoreOperations[list[AssetRequirementOrm]] | list[AssetRequirementOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 3 more union elements, are not assignable to `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `str`, and 3 more union elements, are not assignable to `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/factories_schedule.py:73:46
   |
71 |     defaults.update(kwargs)
72 |
73 |     protocol = FunctionProtocolDefinitionOrm(**defaults)
   |                                              ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | bool | UUID | None`
74 |     if source_repository:
75 |         protocol.source_repository = source_repository
   |
info: Union element `bool`, and 2 more union elements, are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[ProtocolRunStatusEnum] | ProtocolRunStatusEnum`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[ProtocolRunStatusEnum] | ProtocolRunStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[int | None] | int | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[int | None] | int | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[ProtocolRunOrm | None] | ProtocolRunOrm | None`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[ProtocolRunOrm | None] | ProtocolRunOrm | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[ScheduleEntryOrm]] | list[ScheduleEntryOrm]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[list[ScheduleEntryOrm]] | list[ScheduleEntryOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:100:26
    |
 98 |     defaults.update(kwargs)
 99 |
100 |     run = ProtocolRunOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[UUID] | UUID`, found `Unknown | str | UUID`
101 |     db_session.add(run)
102 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID] | UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[AssetType] | AssetType`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[AssetType] | AssetType`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[MachineCategoryEnum] | MachineCategoryEnum`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[MachineCategoryEnum] | MachineCategoryEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[MachineStatusEnum] | MachineStatusEnum`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[MachineStatusEnum] | MachineStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[bool | None] | bool | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[bool | None] | bool | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:169:26
    |
167 |     defaults.update(kwargs)
168 |
169 |     machine = MachineOrm(**defaults)
    |                          ^^^^^^^^^^ Expected `SQLCoreOperations[list[DeckOrm]] | list[DeckOrm]`, found `Unknown | str`
170 |     db_session.add(machine)
171 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[DeckOrm]] | list[DeckOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[AssetType] | AssetType`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[AssetType] | AssetType`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[ResourceStatusEnum] | ResourceStatusEnum`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[ResourceStatusEnum] | ResourceStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:189:28
    |
187 |     defaults.update(kwargs)
188 |
189 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
190 |     db_session.add(resource)
191 |     await db_session.flush()
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[missing-argument]: No arguments provided for required parameters `name`, `released_at`
   --> tests/factories_schedule.py:231:19
    |
230 |       # Build reservation with all kw_only fields as keyword args
231 |       reservation = AssetReservationOrm(
    |  ___________________^
232 | |         protocol_run_accession_id=protocol_run.accession_id,
233 | |         schedule_entry_accession_id=schedule_entry.accession_id,
234 | |         asset_accession_id=asset.accession_id,
235 | |         asset_name=asset.name,
236 | |         redis_lock_key=kwargs.get("redis_lock_key", f"lock:asset:{asset.accession_id}"),
237 | |         lock_timeout_seconds=kwargs.get("lock_timeout_seconds", 3600),
238 | |         status=kwargs.get("status", AssetReservationStatusEnum.PENDING),
239 | |         asset_type=kwargs.get("asset_type", AssetType.ASSET),
240 | |     )
    | |_____^
241 |
242 |       # Set optional fields if provided
    |
info: rule `missing-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[FunctionCallStatusEnum] | FunctionCallStatusEnum`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[FunctionCallStatusEnum] | FunctionCallStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/factories_schedule.py:289:35
    |
287 |     defaults.update(kwargs)
288 |
289 |     call_log = FunctionCallLogOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[int] | int`, found `Unknown | UUID`
290 |
291 |     # Set relationships
    |
info: Element `UUID` of this union is not assignable to `SQLCoreOperations[int] | int`
info: rule `invalid-argument-type` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/factories_schedule.py:341:14
    |
340 |       # Build output with kw_only fields
341 |       output = FunctionDataOutputOrm(
    |  ______________^
342 | |         protocol_run_accession_id=protocol_run.accession_id,
343 | |         function_call_log_accession_id=function_call_log.accession_id,
344 | |         data_type=kwargs.get("data_type", DataOutputTypeEnum.UNKNOWN),
345 | |         data_key=kwargs.get("data_key", ""),
346 | |         spatial_context=kwargs.get("spatial_context", SpatialContextEnum.GLOBAL),
347 | |     )
    | |_____^
348 |
349 |       # Set optional numeric data
    |
info: rule `missing-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[AssetType] | AssetType`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[AssetType] | AssetType`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[ResourceStatusEnum] | ResourceStatusEnum`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[ResourceStatusEnum] | ResourceStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `str` and `ResourceStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:164:28
    |
163 |     accession_id = defaults.pop("accession_id", None)
164 |     resource = ResourceOrm(**defaults)
    |                            ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | ResourceStatusEnum | UUID`
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |
info: Union elements `ResourceStatusEnum` and `UUID` are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-assignment]: Invalid assignment to data descriptor attribute `accession_id` on type `ResourceOrm` with custom `__set__` method
   --> tests/helpers.py:166:9
    |
164 |     resource = ResourceOrm(**defaults)
165 |     if accession_id:
166 |         resource.accession_id = accession_id
    |         ^^^^^^^^^^^^^^^^^^^^^
167 |     db_session.add(resource)
168 |     await db_session.flush()
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[bool] | bool`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[bool] | bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[list[ParameterDefinitionOrm]] | list[ParameterDefinitionOrm]`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[ParameterDefinitionOrm]] | list[ParameterDefinitionOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetRequirementOrm]] | list[AssetRequirementOrm]`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[AssetRequirementOrm]] | list[AssetRequirementOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:319:50
    |
317 |         defaults["source_repository_accession_id"] = source_repository.accession_id
318 |
319 |     protocol_def = FunctionProtocolDefinitionOrm(**defaults)
    |                                                  ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`, found `Unknown | str`
320 |
321 |     # Manually assign relationships since init=False
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[ProtocolRunStatusEnum] | ProtocolRunStatusEnum`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union elements `str` and `UUID` are not assignable to `SQLCoreOperations[ProtocolRunStatusEnum] | ProtocolRunStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[datetime | None] | datetime | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[datetime | None] | datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union elements `UUID` and `ProtocolRunStatusEnum` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[FunctionCallLogOrm]] | list[FunctionCallLogOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[UUID | None] | UUID | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union elements `str` and `ProtocolRunStatusEnum` are not assignable to `SQLCoreOperations[UUID | None] | UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[int | None] | int | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[int | None] | int | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[ProtocolRunOrm | None] | ProtocolRunOrm | None`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[ProtocolRunOrm | None] | ProtocolRunOrm | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[ProtocolRunOrm]] | list[ProtocolRunOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[list[ScheduleEntryOrm]] | list[ScheduleEntryOrm]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[ScheduleEntryOrm]] | list[ScheduleEntryOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[AssetReservationOrm]] | list[AssetReservationOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union elements `UUID` and `ProtocolRunStatusEnum` are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:365:35
    |
363 |     accession_id = defaults.pop("accession_id", uuid7())
364 |
365 |     protocol_run = ProtocolRunOrm(**defaults)
    |                                   ^^^^^^^^^^ Expected `SQLCoreOperations[UUID] | UUID`, found `Unknown | str | UUID | ProtocolRunStatusEnum`
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |
info: Union elements `str` and `ProtocolRunStatusEnum` are not assignable to `SQLCoreOperations[UUID] | UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-assignment]: Invalid assignment to data descriptor attribute `accession_id` on type `ProtocolRunOrm` with custom `__set__` method
   --> tests/helpers.py:367:5
    |
365 |     protocol_run = ProtocolRunOrm(**defaults)
366 |     # Set accession_id manually
367 |     protocol_run.accession_id = accession_id
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
368 |
369 |     db_session.add(protocol_run)
    |
info: rule `invalid-assignment` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `DataOutputTypeEnum` are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[DataOutputTypeEnum] | DataOutputTypeEnum`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[DataOutputTypeEnum] | DataOutputTypeEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `DataOutputTypeEnum` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[SpatialContextEnum] | SpatialContextEnum`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[SpatialContextEnum] | SpatialContextEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `DataOutputTypeEnum` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | float | None] | int | float | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[int | float | None] | int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `DataOutputTypeEnum` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `DataOutputTypeEnum` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[bytes | None] | bytes | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[bytes | None] | bytes | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `DataOutputTypeEnum` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | None] | int | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[int | None] | int | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str | None] | str | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `DataOutputTypeEnum` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[str | None] | str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | float | None] | int | float | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[int | float | None] | int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `DataOutputTypeEnum` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[datetime] | datetime`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[datetime] | datetime`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | None] | int | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[int | None] | int | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `str` and `DataOutputTypeEnum` are not assignable to `SQLCoreOperations[dict[Unknown, Unknown] | None] | dict[Unknown, Unknown] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[FunctionCallLogOrm] | FunctionCallLogOrm`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[FunctionCallLogOrm] | FunctionCallLogOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[ProtocolRunOrm] | ProtocolRunOrm`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[ProtocolRunOrm] | ProtocolRunOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[ResourceOrm] | ResourceOrm`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[ResourceOrm] | ResourceOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[MachineOrm] | MachineOrm`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[MachineOrm] | MachineOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[DeckOrm] | DeckOrm`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[DeckOrm] | DeckOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[FunctionDataOutputOrm | None] | FunctionDataOutputOrm | None`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[FunctionDataOutputOrm | None] | FunctionDataOutputOrm | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[FunctionDataOutputOrm]] | list[FunctionDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union element `str`, and 2 more union elements, are not assignable to `SQLCoreOperations[list[WellDataOutputOrm]] | list[WellDataOutputOrm]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:423:9
    |
421 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
422 |     data_output = FunctionDataOutputOrm(
423 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | DataOutputTypeEnum | dict[Unknown | str, Unknown | int]`
424 |         protocol_run_accession_id=protocol_run.accession_id,
425 |         function_call_log_accession_id=function_call_log.accession_id,
    |
info: Union elements `DataOutputTypeEnum` and `dict[Unknown | str, Unknown | int]` are not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Union elements `str` and `int` are not assignable to `SQLCoreOperations[dict[str, Any]] | dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `int` of this union is not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int] | int`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[int] | int`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int] | int`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[int] | int`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | None] | int | None`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[int | None] | int | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[int | float | None] | int | float | None`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `str` of this union is not assignable to `SQLCoreOperations[int | float | None] | int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[FunctionDataOutputOrm] | FunctionDataOutputOrm`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Union elements `str` and `int` are not assignable to `SQLCoreOperations[FunctionDataOutputOrm] | FunctionDataOutputOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[ResourceOrm] | ResourceOrm`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Union elements `str` and `int` are not assignable to `SQLCoreOperations[ResourceOrm] | ResourceOrm`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/helpers.py:473:9
    |
471 |     # Create ORM with FK IDs only (MappedAsDataclass pattern)
472 |     well_output = WellDataOutputOrm(
473 |         **defaults,
    |         ^^^^^^^^^^ Expected `SQLCoreOperations[str] | str`, found `Unknown | str | int`
474 |         function_data_output_accession_id=function_data_output.accession_id,
475 |         plate_resource_accession_id=plate_resource.accession_id,
    |
info: Element `int` of this union is not assignable to `SQLCoreOperations[str] | str`
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_asset_requirement_orm.py:3:8
  |
1 | """Unit tests for AssetRequirementOrm model."""
2 | import pytest
3 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
4 | from sqlalchemy import select
5 | from sqlalchemy.exc import IntegrityError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_asset_requirement_orm.py:269:12
    |
267 |     # Verify JSONB storage and retrieval
268 |     assert asset.constraints_json == constraints
269 |     assert asset.constraints_json["capacity"] == 96
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
270 |     assert asset.constraints_json["consumable"] is True
271 |     assert asset.constraints_json["allowed_types"] == ["wellplate", "reservoir"]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_asset_requirement_orm.py:270:12
    |
268 |     assert asset.constraints_json == constraints
269 |     assert asset.constraints_json["capacity"] == 96
270 |     assert asset.constraints_json["consumable"] is True
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
271 |     assert asset.constraints_json["allowed_types"] == ["wellplate", "reservoir"]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_asset_requirement_orm.py:271:12
    |
269 |     assert asset.constraints_json["capacity"] == 96
270 |     assert asset.constraints_json["consumable"] is True
271 |     assert asset.constraints_json["allowed_types"] == ["wellplate", "reservoir"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_asset_requirement_orm.py:302:12
    |
300 |     # Verify JSONB storage and retrieval
301 |     assert asset.location_constraints_json == location_constraints
302 |     assert asset.location_constraints_json["allowed_positions"] == ["A1", "B1", "C1"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
303 |     assert asset.location_constraints_json["max_height_mm"] == 100
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_asset_requirement_orm.py:303:12
    |
301 |     assert asset.location_constraints_json == location_constraints
302 |     assert asset.location_constraints_json["allowed_positions"] == ["A1", "B1", "C1"]
303 |     assert asset.location_constraints_json["max_height_mm"] == 100
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

warning[possibly-missing-attribute]: Attribute `assets` may be missing on object of type `FunctionProtocolDefinitionOrm | None`
   --> tests/models/test_orm/test_asset_requirement_orm.py:346:16
    |
345 |     # Verify bidirectional relationship
346 |     assert len(protocol.assets) >= 2
    |                ^^^^^^^^^^^^^^^
347 |     asset_names = [a.name for a in protocol.assets]
348 |     assert "asset1" in asset_names
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `assets` may be missing on object of type `FunctionProtocolDefinitionOrm | None`
   --> tests/models/test_orm/test_asset_requirement_orm.py:347:36
    |
345 |     # Verify bidirectional relationship
346 |     assert len(protocol.assets) >= 2
347 |     asset_names = [a.name for a in protocol.assets]
    |                                    ^^^^^^^^^^^^^^^
348 |     assert "asset1" in asset_names
349 |     assert "asset2" in asset_names
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_asset_reservation_orm.py:7:8
  |
6 | import pytest
7 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
8 | from sqlalchemy import select
9 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-return-type]: Return type does not match returned value
  --> tests/models/test_orm/test_asset_reservation_orm.py:86:12
   |
84 |         return run
85 |
86 |     return _factory
   |            ^^^^^^^^ expected `() -> ProtocolRunOrm`, found `def _factory() -> CoroutineType[Any, Any, ProtocolRunOrm]`
   |
  ::: tests/models/test_orm/test_asset_reservation_orm.py:74:6
   |
72 |     db_session: AsyncSession,
73 |     protocol_definition: FunctionProtocolDefinitionOrm,
74 | ) -> Callable[[], ProtocolRunOrm]:
   |      ---------------------------- Expected `() -> ProtocolRunOrm` because of return type
75 |     """Create a ProtocolRunOrm factory for testing."""
   |
info: rule `invalid-return-type` is enabled by default

error[invalid-return-type]: Return type does not match returned value
   --> tests/models/test_orm/test_asset_reservation_orm.py:109:12
    |
107 |         return entry
108 |
109 |     return _factory
    |            ^^^^^^^^ expected `(ProtocolRunOrm, /) -> ScheduleEntryOrm`, found `def _factory(protocol_run: ProtocolRunOrm) -> CoroutineType[Any, Any, ScheduleEntryOrm]`
    |
   ::: tests/models/test_orm/test_asset_reservation_orm.py:92:6
    |
 90 | def schedule_entry_factory(
 91 |     db_session: AsyncSession,
 92 | ) -> Callable[[ProtocolRunOrm], ScheduleEntryOrm]:
    |      -------------------------------------------- Expected `(ProtocolRunOrm, /) -> ScheduleEntryOrm` because of return type
 93 |     """Create a ScheduleEntryOrm factory for testing."""
    |
info: rule `invalid-return-type` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:133:26
    |
131 | ) -> None:
132 |     """Test creating AssetReservationOrm with minimal required fields."""
133 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
134 |     schedule_entry = await schedule_entry_factory(protocol_run)
135 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:134:28
    |
132 |     """Test creating AssetReservationOrm with minimal required fields."""
133 |     protocol_run = await protocol_run_factory()
134 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |     reservation = AssetReservationOrm(
136 |         name="test_reservation",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:170:26
    |
168 | ) -> None:
169 |     """Test creating AssetReservationOrm with all fields populated."""
170 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
171 |     schedule_entry = await schedule_entry_factory(protocol_run)
172 |     now = datetime.now(timezone.utc)
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:171:28
    |
169 |     """Test creating AssetReservationOrm with all fields populated."""
170 |     protocol_run = await protocol_run_factory()
171 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
172 |     now = datetime.now(timezone.utc)
173 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:202:26
    |
200 | ) -> None:
201 |     """Test full persistence cycle for AssetReservationOrm."""
202 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
203 |     schedule_entry = await schedule_entry_factory(protocol_run)
204 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:203:28
    |
201 |     """Test full persistence cycle for AssetReservationOrm."""
202 |     protocol_run = await protocol_run_factory()
203 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
204 |     reservation = AssetReservationOrm(
205 |         name="test_reservation_persist",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:237:30
    |
235 |     """Test different status values for asset reservations."""
236 |     for status in AssetReservationStatusEnum:
237 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
238 |         schedule_entry = await schedule_entry_factory(protocol_run)
239 |         reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:238:32
    |
236 |     for status in AssetReservationStatusEnum:
237 |         protocol_run = await protocol_run_factory()
238 |         schedule_entry = await schedule_entry_factory(protocol_run)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
239 |         reservation = AssetReservationOrm(
240 |             name=f"test_reservation_{status.value}",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:270:26
    |
268 | ) -> None:
269 |     """Test Redis lock tracking fields."""
270 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
271 |     schedule_entry = await schedule_entry_factory(protocol_run)
272 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:271:28
    |
269 |     """Test Redis lock tracking fields."""
270 |     protocol_run = await protocol_run_factory()
271 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
272 |     reservation = AssetReservationOrm(
273 |         name="test_reservation_redis",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:299:26
    |
297 | ) -> None:
298 |     """Test reservation timing fields."""
299 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
300 |     schedule_entry = await schedule_entry_factory(protocol_run)
301 |     now = datetime.now(timezone.utc)
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:300:28
    |
298 |     """Test reservation timing fields."""
299 |     protocol_run = await protocol_run_factory()
300 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
301 |     now = datetime.now(timezone.utc)
302 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:327:30
    |
325 |     """Test asset_type field for different asset types."""
326 |     for asset_type in list(AssetType):
327 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
328 |         schedule_entry = await schedule_entry_factory(protocol_run)
329 |         reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:328:32
    |
326 |     for asset_type in list(AssetType):
327 |         protocol_run = await protocol_run_factory()
328 |         schedule_entry = await schedule_entry_factory(protocol_run)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
329 |         reservation = AssetReservationOrm(
330 |             name=f"test_reservation_{asset_type.value}",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:362:26
    |
360 | ) -> None:
361 |     """Test relationship between AssetReservationOrm and ProtocolRunOrm."""
362 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
363 |     schedule_entry = await schedule_entry_factory(protocol_run)
364 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:363:28
    |
361 |     """Test relationship between AssetReservationOrm and ProtocolRunOrm."""
362 |     protocol_run = await protocol_run_factory()
363 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
364 |     reservation = AssetReservationOrm(
365 |         name="test_reservation_relationship_run",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:391:26
    |
389 | ) -> None:
390 |     """Test relationship between AssetReservationOrm and ScheduleEntryOrm."""
391 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
392 |     schedule_entry = await schedule_entry_factory(protocol_run)
393 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:392:28
    |
390 |     """Test relationship between AssetReservationOrm and ScheduleEntryOrm."""
391 |     protocol_run = await protocol_run_factory()
392 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
393 |     reservation = AssetReservationOrm(
394 |         name="test_reservation_relationship_schedule",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:420:26
    |
418 | ) -> None:
419 |     """Test relationship between AssetReservationOrm and AssetOrm."""
420 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
421 |     schedule_entry = await schedule_entry_factory(protocol_run)
422 |     reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:421:28
    |
419 |     """Test relationship between AssetReservationOrm and AssetOrm."""
420 |     protocol_run = await protocol_run_factory()
421 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
422 |     reservation = AssetReservationOrm(
423 |         name="test_reservation_relationship_asset",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:455:21
    |
453 |     ]
454 |     for i, status in enumerate(statuses):
455 |         run = await protocol_run_factory()
    |                     ^^^^^^^^^^^^^^^^^^^^^^
456 |         entry = await schedule_entry_factory(run)
457 |         reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:456:23
    |
454 |     for i, status in enumerate(statuses):
455 |         run = await protocol_run_factory()
456 |         entry = await schedule_entry_factory(run)
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
457 |         reservation = AssetReservationOrm(
458 |             name=f"test_reservation_{i}",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:501:21
    |
499 |     ]
500 |     for i, status in enumerate(statuses):
501 |         run = await protocol_run_factory()
    |                     ^^^^^^^^^^^^^^^^^^^^^^
502 |         entry = await schedule_entry_factory(run)
503 |         reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:502:23
    |
500 |     for i, status in enumerate(statuses):
501 |         run = await protocol_run_factory()
502 |         entry = await schedule_entry_factory(run)
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
503 |         reservation = AssetReservationOrm(
504 |             name=f"test_reservation_{i}",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:539:21
    |
537 |     """Test querying reservations for a specific asset."""
538 |     for i in range(3):
539 |         run = await protocol_run_factory()
    |                     ^^^^^^^^^^^^^^^^^^^^^^
540 |         entry = await schedule_entry_factory(run)
541 |         reservation = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:540:23
    |
538 |     for i in range(3):
539 |         run = await protocol_run_factory()
540 |         entry = await schedule_entry_factory(run)
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
541 |         reservation = AssetReservationOrm(
542 |             name=f"test_reservation_{i}",
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:570:26
    |
568 | ) -> None:
569 |     """Test that multiple asset reservations can be created for the same protocol run."""
570 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
571 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_asset_reservation_orm.py:571:28
    |
569 |     """Test that multiple asset reservations can be created for the same protocol run."""
570 |     protocol_run = await protocol_run_factory()
571 |     schedule_entry = await schedule_entry_factory(protocol_run)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
572 |
573 |     reservation1 = AssetReservationOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_deck_orm.py:3:8
  |
1 | """Unit tests for Deck-related ORM models."""
2 | import pytest
3 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
4 | from sqlalchemy import select
5 | from sqlalchemy.exc import IntegrityError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_deck_orm.py:118:12
    |
116 |     assert deck_def.positioning_config_json == positioning_config
117 |     assert deck_def.serialized_constructor_args_json == constructor_args
118 |     assert deck_def.positioning_config_json["method_name"] == "slot_to_location"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 |     assert deck_def.serialized_constructor_args_json["rails"] == 54
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_deck_orm.py:119:12
    |
117 |     assert deck_def.serialized_constructor_args_json == constructor_args
118 |     assert deck_def.positioning_config_json["method_name"] == "slot_to_location"
119 |     assert deck_def.serialized_constructor_args_json["rails"] == 54
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

warning[possibly-missing-attribute]: Attribute `base_path` may be missing on object of type `FileSystemProtocolSourceOrm | None`
   --> tests/models/test_orm/test_file_system_protocol_source_orm.py:216:12
    |
214 |     )
215 |     retrieved = result.scalars().first()
216 |     assert retrieved.base_path == "/opt/protocols/new_path"
    |            ^^^^^^^^^^^^^^^^^^^
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_function_call_log_orm.py:5:8
  |
4 | import pytest
5 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
6 | from sqlalchemy import select
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_call_log_orm.py:279:12
    |
277 |     # Verify JSONB storage and retrieval
278 |     assert call_log.input_args_json == input_args
279 |     assert call_log.input_args_json["volume_ul"] == 50
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
280 |     assert call_log.input_args_json["nested"]["items"] == [1, 2, 3]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_call_log_orm.py:280:12
    |
278 |     assert call_log.input_args_json == input_args
279 |     assert call_log.input_args_json["volume_ul"] == 50
280 |     assert call_log.input_args_json["nested"]["items"] == [1, 2, 3]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_call_log_orm.py:314:12
    |
312 |     # Verify JSONB storage
313 |     assert call_log.return_value_json == return_value
314 |     assert call_log.return_value_json["actual_volume"] == 49.8
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 |     assert call_log.return_value_json["measurements"] == [1.2, 3.4, 5.6]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_call_log_orm.py:315:12
    |
313 |     assert call_log.return_value_json == return_value
314 |     assert call_log.return_value_json["actual_volume"] == 49.8
315 |     assert call_log.return_value_json["measurements"] == [1.2, 3.4, 5.6]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unsupported-operator]: Operator `-` is unsupported between objects of type `datetime | None` and `datetime`
   --> tests/models/test_orm/test_function_call_log_orm.py:423:17
    |
421 |     assert call_log.end_time == end_time
422 |     # Duration should be 10 seconds
423 |     duration = (call_log.end_time - call_log.start_time).total_seconds()
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
424 |     assert duration == 10
    |
info: rule `unsupported-operator` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_function_data_output_orm.py:7:8
  |
6 | import pytest
7 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
8 | from sqlalchemy import select
9 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-return-type]: Return type does not match returned value
  --> tests/models/test_orm/test_function_data_output_orm.py:92:12
   |
90 |         return run
91 |
92 |     return _factory
   |            ^^^^^^^^ expected `() -> ProtocolRunOrm`, found `def _factory() -> CoroutineType[Any, Any, ProtocolRunOrm]`
   |
  ::: tests/models/test_orm/test_function_data_output_orm.py:80:6
   |
78 |     db_session: AsyncSession,
79 |     protocol_definition: FunctionProtocolDefinitionOrm,
80 | ) -> Callable[[], ProtocolRunOrm]:
   |      ---------------------------- Expected `() -> ProtocolRunOrm` because of return type
81 |     """Create a ProtocolRunOrm factory for testing."""
   |
info: rule `invalid-return-type` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_function_data_output_orm.py:102:26
    |
100 | ) -> FunctionCallLogOrm:
101 |     """Create a FunctionCallLogOrm for testing."""
102 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
103 |     call_log = FunctionCallLogOrm(
104 |         name="test_function_call_log",
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_function_data_output_orm.py:193:9
    |
191 |         data_key="absorbance_580nm",
192 |         spatial_context=SpatialContextEnum.WELL_SPECIFIC,
193 |         resource_accession_id=resource_asset.accession_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `UUID`
194 |         machine_accession_id=machine_asset.accession_id,
195 |         spatial_coordinates_json={"well": "A1"},
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_function_data_output_orm.py:194:9
    |
192 |         spatial_context=SpatialContextEnum.WELL_SPECIFIC,
193 |         resource_accession_id=resource_asset.accession_id,
194 |         machine_accession_id=machine_asset.accession_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `UUID`
195 |         spatial_coordinates_json={"well": "A1"},
196 |         data_value_numeric=0.456,
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_function_data_output_orm.py:525:9
    |
523 |         protocol_run_accession_id=function_call_log.protocol_run_accession_id,
524 |         function_call_log_accession_id=function_call_log.accession_id,
525 |         resource_accession_id=resource_asset.accession_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `UUID`
526 |     )
527 |     output.protocol_run = function_call_log.protocol_run
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_function_data_output_orm.py:556:9
    |
554 |         protocol_run_accession_id=function_call_log.protocol_run_accession_id,
555 |         function_call_log_accession_id=function_call_log.accession_id,
556 |         machine_accession_id=machine_asset.accession_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `UUID`
557 |     )
558 |     output.protocol_run = function_call_log.protocol_run
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_function_data_output_orm.py:643:13
    |
641 |             protocol_run_accession_id=function_call_log.protocol_run_accession_id,
642 |             function_call_log_accession_id=function_call_log.accession_id,
643 |             resource_accession_id=resource_asset.accession_id,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[UUID[Unknown] | None] | UUID[Unknown] | None`, found `UUID`
644 |         )
645 |         output.protocol_run = function_call_log.protocol_run
    |
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_function_protocol_definition_orm.py:3:8
  |
1 | """Unit tests for FunctionProtocolDefinitionOrm model."""
2 | import pytest
3 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
4 | from sqlalchemy import select
5 | from sqlalchemy.exc import IntegrityError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_protocol_definition_orm.py:387:12
    |
385 |     # Verify JSONB storage and retrieval
386 |     assert protocol.tags == tags
387 |     assert protocol.tags["category"] == "liquid_handling"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
388 |     assert protocol.tags["hardware"] == ["pipette", "plate_reader"]
389 |     assert protocol.category == "liquid_handling"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_function_protocol_definition_orm.py:388:12
    |
386 |     assert protocol.tags == tags
387 |     assert protocol.tags["category"] == "liquid_handling"
388 |     assert protocol.tags["hardware"] == ["pipette", "plate_reader"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
389 |     assert protocol.category == "liquid_handling"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_machine_definition_orm.py:217:12
    |
215 |     assert retrieved is not None
216 |     assert retrieved.plr_definition_details_json == plr_details
217 |     assert retrieved.plr_definition_details_json["channels"] == 8
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |     assert retrieved.rotation_json == rotation
219 |     assert retrieved.rotation_json["y_deg"] == 90
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_machine_definition_orm.py:219:12
    |
217 |     assert retrieved.plr_definition_details_json["channels"] == 8
218 |     assert retrieved.rotation_json == rotation
219 |     assert retrieved.rotation_json["y_deg"] == 90
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |     assert retrieved.setup_method_json == setup_method
221 |     assert retrieved.setup_method_json["method"] == "setup_with_robot_config"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_machine_definition_orm.py:221:12
    |
219 |     assert retrieved.rotation_json["y_deg"] == 90
220 |     assert retrieved.setup_method_json == setup_method
221 |     assert retrieved.setup_method_json["method"] == "setup_with_robot_config"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_machine_orm.py:263:12
    |
261 |     # Verify JSON was stored correctly
262 |     assert machine.connection_info == connection_data
263 |     assert machine.connection_info["backend"] == "hamilton"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
264 |     assert machine.connection_info["port"] == 8080
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_machine_orm.py:264:12
    |
262 |     assert machine.connection_info == connection_data
263 |     assert machine.connection_info["backend"] == "hamilton"
264 |     assert machine.connection_info["port"] == 8080
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_parameter_definition_orm.py:3:8
  |
1 | """Unit tests for ParameterDefinitionOrm model."""
2 | import pytest
3 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
4 | from sqlalchemy import select
5 | from sqlalchemy.exc import IntegrityError
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `source_repository` does not match any known parameter
  --> tests/models/test_orm/test_parameter_definition_orm.py:21:9
   |
19 |     protocol = FunctionProtocolDefinitionOrm(
20 |         name="test_protocol",
21 |         source_repository=None,
   |         ^^^^^^^^^^^^^^^^^^^^^^
22 |         file_system_source=None,
23 |         fqn="test.protocols.test_protocol",
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `file_system_source` does not match any known parameter
  --> tests/models/test_orm/test_parameter_definition_orm.py:22:9
   |
20 |         name="test_protocol",
21 |         source_repository=None,
22 |         file_system_source=None,
   |         ^^^^^^^^^^^^^^^^^^^^^^^
23 |         fqn="test.protocols.test_protocol",
24 |         version="1.0.0",
   |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_parameter_definition_orm.py:276:12
    |
274 |     # Verify JSONB storage and retrieval
275 |     assert param.constraints_json == constraints
276 |     assert param.constraints_json["min_value"] == 0
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
277 |     assert param.constraints_json["options"] == ["A", "B", "C"]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_parameter_definition_orm.py:277:12
    |
275 |     assert param.constraints_json == constraints
276 |     assert param.constraints_json["min_value"] == 0
277 |     assert param.constraints_json["options"] == ["A", "B", "C"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_parameter_definition_orm.py:307:12
    |
305 |     # Verify JSONB storage and retrieval
306 |     assert param.ui_hint_json == ui_hint
307 |     assert param.ui_hint_json["widget_type"] == "slider"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
308 |     assert param.ui_hint_json["step"] == 5
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_parameter_definition_orm.py:308:12
    |
306 |     assert param.ui_hint_json == ui_hint
307 |     assert param.ui_hint_json["widget_type"] == "slider"
308 |     assert param.ui_hint_json["step"] == 5
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

warning[possibly-missing-attribute]: Attribute `parameters` may be missing on object of type `FunctionProtocolDefinitionOrm | None`
   --> tests/models/test_orm/test_parameter_definition_orm.py:349:16
    |
348 |     # Verify bidirectional relationship
349 |     assert len(protocol.parameters) >= 2
    |                ^^^^^^^^^^^^^^^^^^^
350 |     param_names = [p.name for p in protocol.parameters]
351 |     assert "param1" in param_names
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `parameters` may be missing on object of type `FunctionProtocolDefinitionOrm | None`
   --> tests/models/test_orm/test_parameter_definition_orm.py:350:36
    |
348 |     # Verify bidirectional relationship
349 |     assert len(protocol.parameters) >= 2
350 |     param_names = [p.name for p in protocol.parameters]
    |                                    ^^^^^^^^^^^^^^^^^^^
351 |     assert "param1" in param_names
352 |     assert "param2" in param_names
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_protocol_run_orm.py:5:8
  |
4 | import pytest
5 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
6 | from sqlalchemy import select
7 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:216:12
    |
214 |     # Verify JSONB storage and retrieval
215 |     assert run.input_parameters_json == input_params
216 |     assert run.input_parameters_json["volume_ul"] == 100
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |     assert run.input_parameters_json["plate_ids"] == ["plate_001", "plate_002"]
218 |     assert run.input_parameters_json["nested"]["count"] == 42
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:217:12
    |
215 |     assert run.input_parameters_json == input_params
216 |     assert run.input_parameters_json["volume_ul"] == 100
217 |     assert run.input_parameters_json["plate_ids"] == ["plate_001", "plate_002"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |     assert run.input_parameters_json["nested"]["count"] == 42
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:218:12
    |
216 |     assert run.input_parameters_json["volume_ul"] == 100
217 |     assert run.input_parameters_json["plate_ids"] == ["plate_001", "plate_002"]
218 |     assert run.input_parameters_json["nested"]["count"] == 42
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:243:12
    |
241 |     # Verify JSONB storage
242 |     assert run.resolved_assets_json == resolved_assets
243 |     assert run.resolved_assets_json["liquid_handler"]["id"] == "star_001"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:268:12
    |
266 |     # Verify JSONB storage
267 |     assert run.output_data_json == output_data
268 |     assert run.output_data_json["measurements"] == [1.2, 3.4, 5.6, 7.8]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:301:12
    |
299 |     assert run.initial_state_json == initial_state
300 |     assert run.final_state_json == final_state
301 |     assert run.initial_state_json["tip_count"] == 96
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
302 |     assert run.final_state_json["tip_count"] == 0
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:302:12
    |
300 |     assert run.final_state_json == final_state
301 |     assert run.initial_state_json["tip_count"] == 96
302 |     assert run.final_state_json["tip_count"] == 0
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_protocol_run_orm.py:345:12
    |
343 |     # Verify user info storage
344 |     assert run.created_by_user == user_info
345 |     assert run.created_by_user["username"] == "scientist_alice"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

warning[possibly-missing-attribute]: Attribute `last_synced_commit` may be missing on object of type `ProtocolSourceRepositoryOrm | None`
   --> tests/models/test_orm/test_protocol_source_repository_orm.py:228:12
    |
226 |     )
227 |     retrieved = result.scalars().first()
228 |     assert retrieved.last_synced_commit == "new_commit_abc123"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_resource_definition_orm.py:82:9
   |
80 |     resource_def_id = uuid7()
81 |     resource_def = ResourceDefinitionOrm(
82 |         accession_id=resource_def_id,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |         name="persistence_test_plate",
84 |         fqn="test.persistence.Plate",
   |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_resource_definition_orm.py:186:12
    |
184 |     assert retrieved is not None
185 |     assert retrieved.plr_definition_details_json == plr_details
186 |     assert retrieved.plr_definition_details_json["num_items_x"] == 12
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
187 |     assert retrieved.rotation_json == rotation
188 |     assert retrieved.rotation_json["z_deg"] == 180
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_resource_definition_orm.py:188:12
    |
186 |     assert retrieved.plr_definition_details_json["num_items_x"] == 12
187 |     assert retrieved.rotation_json == rotation
188 |     assert retrieved.rotation_json["z_deg"] == 180
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_resource_orm.py:272:12
    |
270 |     # Verify JSON was stored correctly
271 |     assert resource.plr_state == plr_state
272 |     assert resource.plr_state["location"]["x"] == 100.5
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
273 |     assert resource.plr_state["metadata"]["barcode"] == "ABC123"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_resource_orm.py:273:12
    |
271 |     assert resource.plr_state == plr_state
272 |     assert resource.plr_state["location"]["x"] == 100.5
273 |     assert resource.plr_state["metadata"]["barcode"] == "ABC123"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_schedule_entry_orm.py:7:8
  |
6 | import pytest
7 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
8 | from sqlalchemy import select
9 | from sqlalchemy.ext.asyncio import AsyncSession
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `source_repository` does not match any known parameter
  --> tests/models/test_orm/test_schedule_entry_orm.py:57:9
   |
55 |         version="1.0.0",
56 |         is_top_level=True,
57 |         source_repository=source_repository,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |         file_system_source=file_system_source,
59 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `file_system_source` does not match any known parameter
  --> tests/models/test_orm/test_schedule_entry_orm.py:58:9
   |
56 |         is_top_level=True,
57 |         source_repository=source_repository,
58 |         file_system_source=file_system_source,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
59 |     )
60 |     db_session.add(protocol)
   |
info: rule `unknown-argument` is enabled by default

error[invalid-return-type]: Return type does not match returned value
  --> tests/models/test_orm/test_schedule_entry_orm.py:81:12
   |
79 |         return run
80 |
81 |     return _factory
   |            ^^^^^^^^ expected `() -> ProtocolRunOrm`, found `def _factory() -> CoroutineType[Any, Any, ProtocolRunOrm]`
   |
  ::: tests/models/test_orm/test_schedule_entry_orm.py:69:6
   |
67 |     db_session: AsyncSession,
68 |     protocol_definition: FunctionProtocolDefinitionOrm,
69 | ) -> Callable[[], ProtocolRunOrm]:
   |      ---------------------------- Expected `() -> ProtocolRunOrm` because of return type
70 |     """Create a ProtocolRunOrm factory for testing."""
   |
info: rule `invalid-return-type` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:90:26
    |
 88 | ) -> None:
 89 |     """Test creating ScheduleEntryOrm with minimal required fields."""
 90 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
 91 |     entry = ScheduleEntryOrm(
 92 |         protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:126:26
    |
124 | ) -> None:
125 |     """Test creating ScheduleEntryOrm with all fields populated."""
126 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
127 |     now = datetime.now(timezone.utc)
128 |     asset_reqs = {"pipette": {"type": "p1000", "count": 1}}
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:184:26
    |
182 | ) -> None:
183 |     """Test full persistence cycle for ScheduleEntryOrm."""
184 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
185 |     entry = ScheduleEntryOrm(
186 |         protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:216:30
    |
214 |     """Test different status values for schedule entries."""
215 |     for i, status in enumerate(ScheduleStatusEnum):
216 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
217 |         entry = ScheduleEntryOrm(
218 |             protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:248:30
    |
246 |     priorities = [5, 1, 10]
247 |     for i, p in enumerate(priorities):
248 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
249 |         entry = ScheduleEntryOrm(
250 |             protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:277:26
    |
275 | ) -> None:
276 |     """Test timestamp fields for tracking execution stages."""
277 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
278 |     now = datetime.now(timezone.utc)
279 |     entry = ScheduleEntryOrm(
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:304:26
    |
302 | ) -> None:
303 |     """Test JSONB asset_requirements_json field."""
304 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
305 |     asset_reqs = {
306 |         "pipettes": [{"name": "p1000", "count": 1}],
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_entry_orm.py:322:12
    |
320 |     await db_session.flush()
321 |
322 |     assert entry.asset_requirements_json["pipettes"][0]["name"] == "p1000"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
323 |     assert entry.asset_requirements_json["plates"]["count"] == 2
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_entry_orm.py:323:12
    |
322 |     assert entry.asset_requirements_json["pipettes"][0]["name"] == "p1000"
323 |     assert entry.asset_requirements_json["plates"]["count"] == 2
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:332:26
    |
330 | ) -> None:
331 |     """Test Celery task tracking fields."""
332 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
333 |     entry = ScheduleEntryOrm(
334 |         protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:357:26
    |
355 | ) -> None:
356 |     """Test retry_count and max_retries fields."""
357 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
358 |     entry = ScheduleEntryOrm(
359 |         protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:384:26
    |
382 | ) -> None:
383 |     """Test JSONB user_params_json and initial_state_json fields."""
384 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
385 |     user_params = {"param1": "value1", "nested": {"p2": 2}}
386 |     initial_state = {"state1": "initial", "nested": {"s2": "s2_val"}}
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_entry_orm.py:401:12
    |
399 |     await db_session.flush()
400 |
401 |     assert entry.user_params_json["nested"]["p2"] == 2
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
402 |     assert entry.initial_state_json["nested"]["s2"] == "s2_val"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_entry_orm.py:402:12
    |
401 |     assert entry.user_params_json["nested"]["p2"] == 2
402 |     assert entry.initial_state_json["nested"]["s2"] == "s2_val"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:411:26
    |
409 | ) -> None:
410 |     """Test relationship between ScheduleEntryOrm and ProtocolRunOrm."""
411 |     protocol_run = await protocol_run_factory()
    |                          ^^^^^^^^^^^^^^^^^^^^^^
412 |     entry = ScheduleEntryOrm(
413 |         protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:438:30
    |
436 |     statuses = [ScheduleStatusEnum.QUEUED, ScheduleStatusEnum.READY_TO_EXECUTE, ScheduleStatusEnum.QUEUED]
437 |     for i, status in enumerate(statuses):
438 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
439 |         entry = ScheduleEntryOrm(
440 |             protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ProtocolRunOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_entry_orm.py:477:30
    |
475 |     ]
476 |     for i, data in enumerate(entries_data):
477 |         protocol_run = await protocol_run_factory()
    |                              ^^^^^^^^^^^^^^^^^^^^^^
478 |         entry = ScheduleEntryOrm(
479 |             protocol_run=protocol_run,
    |
   ::: praxis/backend/models/orm/protocol.py:545:7
    |
545 | class ProtocolRunOrm(Base):
    |       -------------- type defined here
546 |
547 |   """SQLAlchemy ORM model for logging a top-level protocol execution.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_schedule_entry_orm.py:481:13
    |
479 |             protocol_run=protocol_run,
480 |             name=f"test_schedule_entry_{i}",
481 |             status=data["status"],
    |             ^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[ScheduleStatusEnum] | ScheduleStatusEnum`, found `Unknown | ScheduleStatusEnum | int`
482 |             priority=data["priority"],
483 |             scheduled_at=datetime.now(timezone.utc),
    |
info: Element `int` of this union is not assignable to `SQLCoreOperations[ScheduleStatusEnum] | ScheduleStatusEnum`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_orm/test_schedule_entry_orm.py:482:13
    |
480 |             name=f"test_schedule_entry_{i}",
481 |             status=data["status"],
482 |             priority=data["priority"],
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `SQLCoreOperations[int] | int`, found `Unknown | ScheduleStatusEnum | int`
483 |             scheduled_at=datetime.now(timezone.utc),
484 |             asset_analysis_completed_at=None,
    |
info: Element `ScheduleStatusEnum` of this union is not assignable to `SQLCoreOperations[int] | int`
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
  --> tests/models/test_orm/test_schedule_history_orm.py:9:8
   |
 8 | import pytest
 9 | import pytest_asyncio
   |        ^^^^^^^^^^^^^^
10 | from sqlalchemy import select
11 | from sqlalchemy.ext.asyncio import AsyncSession
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `source_repository` does not match any known parameter
  --> tests/models/test_orm/test_schedule_history_orm.py:67:9
   |
65 |         version="1.0.0",
66 |         is_top_level=True,
67 |         source_repository=source_repository,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |         file_system_source=file_system_source,
69 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `file_system_source` does not match any known parameter
  --> tests/models/test_orm/test_schedule_history_orm.py:68:9
   |
66 |         is_top_level=True,
67 |         source_repository=source_repository,
68 |         file_system_source=file_system_source,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |     )
70 |     db_session.add(protocol)
   |
info: rule `unknown-argument` is enabled by default

error[invalid-return-type]: Return type does not match returned value
   --> tests/models/test_orm/test_schedule_history_orm.py:105:12
    |
103 |         return entry
104 |
105 |     return _factory
    |            ^^^^^^^^ expected `() -> ScheduleEntryOrm`, found `def _factory() -> CoroutineType[Any, Any, ScheduleEntryOrm]`
    |
   ::: tests/models/test_orm/test_schedule_history_orm.py:79:6
    |
 77 |     db_session: AsyncSession,
 78 |     protocol_definition: FunctionProtocolDefinitionOrm,
 79 | ) -> Callable[[], ScheduleEntryOrm]:
    |      ------------------------------ Expected `() -> ScheduleEntryOrm` because of return type
 80 |     """Create a ScheduleEntryOrm factory for testing."""
    |
info: rule `invalid-return-type` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:122:28
    |
120 |     - Allow nullable from_status, to_status, event_data_json, message, error_details
121 |     """
122 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
123 |
124 |     history = ScheduleHistoryOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:168:28
    |
166 |     - Custom trigger (USER, CELERY, etc.)
167 |     """
168 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
169 |     event_data = {"retry_count": 1, "reason": "Network timeout"}
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:204:28
    |
202 | ) -> None:
203 |     """Test full persistence cycle for ScheduleHistoryOrm."""
204 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
205 |
206 |     history = ScheduleHistoryOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:250:28
    |
248 |     - RETRY_ATTEMPTED
249 |     """
250 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
251 |
252 |     for event_type in ScheduleHistoryEventEnum:
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:288:28
    |
286 |     - EXECUTING  COMPLETED
287 |     """
288 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
289 |
290 |     transitions = [
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:338:28
    |
336 |     - Support override_duration_ms for manual duration
337 |     """
338 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
339 |
340 |     history = ScheduleHistoryOrm(
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:373:28
    |
371 | ) -> None:
372 |     """Test JSONB event_data_json field for storing arbitrary event data."""
373 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
374 |
375 |     event_data = {
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_history_orm.py:397:12
    |
396 |     # Verify JSONB structure
397 |     assert history.event_data_json["assets_reserved"] == ["pipette_1", "plate_reader"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
398 |     assert history.event_data_json["queue_position"] == 3
399 |     assert history.event_data_json["metadata"]["user"] == "test_user"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_history_orm.py:398:12
    |
396 |     # Verify JSONB structure
397 |     assert history.event_data_json["assets_reserved"] == ["pipette_1", "plate_reader"]
398 |     assert history.event_data_json["queue_position"] == 3
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
399 |     assert history.event_data_json["metadata"]["user"] == "test_user"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_orm/test_schedule_history_orm.py:399:12
    |
397 |     assert history.event_data_json["assets_reserved"] == ["pipette_1", "plate_reader"]
398 |     assert history.event_data_json["queue_position"] == 3
399 |     assert history.event_data_json["metadata"]["user"] == "test_user"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:408:28
    |
406 | ) -> None:
407 |     """Test error_details field for tracking failures."""
408 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
409 |
410 |     error_message = """
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[unsupported-operator]: Unsupported `in` operation
   --> tests/models/test_orm/test_schedule_history_orm.py:430:12
    |
428 |     await db_session.flush()
429 |
430 |     assert "AssetUnavailableError" in history.error_details
    |            -----------------------^^^^---------------------
    |            |                          |
    |            |                          Has type `str | None`
    |            Has type `Literal["AssetUnavailableError"]`
431 |     assert "Pipette p1000" in history.error_details
    |
info: Operation fails because operator `in` is not supported between objects of type `Literal["AssetUnavailableError"]` and `None`
info: rule `unsupported-operator` is enabled by default

error[unsupported-operator]: Unsupported `in` operation
   --> tests/models/test_orm/test_schedule_history_orm.py:431:12
    |
430 |     assert "AssetUnavailableError" in history.error_details
431 |     assert "Pipette p1000" in history.error_details
    |            ---------------^^^^---------------------
    |            |                  |
    |            |                  Has type `str | None`
    |            Has type `Literal["Pipette p1000"]`
    |
info: Operation fails because operator `in` is not supported between objects of type `Literal["Pipette p1000"]` and `None`
info: rule `unsupported-operator` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:447:28
    |
445 |     - SCHEDULER
446 |     """
447 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
448 |
449 |     for trigger in ScheduleHistoryEventTriggerEnum:
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:480:28
    |
478 | ) -> None:
479 |     """Test asset_count field for tracking number of assets involved."""
480 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
481 |
482 |     asset_counts = [0, 1, 5, 10]
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[unsupported-operator]: Unsupported `>=` operation
   --> tests/models/test_orm/test_schedule_history_orm.py:503:16
    |
502 |     assert len(high_count_entries) == 2
503 |     assert all(h.asset_count >= 5 for h in high_count_entries)
    |                -------------^^^^-
    |                |                |
    |                |                Has type `Literal[5]`
    |                Has type `int | None`
    |
info: Operation fails because operator `>=` is not supported between objects of type `None` and `Literal[5]`
info: rule `unsupported-operator` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:512:28
    |
510 | ) -> None:
511 |     """Test relationship between ScheduleHistoryOrm and ScheduleEntryOrm."""
512 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
513 |
514 |     # Create multiple history entries for same schedule entry
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:542:28
    |
540 | ) -> None:
541 |     """Test querying history entries by event type."""
542 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
543 |
544 |     # Create mix of event types
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:580:28
    |
578 | ) -> None:
579 |     """Test querying history entries within a time range."""
580 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
581 |
582 |     # Create entries (event_start will be set automatically)
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[invalid-await]: `ScheduleEntryOrm` is not awaitable
   --> tests/models/test_orm/test_schedule_history_orm.py:617:28
    |
615 |     The relationship should have cascade='all, delete-orphan'.
616 |     """
617 |     schedule_entry = await schedule_entry_factory()
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
618 |     entry_id = schedule_entry.accession_id
    |
   ::: praxis/backend/models/orm/schedule.py:52:7
    |
 52 | class ScheduleEntryOrm(Base):
    |       ---------------- type defined here
 53 |
 54 |   """SQLAlchemy ORM model for tracking scheduled protocol runs.
    |
info: `__await__` is missing
info: rule `invalid-await` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
  --> tests/models/test_orm/test_user_orm.py:16:12
   |
15 |       user_id = uuid7()
16 |       user = UserOrm(
   |  ____________^
17 | |         accession_id=user_id,
18 | |         username="testuser",
19 | |         email="test@example.com",
20 | |         hashed_password="hashed_password_123",
21 | |     )
   | |_____^
22 |       db_session.add(user)
23 |       await db_session.flush()
   |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
  --> tests/models/test_orm/test_user_orm.py:42:12
   |
41 |       user_id = uuid7()
42 |       user = UserOrm(
   |  ____________^
43 | |         accession_id=user_id,
44 | |         username="fulluser",
45 | |         email="full@example.com",
46 | |         hashed_password="hashed_password_456",
47 | |         full_name="John Doe",
48 | |         is_active=True,
49 | |         phone_number="555-1234",
50 | |         phone_carrier="verizon",
51 | |     )
   | |_____^
52 |       db_session.add(user)
53 |       await db_session.flush()
   |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
  --> tests/models/test_orm/test_user_orm.py:72:12
   |
71 |       user_id = uuid7()
72 |       user = UserOrm(
   |  ____________^
73 | |         accession_id=user_id,
74 | |         username="persistuser",
75 | |         email="persist@example.com",
76 | |         hashed_password="hashed_password_789",
77 | |         full_name="Jane Smith",
78 | |     )
   | |_____^
79 |       db_session.add(user)
80 |       await db_session.flush()
   |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:104:13
    |
103 |       # Create first user
104 |       user1 = UserOrm(
    |  _____________^
105 | |         accession_id=uuid7(),
106 | |         username="uniqueuser",
107 | |         email="user1@example.com",
108 | |         hashed_password="hash1",
109 | |     )
    | |_____^
110 |       db_session.add(user1)
111 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:114:13
    |
113 |       # Try to create another with same username
114 |       user2 = UserOrm(
    |  _____________^
115 | |         accession_id=uuid7(),
116 | |         username="uniqueuser",  # Duplicate username
117 | |         email="user2@example.com",
118 | |         hashed_password="hash2",
119 | |     )
    | |_____^
120 |       db_session.add(user2)
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:133:13
    |
132 |       # Create first user
133 |       user1 = UserOrm(
    |  _____________^
134 | |         accession_id=uuid7(),
135 | |         username="user1",
136 | |         email="unique@example.com",
137 | |         hashed_password="hash1",
138 | |     )
    | |_____^
139 |       db_session.add(user1)
140 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:143:13
    |
142 |       # Try to create another with same email
143 |       user2 = UserOrm(
    |  _____________^
144 | |         accession_id=uuid7(),
145 | |         username="user2",
146 | |         email="unique@example.com",  # Duplicate email
147 | |         hashed_password="hash2",
148 | |     )
    | |_____^
149 |       db_session.add(user2)
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:162:19
    |
161 |       # Active user (default)
162 |       active_user = UserOrm(
    |  ___________________^
163 | |         accession_id=uuid7(),
164 | |         username="activeuser",
165 | |         email="active@example.com",
166 | |         hashed_password="hash_active",
167 | |     )
    | |_____^
168 |       db_session.add(active_user)
169 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:173:21
    |
172 |       # Inactive user
173 |       inactive_user = UserOrm(
    |  _____________________^
174 | |         accession_id=uuid7(),
175 | |         username="inactiveuser",
176 | |         email="inactive@example.com",
177 | |         hashed_password="hash_inactive",
178 | |         is_active=False,
179 | |     )
    | |_____^
180 |       db_session.add(inactive_user)
181 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:190:12
    |
188 |       from praxis.backend.utils.uuid import uuid7
189 |
190 |       user = UserOrm(
    |  ____________^
191 | |         accession_id=uuid7(),
192 | |         username="phoneuser",
193 | |         email="phone@example.com",
194 | |         hashed_password="hash_phone",
195 | |         phone_number="555-0100",
196 | |         phone_carrier="att",
197 | |     )
    | |_____^
198 |       db_session.add(user)
199 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:218:12
    |
217 |       user_id = uuid7()
218 |       user = UserOrm(
    |  ____________^
219 | |         accession_id=user_id,
220 | |         username="repruser",
221 | |         email="repr@example.com",
222 | |         hashed_password="hash_repr",
223 | |     )
    | |_____^
224 |
225 |       repr_str = repr(user)
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:238:12
    |
236 |       from praxis.backend.utils.uuid import uuid7
237 |
238 |       user = UserOrm(
    |  ____________^
239 | |         accession_id=uuid7(),
240 | |         username="queryuser",
241 | |         email="query@example.com",
242 | |         hashed_password="hash_query",
243 | |     )
    | |_____^
244 |       db_session.add(user)
245 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `name`
   --> tests/models/test_orm/test_user_orm.py:263:12
    |
261 |       from praxis.backend.utils.uuid import uuid7
262 |
263 |       user = UserOrm(
    |  ____________^
264 | |         accession_id=uuid7(),
265 | |         username="emailquery",
266 | |         email="emailquery@example.com",
267 | |         hashed_password="hash_email",
268 | |     )
    | |_____^
269 |       db_session.add(user)
270 |       await db_session.flush()
    |
info: rule `missing-argument` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
 --> tests/models/test_orm/test_well_data_output_orm.py:5:8
  |
4 | import pytest
5 | import pytest_asyncio
  |        ^^^^^^^^^^^^^^
6 | from sqlalchemy.ext.asyncio import AsyncSession
7 | from sqlalchemy.future import select
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_well_data_output_orm.py:84:9
   |
82 |     """Fixture for a function call log."""
83 |     function_call_log = FunctionCallLogOrm(
84 |         accession_id=uuid7(),
   |         ^^^^^^^^^^^^^^^^^^^^
85 |         name="test_function_call",
86 |         protocol_run_accession_id=protocol_run.accession_id,
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_workcell_orm.py:18:9
   |
16 |     workcell_id = uuid7()
17 |     workcell = WorkcellOrm(
18 |         accession_id=workcell_id,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
19 |         name="test_workcell",
20 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_workcell_orm.py:38:9
   |
36 |     workcell_id = uuid7()
37 |     workcell = WorkcellOrm(
38 |         accession_id=workcell_id,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
39 |         name="test_persistence",
40 |         description="A test workcell",
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_workcell_orm.py:71:9
   |
69 |     # Create first workcell
70 |     workcell1 = WorkcellOrm(
71 |         accession_id=uuid7(),
   |         ^^^^^^^^^^^^^^^^^^^^
72 |         name="unique_workcell",
73 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_workcell_orm.py:79:9
   |
77 |     # Try to create another with same name
78 |     workcell2 = WorkcellOrm(
79 |         accession_id=uuid7(),
   |         ^^^^^^^^^^^^^^^^^^^^
80 |         name="unique_workcell",  # Duplicate name
81 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
  --> tests/models/test_orm/test_workcell_orm.py:95:9
   |
94 |     workcell = WorkcellOrm(
95 |         accession_id=uuid7(),
   |         ^^^^^^^^^^^^^^^^^^^^
96 |         name="test_relationships",
97 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_orm/test_workcell_orm.py:111:9
    |
110 |     workcell = WorkcellOrm(
111 |         accession_id=uuid7(),
    |         ^^^^^^^^^^^^^^^^^^^^
112 |         name="test_status",
113 |         status=WorkcellStatusEnum.MAINTENANCE.value,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `resource_definition_accession_id` does not match any known parameter
  --> tests/models/test_pydantic/test_deck_pydantic.py:53:9
   |
51 |         machine_id=machine_id,
52 |         deck_type_id=deck_type_id,
53 |         resource_definition_accession_id=resource_def_id,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unresolved-attribute]: Object of type `DeckBase` has no attribute `resource_definition_accession_id`
  --> tests/models/test_pydantic/test_deck_pydantic.py:62:12
   |
60 |     assert deck.machine_id == machine_id
61 |     assert deck.deck_type_id == deck_type_id
62 |     assert deck.resource_definition_accession_id == resource_def_id
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `datetime`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `datetime`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `datetime | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `UUID` of this union is not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `dict[str, Any]`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `AssetType | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `AssetType | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `UUID` of this union is not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `UUID` of this union is not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `ResourceStatusEnum | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `ResourceStatusEnum | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `UUID` of this union is not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `list[ResourceBase]`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `list[ResourceBase]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `ResourceBase | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `ResourceBase | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `list[UUID]`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `list[UUID]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Element `str` of this union is not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_deck_pydantic.py:169:25
    |
167 |     }
168 |
169 |     deck = DeckResponse(**deck_data)
    |                         ^^^^^^^^^^^ Expected `ResourceResponse | None`, found `Unknown | UUID | str`
170 |
171 |     assert deck.accession_id == deck_id
    |
info: Union elements `UUID` and `str` are not assignable to `ResourceResponse | None`
info: rule `invalid-argument-type` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_deck_pydantic.py:226:9
    |
224 |     deck_id = uuid7()
225 |     orm_deck = DeckOrm(
226 |         accession_id=deck_id,
    |         ^^^^^^^^^^^^^^^^^^^^
227 |         name="orm_test_deck",
228 |         fqn="test.orm.Deck",
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_deck_pydantic.py:285:9
    |
283 |     deck_id = uuid7()
284 |     orm_deck = DeckOrm(
285 |         accession_id=deck_id,
    |         ^^^^^^^^^^^^^^^^^^^^
286 |         name="minimal_deck",
287 |         fqn="test.minimal.Deck",
    |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_pydantic/test_deck_pydantic.py:328:12
    |
326 |     assert config.arg_name == "slot"
327 |     assert config.arg_type == "str"
328 |     assert config.params["offset_x"] == 10.0
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unsupported-operator]: Unsupported `in` operation
   --> tests/models/test_pydantic/test_deck_pydantic.py:387:12
    |
386 |     assert position.compatible_resource_fqns == compatible_resources
387 |     assert "plates" in position.compatible_resource_fqns
    |            --------^^^^---------------------------------
    |            |           |
    |            |           Has type `dict[str, Any] | None`
    |            Has type `Literal["plates"]`
388 |     assert len(position.compatible_resource_fqns["plates"]) == 2
    |
info: Operation fails because operator `in` is not supported between objects of type `Literal["plates"]` and `None`
info: rule `unsupported-operator` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_pydantic/test_deck_pydantic.py:388:16
    |
386 |     assert position.compatible_resource_fqns == compatible_resources
387 |     assert "plates" in position.compatible_resource_fqns
388 |     assert len(position.compatible_resource_fqns["plates"]) == 2
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
  --> tests/models/test_pydantic/test_machine_definition_pydantic.py:75:9
   |
73 |     """Test MachineDefinitionCreate model."""
74 |     machine_def = MachineDefinitionCreate(
75 |         name="test_liquid_handler",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
76 |         fqn="test.machine.LiquidHandler",
77 |         machine_category=MachineCategoryEnum.LIQUID_HANDLER,
   |
info: rule `unknown-argument` is enabled by default

error[unresolved-attribute]: Object of type `MachineDefinitionCreate` has no attribute `name`
  --> tests/models/test_pydantic/test_machine_definition_pydantic.py:82:12
   |
80 |     )
81 |
82 |     assert machine_def.name == "test_liquid_handler"
   |            ^^^^^^^^^^^^^^^^
83 |     assert machine_def.fqn == "test.machine.LiquidHandler"
84 |     assert machine_def.machine_category == "LiquidHandler"
   |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `UUID`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `str` and `MachineCategoryEnum` are not assignable to `UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `datetime`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `datetime`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `datetime | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `dict[str, Any]`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `MachineCategoryEnum | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `str` are not assignable to `MachineCategoryEnum | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `UUID` and `MachineCategoryEnum` are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `str` and `MachineCategoryEnum` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `bool | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `bool | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `UUID | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union elements `str` and `MachineCategoryEnum` are not assignable to `UUID | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:169:42
    |
167 |     }
168 |
169 |     response = MachineDefinitionResponse(**machine_data)
    |                                          ^^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str | MachineCategoryEnum`
170 |
171 |     assert response.accession_id == machine_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:295:9
    |
294 |     machine_def = MachineDefinitionCreate(
295 |         name="jsonb_test",
    |         ^^^^^^^^^^^^^^^^^
296 |         fqn="test.jsonb.Machine",
297 |         plr_definition_details_json=plr_details,
    |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:302:12
    |
301 |     assert machine_def.plr_definition_details_json == plr_details
302 |     assert machine_def.plr_definition_details_json["num_channels"] == 8
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
303 |     assert machine_def.setup_method_json == setup_method
    |
info: rule `non-subscriptable` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:318:13
    |
316 |     for category in categories:
317 |         machine_def = MachineDefinitionCreate(
318 |             name=f"test_{category.value}",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
319 |             fqn=f"test.category.{category.value}",
320 |             machine_category=category,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:328:9
    |
326 |     """Test physical dimension fields."""
327 |     machine_def = MachineDefinitionCreate(
328 |         name="dimensioned_machine",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
329 |         fqn="test.dimensions.Machine",
330 |         size_x_mm=1600.0,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:344:9
    |
342 |     # Liquid handler with deck
343 |     with_deck = MachineDefinitionCreate(
344 |         name="liquid_handler_with_deck",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
345 |         fqn="test.deck.WithDeck",
346 |         machine_category=MachineCategoryEnum.LIQUID_HANDLER,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_definition_pydantic.py:353:9
    |
351 |     # Pump without deck
352 |     without_deck = MachineDefinitionCreate(
353 |         name="pump_without_deck",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
354 |         fqn="test.deck.WithoutDeck",
355 |         machine_category=MachineCategoryEnum.PUMP,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `asset_type` does not match any known parameter
  --> tests/models/test_pydantic/test_machine_pydantic.py:91:28
   |
89 |     # Create with minimal required field (asset_type)
90 |     # Note: name has default_factory in PraxisBaseModel, so it's auto-generated
91 |     update = MachineUpdate(asset_type=AssetType.MACHINE)
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
92 |     assert update.asset_type == "MACHINE"
93 |     assert update.name is not None  # Auto-generated from UUID
   |
info: rule `unknown-argument` is enabled by default

error[unresolved-attribute]: Object of type `MachineUpdate` has no attribute `asset_type`
  --> tests/models/test_pydantic/test_machine_pydantic.py:92:12
   |
90 |     # Note: name has default_factory in PraxisBaseModel, so it's auto-generated
91 |     update = MachineUpdate(asset_type=AssetType.MACHINE)
92 |     assert update.asset_type == "MACHINE"
   |            ^^^^^^^^^^^^^^^^^
93 |     assert update.name is not None  # Auto-generated from UUID
94 |     assert update.description is None
   |
info: rule `unresolved-attribute` is enabled by default

error[unknown-argument]: Argument `asset_type` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_pydantic.py:99:9
    |
 97 |     # Should be able to create with partial fields
 98 |     update_partial = MachineUpdate(
 99 |         asset_type=AssetType.MACHINE,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |         name="new_name",
101 |         status=MachineStatusEnum.MAINTENANCE,
    |
info: rule `unknown-argument` is enabled by default

error[unresolved-attribute]: Object of type `MachineUpdate` has no attribute `asset_type`
   --> tests/models/test_pydantic/test_machine_pydantic.py:103:12
    |
101 |         status=MachineStatusEnum.MAINTENANCE,
102 |     )
103 |     assert update_partial.asset_type == "MACHINE"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
104 |     assert update_partial.name == "new_name"
105 |     assert update_partial.status == "MAINTENANCE"
    |
info: rule `unresolved-attribute` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_pydantic.py:183:9
    |
181 |         fqn="test.enum.1",
182 |         asset_type=AssetType.MACHINE,
183 |         status="AVAILABLE",
    |         ^^^^^^^^^^^^^^^^^^ Expected `MachineStatusEnum | None`, found `Literal["AVAILABLE"]`
184 |     )
185 |     assert machine1.status == "AVAILABLE"
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_machine_pydantic.py:202:13
    |
200 |             fqn="test.enum.3",
201 |             asset_type=AssetType.MACHINE,
202 |             status="invalid_status",
    |             ^^^^^^^^^^^^^^^^^^^^^^^ Expected `MachineStatusEnum | None`, found `Literal["invalid_status"]`
203 |         )
    |
info: rule `invalid-argument-type` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_pydantic.py:246:9
    |
244 |     machine_id = uuid7()
245 |     orm_machine = MachineOrm(
246 |         accession_id=machine_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
247 |         name="orm_test_machine",
248 |         fqn="test.orm.Machine",
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_machine_pydantic.py:283:9
    |
281 |     machine_id = uuid7()
282 |     orm_machine = MachineOrm(
283 |         accession_id=machine_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
284 |         name="minimal_machine",
285 |         fqn="test.minimal.Machine",
    |
info: rule `unknown-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `UUID`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `str`, and 2 more union elements, are not assignable to `UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `datetime`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 3 more union elements, are not assignable to `datetime`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `datetime | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 3 more union elements, are not assignable to `datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `dict[str, Any]`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 3 more union elements, are not assignable to `dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `bool`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union elements `UUID` and `str` are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 3 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union elements `UUID` and `str` are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union elements `UUID` and `str` are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `int | float | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union elements `UUID` and `str` are not assignable to `int | float | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `dict[str, Any] | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 3 more union elements, are not assignable to `dict[str, Any] | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:162:43
    |
160 |     }
161 |
162 |     response = ResourceDefinitionResponse(**resource_data)
    |                                           ^^^^^^^^^^^^^^^ Expected `str | None`, found `Unknown | UUID | str | bool | float`
163 |
164 |     assert response.accession_id == resource_id
    |
info: Union element `UUID`, and 2 more union elements, are not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/models/test_pydantic/test_resource_definition_pydantic.py:291:12
    |
290 |     assert resource_def.plr_definition_details_json == plr_details
291 |     assert resource_def.plr_definition_details_json["num_items_x"] == 12
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/models/test_pydantic/test_resource_pydantic.py:47:9
   |
45 |         status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
46 |         status_details="Ready to use",
47 |         resource_definition_accession_id="019a6f00-0000-7000-8000-000000000001",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `UUID | None`, found `Literal["019a6f00-0000-7000-8000-000000000001"]`
48 |         parent_accession_id="019a6f00-0000-7000-8000-000000000002",
49 |         workcell_accession_id="019a6f00-0000-7000-8000-000000000003",
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/models/test_pydantic/test_resource_pydantic.py:48:9
   |
46 |         status_details="Ready to use",
47 |         resource_definition_accession_id="019a6f00-0000-7000-8000-000000000001",
48 |         parent_accession_id="019a6f00-0000-7000-8000-000000000002",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `UUID | None`, found `Literal["019a6f00-0000-7000-8000-000000000002"]`
49 |         workcell_accession_id="019a6f00-0000-7000-8000-000000000003",
50 |         plr_state=plr_state,
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/models/test_pydantic/test_resource_pydantic.py:49:9
   |
47 |         resource_definition_accession_id="019a6f00-0000-7000-8000-000000000001",
48 |         parent_accession_id="019a6f00-0000-7000-8000-000000000002",
49 |         workcell_accession_id="019a6f00-0000-7000-8000-000000000003",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `UUID | None`, found `Literal["019a6f00-0000-7000-8000-000000000003"]`
50 |         plr_state=plr_state,
51 |     )
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_pydantic.py:171:9
    |
169 |         fqn="test.enum.1",
170 |         asset_type=AssetType.RESOURCE,
171 |         status="available_in_storage",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `ResourceStatusEnum | None`, found `Literal["available_in_storage"]`
172 |     )
173 |     assert resource1.status == "available_in_storage"
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_pydantic.py:190:13
    |
188 |             fqn="test.enum.3",
189 |             asset_type=AssetType.RESOURCE,
190 |             status="invalid_status",
    |             ^^^^^^^^^^^^^^^^^^^^^^^ Expected `ResourceStatusEnum | None`, found `Literal["invalid_status"]`
191 |         )
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_resource_pydantic.py:202:9
    |
200 |         status=ResourceStatusEnum.EMPTY,
201 |         status_details="Testing roundtrip",
202 |         resource_definition_accession_id="019a6f00-1234-7000-8000-444444444444",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected `UUID | None`, found `Literal["019a6f00-1234-7000-8000-444444444444"]`
203 |         plr_state={"test": "data", "nested": {"value": 123}},
204 |     )
    |
info: rule `invalid-argument-type` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_resource_pydantic.py:242:9
    |
240 |     resource_id = uuid7()
241 |     orm_resource = ResourceOrm(
242 |         accession_id=resource_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
243 |         name="orm_test_resource",
244 |         fqn="test.orm.Resource",
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_resource_pydantic.py:290:9
    |
288 |     resource_id = uuid7()
289 |     orm_resource = ResourceOrm(
290 |         accession_id=resource_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
291 |         name="minimal_resource",
292 |         fqn="test.minimal.Resource",
    |
info: rule `unknown-argument` is enabled by default

error[missing-argument]: No argument provided for required parameter `password`
  --> tests/models/test_pydantic/test_user_pydantic.py:62:9
   |
60 |       """Test that UserCreate requires password field."""
61 |       with pytest.raises(ValidationError) as exc_info:
62 | /         UserCreate(
63 | |             username="testuser",
64 | |             email="test@example.com",
65 | |             # Missing password
66 | |         )
   | |_________^
67 |
68 |       errors = exc_info.value.errors()
   |
info: rule `missing-argument` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `UUID`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Union elements `str` and `bool` are not assignable to `UUID`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `datetime`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Union elements `str` and `bool` are not assignable to `datetime`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `datetime | None`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Union elements `str` and `bool` are not assignable to `datetime | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Element `bool` of this union is not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `dict[str, Any]`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Union elements `str` and `bool` are not assignable to `dict[str, Any]`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Element `bool` of this union is not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `str`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Element `bool` of this union is not assignable to `str`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `str | None`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Element `bool` of this union is not assignable to `str | None`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_user_pydantic.py:145:29
    |
143 |     }
144 |
145 |     response = UserResponse(**user_data)
    |                             ^^^^^^^^^^^ Expected `bool`, found `Unknown | str | bool`
146 |
147 |     assert response.username == "deserialized_user"
    |
info: Element `str` of this union is not assignable to `bool`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_workcell_pydantic.py:167:9
    |
165 |     workcell1 = WorkcellResponse(
166 |         name="enum_test_1",
167 |         status="active",
    |         ^^^^^^^^^^^^^^^ Expected `WorkcellStatusEnum`, found `Literal["active"]`
168 |     )
169 |     # With use_enum_values=True, status is stored as string
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/models/test_pydantic/test_workcell_pydantic.py:184:13
    |
182 |         WorkcellResponse(
183 |             name="enum_test_3",
184 |             status="invalid_status",
    |             ^^^^^^^^^^^^^^^^^^^^^^^ Expected `WorkcellStatusEnum`, found `Literal["invalid_status"]`
185 |         )
    |
info: rule `invalid-argument-type` is enabled by default

error[unknown-argument]: Argument `accession_id` does not match any known parameter
   --> tests/models/test_pydantic/test_workcell_pydantic.py:224:9
    |
222 |     workcell_id = uuid7()
223 |     orm_workcell = WorkcellOrm(
224 |         accession_id=workcell_id,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
225 |         name="orm_test_workcell",
226 |         description="Testing ORM to Pydantic conversion",
    |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `DeckOrm | None`
   --> tests/services/test_deck_service.py:192:12
    |
191 |     refetched = await deck_service.get(db=db_session, accession_id=created.accession_id)
192 |     assert refetched.name == "Updated Deck Name"
    |            ^^^^^^^^^^^^^^
193 |
194 | @pytest.mark.asyncio
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
  --> tests/services/test_deck_type_definition_service.py:31:9
   |
30 |     pos_def = DeckPositionDefinitionCreate(
31 |         name="Pos1",
   |         ^^^^^^^^^^^
32 |         nominal_x_mm=10.0,
33 |         nominal_y_mm=20.0,
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `version` does not match any known parameter
  --> tests/services/test_deck_type_definition_service.py:42:9
   |
40 |         name="Hamilton STAR",
41 |         fqn="pylabrobot.liquid_handling.backends.hamilton.STARDeck",
42 |         version="1.0.0",
   |         ^^^^^^^^^^^^^^^
43 |         positioning_config=pos_config,
44 |         position_definitions=[pos_def],
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `version` does not match any known parameter
  --> tests/services/test_deck_type_definition_service.py:71:9
   |
69 |         name="Test Deck",
70 |         fqn="test.deck",
71 |         version="1.0.0",
   |         ^^^^^^^^^^^^^^^
72 |         positioning_config=pos_config,
73 |         position_definitions=[],
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `version` does not match any known parameter
  --> tests/services/test_deck_type_definition_service.py:94:9
   |
92 |         name="Update Deck",
93 |         fqn="update.deck",
94 |         version="1.0.0",
   |         ^^^^^^^^^^^^^^^
95 |         positioning_config=pos_config,
96 |         position_definitions=[],
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `version` does not match any known parameter
   --> tests/services/test_deck_type_definition_service.py:122:9
    |
120 |         name="Delete Deck",
121 |         fqn="delete.deck",
122 |         version="1.0.0",
    |         ^^^^^^^^^^^^^^^
123 |         positioning_config=pos_config,
124 |     )
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `asset_type` does not match any known parameter
   --> tests/services/test_machine_service.py:113:9
    |
111 |         name="Updated Name",
112 |         status=MachineStatusEnum.AVAILABLE,
113 |         asset_type=AssetType.MACHINE,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     )
115 |     updated = await machine_service.update(db=db_session, db_obj=created, obj_in=update_data)
    |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `MachineOrm | None`
   --> tests/services/test_machine_service.py:122:12
    |
121 |     refetched = await machine_service.get(db=db_session, accession_id=created.accession_id)
122 |     assert refetched.name == "Updated Name"
    |            ^^^^^^^^^^^^^^
123 |
124 | @pytest.mark.asyncio
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unknown-argument]: Argument `asset_type` does not match any known parameter
   --> tests/services/test_machine_service.py:131:55
    |
130 |     # Provide asset_type
131 |     update_data = MachineUpdate(name="Existing Name", asset_type=AssetType.MACHINE)
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
132 |     with pytest.raises(ValueError, match="already exists"):
133 |         await machine_service.update(db=db_session, db_obj=target, obj_in=update_data)
    |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `MachineOrm | None`
   --> tests/services/test_machine_service.py:166:12
    |
164 |     )
165 |
166 |     assert updated.status == MachineStatusEnum.IN_USE
    |            ^^^^^^^^^^^^^^
167 |     assert updated.status_details == "Running protocol"
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `status_details` may be missing on object of type `MachineOrm | None`
   --> tests/services/test_machine_service.py:167:12
    |
166 |     assert updated.status == MachineStatusEnum.IN_USE
167 |     assert updated.status_details == "Running protocol"
    |            ^^^^^^^^^^^^^^^^^^^^^^
168 |
169 |     # Note: We cannot easily test current_protocol_run_accession_id here without
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unknown-argument]: Argument `asset_type` does not match any known parameter
   --> tests/services/test_machine_service.py:209:9
    |
208 |     update_data = MachineUpdate(
209 |         asset_type=AssetType.MACHINE,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |         resource_def_name=res_def_name,
211 |     )
    |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `ProtocolSourceRepositoryOrm | None`
  --> tests/services/test_protocol_definition_service.py:75:12
   |
73 |     created_def = await protocol_definition_service.create(db_session, obj_in=create_data)
74 |
75 |     assert created_def.source_repository.name == "existing_repo"
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
76 |     assert created_def.file_system_source.name == "existing_fs"
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `FileSystemProtocolSourceOrm | None`
  --> tests/services/test_protocol_definition_service.py:76:12
   |
75 |     assert created_def.source_repository.name == "existing_repo"
76 |     assert created_def.file_system_source.name == "existing_fs"
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |
78 | @pytest.mark.asyncio
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `ProtocolSourceRepositoryOrm | None`
  --> tests/services/test_protocol_definition_service.py:96:12
   |
94 |     created_def = await protocol_definition_service.create(db_session, obj_in=create_data)
95 |
96 |     assert created_def.source_repository.name == "missing_repo"
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |     assert created_def.file_system_source.name == "missing_fs"
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `FileSystemProtocolSourceOrm | None`
  --> tests/services/test_protocol_definition_service.py:97:12
   |
96 |     assert created_def.source_repository.name == "missing_repo"
97 |     assert created_def.file_system_source.name == "missing_fs"
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
98 |
99 | @pytest.mark.asyncio
   |
info: rule `possibly-missing-attribute` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
  --> tests/services/test_protocol_run_service.py:21:8
   |
20 | import pytest
21 | import pytest_asyncio
   |        ^^^^^^^^^^^^^^
22 | from unittest.mock import AsyncMock, patch
23 | from sqlalchemy import select
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `source_repository` does not match any known parameter
  --> tests/services/test_protocol_run_service.py:52:9
   |
50 |         version="1.0.0",
51 |         is_top_level=True,
52 |         source_repository=None,
   |         ^^^^^^^^^^^^^^^^^^^^^^
53 |         file_system_source=None,
54 |     )
   |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `file_system_source` does not match any known parameter
  --> tests/services/test_protocol_run_service.py:53:9
   |
51 |         is_top_level=True,
52 |         source_repository=None,
53 |         file_system_source=None,
   |         ^^^^^^^^^^^^^^^^^^^^^^^
54 |     )
55 |     db_session.add(protocol)
   |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_protocol_run_service.py:158:12
    |
156 |     # Verify JSONB fields stored correctly with nested access
157 |     assert run.input_parameters_json == input_params
158 |     assert run.input_parameters_json["volumes"] == [50, 100, 150]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |     assert run.input_parameters_json["config"]["mix_cycles"] == 3
160 |     assert run.initial_state_json == initial_state
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_protocol_run_service.py:159:12
    |
157 |     assert run.input_parameters_json == input_params
158 |     assert run.input_parameters_json["volumes"] == [50, 100, 150]
159 |     assert run.input_parameters_json["config"]["mix_cycles"] == 3
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
160 |     assert run.initial_state_json == initial_state
161 |     assert run.initial_state_json["plates"] == ["plate_001", "plate_002"]
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_protocol_run_service.py:161:12
    |
159 |     assert run.input_parameters_json["config"]["mix_cycles"] == 3
160 |     assert run.initial_state_json == initial_state
161 |     assert run.initial_state_json["plates"] == ["plate_001", "plate_002"]
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:183:13
    |
181 |         create_data = ProtocolRunCreate(
182 |             run_accession_id=uuid7(),
183 |             name=f"test_run_{i}",
    |             ^^^^^^^^^^^^^^^^^^^^
184 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
185 |             status=ProtocolRunStatusEnum.RUNNING if i % 2 == 0 else ProtocolRunStatusEnum.COMPLETED,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:191:29
    |
190 |     # Get all runs
191 |     filters = SearchFilters(skip=0, limit=10)
    |                             ^^^^^^
192 |     retrieved_runs = await protocol_run_service.get_multi(db_session, filters=filters)
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `source_repository` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:220:9
    |
218 |         version="1.0.0",
219 |         is_top_level=True,
220 |         source_repository=None,
    |         ^^^^^^^^^^^^^^^^^^^^^^
221 |         file_system_source=None,
222 |     )
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `file_system_source` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:221:9
    |
219 |         is_top_level=True,
220 |         source_repository=None,
221 |         file_system_source=None,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
222 |     )
223 |     db_session.add(other_protocol)
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:231:13
    |
229 |         obj_in=ProtocolRunCreate(
230 |             run_accession_id=uuid7(),
231 |             name="run_proto1",
    |             ^^^^^^^^^^^^^^^^^
232 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
233 |         ),
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:239:13
    |
237 |         obj_in=ProtocolRunCreate(
238 |             run_accession_id=uuid7(),
239 |             name="run_proto2",
    |             ^^^^^^^^^^^^^^^^^
240 |             top_level_protocol_definition_accession_id=other_protocol.accession_id,
241 |         ),
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:245:29
    |
244 |     # Filter by first protocol definition
245 |     filters = SearchFilters(skip=0, limit=10)
    |                             ^^^^^^
246 |     filtered_runs = await protocol_run_service.get_multi(
247 |         db_session,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:276:13
    |
274 |         obj_in=ProtocolRunCreate(
275 |             run_accession_id=uuid7(),
276 |             name="completed_run",
    |             ^^^^^^^^^^^^^^^^^^^^
277 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
278 |             status=ProtocolRunStatusEnum.COMPLETED,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:285:13
    |
283 |         obj_in=ProtocolRunCreate(
284 |             run_accession_id=uuid7(),
285 |             name="running_run",
    |             ^^^^^^^^^^^^^^^^^^
286 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
287 |             status=ProtocolRunStatusEnum.RUNNING,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:292:29
    |
291 |     # Filter by RUNNING status
292 |     filters = SearchFilters(skip=0, limit=10)
    |                             ^^^^^^
293 |     running_runs = await protocol_run_service.get_multi(
294 |         db_session,
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:323:13
    |
321 |         obj_in=ProtocolRunCreate(
322 |             run_accession_id=uuid7(),
323 |             name="my_run_instance",
    |             ^^^^^^^^^^^^^^^^^^^^^^
324 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
325 |         ),
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `name` does not match any known parameter
   --> tests/services/test_protocol_run_service.py:714:13
    |
712 |         obj_in=ProtocolRunCreate(
713 |             run_accession_id=uuid7(),
714 |             name="lifecycle_test",
    |             ^^^^^^^^^^^^^^^^^^^^^
715 |             top_level_protocol_definition_accession_id=protocol_definition.accession_id,
716 |             status=ProtocolRunStatusEnum.PENDING,
    |
info: rule `unknown-argument` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:730:12
    |
728 |         new_status=ProtocolRunStatusEnum.RUNNING,
729 |     )
730 |     assert run.status == ProtocolRunStatusEnum.RUNNING
    |            ^^^^^^^^^^
731 |     assert run.start_time is not None
732 |     start_time = run.start_time
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `start_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:731:12
    |
729 |     )
730 |     assert run.status == ProtocolRunStatusEnum.RUNNING
731 |     assert run.start_time is not None
    |            ^^^^^^^^^^^^^^
732 |     start_time = run.start_time
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `start_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:732:18
    |
730 |     assert run.status == ProtocolRunStatusEnum.RUNNING
731 |     assert run.start_time is not None
732 |     start_time = run.start_time
    |                  ^^^^^^^^^^^^^^
733 |
734 |     # 3. Log function calls
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `accession_id` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:737:39
    |
735 |     call1 = await log_function_call_start(
736 |         db_session,
737 |         protocol_run_orm_accession_id=run.accession_id,
    |                                       ^^^^^^^^^^^^^^^^
738 |         function_definition_accession_id=protocol_definition.accession_id,
739 |         sequence_in_run=0,
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `accession_id` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:751:39
    |
749 |     call2 = await log_function_call_start(
750 |         db_session,
751 |         protocol_run_orm_accession_id=run.accession_id,
    |                                       ^^^^^^^^^^^^^^^^
752 |         function_definition_accession_id=protocol_definition.accession_id,
753 |         sequence_in_run=1,
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `accession_id` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:766:35
    |
764 |     run = await protocol_run_service.update_run_status(
765 |         db_session,
766 |         protocol_run_accession_id=run.accession_id,
    |                                   ^^^^^^^^^^^^^^^^
767 |         new_status=ProtocolRunStatusEnum.COMPLETED,
768 |         output_data_json=json.dumps({"success": True, "total_transferred": 98.5}),
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:773:12
    |
772 |     # 5. Verify complete lifecycle
773 |     assert run.status == ProtocolRunStatusEnum.COMPLETED
    |            ^^^^^^^^^^
774 |     assert run.start_time == start_time
775 |     assert run.end_time is not None
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `start_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:774:12
    |
772 |     # 5. Verify complete lifecycle
773 |     assert run.status == ProtocolRunStatusEnum.COMPLETED
774 |     assert run.start_time == start_time
    |            ^^^^^^^^^^^^^^
775 |     assert run.end_time is not None
776 |     assert run.end_time > run.start_time
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `end_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:775:12
    |
773 |     assert run.status == ProtocolRunStatusEnum.COMPLETED
774 |     assert run.start_time == start_time
775 |     assert run.end_time is not None
    |            ^^^^^^^^^^^^
776 |     assert run.end_time > run.start_time
777 |     assert run.duration_ms is not None
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unsupported-operator]: Unsupported `>` operation
   --> tests/services/test_protocol_run_service.py:776:12
    |
774 |     assert run.start_time == start_time
775 |     assert run.end_time is not None
776 |     assert run.end_time > run.start_time
    |            ------------^^^--------------
    |            |              |
    |            |              Has type `datetime | None`
    |            Has type `datetime`
777 |     assert run.duration_ms is not None
778 |     assert run.duration_ms > 0
    |
info: Operation fails because operator `>` is not supported between objects of type `datetime` and `None`
info: rule `unsupported-operator` is enabled by default

warning[possibly-missing-attribute]: Attribute `end_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:776:12
    |
774 |     assert run.start_time == start_time
775 |     assert run.end_time is not None
776 |     assert run.end_time > run.start_time
    |            ^^^^^^^^^^^^
777 |     assert run.duration_ms is not None
778 |     assert run.duration_ms > 0
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `start_time` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:776:27
    |
774 |     assert run.start_time == start_time
775 |     assert run.end_time is not None
776 |     assert run.end_time > run.start_time
    |                           ^^^^^^^^^^^^^^
777 |     assert run.duration_ms is not None
778 |     assert run.duration_ms > 0
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `duration_ms` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:777:12
    |
775 |     assert run.end_time is not None
776 |     assert run.end_time > run.start_time
777 |     assert run.duration_ms is not None
    |            ^^^^^^^^^^^^^^^
778 |     assert run.duration_ms > 0
779 |     assert run.input_parameters_json == {"volume": 100}
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `duration_ms` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:778:12
    |
776 |     assert run.end_time > run.start_time
777 |     assert run.duration_ms is not None
778 |     assert run.duration_ms > 0
    |            ^^^^^^^^^^^^^^^
779 |     assert run.input_parameters_json == {"volume": 100}
780 |     assert run.output_data_json == {"success": True, "total_transferred": 98.5}
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `input_parameters_json` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:779:12
    |
777 |     assert run.duration_ms is not None
778 |     assert run.duration_ms > 0
779 |     assert run.input_parameters_json == {"volume": 100}
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
780 |     assert run.output_data_json == {"success": True, "total_transferred": 98.5}
781 |     assert run.initial_state_json == {"tip_count": 96}
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `output_data_json` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:780:12
    |
778 |     assert run.duration_ms > 0
779 |     assert run.input_parameters_json == {"volume": 100}
780 |     assert run.output_data_json == {"success": True, "total_transferred": 98.5}
    |            ^^^^^^^^^^^^^^^^^^^^
781 |     assert run.initial_state_json == {"tip_count": 96}
782 |     assert run.final_state_json == {"tip_count": 95}
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `initial_state_json` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:781:12
    |
779 |     assert run.input_parameters_json == {"volume": 100}
780 |     assert run.output_data_json == {"success": True, "total_transferred": 98.5}
781 |     assert run.initial_state_json == {"tip_count": 96}
    |            ^^^^^^^^^^^^^^^^^^^^^^
782 |     assert run.final_state_json == {"tip_count": 95}
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `final_state_json` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:782:12
    |
780 |     assert run.output_data_json == {"success": True, "total_transferred": 98.5}
781 |     assert run.initial_state_json == {"tip_count": 96}
782 |     assert run.final_state_json == {"tip_count": 95}
    |            ^^^^^^^^^^^^^^^^^^^^
783 |
784 |     # 6. Verify function calls were logged
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `accession_id` may be missing on object of type `ProtocolRunOrm | None`
   --> tests/services/test_protocol_run_service.py:787:61
    |
785 |     result = await db_session.execute(
786 |         select(FunctionCallLogOrm).where(
787 |             FunctionCallLogOrm.protocol_run_accession_id == run.accession_id,
    |                                                             ^^^^^^^^^^^^^^^^
788 |         ).order_by(FunctionCallLogOrm.sequence_in_run),
789 |     )
    |
info: rule `possibly-missing-attribute` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_resource_service.py:137:29
    |
136 |     # Get all resources
137 |     filters = SearchFilters(skip=0, limit=10)
    |                             ^^^^^^
138 |     resources = await resource_service.get_multi(db_session, filters=filters)
    |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_resource_service.py:338:12
    |
336 |     updated = await resource_service.update(db_session, db_obj=resource, obj_in=update_data)
337 |
338 |     assert updated.plr_state["volume_ul"] == 75.0
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
339 |     assert updated.plr_state["concentration_ng_ul"] == 45.0
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_resource_service.py:339:12
    |
338 |     assert updated.plr_state["volume_ul"] == 75.0
339 |     assert updated.plr_state["concentration_ng_ul"] == 45.0
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

error[unknown-argument]: Argument `version` does not match any known parameter
  --> tests/services/test_resource_type_definition_service.py:35:9
   |
33 |         name="Test Resource",
34 |         fqn="test.resource.Type",
35 |         version="1.0.0",
   |         ^^^^^^^^^^^^^^^
36 |         description="A test resource",
37 |         size_x_mm=100.0,
   |
info: rule `unknown-argument` is enabled by default

error[unresolved-import]: Cannot resolve imported module `pytest_asyncio`
  --> tests/services/test_scheduler_service.py:23:8
   |
22 | import pytest
23 | import pytest_asyncio
   |        ^^^^^^^^^^^^^^
24 | from sqlalchemy.ext.asyncio import AsyncSession
   |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_scheduler_service.py:221:29
    |
220 |     # Get all entries
221 |     filters = SearchFilters(skip=0, limit=10)
    |                             ^^^^^^
222 |     retrieved = await schedule_entry_service.get_multi(db_session, filters=filters)
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_scheduler_service.py:227:29
    |
226 |     # Get with pagination
227 |     filters = SearchFilters(skip=2, limit=2)
    |                             ^^^^^^
228 |     paginated = await schedule_entry_service.get_multi(db_session, filters=filters)
    |
info: rule `unknown-argument` is enabled by default

error[unknown-argument]: Argument `skip` does not match any known parameter
   --> tests/services/test_scheduler_service.py:256:29
    |
255 |     # Sort by priority ascending
256 |     filters = SearchFilters(skip=0, limit=10, sort_by="priority")
    |                             ^^^^^^
257 |     sorted_entries = await schedule_entry_service.get_multi(db_session, filters=filters)
    |
info: rule `unknown-argument` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_scheduler_service.py:366:12
    |
364 |     priority_changes = [h for h in history if h.event_type == ScheduleHistoryEventEnum.PRIORITY_CHANGED]
365 |     assert len(priority_changes) == 1
366 |     assert priority_changes[0].event_data_json["old_priority"] == 1
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
367 |     assert priority_changes[0].event_data_json["new_priority"] == 10
368 |     assert priority_changes[0].event_data_json["reason"] == "Urgent request"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_scheduler_service.py:367:12
    |
365 |     assert len(priority_changes) == 1
366 |     assert priority_changes[0].event_data_json["old_priority"] == 1
367 |     assert priority_changes[0].event_data_json["new_priority"] == 10
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
368 |     assert priority_changes[0].event_data_json["reason"] == "Urgent request"
    |
info: rule `non-subscriptable` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_scheduler_service.py:368:12
    |
366 |     assert priority_changes[0].event_data_json["old_priority"] == 1
367 |     assert priority_changes[0].event_data_json["new_priority"] == 10
368 |     assert priority_changes[0].event_data_json["reason"] == "Urgent request"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
info: rule `non-subscriptable` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `AssetReservationOrm | None`
   --> tests/services/test_scheduler_service.py:710:12
    |
708 |     # Verify expired was updated
709 |     expired = await read_asset_reservation(db_session, expired_reservation.accession_id)
710 |     assert expired.status == AssetReservationStatusEnum.EXPIRED
    |            ^^^^^^^^^^^^^^
711 |     assert expired.released_at is not None
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `released_at` may be missing on object of type `AssetReservationOrm | None`
   --> tests/services/test_scheduler_service.py:711:12
    |
709 |     expired = await read_asset_reservation(db_session, expired_reservation.accession_id)
710 |     assert expired.status == AssetReservationStatusEnum.EXPIRED
711 |     assert expired.released_at is not None
    |            ^^^^^^^^^^^^^^^^^^^
712 |
713 |     # Verify active was not touched
    |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `AssetReservationOrm | None`
   --> tests/services/test_scheduler_service.py:715:12
    |
713 |     # Verify active was not touched
714 |     active = await read_asset_reservation(db_session, active_reservation.accession_id)
715 |     assert active.status == AssetReservationStatusEnum.PENDING
    |            ^^^^^^^^^^^^^
    |
info: rule `possibly-missing-attribute` is enabled by default

error[non-subscriptable]: Cannot subscript object of type `None` with no `__getitem__` method
   --> tests/services/test_scheduler_service.py:750:12
    |
748 |     assert history_entry.schedule_entry_accession_id == entry.accession_id
749 |     assert history_entry.event_type == ScheduleHistoryEventEnum.SCHEDULED
750 |     assert history_entry.event_data_json["asset_count"] == 3
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
751 |     assert history_entry.message == "Started analyzing asset requirements"
    |
info: rule `non-subscriptable` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis.exceptions`
 --> tests/services/test_state_service.py:5:6
  |
4 | import pytest
5 | from redis.exceptions import ConnectionError, RedisError
  |      ^^^^^^^^^^^^^^^^
6 |
7 | from praxis.backend.configure import PraxisConfiguration
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

warning[possibly-missing-attribute]: Attribute `name` may be missing on object of type `WorkcellOrm | None`
  --> tests/services/test_workcell_service.py:79:12
   |
77 |     # Verify persistence
78 |     refetched = await workcell_service.get(db=db_session, accession_id=created_workcell.accession_id)
79 |     assert refetched.name == "Partially Updated Name"
   |            ^^^^^^^^^^^^^^
80 |     assert refetched.description == "Initial Description"
81 |     assert refetched.status == WorkcellStatusEnum.AVAILABLE.value
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `description` may be missing on object of type `WorkcellOrm | None`
  --> tests/services/test_workcell_service.py:80:12
   |
78 |     refetched = await workcell_service.get(db=db_session, accession_id=created_workcell.accession_id)
79 |     assert refetched.name == "Partially Updated Name"
80 |     assert refetched.description == "Initial Description"
   |            ^^^^^^^^^^^^^^^^^^^^^
81 |     assert refetched.status == WorkcellStatusEnum.AVAILABLE.value
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `status` may be missing on object of type `WorkcellOrm | None`
  --> tests/services/test_workcell_service.py:81:12
   |
79 |     assert refetched.name == "Partially Updated Name"
80 |     assert refetched.description == "Initial Description"
81 |     assert refetched.status == WorkcellStatusEnum.AVAILABLE.value
   |            ^^^^^^^^^^^^^^^^
82 |
83 | @pytest.mark.asyncio
   |
info: rule `possibly-missing-attribute` is enabled by default

warning[possibly-missing-attribute]: Attribute `accession_id` may be missing on object of type `DeckOrm | None`
  --> tests/test_deck_serialization.py:19:37
   |
17 |     # Retrieve it using service (which loads relationships)
18 |     deck = await deck_service.get(db_session, deck_created.accession_id)
19 |     print(f"Retrieved via service: {deck.accession_id}")
   |                                     ^^^^^^^^^^^^^^^^^
20 |
21 |     # Try to convert to Pydantic model
   |
info: rule `possibly-missing-attribute` is enabled by default

error[invalid-argument-type]: Argument to function `is_resource_subclass` is incorrect
   --> tests/utils/test_plr_inspection.py:185:37
    |
183 |     def test_is_resource_subclass_returns_false_for_non_class(self) -> None:
184 |         """Test that non-class objects return False."""
185 |         assert is_resource_subclass("not a class") is False
    |                                     ^^^^^^^^^^^^^ Expected `type[Any]`, found `Literal["not a class"]`
186 |
187 |     def test_is_resource_subclass_returns_false_for_unrelated_class(self) -> None:
    |
info: Function defined here
   --> praxis/backend/utils/plr_inspection.py:109:5
    |
109 | def is_resource_subclass(item_class: type[Any]) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^^ --------------------- Parameter declared here
110 |   """Check if a class is a non-abstract subclass of pylabrobot.resources.Resource."""
111 |   return (
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `is_machine_subclass` is incorrect
   --> tests/utils/test_plr_inspection.py:206:36
    |
204 |     def test_is_machine_subclass_returns_false_for_non_class(self) -> None:
205 |         """Test that non-class objects return False."""
206 |         assert is_machine_subclass(123) is False
    |                                    ^^^ Expected `type[Any]`, found `Literal[123]`
207 |
208 |     def test_is_machine_subclass_returns_false_for_resource(self) -> None:
    |
info: Function defined here
   --> praxis/backend/utils/plr_inspection.py:119:5
    |
119 | def is_machine_subclass(item_class: type[Any]) -> bool:
    |     ^^^^^^^^^^^^^^^^^^^ --------------------- Parameter declared here
120 |   """Check if a class is a non-abstract subclass of Machine."""
121 |   return (
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `is_deck_subclass` is incorrect
   --> tests/utils/test_plr_inspection.py:223:33
    |
221 |     def test_is_deck_subclass_returns_false_for_non_class(self) -> None:
222 |         """Test that non-class objects return False."""
223 |         assert is_deck_subclass([]) is False
    |                                 ^^ Expected `type[Any]`, found `list[Unknown]`
224 |
225 |     def test_is_deck_subclass_returns_false_for_resource(self) -> None:
    |
info: Function defined here
   --> praxis/backend/utils/plr_inspection.py:129:5
    |
129 | def is_deck_subclass(item_class: type[Any]) -> bool:
    |     ^^^^^^^^^^^^^^^^ --------------------- Parameter declared here
130 |   """Check if a class is a non-abstract subclass of pylabrobot.resources.Deck."""
131 |   return (
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
  --> tests/utils/test_redis_lock.py:83:42
   |
82 |         with acquire_lock(
83 |             mock_redis, "test_resource", acquire_timeout=0.2,
   |                                          ^^^^^^^^^^^^^^^^^^^ Expected `int`, found `float`
84 |         ) as acquired:
85 |             assert acquired is False
   |
info: Union variant `(redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]` is incompatible with this call site
info: Attempted to call union type `((redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]) | ((redis_client: Divergent, resource_name: Divergent, lock_timeout: Divergent = Divergent, acquire_timeout: Divergent = Divergent) -> _GeneratorContextManager[Unknown, None, None])`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/utils/test_redis_lock.py:127:42
    |
126 |         with acquire_lock(
127 |             mock_redis, "test_resource", acquire_timeout=0.1,
    |                                          ^^^^^^^^^^^^^^^^^^^ Expected `int`, found `float`
128 |         ) as acquired:
129 |             assert acquired is False
    |
info: Union variant `(redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]` is incompatible with this call site
info: Attempted to call union type `((redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]) | ((redis_client: Divergent, resource_name: Divergent, lock_timeout: Divergent = Divergent, acquire_timeout: Divergent = Divergent) -> _GeneratorContextManager[Unknown, None, None])`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/utils/test_redis_lock.py:179:42
    |
177 |         start_time = time.time()
178 |         with acquire_lock(
179 |             mock_redis, "test_resource", acquire_timeout=0.3,
    |                                          ^^^^^^^^^^^^^^^^^^^ Expected `int`, found `float`
180 |         ) as acquired:
181 |             elapsed = time.time() - start_time
    |
info: Union variant `(redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]` is incompatible with this call site
info: Attempted to call union type `((redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]) | ((redis_client: Divergent, resource_name: Divergent, lock_timeout: Divergent = Divergent, acquire_timeout: Divergent = Divergent) -> _GeneratorContextManager[Unknown, None, None])`
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument is incorrect
   --> tests/utils/test_redis_lock.py:261:42
    |
260 |         with acquire_lock(
261 |             mock_redis, "test_resource", acquire_timeout=0.0,
    |                                          ^^^^^^^^^^^^^^^^^^^ Expected `int`, found `float`
262 |         ) as acquired:
263 |             # Should immediately timeout
    |
info: Union variant `(redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]` is incompatible with this call site
info: Attempted to call union type `((redis_client: Unknown, resource_name: str, lock_timeout: int = Literal[60], acquire_timeout: int = Literal[10]) -> _GeneratorContextManager[Unknown, None, None]) | ((redis_client: Divergent, resource_name: Divergent, lock_timeout: Divergent = Divergent, acquire_timeout: Divergent = Divergent) -> _GeneratorContextManager[Unknown, None, None])`
info: rule `invalid-argument-type` is enabled by default

error[unresolved-import]: Cannot resolve imported module `redis.exceptions`
 --> tests/utils/test_run_control.py:7:6
  |
6 | import pytest
7 | from redis.exceptions import RedisError
  |      ^^^^^^^^^^^^^^^^
8 |
9 | from praxis.backend.utils.run_control import (
  |
info: Searched in the following paths during module resolution:
info:   1. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis (first-party code)
info:   2. vendored://stdlib (stdlib typeshed stubs vendored by ty)
info:   3. /Users/mar/MIT Dropbox/Marielle Russo/PLR_workspace/pylabpraxis/.venv/lib/python3.13/site-packages (site-packages)
info: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment
info: rule `unresolved-import` is enabled by default

error[invalid-argument-type]: Argument to function `fill_in_default` is incorrect
   --> tests/utils/test_sanitation.py:128:40
    |
126 |     async def test_fill_in_default_repeats_non_list_value(self) -> None:
127 |         """Test that non-list value is repeated."""
128 |         result = await fill_in_default(5, [1, 2, 3])
    |                                        ^ Expected `list[Unknown | int] | None`, found `Literal[5]`
129 |         assert result == [5, 5, 5]
    |
info: Function defined here
  --> praxis/backend/utils/sanitation.py:89:11
   |
89 | async def fill_in_default(val: list[T] | None, default: list[T]) -> list[T]:
   |           ^^^^^^^^^^^^^^^ ------------------- Parameter declared here
90 |   """Util for converting an argument to the appropriate format for low level methods."""
91 |   t = type(default[0])
   |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `fill_in_defaults` is incorrect
   --> tests/utils/test_sanitation.py:158:13
    |
156 |         """Test that fill_in_defaults processes multiple items."""
157 |         result = await fill_in_defaults(
158 |             [None, 5, [7, 8]], [[1, 2], [3, 4], [5, 6]],
    |             ^^^^^^^^^^^^^^^^^ Expected `list[list[Unknown] | None]`, found `list[Unknown | None | int | list[Unknown | int]]`
159 |         )
160 |         assert result == [[1, 2], [5, 5], [7, 8]]
    |
info: Function defined here
   --> praxis/backend/utils/sanitation.py:112:11
    |
112 | async def fill_in_defaults(
    |           ^^^^^^^^^^^^^^^^
113 |   items: list[list[T] | None],
    |   --------------------------- Parameter declared here
114 |   defaults: list[list[T]],
115 | ) -> list[list[T]]:
    |
info: rule `invalid-argument-type` is enabled by default

error[invalid-argument-type]: Argument to function `fill_in_defaults` is incorrect
   --> tests/utils/test_sanitation.py:324:41
    |
322 |     async def test_type_check_after_fill_in_defaults(self) -> None:
323 |         """Test type checking after filling in defaults."""
324 |         filled = await fill_in_defaults([None, 5], [[1, 2], [3, 4]])
    |                                         ^^^^^^^^^ Expected `list[list[Unknown] | None]`, found `list[Unknown | None | int]`
325 |         # Verify types
326 |         await type_check(filled[0], [int, int])
    |
info: Function defined here
   --> praxis/backend/utils/sanitation.py:112:11
    |
112 | async def fill_in_defaults(
    |           ^^^^^^^^^^^^^^^^
113 |   items: list[list[T] | None],
    |   --------------------------- Parameter declared here
114 |   defaults: list[list[T]],
115 | ) -> list[list[T]]:
    |
info: rule `invalid-argument-type` is enabled by default

Found 865 diagnostics
