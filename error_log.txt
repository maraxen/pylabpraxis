============================= test session starts ==============================
platform darwin -- Python 3.13.5, pytest-8.4.2, pluggy-1.6.0
Database: SQLite (in-memory)
rootdir: /Users/mar/Projects/pylabpraxis
configfile: pyproject.toml
plugins: playwright-0.7.2, asyncio-1.2.0, anyio-4.11.0, socket-0.7.0, xdist-3.8.0, timeout-2.4.0, Faker-37.11.0, base-url-2.1.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
timeout: 300.0s
timeout method: signal
timeout func_only: False
collected 305 items

tests/models/test_domain/test_asset_requirement.py ...........           [  3%]
tests/models/test_domain/test_asset_reservation.py F....F.F.F....        [  8%]
tests/models/test_domain/test_asset_sqlmodel.py F.....                   [ 10%]
tests/models/test_domain/test_deck.py .........................          [ 18%]
tests/models/test_domain/test_file_system_protocol_source.py FF..F....F  [ 21%]
tests/models/test_domain/test_function_call_log.py FFFFFFFFFFFFF         [ 25%]
tests/models/test_domain/test_function_data_output.py EEEEEEEEEEEEEEEEEE [ 31%]
E                                                                        [ 32%]
tests/models/test_domain/test_function_protocol_definition.py .......... [ 35%]
.....                                                                    [ 37%]
tests/models/test_domain/test_machine.py FF.FFFF............             [ 43%]
tests/models/test_domain/test_machine_definition.py FFF.FFFF.FF.F......F [ 49%]
...                                                                      [ 50%]
tests/models/test_domain/test_parameter_definition.py ...........        [ 54%]
tests/models/test_domain/test_protocol_run.py FFFF.......FFFF            [ 59%]
tests/models/test_domain/test_protocol_source_repository.py .........    [ 62%]
tests/models/test_domain/test_resource.py ..................             [ 68%]
tests/models/test_domain/test_resource_definition.py ................... [ 74%]
...                                                                      [ 75%]
tests/models/test_domain/test_schedule_entry.py .............            [ 79%]
tests/models/test_domain/test_schedule_history.py .....F.......F         [ 84%]
tests/models/test_domain/test_sqlmodel_base.py ....                      [ 85%]
tests/models/test_domain/test_user.py .........................          [ 93%]
tests/models/test_domain/test_well_data_output.py EEEE                   [ 95%]
tests/models/test_domain/test_workcell.py ...............
ERROR: Coverage failure: total of 12 is less than fail-under=80
                                                                         [100%]

==================================== ERRORS ====================================
_______ ERROR at setup of test_function_data_output_orm_creation_minimal _______

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e91df0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x107748f40>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-555a-77e0-8...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5558-7790-9bcd-5aec447...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___ ERROR at setup of test_function_data_output_orm_creation_with_all_fields ___

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e83830>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x107749760>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-55b2-7f21-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-55b0-7f20-aaf9-819d49f...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_____ ERROR at setup of test_function_data_output_orm_persist_to_database ______

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e83770>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x107748a40>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-560a-7043-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5608-7693-98af-94712e6...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_______ ERROR at setup of test_function_data_output_orm_data_type_values _______

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1f0b0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x1077498a0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5664-7d01-8...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5662-78d0-ada2-f4ff5bf...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
____ ERROR at setup of test_function_data_output_orm_spatial_context_values ____

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1f5f0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774a480>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-56c1-7013-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-56bf-7531-a59e-f225c2c...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_________ ERROR at setup of test_function_data_output_orm_numeric_data _________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1ffb0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774a840>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5751-7db1-8...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-574e-7e31-bd93-91edba0...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__________ ERROR at setup of test_function_data_output_orm_json_data ___________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1cfb0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x107748540>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-57ad-75e0-8...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-57ab-7f21-aec5-b496eea...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__________ ERROR at setup of test_function_data_output_orm_text_data ___________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e81fd0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774a160>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-580d-7bb3-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-580a-7670-b175-74127f6...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_________ ERROR at setup of test_function_data_output_orm_binary_data __________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e81af0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774b920>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5865-7640-9...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5862-7f70-ba83-59e2095...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__ ERROR at setup of test_function_data_output_orm_spatial_coordinates_jsonb ___

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e820f0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774b740>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-58bc-7ca1-9...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-58ba-7ad1-b2a7-d5b1daa...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
________ ERROR at setup of test_function_data_output_orm_metadata_jsonb ________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e82cf0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774b4c0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5912-7e63-9...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5910-7c63-a6ab-d5c5067...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__________ ERROR at setup of test_function_data_output_orm_file_path ___________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1f4d0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774a700>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-59c2-7ed0-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-59bf-7461-b3a7-9851e6e...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_ ERROR at setup of test_function_data_output_orm_relationship_to_protocol_run _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1f0b0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x1077487c0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5a4c-73b1-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5a4a-7931-8346-c58e6f3...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_ ERROR at setup of test_function_data_output_orm_relationship_to_function_call_log _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1c590>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x1077499e0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5aa5-7490-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5aa3-7290-b96e-1fdfe8a...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___ ERROR at setup of test_function_data_output_orm_relationship_to_resource ___

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e1e870>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x10774a340>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5afd-7c41-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5afb-7bf2-9cc5-58b4a1b...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___ ERROR at setup of test_function_data_output_orm_relationship_to_machine ____

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e82ab0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106df40e0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5b59-7db2-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5b57-79d2-a6fe-937b1a9...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
______ ERROR at setup of test_function_data_output_orm_query_by_data_type ______

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f03650>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106faa700>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5be2-7983-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5be0-7a23-9522-5bb0d71...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
____ ERROR at setup of test_function_data_output_orm_query_by_protocol_run _____

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106452570>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106fa98a0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5c39-7d31-b...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5c37-7e02-8354-ee021eb...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
______ ERROR at setup of test_function_data_output_orm_query_by_resource _______

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106452450>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106df4e00>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Create a FunctionCallLogfor testing."""
        protocol_run = await protocol_run_factory()
        call_log = FunctionCallLog(
            name="test_function_call_log",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
        call_log.start_time = datetime.now(timezone.utc)
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_data_output.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call_log', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5c90-7572-a...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_protocol_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5c8e-7502-aa85-8f2367a...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_pr...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_________ ERROR at setup of test_well_data_output_orm_creation_minimal _________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1071e1c10>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-70bc-7101-82fc-cf5dddd6be8d'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocol', source_repository_accession_id=UUID('019bb4fd-70...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Fixture for a function call log."""
        function_call_log = FunctionCallLog(
            name="test_function_call",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
>       function_call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_well_data_output.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-70be-7283-84bf-...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-70bc-7101-82fc-cf5dddd6be8d'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_______ ERROR at setup of test_well_data_output_orm_creation_all_fields ________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1071e1a90>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-7129-7940-8db9-8ac388c60c75'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocol', source_repository_accession_id=UUID('019bb4fd-71...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Fixture for a function call log."""
        function_call_log = FunctionCallLog(
            name="test_function_call",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
>       function_call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_well_data_output.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-712c-7682-ab5f-...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-7129-7940-8db9-8ac388c60c75'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___________ ERROR at setup of test_well_data_output_orm_persistence ____________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x108350b30>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-7185-7f43-8fd4-844815eb36fb'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocol', source_repository_accession_id=UUID('019bb4fd-71...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Fixture for a function call log."""
        function_call_log = FunctionCallLog(
            name="test_function_call",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
>       function_call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_well_data_output.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-7187-7682-9fa2-...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-7185-7f43-8fd4-844815eb36fb'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__________ ERROR at setup of test_well_data_output_orm_relationships ___________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x108350a70>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-71da-7641-91e1-ac025b390d8c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocol', source_repository_accession_id=UUID('019bb4fd-71...json=None, simulation_result_json=None, inferred_requirements_json=None, failure_modes_json=None, cached_bytecode=None)

    @pytest_asyncio.fixture
    async def function_call_log(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> FunctionCallLog:
        """Fixture for a function call log."""
        function_call_log = FunctionCallLog(
            name="test_function_call",
            protocol_run_accession_id=protocol_run.accession_id,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            sequence_in_run=0,
        )
>       function_call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_well_data_output.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_function_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-71dc-7bd2-956c-...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-71da-7641-91e1-ac025b390d8c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
=================================== FAILURES ===================================
_________________ test_asset_reservation_orm_creation_minimal __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106b0f4d0>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106b6f920>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x106b6ce00>
machine_asset = Machine(name='test_machine_reservation', asset_type='MACHINE', fqn='test.machines.TestMachine', accession_id=UUID('019... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None)

    @pytest.mark.asyncio
    async def test_asset_reservation_orm_creation_minimal(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        schedule_entry_factory: Callable[[ProtocolRun], ScheduleEntry],
        machine_asset: Machine,
    ) -> None:
        """Test creating AssetReservationwith minimal required fields."""
        protocol_run = await protocol_run_factory()
        schedule_entry = await schedule_entry_factory(protocol_run)
        reservation = AssetReservation(
            name="test_reservation",
            protocol_run_accession_id=protocol_run.accession_id,
            schedule_entry_accession_id=schedule_entry.accession_id,
            asset_accession_id=machine_asset.accession_id,
            asset_name=machine_asset.name,
            redis_lock_key=f"lock:{machine_asset.accession_id}",
            released_at=None,
        )
    
        db_session.add(reservation)
        await db_session.flush()
    
        assert reservation.accession_id is not None
        assert reservation.protocol_run_accession_id == protocol_run.accession_id
        assert reservation.schedule_entry_accession_id == schedule_entry.accession_id
        assert reservation.asset_accession_id == machine_asset.accession_id
        assert reservation.asset_name == machine_asset.name
        assert reservation.redis_lock_key == f"lock:{machine_asset.accession_id}"
        assert reservation.asset_type == AssetType.ASSET
        assert reservation.status == AssetReservationStatusEnum.PENDING
        assert reservation.lock_timeout_seconds == 3600
        assert reservation.redis_lock_value is None
>       assert reservation.reserved_at is not None
E       AssertionError: assert None is not None
E        +  where None = AssetReservation(name='test_reservation', released_at=None, asset_name='test_machine_reservation', redis_lock_key='loc...', redis_lock_value=None, lock_timeout_seconds=3600, required_capabilities_json=None, estimated_usage_duration_ms=None).reserved_at

tests/models/test_domain/test_asset_reservation.py:161: AssertionError
___________________ test_asset_reservation_orm_timing_fields ___________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106be2a50>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106b9e2a0>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x106bf3740>
machine_asset = Machine(name='test_machine_reservation', asset_type='MACHINE', fqn='test.machines.TestMachine', accession_id=UUID('019... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None)

    @pytest.mark.asyncio
    async def test_asset_reservation_orm_timing_fields(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        schedule_entry_factory: Callable[[ProtocolRun], ScheduleEntry],
        machine_asset: Machine,
    ) -> None:
        """Test reservation timing fields."""
        protocol_run = await protocol_run_factory()
        schedule_entry = await schedule_entry_factory(protocol_run)
        now = datetime.now(timezone.utc)
        reservation = AssetReservation(
            name="test_reservation_timing",
            protocol_run_accession_id=protocol_run.accession_id,
            schedule_entry_accession_id=schedule_entry.accession_id,
            asset_accession_id=machine_asset.accession_id,
            asset_name=machine_asset.name,
            redis_lock_key=f"lock:{machine_asset.accession_id}",
            released_at=now,
        )
        db_session.add(reservation)
        await db_session.flush()
    
>       assert reservation.reserved_at is not None
E       AssertionError: assert None is not None
E        +  where None = AssetReservation(name='test_reservation_timing', released_at=datetime.datetime(2026, 1, 13, 1, 34, 17, 422708, tzinfo=...', redis_lock_value=None, lock_timeout_seconds=3600, required_capabilities_json=None, estimated_usage_duration_ms=None).reserved_at

tests/models/test_domain/test_asset_reservation.py:317: AssertionError
___________ test_asset_reservation_orm_relationship_to_protocol_run ____________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106c7d180>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106c69800>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x106c6a340>
machine_asset = Machine(name='test_machine_reservation', asset_type='MACHINE', fqn='test.machines.TestMachine', accession_id=UUID('019... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None)

    @pytest.mark.asyncio
    async def test_asset_reservation_orm_relationship_to_protocol_run(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        schedule_entry_factory: Callable[[ProtocolRun], ScheduleEntry],
        machine_asset: Machine,
    ) -> None:
        """Test relationship between AssetReservationand ProtocolRun."""
        protocol_run = await protocol_run_factory()
        schedule_entry = await schedule_entry_factory(protocol_run)
        reservation = AssetReservation(
            name="test_reservation_relationship_run",
            protocol_run_accession_id=protocol_run.accession_id,
            schedule_entry_accession_id=schedule_entry.accession_id,
            asset_accession_id=machine_asset.accession_id,
            asset_name=machine_asset.name,
            redis_lock_key=f"lock:{machine_asset.accession_id}",
            released_at=None,
        )
        reservation.protocol_run = protocol_run
        db_session.add(reservation)
        await db_session.flush()
    
        assert reservation.protocol_run_accession_id == protocol_run.accession_id
        assert reservation.protocol_run == protocol_run
>       await db_session.refresh(protocol_run, ["asset_reservations"])

tests/models/test_domain/test_asset_reservation.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:190: in greenlet_spawn
    result = context.switch(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:3133: in refresh
    self._expire_state(state, attribute_names)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:3261: in _expire_state
    state._expire_attributes(state.dict, attribute_names)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.state.InstanceState object at 0x106c1e930>
dict_ = {'_sa_instance_state': <sqlalchemy.orm.state.InstanceState object at 0x106c1e930>, 'accession_id': UUID('019bb4fd-4b87...ted_at': datetime.datetime(2026, 1, 13, 1, 34, 17, 479998, tzinfo=datetime.timezone.utc), 'created_by_user': None, ...}
attribute_names = ['asset_reservations'], no_loader = False

    def _expire_attributes(
        self,
        dict_: _InstanceDict,
        attribute_names: Iterable[str],
        no_loader: bool = False,
    ) -> None:
        pending = self.__dict__.get("_pending_mutations", None)
    
        callables = self.callables
    
        for key in attribute_names:
>           impl = self.manager[key].impl
                   ^^^^^^^^^^^^^^^^^
E           KeyError: 'asset_reservations'

.venv/lib/python3.13/site-packages/sqlalchemy/orm/state.py:762: KeyError
_______________ test_asset_reservation_orm_relationship_to_asset _______________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106c6aa30>
protocol_run_factory = <function protocol_run_factory.<locals>._factory at 0x106c694e0>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x106c6a0c0>
machine_asset = Machine(name='test_machine_reservation', asset_type='MACHINE', fqn='test.machines.TestMachine', accession_id=UUID('019... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None)

    @pytest.mark.asyncio
    async def test_asset_reservation_orm_relationship_to_asset(
        db_session: AsyncSession,
        protocol_run_factory: Callable[[], ProtocolRun],
        schedule_entry_factory: Callable[[ProtocolRun], ScheduleEntry],
        machine_asset: Machine,
    ) -> None:
        """Test relationship between AssetReservationand Asset."""
        protocol_run = await protocol_run_factory()
        schedule_entry = await schedule_entry_factory(protocol_run)
        reservation = AssetReservation(
            name="test_reservation_relationship_asset",
            protocol_run_accession_id=protocol_run.accession_id,
            schedule_entry_accession_id=schedule_entry.accession_id,
            asset_accession_id=machine_asset.accession_id,
            asset_name=machine_asset.name,
            redis_lock_key=f"lock:{machine_asset.accession_id}",
            released_at=None,
        )
>       reservation.asset = machine_asset
        ^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_asset_reservation.py:434: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = AssetReservation(name='test_reservation_relationship_asset', released_at=None, asset_name='test_machine_reservation', ...', redis_lock_value=None, lock_timeout_seconds=3600, required_capabilities_json=None, estimated_usage_duration_ms=None)
name = 'asset'
val = Machine(name='test_machine_reservation', asset_type='MACHINE', fqn='test.machines.TestMachine', accession_id=UUID('019... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for AssetReservation
E   asset
E     Object has no attribute 'asset' [type=no_such_attribute, input_value=Machine(name='test_machin...ition_accession_id=None), input_type=Machine]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
________________ TestAssetSQLModel.test_asset_creation_defaults ________________

self = <test_asset_sqlmodel.TestAssetSQLModel object at 0x106469810>
session = <sqlmodel.orm.session.Session object at 0x106c342f0>

    def test_asset_creation_defaults(self, session):
        """Test creating Asset with minimal fields."""
        asset = ConcreteAsset(name="test_asset")
        session.add(asset)
        session.commit()
        session.refresh(asset)
    
        assert asset.accession_id is not None
        assert asset.name == "test_asset"
        assert asset.asset_type == AssetType.ASSET
>       assert asset.fqn == ""
E       AssertionError: assert None == ''
E        +  where None = ConcreteAsset(properties_json=None, updated_at=None, created_at=datetime.datetime(2026, 1, 13, 1, 34, 17, 866403), fqn...bb4fd-4d0a-7ff1-9307-df5d3df2b751'), asset_type=<AssetType.ASSET: 'GENERIC_ASSET'>, location=None, plr_definition=None).fqn

tests/models/test_domain/test_asset_sqlmodel.py:42: AssertionError
____________ test_file_system_protocol_source_orm_creation_minimal _____________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f3d910>

    @pytest.mark.asyncio
    async def test_file_system_protocol_source_orm_creation_minimal(
        db_session: AsyncSession,
    ) -> None:
        """Test creating FileSystemProtocolSourcewith minimal required fields."""
        source = FileSystemProtocolSource(
            name="test_fs_source",
        )
        db_session.add(source)
        await db_session.flush()
    
        # Verify creation
        assert source.accession_id is not None
        assert source.name == "test_fs_source"
        assert source.base_path == ""  # Default
        assert source.is_recursive is True  # Default
>       assert source.status == ProtocolSourceStatusEnum.ACTIVE  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'active' == <ProtocolSourceStatusEnum.ACTIVE: 'active'>
E        +  where 'active' = FileSystemProtocolSource(name='test_fs_source', accession_id=UUID('019bb4fd-4ecf-7dd2-a634-c204d9f5a74e'), created_at=...tzinfo=datetime.timezone.utc), updated_at=None, properties_json=None, base_path='', is_recursive=True, status='active').status
E        +  and   <ProtocolSourceStatusEnum.ACTIVE: 'active'> = ProtocolSourceStatusEnum.ACTIVE

tests/models/test_domain/test_file_system_protocol_source.py:26: AssertionError
________ test_file_system_protocol_source_orm_creation_with_all_fields _________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f3e5d0>

    @pytest.mark.asyncio
    async def test_file_system_protocol_source_orm_creation_with_all_fields(
        db_session: AsyncSession,
    ) -> None:
        """Test creating FileSystemProtocolSourcewith all fields populated."""
        source = FileSystemProtocolSource(
            name="full_fs_source",
            base_path="/opt/protocols/library",
            is_recursive=False,
            status=ProtocolSourceStatusEnum.INACTIVE,
        )
        db_session.add(source)
        await db_session.flush()
    
        # Verify all fields
        assert source.accession_id is not None
        assert source.name == "full_fs_source"
        assert source.base_path == "/opt/protocols/library"
        assert source.is_recursive is False
>       assert source.status == ProtocolSourceStatusEnum.INACTIVE
E       AssertionError: assert 'inactive' == <ProtocolSourceStatusEnum.INACTIVE: 'inactive'>
E        +  where 'inactive' = FileSystemProtocolSource(name='full_fs_source', base_path='/opt/protocols/library', is_recursive=False, status='inacti...datetime.datetime(2026, 1, 13, 1, 34, 18, 332414, tzinfo=datetime.timezone.utc), updated_at=None, properties_json=None).status
E        +  and   <ProtocolSourceStatusEnum.INACTIVE: 'inactive'> = ProtocolSourceStatusEnum.INACTIVE

tests/models/test_domain/test_file_system_protocol_source.py:48: AssertionError
___________ test_file_system_protocol_source_orm_status_transitions ____________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f60470>

    @pytest.mark.asyncio
    async def test_file_system_protocol_source_orm_status_transitions(
        db_session: AsyncSession,
    ) -> None:
        """Test different status values for file system protocol source."""
        statuses = [
            (ProtocolSourceStatusEnum.ACTIVE, "active_fs"),
            (ProtocolSourceStatusEnum.SYNCING, "syncing_fs"),
            (ProtocolSourceStatusEnum.SYNC_ERROR, "error_fs"),
            (ProtocolSourceStatusEnum.INACTIVE, "inactive_fs"),
        ]
    
        for status, name in statuses:
            source = FileSystemProtocolSource(
                name=name,
                base_path=f"/opt/protocols/{name}",
                status=status,
            )
            db_session.add(source)
            await db_session.flush()
    
            # Verify status
>           assert source.status == status
E           AssertionError: assert 'active' == <ProtocolSourceStatusEnum.ACTIVE: 'active'>
E            +  where 'active' = FileSystemProtocolSource(name='active_fs', base_path='/opt/protocols/active_fs', status='active', accession_id=UUID('0...026, 1, 13, 1, 34, 18, 360132, tzinfo=datetime.timezone.utc), updated_at=None, properties_json=None, is_recursive=True).status

tests/models/test_domain/test_file_system_protocol_source.py:129: AssertionError
_____________ test_file_system_protocol_source_orm_query_by_status _____________

self = <sqlalchemy.engine.base.Connection object at 0x106f52c10>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x1067646e0>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x106f06d50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x106f7c750>
parameters = [(<ProtocolSourceStatusEnum.ACTIVE: 'active'>,)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:340: in _handle_exception
    raise error
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-1, started daemon 6173880320)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlite3.ProgrammingError: Error binding parameter 1: type 'ProtocolSourceStatusEnum' is not supported

.venv/lib/python3.13/site-packages/aiosqlite/core.py:105: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f3fef0>

    @pytest.mark.asyncio
    async def test_file_system_protocol_source_orm_query_by_status(
        db_session: AsyncSession,
    ) -> None:
        """Test querying sources by status."""
        # Create sources with different statuses
        active_source = FileSystemProtocolSource(
            name="active_status_fs",
            base_path="/opt/protocols/active",
            status=ProtocolSourceStatusEnum.ACTIVE,
        )
        inactive_source = FileSystemProtocolSource(
            name="inactive_status_fs",
            base_path="/opt/protocols/inactive",
            status=ProtocolSourceStatusEnum.INACTIVE,
        )
        db_session.add(active_source)
        db_session.add(inactive_source)
        await db_session.flush()
    
        # Query for active sources
>       result = await db_session.execute(
            select(FileSystemProtocolSource).where(
                FileSystemProtocolSource.status == ProtocolSourceStatusEnum.ACTIVE,
            ),
        )

tests/models/test_domain/test_file_system_protocol_source.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:340: in _handle_exception
    raise error
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-1, started daemon 6173880320)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) Error binding parameter 1: type 'ProtocolSourceStatusEnum' is not supported
E               [SQL: SELECT file_system_protocol_sources.accession_id, file_system_protocol_sources.created_at, file_system_protocol_sources.updated_at, file_system_protocol_sources.name, file_system_protocol_sources.properties_json, file_system_protocol_sources.base_path, file_system_protocol_sources.is_recursive, file_system_protocol_sources.status 
E               FROM file_system_protocol_sources 
E               WHERE file_system_protocol_sources.status = ?]
E               [parameters: (<ProtocolSourceStatusEnum.ACTIVE: 'active'>,)]
E               (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.13/site-packages/aiosqlite/core.py:105: ProgrammingError
_________________ test_function_call_log_orm_creation_minimal __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x107aedfd0>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-515e-7300-b77d-62448b7cb211'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_creation_minimal(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test creating FunctionCallLogwith minimal required fields."""
        now = datetime.now(timezone.utc)
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
        )
        call_log.start_time = now
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5160-7ae1-a5fa-6a34916e5...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-515e-7300-b77d-62448b7cb211'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_____________ test_function_call_log_orm_creation_with_all_fields ______________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd6630>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-51b3-7853-ba56-46518d71b3c9'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_creation_with_all_fields(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test creating FunctionCallLogwith all fields populated."""
        from datetime import timedelta
        start_time = datetime.now(timezone.utc)
        end_time = start_time + timedelta(seconds=5)
        input_args = {"volume": 100, "source": "A1", "dest": "B1"}
        return_value = {"success": True, "transferred_volume": 98.5}
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            input_args_json=input_args,
            return_value_json=return_value,
            status=FunctionCallStatusEnum.SUCCESS,
        )
        call_log.start_time = start_time
        call_log.end_time = end_time
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, status='success', input_args_json={'volume': 100, 'source': 'A1',...utc), duration_ms=None, error_message_text=None, error_traceback_text=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-51b3-7853-ba56-46518d71b3c9'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
________________ test_function_call_log_orm_persist_to_database ________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd6e70>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5204-7bf3-92e5-17d7e3419b4c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_persist_to_database(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test full persistence cycle for FunctionCallLog."""
        now = datetime.now(timezone.utc)
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=5,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            status=FunctionCallStatusEnum.IN_PROGRESS,
        )
        call_log.start_time = now
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=5, status='in_progress', protocol_run_accession_id=UUID('019bb4fd-52...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5204-7bf3-92e5-17d7e3419b4c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_________________ test_function_call_log_orm_sequence_ordering _________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd6d50>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5256-7813-8023-d228a762df47'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_sequence_ordering(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test sequence_in_run for ordering function calls."""
        now = datetime.now(timezone.utc)
    
        # Create multiple calls with different sequences
        for seq in [0, 1, 2, 3, 4]:
            call_log = FunctionCallLog(
                name="test_call",
                protocol_run_accession_id=protocol_run.accession_id,
                sequence_in_run=seq,
                function_protocol_definition_accession_id=protocol_definition.accession_id,
            )
            call_log.start_time = now
>           call_log.protocol_run = protocol_run
            ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-5257-73f0-b83e-9bb7862ac...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5256-7813-8023-d228a762df47'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___________________ test_function_call_log_orm_status_values ___________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd75f0>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-52a9-7002-86d0-42bee3904de4'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_status_values(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test different status values for function calls."""
        now = datetime.now(timezone.utc)
        statuses = [
            FunctionCallStatusEnum.UNKNOWN,
            FunctionCallStatusEnum.PENDING,
            FunctionCallStatusEnum.IN_PROGRESS,
            FunctionCallStatusEnum.SUCCESS,
            FunctionCallStatusEnum.ERROR,
            FunctionCallStatusEnum.SKIPPED,
            FunctionCallStatusEnum.CANCELED,
        ]
    
        for idx, status in enumerate(statuses):
            call_log = FunctionCallLog(
                name="test_call",
                protocol_run_accession_id=protocol_run.accession_id,
                sequence_in_run=idx,
                function_protocol_definition_accession_id=protocol_definition.accession_id,
                status=status,
            )
            call_log.start_time = now
>           call_log.protocol_run = protocol_run
            ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, status='unknown', protocol_run_accession_id=UUID('019bb4fd-52ab-7...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-52a9-7002-86d0-42bee3904de4'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_________________ test_function_call_log_orm_input_args_jsonb __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd7710>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-52fd-7013-88b4-d5b0727c519b'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_input_args_jsonb(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test JSONB input_args_json field."""
        now = datetime.now(timezone.utc)
        input_args = {
            "volume_ul": 50,
            "source_well": "A1",
            "dest_well": "B1",
            "aspirate_speed": 100,
            "dispense_speed": 150,
            "mix_cycles": 3,
            "tip_type": "standard",
            "nested": {"key": "value", "items": [1, 2, 3]},
        }
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            input_args_json=input_args,
        )
        call_log.start_time = now
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, input_args_json={'volume_ul': 50, 'source_well': 'A1', 'dest_well...error_message_text=None, error_traceback_text=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-52fd-7013-88b4-d5b0727c519b'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
________________ test_function_call_log_orm_return_value_jsonb _________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd5310>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5351-7821-98a5-73ab59fd0fbc'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_return_value_jsonb(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test JSONB return_value_json field."""
        now = datetime.now(timezone.utc)
        return_value = {
            "success": True,
            "actual_volume": 49.8,
            "errors": [],
            "warnings": ["Tip slightly bent"],
            "measurements": [1.2, 3.4, 5.6],
        }
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            return_value_json=return_value,
        )
        call_log.start_time = now
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, return_value_json={'success': True, 'actual_volume': 49.8, 'error..., error_message_text=None, error_traceback_text=None, input_args_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5351-7821-98a5-73ab59fd0fbc'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___________________ test_function_call_log_orm_error_fields ____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd5af0>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-53a4-7941-ae8c-c2bf39b75959'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_error_fields(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test error_message_text and error_traceback_text fields."""
        now = datetime.now(timezone.utc)
        error_message = "ValueError: Invalid volume specified"
        error_traceback = """Traceback (most recent call last):
      File "protocol.py", line 42, in transfer
        validate_volume(volume)
    ValueError: Invalid volume specified"""
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            status=FunctionCallStatusEnum.ERROR,
            error_message_text=error_message,
            error_traceback_text=error_traceback,
        )
        call_log.start_time = now
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, status='error', error_message_text='ValueError: Invalid volume sp..._time=None, duration_ms=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-53a4-7941-ae8c-c2bf39b75959'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
___________________ test_function_call_log_orm_nested_calls ____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd6510>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-53f7-7bf2-8e57-583a71a772dd'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_nested_calls(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test parent-child relationship for nested function calls."""
        now = datetime.now(timezone.utc)
    
        # Create parent call
        parent_call = FunctionCallLog(
            name="parent_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
        )
        parent_call.start_time = now
>       parent_call.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='parent_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-53f8-7922-97b1-2970804...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-53f7-7bf2-8e57-583a71a772dd'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
______________________ test_function_call_log_orm_timing _______________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd7a70>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-544a-7b13-9802-55e1fd81cf4e'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_timing(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test start_time and end_time fields."""
        from datetime import timedelta
        start_time = datetime.now(timezone.utc)
        end_time = start_time + timedelta(seconds=10)
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            status=FunctionCallStatusEnum.SUCCESS,
        )
        call_log.start_time = start_time
        call_log.end_time = end_time
>       call_log.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, status='success', protocol_run_accession_id=UUID('019bb4fd-544b-7...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-544a-7b13-9802-55e1fd81cf4e'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_______________ test_function_call_log_orm_query_by_protocol_run _______________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd7710>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-549c-7573-bd24-f684cad82665'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_query_by_protocol_run(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test querying all function calls for a protocol run."""
        now = datetime.now(timezone.utc)
    
        # Create multiple calls for the same run
        for i in range(5):
            call_log = FunctionCallLog(
                name="test_call",
                protocol_run_accession_id=protocol_run.accession_id,
                sequence_in_run=i,
                function_protocol_definition_accession_id=protocol_definition.accession_id,
            )
            call_log.start_time = now
>           call_log.protocol_run = protocol_run
            ^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:438: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='test_call', sequence_in_run=0, protocol_run_accession_id=UUID('019bb4fd-549e-7ae0-8589-bcbea7168...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-549c-7573-bd24-f684cad82665'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
__________________ test_function_call_log_orm_query_by_status __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e927b0>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-54ef-7231-9eb5-ddfc6971ec4c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_query_by_status(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test querying function calls by status."""
        now = datetime.now(timezone.utc)
    
        # Create calls with different statuses
        success_call = FunctionCallLog(
            name="success_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=0,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            status=FunctionCallStatusEnum.SUCCESS,
        )
        success_call.start_time = now
>       success_call.protocol_run = protocol_run
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_function_call_log.py:474: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlmodel/main.py:806: in __setattr__
    super().__setattr__(name, value)
.venv/lib/python3.13/site-packages/pydantic/main.py:1033: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

model = FunctionCallLog(name='success_call', sequence_in_run=0, status='success', protocol_run_accession_id=UUID('019bb4fd-54f...e, error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)
name = 'protocol_run'
val = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-54ef-7231-9eb5-ddfc6971ec4c'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)

>       'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        'private': _private_setattr_handler,
        'cached_property': lambda model, name, val: model.__dict__.__setitem__(name, val),
        'extra_known': lambda model, name, val: _object_setattr(model, name, val),
    }
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for FunctionCallLog
E   protocol_run
E     Object has no attribute 'protocol_run' [type=no_such_attribute, input_value=ProtocolRun(name='test_ru...vious_accession_id=None), input_type=ProtocolRun]
E       For further information visit https://errors.pydantic.dev/2.12/v/no_such_attribute

.venv/lib/python3.13/site-packages/pydantic/main.py:111: ValidationError
_______________________ test_function_call_log_orm_repr ________________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106dd5670>
protocol_run = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-5542-7b92-8cd0-d752a4641ffe'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_function_call_log_orm_repr(
        db_session: AsyncSession,
        protocol_run: ProtocolRun,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test string representation of FunctionCallLog."""
        now = datetime.now(timezone.utc)
    
        call_log = FunctionCallLog(
            name="test_call",
            protocol_run_accession_id=protocol_run.accession_id,
            sequence_in_run=42,
            function_protocol_definition_accession_id=protocol_definition.accession_id,
            status=FunctionCallStatusEnum.SUCCESS,
        )
        call_log.start_time = now
    
        repr_str = repr(call_log)
        assert "FunctionCallLog" in repr_str
        assert str(call_log.accession_id) in repr_str
        assert str(protocol_run.accession_id) in repr_str
        assert "42" in repr_str
>       assert "SUCCESS" in repr_str
E       assert 'SUCCESS' in "FunctionCallLog(name='test_call', sequence_in_run=42, status='success', protocol_run_accession_id=UUID('019bb4fd-5543..., error_traceback_text=None, input_args_json=None, return_value_json=None, parent_function_call_log_accession_id=None)"

tests/models/test_domain/test_function_call_log.py:528: AssertionError
___________________ test_machine_orm_creation_with_defaults ____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e49eb0>

    @pytest.mark.asyncio
    async def test_machine_orm_creation_with_defaults(db_session: AsyncSession) -> None:
        """Test creating a Machinewith default values."""
        from praxis.backend.utils.uuid import uuid7
    
        # Create a machine with only required fields
        machine_id = uuid7()
        machine = Machine(
            name="test_machine",
            fqn="test.machine.Fqn",
            asset_type=AssetType.MACHINE,  # Must set explicitly for polymorphic identity
        )
        machine.accession_id = machine_id
    
        # Verify defaults are set
        assert machine.accession_id == machine_id
        assert machine.name == "test_machine"
        assert machine.fqn == "test.machine.Fqn"
        assert machine.asset_type == AssetType.MACHINE
>       assert machine.status == MachineStatusEnum.OFFLINE
E       AssertionError: assert 'OFFLINE' == <MachineStatusEnum.OFFLINE: 'OFFLINE'>
E        +  where 'OFFLINE' = Machine(name='test_machine', asset_type='MACHINE', fqn='test.machine.Fqn', accession_id=UUID('019bb4fd-5d61-73d2-881d-... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None).status
E        +  and   <MachineStatusEnum.OFFLINE: 'OFFLINE'> = MachineStatusEnum.OFFLINE

tests/models/test_domain/test_machine.py:36: AssertionError
_____________________ test_machine_orm_persist_to_database _____________________

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'LiquidHandler'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'LiquidHandler'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106e621b0>

    @pytest.mark.asyncio
    async def test_machine_orm_persist_to_database(db_session: AsyncSession) -> None:
        """Test that a Machinecan be persisted to the database."""
        from praxis.backend.utils.uuid import uuid7
    
        machine_id = uuid7()
        machine = Machine(
            name="test_persistence",
            fqn="test.persistence.Machine",
            asset_type=AssetType.MACHINE,
            description="A test machine",
            manufacturer="Test Manufacturer",
            model="Model X",
            status=MachineStatusEnum.AVAILABLE,  # Changed from ONLINE
            machine_category=MachineCategoryEnum.LIQUID_HANDLER,
        )
        machine.accession_id = machine_id
    
        # Add to session and flush
        db_session.add(machine)
        await db_session.flush()
    
        # Query back from database
>       result = await db_session.execute(
            select(Machine).where(Machine.accession_id == machine_id),
        )

tests/models/test_domain/test_machine.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'LiquidHandler'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'LiquidHandler' is not among the defined enum values. Enum name: machinecategoryenum. Possible values: LIQUID_HAND.., PLATE_READE.., INCUBATOR, ..., UNKNOWN

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
____________________ test_machine_orm_unique_serial_number _____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1075ecad0>

    @pytest.mark.asyncio
    async def test_machine_orm_unique_serial_number(db_session: AsyncSession) -> None:
        """Test that machine serial numbers must be unique."""
        from sqlalchemy.exc import IntegrityError
    
        from praxis.backend.utils.uuid import uuid7
    
        # Create first machine with serial number
        machine1 = Machine(
            name="machine1",
            fqn="test.machine.1",
            asset_type=AssetType.MACHINE,
            serial_number="SN123456",
        )
        machine1.accession_id = uuid7()
        db_session.add(machine1)
        await db_session.flush()
    
        # Try to create another with same serial number
        machine2 = Machine(
            name="machine2",
            fqn="test.machine.2",
            asset_type=AssetType.MACHINE,
            serial_number="SN123456",  # Duplicate serial
        )
        machine2.accession_id = uuid7()
        db_session.add(machine2)
    
        # Should raise IntegrityError
>       with pytest.raises(IntegrityError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'sqlalchemy.exc.IntegrityError'>

tests/models/test_domain/test_machine.py:146: Failed
_________________ test_machine_orm_with_workcell_relationship __________________

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'Unknown'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x108363d10>

    @pytest.mark.asyncio
    async def test_machine_orm_with_workcell_relationship(db_session: AsyncSession) -> None:
        """Test creating a machine with a workcell relationship."""
        from praxis.backend.models.domain.workcell import Workcell
        from praxis.backend.utils.uuid import uuid7
    
        # Create a workcell first
        workcell_id = uuid7()
        workcell = Workcell(
            name="test_workcell",
        )
        workcell.accession_id = workcell_id
        db_session.add(workcell)
        await db_session.flush()
    
        # Create a machine and set workcell via attribute (not constructor)
        machine_id = uuid7()
        machine = Machine(
            name="test_machine_in_workcell",
            fqn="test.machine.InWorkcell",
            asset_type=AssetType.MACHINE,
        )
        machine.accession_id = machine_id
        # Set workcell FK after instantiation
        machine.workcell = workcell
    
        db_session.add(machine)
        await db_session.flush()
    
        # Query back and verify relationship
>       result = await db_session.execute(
            select(Machine).where(Machine.accession_id == machine_id),
        )

tests/models/test_domain/test_machine.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'Unknown' is not among the defined enum values. Enum name: machinecategoryenum. Possible values: LIQUID_HAND.., PLATE_READE.., INCUBATOR, ..., UNKNOWN

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
_____________________ test_machine_orm_status_enum_values ______________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10744fb90>

    @pytest.mark.asyncio
    async def test_machine_orm_status_enum_values(db_session: AsyncSession) -> None:
        """Test that machine status enum values are stored correctly."""
        from praxis.backend.utils.uuid import uuid7
    
        # Test each status
        statuses = [
            MachineStatusEnum.AVAILABLE,  # Changed from ONLINE
            MachineStatusEnum.OFFLINE,
            MachineStatusEnum.ERROR,
            MachineStatusEnum.MAINTENANCE,
        ]
    
        for status in statuses:
            machine = Machine(
                name=f"machine_{status.value}",
                fqn=f"test.machine.{status.value}",
                asset_type=AssetType.MACHINE,
                status=status,
            )
            machine.accession_id = uuid7()
            db_session.add(machine)
            await db_session.flush()
    
            # Verify status was set correctly
>           assert machine.status == status
E           AssertionError: assert 'AVAILABLE' == <MachineStatusEnum.AVAILABLE: 'AVAILABLE'>
E            +  where 'AVAILABLE' = Machine(name='machine_AVAILABLE', asset_type='MACHINE', fqn='test.machine.AVAILABLE', status='AVAILABLE', accession_id... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None).status

tests/models/test_domain/test_machine.py:214: AssertionError
____________________ test_machine_orm_category_enum_values _____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10744fad0>

    @pytest.mark.asyncio
    async def test_machine_orm_category_enum_values(db_session: AsyncSession) -> None:
        """Test that machine category enum values are stored correctly."""
        from praxis.backend.utils.uuid import uuid7
    
        # Test a few key categories
        categories = [
            MachineCategoryEnum.LIQUID_HANDLER,
            MachineCategoryEnum.PLATE_READER,
            MachineCategoryEnum.CENTRIFUGE,
            MachineCategoryEnum.UNKNOWN,
        ]
    
        for category in categories:
            machine = Machine(
                name=f"machine_{category.value}",
                fqn=f"test.machine.{category.value}",
                asset_type=AssetType.MACHINE,
                machine_category=category,
            )
            machine.accession_id = uuid7()
            db_session.add(machine)
            await db_session.flush()
    
            # Verify category was set correctly
>           assert machine.machine_category == category
E           AssertionError: assert 'LiquidHandler' == <MachineCategoryEnum.LIQUID_HANDLER: 'LiquidHandler'>
E            +  where 'LiquidHandler' = Machine(name='machine_LiquidHandler', asset_type='MACHINE', fqn='test.machine.LiquidHandler', machine_category='Liquid... deck_child_definition_accession_id=None, current_protocol_run_accession_id=None, machine_definition_accession_id=None).machine_category

tests/models/test_domain/test_machine.py:242: AssertionError
_________________ test_machine_definition_orm_creation_minimal _________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10744dc70>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_creation_minimal(db_session: AsyncSession) -> None:
        """Test creating MachineDefinition with minimal required fields."""
        machine_def = MachineDefinition(
            name="test_liquid_handler",
            fqn="test.machine.LiquidHandler",
        )
        db_session.add(machine_def)
        await db_session.flush()
    
        # Verify creation
        assert machine_def.accession_id is not None
        assert machine_def.name == "test_liquid_handler"
        assert machine_def.fqn == "test.machine.LiquidHandler"
>       assert machine_def.machine_category == MachineCategoryEnum.UNKNOWN  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'Unknown' == <MachineCategoryEnum.UNKNOWN: 'Unknown'>
E        +  where 'Unknown' = MachineDefinition(name='test_liquid_handler', fqn='test.machine.LiquidHandler', accession_id=UUID('019bb4fd-60ca-7703-...ig=None, resource_definition_accession_id=None, deck_definition_accession_id=None, asset_requirement_accession_id=None).machine_category
E        +  and   <MachineCategoryEnum.UNKNOWN: 'Unknown'> = MachineCategoryEnum.UNKNOWN

tests/models/test_domain/test_machine_definition.py:31: AssertionError
_________________ test_machine_definition_orm_with_all_fields __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1073e6870>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_with_all_fields(db_session: AsyncSession) -> None:
        """Test MachineDefinition with all fields populated."""
        plr_details = {
            "backend_class": "STAR",
            "module": "pylabrobot.liquid_handling.backends.hamilton",
        }
        rotation = {"x_deg": 0, "y_deg": 0, "z_deg": 0}
        setup_method = {
            "method_name": "setup",
            "params": {"simulate": True},
        }
    
        machine_def = MachineDefinition(
            name="hamilton_star",
            fqn="pylabrobot.liquid_handling.backends.hamilton.STAR",
            machine_category=MachineCategoryEnum.LIQUID_HANDLER,
            description="Hamilton STAR liquid handler",
            material="stainless_steel",
            manufacturer="Hamilton",
            plr_definition_details_json=plr_details,
            size_x_mm=1600.0,
            size_y_mm=900.0,
            size_z_mm=800.0,
            model="STAR",
            rotation_json=rotation,
            plr_category="liquid_handler",
            has_deck=True,
            setup_method_json=setup_method,
        )
        db_session.add(machine_def)
        await db_session.flush()
    
        # Verify all fields
        assert machine_def.name == "hamilton_star"
>       assert machine_def.machine_category == MachineCategoryEnum.LIQUID_HANDLER
E       AssertionError: assert 'LiquidHandler' == <MachineCategoryEnum.LIQUID_HANDLER: 'LiquidHandler'>
E        +  where 'LiquidHandler' = MachineDefinition(name='hamilton_star', fqn='pylabrobot.liquid_handling.backends.hamilton.STAR', description='Hamilton...ig=None, resource_definition_accession_id=None, deck_definition_accession_id=None, asset_requirement_accession_id=None).machine_category
E        +  and   <MachineCategoryEnum.LIQUID_HANDLER: 'LiquidHandler'> = MachineCategoryEnum.LIQUID_HANDLER

tests/models/test_domain/test_machine_definition.py:70: AssertionError
_______________ test_machine_definition_orm_persist_to_database ________________

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'PlateReader'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'PlateReader'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1073e67b0>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_persist_to_database(db_session: AsyncSession) -> None:
        """Test full persistence cycle for MachineDefinition."""
        from praxis.backend.utils.uuid import uuid7
    
        machine_def_id = uuid7()
        machine_def = MachineDefinition(
            name="persistence_test_machine",
            fqn="test.persistence.Machine",
            machine_category=MachineCategoryEnum.PLATE_READER,
            manufacturer="Test Corp",
        )
        machine_def.accession_id = machine_def_id
        db_session.add(machine_def)
        await db_session.flush()
    
        # Query back
>       result = await db_session.execute(
            select(MachineDefinition).where(
                MachineDefinition.accession_id == machine_def_id,
            ),
        )

tests/models/test_domain/test_machine_definition.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'PlateReader'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'PlateReader' is not among the defined enum values. Enum name: machinecategoryenum. Possible values: LIQUID_HAND.., PLATE_READE.., INCUBATOR, ..., UNKNOWN

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
______________ test_machine_definition_orm_unique_name_constraint ______________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x107454a70>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_unique_name_constraint(db_session: AsyncSession) -> None:
        """Test that name must be unique."""
        # Create first machine definition
        machine_def1 = MachineDefinition(
            name="unique_machine",
            fqn="test.unique.Machine1",
        )
        db_session.add(machine_def1)
        await db_session.flush()
    
        # Try to create another with same name
        machine_def2 = MachineDefinition(
            name="unique_machine",  # Duplicate name
            fqn="test.unique.Machine2",
        )
        db_session.add(machine_def2)
    
        # Should raise IntegrityError
>       with pytest.raises(IntegrityError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'sqlalchemy.exc.IntegrityError'>

tests/models/test_domain/test_machine_definition.py:160: Failed
________________ test_machine_definition_orm_machine_categories ________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10744e3f0>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_machine_categories(db_session: AsyncSession) -> None:
        """Test different machine category types."""
        categories = [
            (MachineCategoryEnum.LIQUID_HANDLER, "liquid_handler"),
            (MachineCategoryEnum.PLATE_READER, "plate_reader"),
            (MachineCategoryEnum.INCUBATOR, "incubator"),
            (MachineCategoryEnum.SHAKER, "shaker"),
            (MachineCategoryEnum.THERMOCYCLER, "thermocycler"),
        ]
    
        for category, name_suffix in categories:
            machine_def = MachineDefinition(
                name=f"test_{name_suffix}",
                fqn=f"test.machine.{category.value}",
                machine_category=category,
            )
            db_session.add(machine_def)
            await db_session.flush()
    
            # Verify category was set correctly
>           assert machine_def.machine_category == category
E           AssertionError: assert 'LiquidHandler' == <MachineCategoryEnum.LIQUID_HANDLER: 'LiquidHandler'>
E            +  where 'LiquidHandler' = MachineDefinition(name='test_liquid_handler', fqn='test.machine.LiquidHandler', machine_category='LiquidHandler', acce...ig=None, resource_definition_accession_id=None, deck_definition_accession_id=None, asset_requirement_accession_id=None).machine_category

tests/models/test_domain/test_machine_definition.py:185: AssertionError
___________________ test_machine_definition_orm_jsonb_fields ___________________

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'Unknown'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10744ddf0>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_jsonb_fields(db_session: AsyncSession) -> None:
        """Test JSONB field handling."""
        plr_details = {
            "backend": "STAR",
            "channels": 8,
            "min_volume_ul": 0.5,
            "max_volume_ul": 1000.0,
        }
        rotation = {"x_deg": 0, "y_deg": 90, "z_deg": 180}
        setup_method = {
            "method": "setup_with_robot_config",
            "config_path": "/path/to/config.yaml",
        }
    
        machine_def = MachineDefinition(
            name="jsonb_test_machine",
            fqn="test.jsonb.Machine",
            plr_definition_details_json=plr_details,
            rotation_json=rotation,
            setup_method_json=setup_method,
        )
        db_session.add(machine_def)
        await db_session.flush()
    
        # Query back to verify JSONB storage
>       result = await db_session.execute(
            select(MachineDefinition).where(
                MachineDefinition.name == "jsonb_test_machine",
            ),
        )

tests/models/test_domain/test_machine_definition.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'Unknown' is not among the defined enum values. Enum name: machinecategoryenum. Possible values: LIQUID_HAND.., PLATE_READE.., INCUBATOR, ..., UNKNOWN

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
____________________ test_machine_definition_orm_dimensions ____________________

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'Unknown'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10788fdd0>

    @pytest.mark.asyncio
    async def test_machine_definition_orm_dimensions(db_session: AsyncSession) -> None:
        """Test physical dimension fields."""
        machine_def = MachineDefinition(
            name="dimensioned_machine",
            fqn="test.dimensions.Machine",
            size_x_mm=1600.0,
            size_y_mm=900.0,
            size_z_mm=800.0,
        )
        db_session.add(machine_def)
        await db_session.flush()
    
        # Query back
>       result = await db_session.execute(
            select(MachineDefinition).where(
                MachineDefinition.name == "dimensioned_machine",
            ),
        )

tests/models/test_domain/test_machine_definition.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('LIQUID_HANDLER', 'PLATE_READER', 'INCUBATOR', 'SHAKER', 'HEATER_SHAKER', 'PUMP', 'FAN', 'TEMPERATURE_CONTROLLER'...', 'ARM', 'GENERAL_AUTOMATION_DEVICE', 'OTHER_INSTRUMENT', 'UNKNOWN', name='machinecategoryenum', _create_events=False)
elem = 'Unknown'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'Unknown' is not among the defined enum values. Enum name: machinecategoryenum. Possible values: LIQUID_HAND.., PLATE_READE.., INCUBATOR, ..., UNKNOWN

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
______ TestMachineDefinitionSchemas.test_machine_definition_base_minimal _______

self = <test_machine_definition.TestMachineDefinitionSchemas object at 0x10646ae90>

    def test_machine_definition_base_minimal(self) -> None:
        """Test MachineDefinitionBase with minimal fields."""
        machine_def = MachineDefinitionBase(
            fqn="test.minimal.Machine",
            name="minimal_machine",
        )
    
        # Verify defaults
        assert machine_def.fqn == "test.minimal.Machine"
>       assert machine_def.machine_category is None
E       AssertionError: assert <MachineCategoryEnum.UNKNOWN: 'Unknown'> is None
E        +  where <MachineCategoryEnum.UNKNOWN: 'Unknown'> = MachineDefinitionBase(accession_id=UUID('019bb4fd-6576-77e1-b801-519ddc4ff263'), created_at=datetime.datetime(2026, 1,...None, manufacturer=None, model=None, size_x_mm=None, size_y_mm=None, size_z_mm=None, has_deck=False, frontend_fqn=None).machine_category

tests/models/test_domain/test_machine_definition.py:302: AssertionError
__ TestMachineDefinitionSchemas.test_machine_definition_base_with_all_fields ___

self = <test_machine_definition.TestMachineDefinitionSchemas object at 0x10646aad0>

    def test_machine_definition_base_with_all_fields(self) -> None:
        """Test MachineDefinitionBase with all fields populated."""
        from praxis.backend.utils.uuid import uuid7
    
        plr_details = {
            "backend": "STAR",
            "num_channels": 8,
        }
        rotation = {"x_deg": 0, "y_deg": 0, "z_deg": 90}
        setup_method = {"method": "setup", "params": {"simulate": True}}
        resource_def_id = uuid7()
        deck_def_id = uuid7()
    
        machine_def = MachineDefinitionBase(
            name="full_machine",
            fqn="test.full.Machine",
            machine_category=MachineCategoryEnum.LIQUID_HANDLER,
            nominal_volume_ul=1000.0,
            material="stainless_steel",
            manufacturer="Hamilton",
            plr_definition_details_json=plr_details,
            size_x_mm=1600.0,
            size_y_mm=900.0,
            size_z_mm=800.0,
            model="STAR",
            rotation_json=rotation,
            resource_definition_accession_id=resource_def_id,
            has_deck=True,
            deck_definition_accession_id=deck_def_id,
            setup_method_json=setup_method,
        )
    
        assert machine_def.fqn == "test.full.Machine"
        assert machine_def.machine_category == "LiquidHandler"  # Serialized to string
>       assert machine_def.nominal_volume_ul == 1000.0
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_machine_definition.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MachineDefinitionBase(accession_id=UUID('019bb4fd-6586-74d1-a3c1-71fd81f1a517'), created_at=datetime.datetime(2026, 1,...acturer='Hamilton', model='STAR', size_x_mm=1600.0, size_y_mm=900.0, size_z_mm=800.0, has_deck=True, frontend_fqn=None)
item = 'nominal_volume_ul'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra and item in pydantic_extra:
                return pydantic_extra[item]
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MachineDefinitionBase' object has no attribute 'nominal_volume_ul'

.venv/lib/python3.13/site-packages/pydantic/main.py:1026: AttributeError
_________ TestMachineDefinitionSchemas.test_machine_definition_update __________

self = <test_machine_definition.TestMachineDefinitionSchemas object at 0x1064ea060>

    def test_machine_definition_update(self) -> None:
        """Test MachineDefinitionUpdate model."""
        # Update requires fqn but other fields are optional
        update = MachineDefinitionUpdate(fqn="test.update.Machine")
    
        assert update.fqn == "test.update.Machine"
        assert update.machine_category is None
        assert update.description is None
    
        # Can update specific fields
        update_partial = MachineDefinitionUpdate(
            fqn="test.update.Machine2",
            description="Updated description",
            manufacturer="Updated Corp",
            size_x_mm=1700.0,
            machine_category=MachineCategoryEnum.PLATE_READER,
        )
    
        assert update_partial.fqn == "test.update.Machine2"
        assert update_partial.description == "Updated description"
        assert update_partial.manufacturer == "Updated Corp"
        assert update_partial.size_x_mm == 1700.0
>       assert update_partial.machine_category == "PlateReader"  # Serialized to string
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <MachineCategoryEnum.PLATE_READER: 'PlateReader'> == 'PlateReader'
E        +  where <MachineCategoryEnum.PLATE_READER: 'PlateReader'> = MachineDefinitionUpdate(name=None, fqn='test.update.Machine2', description='Updated description', plr_category=None, m...m=None, has_deck=None, frontend_fqn=None, plr_definition_details_json=None, rotation_json=None, setup_method_json=None).machine_category

tests/models/test_domain/test_machine_definition.py:390: AssertionError
____ TestMachineDefinitionSchemas.test_machine_definition_jsonb_validation _____

self = <test_machine_definition.TestMachineDefinitionSchemas object at 0x1064c27b0>

    def test_machine_definition_jsonb_validation(self) -> None:
        """Test JSONB field validation in Pydantic models."""
        plr_details = {
            "backend_class": "STAR",
            "num_channels": 8,
            "channel_spacing_mm": 9.0,
        }
        setup_method = {
            "method_name": "setup_with_config",
            "config_file": "robot_config.yaml",
        }
    
        machine_def = MachineDefinitionCreate(
            name="jsonb_test",
            fqn="test.jsonb.Machine",
            plr_definition_details_json=plr_details,
            setup_method_json=setup_method,
        )
    
>       assert machine_def.plr_definition_details_json == plr_details
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/models/test_domain/test_machine_definition.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MachineDefinitionCreate(accession_id=UUID('019bb4fd-65e2-7940-8f8f-9ec01d4a318a'), created_at=datetime.datetime(2026, ...None, manufacturer=None, model=None, size_x_mm=None, size_y_mm=None, size_z_mm=None, has_deck=False, frontend_fqn=None)
item = 'plr_definition_details_json'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra and item in pydantic_extra:
                return pydantic_extra[item]
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MachineDefinitionCreate' object has no attribute 'plr_definition_details_json'

.venv/lib/python3.13/site-packages/pydantic/main.py:1026: AttributeError
______________________ test_protocol_run_creation_minimal ______________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x107848410>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_creation_minimal(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test creating ProtocolRunwith minimal required fields."""
        run = ProtocolRun(
            name="test_run",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
        )
        db_session.add(run)
        await db_session.flush()
    
        # Verify creation with defaults
        assert run.accession_id is not None
        assert run.top_level_protocol_definition_accession_id == protocol_definition.accession_id
>       assert run.status == ProtocolRunStatusEnum.PENDING  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'pending' == <ProtocolRunStatusEnum.PENDING: 'pending'>
E        +  where 'pending' = ProtocolRun(name='test_run', top_level_protocol_definition_accession_id=UUID('019bb4fd-6686-7771-9a04-069481d2253f'), ...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None).status
E        +  and   <ProtocolRunStatusEnum.PENDING: 'pending'> = ProtocolRunStatusEnum.PENDING

tests/models/test_domain/test_protocol_run.py:46: AssertionError
__________________ test_protocol_run_creation_with_all_fields __________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077caab0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_creation_with_all_fields(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test creating ProtocolRunwith all fields populated."""
        now = datetime.now(timezone.utc)
        input_params = {"volume": 50, "temperature": 37}
        resolved_assets = {"plate": "plate_123", "machine": "star_001"}
        output_data = {"result": "success", "measurements": [1.2, 3.4, 5.6]}
        initial_state = {"deck_layout": "config_a"}
        final_state = {"deck_layout": "config_b", "tips_used": 96}
        user_info = {"user_id": "user123", "username": "testuser"}
    
        run = ProtocolRun(
            name="test_run",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.RUNNING,
            start_time=now,
            input_parameters_json=input_params,
            resolved_assets_json=resolved_assets,
            output_data_json=output_data,
            initial_state_json=initial_state,
            final_state_json=final_state,
            data_directory_path="/data/runs/run_123",
            created_by_user=user_info,
            duration_ms=45000,
        )
        db_session.add(run)
        await db_session.flush()
    
        # Verify all fields
        assert run.accession_id is not None
>       assert run.status == ProtocolRunStatusEnum.RUNNING
E       AssertionError: assert 'running' == <ProtocolRunStatusEnum.RUNNING: 'running'>
E        +  where 'running' = ProtocolRun(name='test_run', status='running', start_time=datetime.datetime(2026, 1, 13, 1, 34, 24, 410952, tzinfo=dat...11034, tzinfo=datetime.timezone.utc), updated_at=None, properties_json=None, end_time=None, previous_accession_id=None).status
E        +  and   <ProtocolRunStatusEnum.RUNNING: 'running'> = ProtocolRunStatusEnum.RUNNING

tests/models/test_domain/test_protocol_run.py:93: AssertionError
____________________ test_protocol_run_persist_to_database _____________________

self = Enum('QUEUED', 'PENDING', 'PREPARING', 'RUNNING', 'PAUSING', 'PAUSED', 'RESUMING', 'COMPLETED', 'FAILED', 'CANCELING', 'CANCELLED', 'INTERVENING', 'REQUIRES_INTERVENTION', name='protocolrunstatusenum', _create_events=False)
elem = 'completed'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'completed'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077ca9f0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_persist_to_database(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test full persistence cycle for ProtocolRun."""
        run = ProtocolRun(
            name="test_run",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.COMPLETED,
            input_parameters_json={"test": "value"},
        )
        db_session.add(run)
        await db_session.flush()
    
        run_id = run.accession_id
    
        # Query back
>       result = await db_session.execute(
            select(ProtocolRun).where(ProtocolRun.accession_id == run_id),
        )

tests/models/test_domain/test_protocol_run.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('QUEUED', 'PENDING', 'PREPARING', 'RUNNING', 'PAUSING', 'PAUSED', 'RESUMING', 'COMPLETED', 'FAILED', 'CANCELING', 'CANCELLED', 'INTERVENING', 'REQUIRES_INTERVENTION', name='protocolrunstatusenum', _create_events=False)
elem = 'completed'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'completed' is not among the defined enum values. Enum name: protocolrunstatusenum. Possible values: QUEUED, PENDING, PREPARING, ..., REQUIRES_IN..

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
_____________________ test_protocol_run_status_transitions _____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077cac90>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_status_transitions(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test different status values for protocol runs."""
        statuses = [
            (ProtocolRunStatusEnum.PENDING, "pending_run"),
            (ProtocolRunStatusEnum.QUEUED, "queued_run"),
            (ProtocolRunStatusEnum.RUNNING, "running_run"),
            (ProtocolRunStatusEnum.COMPLETED, "completed_run"),
            (ProtocolRunStatusEnum.FAILED, "failed_run"),
            (ProtocolRunStatusEnum.CANCELLED, "cancelled_run"),
            (ProtocolRunStatusEnum.PAUSED, "paused_run"),
        ]
    
        for status, name in statuses:
            run = ProtocolRun(
                name=name,
                top_level_protocol_definition_accession_id=protocol_definition.accession_id,
                status=status,
            )
            db_session.add(run)
            await db_session.flush()
    
            # Verify status
>           assert run.status == status
E           AssertionError: assert 'pending' == <ProtocolRunStatusEnum.PENDING: 'pending'>
E            +  where 'pending' = ProtocolRun(name='pending_run', status='pending', top_level_protocol_definition_accession_id=UUID('019bb4fd-6820-7b32-...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None).status

tests/models/test_domain/test_protocol_run.py:161: AssertionError
_____________________ test_protocol_run_continuation_chain _____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077cb3b0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_continuation_chain(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test previous_accession_id for protocol run continuations."""
        # Create first run
        run1 = ProtocolRun(
            name="run1",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.COMPLETED,
        )
        db_session.add(run1)
        await db_session.flush()
        run1_id = run1.accession_id
    
        # Create continuation run
        run2 = ProtocolRun(
            name="run2",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.RUNNING,
            previous_run=run1,
        )
        db_session.add(run2)
        await db_session.flush()
    
        # Verify continuation link
>       assert run2.previous_accession_id == run1_id
E       AssertionError: assert None == UUID('019bb4fd-686c-7832-b3ee-7f00ede75df6')
E        +  where None = ProtocolRun(name='run2', status='running', top_level_protocol_definition_accession_id=UUID('019bb4fd-686a-7552-865d-a8...utput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None).previous_accession_id

tests/models/test_domain/test_protocol_run.py:375: AssertionError
______________________ test_protocol_run_query_by_status _______________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077ca390>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_query_by_status(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test querying protocol runs by status."""
        # Create runs with different statuses
        running_run = ProtocolRun(
            name="running_query_test",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.RUNNING,
        )
        completed_run = ProtocolRun(
            name="completed_query_test",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.COMPLETED,
        )
        db_session.add(running_run)
        db_session.add(completed_run)
        await db_session.flush()
    
        # Query for running protocols
        result = await db_session.execute(
            select(ProtocolRun).where(
                ProtocolRun.status == ProtocolRunStatusEnum.RUNNING,
            ),
        )
        running_runs = result.scalars().all()
    
        # Should find at least our running run
>       assert len(running_runs) >= 1
E       assert 0 >= 1
E        +  where 0 = len([])

tests/models/test_domain/test_protocol_run.py:409: AssertionError
_____________________ test_protocol_run_query_by_protocol ______________________

self = Enum('QUEUED', 'PENDING', 'PREPARING', 'RUNNING', 'PAUSING', 'PAUSED', 'RESUMING', 'COMPLETED', 'FAILED', 'CANCELING', 'CANCELLED', 'INTERVENING', 'REQUIRES_INTERVENTION', name='protocolrunstatusenum', _create_events=False)
elem = 'pending'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
>           return self._object_lookup[elem]  # type: ignore[return-value]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'pending'

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1709: KeyError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1077c9070>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_query_by_protocol(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test querying all runs for a specific protocol."""
        # Create multiple runs for the same protocol
        run1 = ProtocolRun(
            name="protocol_query_run1",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
        )
        run2 = ProtocolRun(
            name="protocol_query_run2",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
        )
        db_session.add(run1)
        db_session.add(run2)
        await db_session.flush()
    
        # Query all runs for this protocol
>       result = await db_session.execute(
            select(ProtocolRun).where(
                ProtocolRun.top_level_protocol_definition_accession_id
                == protocol_definition.accession_id,
            ),
        )

tests/models/test_domain/test_protocol_run.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:449: in execute
    result = await greenlet_spawn(
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:309: in orm_execute_statement
    return cls.orm_setup_cursor_result(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py:616: in orm_setup_cursor_result
    return loading.instances(result, querycontext)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:262: in instances
    _prebuffered = list(chunks(None))
                   ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py:220: in chunks
    fetch = cursor._raw_all_rows()
            ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py:541: in _raw_all_rows
    return [make_row(row) for row in rows]
            ^^^^^^^^^^^^^
lib/sqlalchemy/cyextension/resultproxy.pyx:22: in sqlalchemy.cyextension.resultproxy.BaseRow.__init__
    ???
lib/sqlalchemy/cyextension/resultproxy.pyx:79: in sqlalchemy.cyextension.resultproxy._apply_processors
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1829: in process
    value = self._object_value_for_elem(value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Enum('QUEUED', 'PENDING', 'PREPARING', 'RUNNING', 'PAUSING', 'PAUSED', 'RESUMING', 'COMPLETED', 'FAILED', 'CANCELING', 'CANCELLED', 'INTERVENING', 'REQUIRES_INTERVENTION', name='protocolrunstatusenum', _create_events=False)
elem = 'pending'

    def _object_value_for_elem(self, elem: str) -> Union[str, enum.Enum]:
        try:
            # Value will not be None beacuse key is not None
            return self._object_lookup[elem]  # type: ignore[return-value]
        except KeyError as err:
>           raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
E           LookupError: 'pending' is not among the defined enum values. Enum name: protocolrunstatusenum. Possible values: QUEUED, PENDING, PREPARING, ..., REQUIRES_IN..

.venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py:1711: LookupError
____________________________ test_protocol_run_repr ____________________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10784f0b0>
protocol_definition = FunctionProtocolDefinition(name='test_protocol', fqn='test.protocols.test_protocol', version='1.0.0', is_top_level=Tru...ilure_modes_json=None, cached_bytecode=None, source_repository_accession_id=None, file_system_source_accession_id=None)

    @pytest.mark.asyncio
    async def test_protocol_run_repr(
        db_session: AsyncSession,
        protocol_definition: FunctionProtocolDefinition,
    ) -> None:
        """Test string representation of ProtocolRun."""
        run = ProtocolRun(
            name="test_run",
            top_level_protocol_definition_accession_id=protocol_definition.accession_id,
            status=ProtocolRunStatusEnum.RUNNING,
        )
        db_session.add(run)
        await db_session.flush()
        run_id = run.accession_id
    
        repr_str = repr(run)
        assert "ProtocolRun" in repr_str
        assert str(run_id) in repr_str
>       assert "RUNNING" in repr_str
E       assert 'RUNNING' in "ProtocolRun(name='test_run', status='running', top_level_protocol_definition_accession_id=UUID('019bb4fd-69fb-77d1-a6...tput_data_json=None, initial_state_json=None, final_state_json=None, created_by_user=None, previous_accession_id=None)"

tests/models/test_domain/test_protocol_run.py:466: AssertionError
____________________ test_schedule_history_orm_event_timing ____________________

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x107b144d0>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x107b31800>

    @pytest.mark.asyncio
    async def test_schedule_history_orm_event_timing(
        db_session: AsyncSession,
        schedule_entry_factory: Callable[[], ScheduleEntry],
    ) -> None:
        """Test event_start, event_end, and computed duration.
    
        Should:
        - Auto-set event_start with server_default
        - Allow manual event_end
        - Compute completed_duration_ms from event_end - event_start
        - Support override_duration_ms for manual duration
        """
        schedule_entry = await schedule_entry_factory()
    
        history = ScheduleHistory(
            name="test_history_timing",
            schedule_entry_accession_id=schedule_entry.accession_id,
            event_type=ScheduleHistoryEventEnum.COMPLETED.value,
            override_duration_ms=5000,
            event_start=datetime.now(timezone.utc),
        )
        history.schedule_entry = schedule_entry
    
        db_session.add(history)
        await db_session.flush()
        await db_session.refresh(history)
    
        # Verify timing fields
        # If this fails, it means event_start was not persisted or retrieved correctly
        if history.event_start is None:
            raise AssertionError(f"event_start is None! {history.model_dump()}")
    
        assert history.event_start is not None
        assert history.event_end is None  # Not set yet
        assert history.override_duration_ms == 5000
    
        # Set event_end
        history.event_end = history.event_start + timedelta(seconds=3)
        await db_session.flush()
        await db_session.refresh(history)
    
        # computed_duration_ms should be calculated by database
>       assert history.completed_duration_ms is not None
E       AssertionError: assert None is not None
E        +  where None = ScheduleHistory(properties_json=None, completed_duration_ms=None, created_at=datetime.datetime(2026, 1, 13, 1, 34, 25,...26, 1, 13, 1, 34, 25, 918008), name='test_history_timing', event_end=datetime.datetime(2026, 1, 13, 1, 34, 28, 918008)).completed_duration_ms

tests/models/test_domain/test_schedule_history.py:373: AssertionError
___________________ test_schedule_history_orm_cascade_delete ___________________

self = <sqlalchemy.engine.base.Connection object at 0x107afbe70>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x1067646e0>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x1083a3ad0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x1083a4550>
parameters = [(None, '019bb4fd6d0877628575892ecf12f760'), (None, '019bb4fd6d0877628575894a2db1479d'), (None, '019bb4fd6d097b20ba9328115b36742c')]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,

.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:948: in do_executemany
    cursor.executemany(statement, parameters)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:195: in executemany
    self._adapt_connection._handle_exception(error)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:340: in _handle_exception
    raise error
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:189: in executemany
    self.await_(_cursor.executemany(operation, seq_of_parameters))
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:47: in executemany
    await self._execute(self._cursor.executemany, sql, parameters)
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-1, started daemon 6173880320)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlite3.IntegrityError: NOT NULL constraint failed: schedule_history.schedule_entry_accession_id

.venv/lib/python3.13/site-packages/aiosqlite/core.py:105: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x108323890>
schedule_entry_factory = <function schedule_entry_factory.<locals>._factory at 0x107b30860>

    @pytest.mark.asyncio
    async def test_schedule_history_orm_cascade_delete(
        db_session: AsyncSession,
        schedule_entry_factory: Callable[[], ScheduleEntry],
    ) -> None:
        """Test that deleting schedule entry cascades to delete history entries.
    
        The relationship should have cascade='all, delete-orphan'.
        """
        schedule_entry = await schedule_entry_factory()
        entry_id = schedule_entry.accession_id
    
        # Create history entries
        for _i in range(3):
            history = ScheduleHistory(
                name=f"test_history_{uuid7()}",
                schedule_entry_accession_id=schedule_entry.accession_id,
                event_type=ScheduleHistoryEventEnum.STATUS_CHANGED.value,
                event_start=datetime.now(timezone.utc),
            )
            history.schedule_entry = schedule_entry
            db_session.add(history)
    
        await db_session.flush()
    
        # Delete schedule entry
        await db_session.delete(schedule_entry)
>       await db_session.commit()

tests/models/test_domain/test_schedule_history.py:645: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:1286: in _prepare_impl
    self.session.flush()
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4331: in flush
    self._flush(objects)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py:4427: in _flush
    flush_context.execute()
.venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
.venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:85: in save_obj
    _emit_update_statements(
.venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py:912: in _emit_update_statements
    c = connection.execute(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py:1936: in _exec_single_context
    self.dialect.do_executemany(
.venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py:948: in do_executemany
    cursor.executemany(statement, parameters)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:195: in executemany
    self._adapt_connection._handle_exception(error)
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:340: in _handle_exception
    raise error
.venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:189: in executemany
    self.await_(_cursor.executemany(operation, seq_of_parameters))
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:47: in executemany
    await self._execute(self._cursor.executemany, sql, parameters)
.venv/lib/python3.13/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/aiosqlite/core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-1, started daemon 6173880320)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: schedule_history.schedule_entry_accession_id
E               [SQL: UPDATE schedule_history SET updated_at=CURRENT_TIMESTAMP, schedule_entry_accession_id=? WHERE schedule_history.accession_id = ?]
E               [parameters: [(None, '019bb4fd6d0877628575892ecf12f760'), (None, '019bb4fd6d0877628575894a2db1479d'), (None, '019bb4fd6d097b20ba9328115b36742c')]]
E               (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv/lib/python3.13/site-packages/aiosqlite/core.py:105: IntegrityError
================================ tests coverage ================================
_______________ coverage: platform darwin, python 3.13.5-final-0 _______________

Name                                                                                  Stmts   Miss  Cover   Missing
-------------------------------------------------------------------------------------------------------------------
praxis/backend/__init__.py                                                                1      0   100%
praxis/backend/api/__init__.py                                                            4      4     0%   8-14
praxis/backend/api/auth.py                                                               49     49     0%   3-181
praxis/backend/api/decks.py                                                               9      9     0%   3-31
praxis/backend/api/dependencies.py                                                       30     30     0%   3-67
praxis/backend/api/discovery.py                                                          16     16     0%   3-39
praxis/backend/api/global_dependencies.py                                                33     33     0%   10-74
praxis/backend/api/hardware.py                                                          149    149     0%   7-500
praxis/backend/api/machines.py                                                           47     47     0%   7-170
praxis/backend/api/outputs.py                                                             9      9     0%   3-31
praxis/backend/api/protocols.py                                                         134    134     0%   7-467
praxis/backend/api/repl.py                                                               64     64     0%   1-134
praxis/backend/api/resources.py                                                          38     38     0%   8-124
praxis/backend/api/scheduler.py                                                         105    105     0%   1-395
praxis/backend/api/utils/__init__.py                                                      0      0   100%
praxis/backend/api/utils/crud_router_factory.py                                          40     40     0%   3-90
praxis/backend/api/websockets.py                                                         65     65     0%   1-151
praxis/backend/api/workcell.py                                                            7      7     0%   7-20
praxis/backend/celery_app.py                                                              2      2     0%   1-3
praxis/backend/configure.py                                                             152     64    58%   43, 49, 61-69, 81-87, 117, 122, 127, 132, 137-139, 144, 149, 157, 176, 188-190, 195, 200, 205, 210, 215-217, 222, 227, 232, 241-248, 253-254, 259, 264-265, 274-287, 293-295, 305-306, 322-329
praxis/backend/core/__init__.py                                                           2      2     0%   3-5
praxis/backend/core/asset_lock_manager.py                                                39     39     0%   3-76
praxis/backend/core/asset_manager/__init__.py                                             8      8     0%   3-28
praxis/backend/core/asset_manager/core.py                                                52     52     0%   4-149
praxis/backend/core/asset_manager/deck_manager.py                                        74     74     0%   5-217
praxis/backend/core/asset_manager/location_handler.py                                    46     46     0%   4-95
praxis/backend/core/asset_manager/machine_manager.py                                     79     79     0%   4-205
praxis/backend/core/asset_manager/resource_manager.py                                   129    129     0%   4-380
praxis/backend/core/celery.py                                                             4      4     0%   7-15
praxis/backend/core/celery_base.py                                                       12     12     0%   1-23
praxis/backend/core/celery_tasks.py                                                      72     72     0%   9-203
praxis/backend/core/consumable_assignment.py                                            165    165     0%   17-456
praxis/backend/core/container.py                                                         49     49     0%   10-215
praxis/backend/core/deck_config.py                                                       82     82     0%   16-263
praxis/backend/core/decorators/__init__.py                                                5      5     0%   1-23
praxis/backend/core/decorators/definition_builder.py                                     50     50     0%   1-188
praxis/backend/core/decorators/models.py                                                 60     60     0%   1-153
praxis/backend/core/decorators/parameter_processor.py                                    50     50     0%   1-130
praxis/backend/core/decorators/protocol_decorator.py                                    206    206     0%   1-547
praxis/backend/core/filesystem.py                                                        21     21     0%   3-61
praxis/backend/core/orchestrator/__init__.py                                              3      3     0%   3-12
praxis/backend/core/orchestrator/asset_acquisition.py                                    58     58     0%   3-151
praxis/backend/core/orchestrator/core.py                                                 26     26     0%   5-81
praxis/backend/core/orchestrator/error_handling.py                                       75     75     0%   3-191
praxis/backend/core/orchestrator/execution.py                                           175    175     0%   3-465
praxis/backend/core/orchestrator/protocol_preparation.py                                 75     75     0%   3-205
praxis/backend/core/precondition_resolver.py                                            181    181     0%   14-523
praxis/backend/core/protocol_cache.py                                                   128    128     0%   14-473
praxis/backend/core/protocol_code_manager.py                                            152    152     0%   14-520
praxis/backend/core/protocol_execution_service.py                                        99     99     0%   9-304
praxis/backend/core/protocols/__init__.py                                                 0      0   100%
praxis/backend/core/protocols/asset_lock_manager.py                                       5      5     0%   1-8
praxis/backend/core/protocols/asset_manager.py                                            7      7     0%   3-11
praxis/backend/core/protocols/filesystem.py                                               1      1     0%   1
praxis/backend/core/protocols/orchestrator.py                                             2      2     0%   3-5
praxis/backend/core/protocols/protocol_code_manager.py                                    3      3     0%   3-6
praxis/backend/core/protocols/protocol_execution_service.py                               3      3     0%   3-6
praxis/backend/core/protocols/scheduler.py                                                2      2     0%   3-4
praxis/backend/core/protocols/workcell.py                                                 3      3     0%   3-6
praxis/backend/core/protocols/workcell_runtime.py                                         7      7     0%   3-11
praxis/backend/core/repl_session.py                                                      72     72     0%   3-128
praxis/backend/core/run_context.py                                                       50     50     0%   19-130
praxis/backend/core/scheduler.py                                                        282    282     0%   4-731
praxis/backend/core/simulation/__init__.py                                               10     10     0%   22-92
praxis/backend/core/simulation/bounds_analyzer.py                                       113    113     0%   7-356
praxis/backend/core/simulation/failure_detector.py                                      126    126     0%   7-386
praxis/backend/core/simulation/graph_replay.py                                          152    152     0%   18-488
praxis/backend/core/simulation/method_contracts.py                                       80     80     0%   11-546
praxis/backend/core/simulation/pipeline.py                                              148    148     0%   13-545
praxis/backend/core/simulation/simulator.py                                              59     59     0%   8-294
praxis/backend/core/simulation/state_models.py                                          268    268     0%   12-582
praxis/backend/core/simulation/state_resolution.py                                      163    163     0%   20-608
praxis/backend/core/simulation/stateful_tracers.py                                      188    188     0%   8-499
praxis/backend/core/storage/__init__.py                                                   3      3     0%   16-27
praxis/backend/core/storage/celery_adapter.py                                            40     40     0%   7-132
praxis/backend/core/storage/factory.py                                                   75     75     0%   24-242
praxis/backend/core/storage/memory_adapter.py                                           233    233     0%   18-395
praxis/backend/core/storage/protocols.py                                                  2      2     0%   13-14
praxis/backend/core/storage/redis_adapter.py                                            162    162     0%   9-327
praxis/backend/core/storage/sqlite_adapter.py                                           106    106     0%   19-279
praxis/backend/core/tracing/__init__.py                                                   4      4     0%   8-18
praxis/backend/core/tracing/executor.py                                                  73     73     0%   8-323
praxis/backend/core/tracing/recorder.py                                                 121    121     0%   7-360
praxis/backend/core/tracing/tracers.py                                                  144    144     0%   11-447
praxis/backend/core/workcell.py                                                         107    107     0%   13-242
praxis/backend/core/workcell_runtime/__init__.py                                          2      2     0%   1-3
praxis/backend/core/workcell_runtime/core.py                                             38     38     0%   3-72
praxis/backend/core/workcell_runtime/deck_manager.py                                    201    201     0%   4-487
praxis/backend/core/workcell_runtime/machine_manager.py                                 171    171     0%   4-426
praxis/backend/core/workcell_runtime/resource_manager.py                                 83     83     0%   4-208
praxis/backend/core/workcell_runtime/state_sync.py                                       91     91     0%   3-180
praxis/backend/core/workcell_runtime/utils.py                                            13     13     0%   3-26
praxis/backend/main.py                                                                  156    156     0%   3-353
praxis/backend/models/__init__.py                                                        14      0   100%
praxis/backend/models/domain/__init__.py                                                 14      0   100%
praxis/backend/models/domain/asset.py                                                    37      0   100%
praxis/backend/models/domain/deck.py                                                    151     13    91%   15, 20-22, 198, 236-240, 299, 306, 331
praxis/backend/models/domain/filters.py                                                  17      0   100%
praxis/backend/models/domain/machine.py                                                 124      4    97%   20-23
praxis/backend/models/domain/outputs.py                                                 152      5    97%   17-21
praxis/backend/models/domain/plr_sync.py                                                  8      0   100%
praxis/backend/models/domain/protocol.py                                                231      2    99%   23-27
praxis/backend/models/domain/protocol_source.py                                          46      1    98%   15
praxis/backend/models/domain/resolution.py                                               36      2    94%   15-16
praxis/backend/models/domain/resource.py                                                166     12    93%   17-20, 163-165, 170-172, 247, 254
praxis/backend/models/domain/schedule.py                                                168      1    99%   20
praxis/backend/models/domain/sqlmodel_base.py                                            21      1    95%   44
praxis/backend/models/domain/user.py                                                     26      0   100%
praxis/backend/models/domain/workcell.py                                                 40      3    92%   18-20
praxis/backend/models/enums/__init__.py                                                  10      0   100%
praxis/backend/models/enums/asset.py                                                     14      0   100%
praxis/backend/models/enums/machine.py                                                   30      1    97%   53
praxis/backend/models/enums/outputs.py                                                   29      0   100%
praxis/backend/models/enums/plr_category.py                                              81     47    42%   109-119, 136-178
praxis/backend/models/enums/protocol.py                                                  30      0   100%
praxis/backend/models/enums/resolution.py                                                11      0   100%
praxis/backend/models/enums/resource.py                                                  60      3    95%   101, 121, 135
praxis/backend/models/enums/schedule.py                                                  33      0   100%
praxis/backend/models/enums/workcell.py                                                  12      1    92%   28
praxis/backend/models/pydantic_internals/__init__.py                                     13      0   100%
praxis/backend/models/pydantic_internals/maintenance.py                                  22     22     0%   1-43
praxis/backend/models/pydantic_internals/plr_sync.py                                     17     17     0%   3-39
praxis/backend/models/pydantic_internals/pydantic_base.py                                13      1    92%   45
praxis/backend/models/pydantic_internals/runtime.py                                      42      3    93%   31, 42-43
praxis/backend/services/__init__.py                                                      13     13     0%   14-31
praxis/backend/services/async_state.py                                                   89     89     0%   8-208
praxis/backend/services/capability_matcher.py                                            63     63     0%   7-217
praxis/backend/services/deck.py                                                         135    135     0%   8-325
praxis/backend/services/deck_type_definition.py                                          26     26     0%   3-59
praxis/backend/services/discovery_service.py                                            112    112     0%   12-276
praxis/backend/services/entity_linking.py                                               147    147     0%   8-405
praxis/backend/services/hardware_connection_manager.py                                  118    118     0%   25-380
praxis/backend/services/hardware_discovery.py                                           129    129     0%   12-457
praxis/backend/services/machine.py                                                      110    110     0%   10-255
praxis/backend/services/machine_type_definition.py                                       65     65     0%   3-173
praxis/backend/services/mock_data_generator.py                                           89     89     0%   3-166
praxis/backend/services/outputs.py                                                       66     66     0%   8-159
praxis/backend/services/plate_parsing.py                                                 60     60     0%   8-144
praxis/backend/services/plate_viz.py                                                     25     25     0%   10-99
praxis/backend/services/plr_type_base.py                                                  8      8     0%   3-19
praxis/backend/services/praxis_orm_service.py                                           171    171     0%   12-433
praxis/backend/services/protocol_definition.py                                          135    135     0%   3-392
praxis/backend/services/protocol_output_data.py                                          24     24     0%   8-125
praxis/backend/services/protocols.py                                                    172    172     0%   12-421
praxis/backend/services/resource.py                                                     111    111     0%   4-274
praxis/backend/services/resource_type_definition.py                                     280    280     0%   3-699
praxis/backend/services/scheduler.py                                                    176    176     0%   12-574
praxis/backend/services/simulation_service.py                                           135    135     0%   12-516
praxis/backend/services/state.py                                                        124    124     0%   3-274
praxis/backend/services/state_resolution_service.py                                     150    150     0%   16-487
praxis/backend/services/type_definition_base.py                                           6      6     0%   3-14
praxis/backend/services/user.py                                                         116    116     0%   8-337
praxis/backend/services/utils/__init__.py                                                 2      2     0%   3-10
praxis/backend/services/utils/crud_base.py                                              104    104     0%   3-203
praxis/backend/services/utils/plr_type_base.py                                           56     56     0%   3-116
praxis/backend/services/utils/query_builder.py                                           66     66     0%   8-209
praxis/backend/services/well_outputs.py                                                 123    123     0%   8-329
praxis/backend/services/workcell.py                                                      83     83     0%   12-202
praxis/backend/utils/__init__.py                                                          7      0   100%
praxis/backend/utils/accession_resolver.py                                               19     19     0%   6-68
praxis/backend/utils/auth.py                                                             62     62     0%   7-124
praxis/backend/utils/db.py                                                              120     62    48%   35-37, 43, 58-61, 68-92, 100-132, 141-142, 204-211, 219-239, 247-248, 256, 276, 297
praxis/backend/utils/db_decorator.py                                                     34     34     0%   3-76
praxis/backend/utils/errors.py                                                           62     30    52%   19-20, 24, 42-43, 47, 65-66, 70, 88-89, 93, 111-112, 116, 134-135, 139, 158-159, 163, 181-182, 186, 201-202, 223-224, 236, 254
praxis/backend/utils/filesystem.py                                                        4      4     0%   1-9
praxis/backend/utils/logging.py                                                          47     38    19%   12-18, 32-48, 92-111, 155-174
praxis/backend/utils/notify.py                                                           27     13    52%   63-74, 95-96
praxis/backend/utils/plr_inspection.py                                                  207    207     0%   11-716
praxis/backend/utils/plr_static_analysis/__init__.py                                      3      3     0%   15-33
praxis/backend/utils/plr_static_analysis/cache.py                                        68     68     0%   3-172
praxis/backend/utils/plr_static_analysis/capability_config_templates.py                  21     21     0%   8-412
praxis/backend/utils/plr_static_analysis/connection_config_templates.py                  17     17     0%   8-148
praxis/backend/utils/plr_static_analysis/manufacturer_inference.py                       16     16     0%   5-123
praxis/backend/utils/plr_static_analysis/models.py                                      280    280     0%   3-655
praxis/backend/utils/plr_static_analysis/parser.py                                      218    218     0%   3-532
praxis/backend/utils/plr_static_analysis/resource_hierarchy.py                          116    116     0%   12-492
praxis/backend/utils/plr_static_analysis/type_annotation_analyzer.py                    109    109     0%   7-304
praxis/backend/utils/plr_static_analysis/visitors/__init__.py                             6      6     0%   3-16
praxis/backend/utils/plr_static_analysis/visitors/base.py                                56     56     0%   3-135
praxis/backend/utils/plr_static_analysis/visitors/capability_extractor.py               228    228     0%   3-536
praxis/backend/utils/plr_static_analysis/visitors/class_discovery.py                    177    177     0%   3-593
praxis/backend/utils/plr_static_analysis/visitors/computation_graph_extractor.py        244    244     0%   14-673
praxis/backend/utils/plr_static_analysis/visitors/protocol_discovery.py                  91     91     0%   3-262
praxis/backend/utils/plr_static_analysis/visitors/protocol_requirement_extractor.py      86     86     0%   7-298
praxis/backend/utils/plr_static_analysis/visitors/resource_factory.py                   109    109     0%   13-328
praxis/backend/utils/redis_lock.py                                                       21     15    29%   30-49
praxis/backend/utils/run_control.py                                                      38     38     0%   3-90
praxis/backend/utils/sanitation.py                                                      151    132    13%   24-25, 43-54, 68-86, 91-109, 117, 136-142, 152-157, 183-218, 231-234, 248, 252-261, 269-283, 320-349, 366-372
praxis/backend/utils/type_inspection.py                                                  24     24     0%   4-64
praxis/backend/utils/uuid.py                                                              9      3    67%   34, 39-40
praxis/common/__init__.py                                                                 0      0   100%
praxis/common/type_inspection.py                                                        124    124     0%   4-313
praxis/protocol/__init__.py                                                               2      2     0%   6-12
praxis/protocol/protocols/__init__.py                                                     7      7     0%   13-20
praxis/protocol/protocols/kinetic_assay.py                                               55     55     0%   10-204
praxis/protocol/protocols/plate_preparation.py                                           50     50     0%   7-143
praxis/protocol/protocols/plate_reader_assay.py                                          28     28     0%   10-134
praxis/protocol/protocols/selective_transfer.py                                          52     52     0%   8-218
praxis/protocol/protocols/serial_dilution.py                                             30     30     0%   7-134
praxis/protocol/protocols/simple_transfer.py                                             20     20     0%   7-112
-------------------------------------------------------------------------------------------------------------------
TOTAL                                                                                 14702  12933    12%
Coverage HTML written to dir htmlcov
FAIL Required test coverage of 80% not reached. Total coverage: 12.03%
=========================== short test summary info ============================
FAILED tests/models/test_domain/test_asset_reservation.py::test_asset_reservation_orm_creation_minimal
FAILED tests/models/test_domain/test_asset_reservation.py::test_asset_reservation_orm_timing_fields
FAILED tests/models/test_domain/test_asset_reservation.py::test_asset_reservation_orm_relationship_to_protocol_run
FAILED tests/models/test_domain/test_asset_reservation.py::test_asset_reservation_orm_relationship_to_asset
FAILED tests/models/test_domain/test_asset_sqlmodel.py::TestAssetSQLModel::test_asset_creation_defaults
FAILED tests/models/test_domain/test_file_system_protocol_source.py::test_file_system_protocol_source_orm_creation_minimal
FAILED tests/models/test_domain/test_file_system_protocol_source.py::test_file_system_protocol_source_orm_creation_with_all_fields
FAILED tests/models/test_domain/test_file_system_protocol_source.py::test_file_system_protocol_source_orm_status_transitions
FAILED tests/models/test_domain/test_file_system_protocol_source.py::test_file_system_protocol_source_orm_query_by_status
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_creation_minimal
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_creation_with_all_fields
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_persist_to_database
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_sequence_ordering
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_status_values
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_input_args_jsonb
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_return_value_jsonb
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_error_fields
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_nested_calls
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_timing
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_query_by_protocol_run
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_query_by_status
FAILED tests/models/test_domain/test_function_call_log.py::test_function_call_log_orm_repr
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_creation_with_defaults
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_persist_to_database
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_unique_serial_number
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_with_workcell_relationship
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_status_enum_values
FAILED tests/models/test_domain/test_machine.py::test_machine_orm_category_enum_values
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_creation_minimal
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_with_all_fields
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_persist_to_database
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_unique_name_constraint
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_machine_categories
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_jsonb_fields
FAILED tests/models/test_domain/test_machine_definition.py::test_machine_definition_orm_dimensions
FAILED tests/models/test_domain/test_machine_definition.py::TestMachineDefinitionSchemas::test_machine_definition_base_minimal
FAILED tests/models/test_domain/test_machine_definition.py::TestMachineDefinitionSchemas::test_machine_definition_base_with_all_fields
FAILED tests/models/test_domain/test_machine_definition.py::TestMachineDefinitionSchemas::test_machine_definition_update
FAILED tests/models/test_domain/test_machine_definition.py::TestMachineDefinitionSchemas::test_machine_definition_jsonb_validation
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_creation_minimal
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_creation_with_all_fields
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_persist_to_database
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_status_transitions
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_continuation_chain
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_query_by_status
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_query_by_protocol
FAILED tests/models/test_domain/test_protocol_run.py::test_protocol_run_repr
FAILED tests/models/test_domain/test_schedule_history.py::test_schedule_history_orm_event_timing
FAILED tests/models/test_domain/test_schedule_history.py::test_schedule_history_orm_cascade_delete
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_creation_minimal
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_creation_with_all_fields
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_persist_to_database
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_data_type_values
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_spatial_context_values
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_numeric_data
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_json_data
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_text_data
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_binary_data
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_spatial_coordinates_jsonb
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_metadata_jsonb
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_file_path
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_relationship_to_protocol_run
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_relationship_to_function_call_log
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_relationship_to_resource
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_relationship_to_machine
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_query_by_data_type
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_query_by_protocol_run
ERROR tests/models/test_domain/test_function_data_output.py::test_function_data_output_orm_query_by_resource
ERROR tests/models/test_domain/test_well_data_output.py::test_well_data_output_orm_creation_minimal
ERROR tests/models/test_domain/test_well_data_output.py::test_well_data_output_orm_creation_all_fields
ERROR tests/models/test_domain/test_well_data_output.py::test_well_data_output_orm_persistence
ERROR tests/models/test_domain/test_well_data_output.py::test_well_data_output_orm_relationships
=========== 49 failed, 233 passed, 27 warnings, 23 errors in 13.50s ============
