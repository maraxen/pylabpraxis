import{a as l,b as u,c as P}from"./chunk-FGBSBVHW.js";import{a as D,b as y}from"./chunk-SKMC2KSJ.js";import{Ga as f,Zc as g,ha as S,ma as w,v as m}from"./chunk-ZXFVGPYG.js";import{a as c,b as d}from"./chunk-RNQFGQA5.js";var p=class{static discoverHardwareApiV1HardwareDiscoverGet(){return u(l,{method:"GET",url:"/api/v1/hardware/discover"})}static discoverSerialApiV1HardwareDiscoverSerialGet(){return u(l,{method:"GET",url:"/api/v1/hardware/discover/serial"})}static discoverSimulatorsApiV1HardwareDiscoverSimulatorsGet(){return u(l,{method:"GET",url:"/api/v1/hardware/discover/simulators"})}static connectDeviceApiV1HardwareConnectPost(e){return u(l,{method:"POST",url:"/api/v1/hardware/connect",body:e,mediaType:"application/json",errors:{422:"Validation Error"}})}static disconnectDeviceApiV1HardwareDisconnectPost(e){return u(l,{method:"POST",url:"/api/v1/hardware/disconnect",body:e,mediaType:"application/json",errors:{422:"Validation Error"}})}static listConnectionsApiV1HardwareConnectionsGet(){return u(l,{method:"GET",url:"/api/v1/hardware/connections"})}static sendHeartbeatApiV1HardwareHeartbeatPost(e){return u(l,{method:"POST",url:"/api/v1/hardware/heartbeat",body:e,mediaType:"application/json",errors:{422:"Validation Error"}})}static getConnectionApiV1HardwareConnectionsDeviceIdGet(e){return u(l,{method:"GET",url:"/api/v1/hardware/connections/{device_id}",path:{device_id:e},errors:{422:"Validation Error"}})}static registerMachineApiV1HardwareRegisterPost(e){return u(l,{method:"POST",url:"/api/v1/hardware/register",body:e,mediaType:"application/json",errors:{422:"Validation Error"}})}static executeReplCommandApiV1HardwareReplPost(e){return u(l,{method:"POST",url:"/api/v1/hardware/repl",body:e,mediaType:"application/json",errors:{422:"Validation Error"}})}};var b={deck_layout:{type:"string",label:"Deck Layout",required:!1,description:"Custom deck layout file"}},k={"0x08BB:0x0106":{manufacturer:"Hamilton",model:"STAR",plrBackend:"pylabrobot.liquid_handling.backends.hamilton.STAR",configSchema:b},"0x08BB:0x0107":{manufacturer:"Hamilton",model:"Starlet",plrBackend:"pylabrobot.liquid_handling.backends.hamilton.Starlet",configSchema:b},"0x04D8:0xE11A":{manufacturer:"Opentrons",model:"OT-2",plrBackend:"pylabrobot.liquid_handling.backends.opentrons.OT2",configSchema:{simulate:{type:"boolean",label:"Simulation Mode",required:!1,default:!1}}},"0x0856:0xAC11":{manufacturer:"Hamilton",model:"STAR/Starlet (via B&B Adapter)",plrBackend:"pylabrobot.liquid_handling.backends.hamilton.STAR",configSchema:b},"0x0403:0xBB68":{manufacturer:"BMG LABTECH",model:"CLARIOstar",plrBackend:"pylabrobot.plate_reading.clario_star_backend.CLARIOstarBackend"},"0x08AF:0x8000":{manufacturer:"Hamilton",model:"STAR/Starlet (via MCT Adapter)",plrBackend:"pylabrobot.liquid_handling.backends.hamilton.STAR",configSchema:b},"0x1A86:0x7523":{manufacturer:"Generic",model:"USB-Serial (CH340)",plrBackend:""},"0x0403:0x6001":{manufacturer:"FTDI",model:"USB-Serial (FT232)",plrBackend:""},"0x067B:0x2303":{manufacturer:"Prolific",model:"USB-Serial (PL2303)",plrBackend:""}},R=class v{apiWrapper=w(P);discoveredDevices=f([]);isDiscovering=f(!1);webSerialSupported=f(!1);webUsbSupported=f(!1);supportedDevices=g(()=>this.discoveredDevices().filter(e=>e.plrBackend&&e.plrBackend.length>0));unconfiguredDevices=g(()=>this.discoveredDevices().filter(e=>e.status==="requires_config"));connectedDevices=g(()=>this.discoveredDevices().filter(e=>e.status==="connected"));constructor(){this.webSerialSupported.set("serial"in navigator),this.webUsbSupported.set("usb"in navigator)}hasWebSerialSupport(){return"serial"in navigator}hasWebUsbSupport(){return"usb"in navigator}async requestSerialPort(){if(!this.hasWebSerialSupport())return console.warn("WebSerial not supported in this browser"),null;try{let e=await navigator.serial.requestPort(),r=this.createDeviceFromSerialPort(e,`serial-${Date.now()}`);return this.discoveredDevices.update(i=>[...i,r]),r}catch(e){return e.name!=="NotAllowedError"&&console.error("Error requesting serial port:",e),null}}async discoverAllDebug(){if(!this.hasWebSerialSupport()){console.warn("[HardwareDiscovery] WebSerial not supported");return}try{console.log("[HardwareDiscovery] Requesting ALL ports (no filters)...");let e=await navigator.serial.requestPort({filters:[]}),r=e.getInfo();console.log("[HardwareDiscovery] Selected Debug Port:",r);let i=this.createDeviceFromSerialPort(e,`debug-${Date.now()}`);this.discoveredDevices.update(n=>[...n.filter(o=>o.id!==i.id),i])}catch(e){console.error("[HardwareDiscovery] Debug Discovery failed:",e)}}async requestUsbDevice(){if(!this.hasWebUsbSupport())return console.warn("WebUSB not supported in this browser"),null;try{let e=await navigator.usb.requestDevice({filters:[]}),r=this.createDeviceFromUSB(e,`usb-${Date.now()}`);return this.discoveredDevices.update(i=>[...i,r]),r}catch(e){return e.name!=="NotAllowedError"&&console.error("Error requesting USB device:",e),null}}createDeviceFromSerialPort(e,r){let i=e.getInfo(),n=this.formatDeviceKey(i.usbVendorId,i.usbProductId),t=k[n],o=this.inferBackendDefinition(t?.plrBackend),a=o?D.find(h=>h.fqn===o.fqn):void 0,s=!!(t?.configSchema&&Object.keys(t.configSchema).length>0);return{id:r,name:t?.model||o?.name||a?.name||"Serial Device",connectionType:"serial",status:s?"requires_config":"available",port:e,vendorId:i.usbVendorId,productId:i.usbProductId,manufacturer:t?.manufacturer||o?.manufacturer||a?.vendor,productName:t?.model||o?.name||a?.name,plrBackend:t?.plrBackend||o?.fqn||a?.fqn,plrBackendDefinition:o,plrMachineDefinition:a,frontendDefinitionAccessionId:o?.frontend_definition_accession_id,backendDefinitionAccessionId:o?.accession_id,requiresConfiguration:s,configurationSchema:t?.configSchema}}createDeviceFromUSB(e,r){let i=this.formatDeviceKey(e.vendorId,e.productId),n=k[i],t=this.inferBackendDefinition(n?.plrBackend),o=t?D.find(s=>s.fqn===t.fqn):void 0,a=!!(n?.configSchema&&Object.keys(n.configSchema).length>0);return{id:r,name:e.productName||n?.model||t?.name||o?.name||"USB Device",connectionType:"usb",status:a?"requires_config":"available",usbDevice:e,vendorId:e.vendorId,productId:e.productId,manufacturer:e.manufacturerName||n?.manufacturer||t?.manufacturer||o?.vendor,productName:e.productName||n?.model||t?.name||o?.name,serialNumber:e.serialNumber,plrBackend:n?.plrBackend||t?.fqn||o?.fqn,plrBackendDefinition:t,plrMachineDefinition:o,frontendDefinitionAccessionId:t?.frontend_definition_accession_id,backendDefinitionAccessionId:t?.accession_id,requiresConfiguration:a,configurationSchema:n?.configSchema}}formatDeviceKey(e,r){return e===void 0||r===void 0?"":`0x${e.toString(16).toUpperCase().padStart(4,"0")}:0x${r.toString(16).toUpperCase().padStart(4,"0")}`}inferBackendDefinition(e){if(e)return y.find(r=>r.fqn===e)}async getAuthorizedSerialPorts(){if(!this.hasWebSerialSupport())return[];try{return(await navigator.serial.getPorts()).map((r,i)=>this.createDeviceFromSerialPort(r,`serial-authorized-${i}`))}catch(e){return console.error("Error getting authorized serial ports:",e),[]}}async getAuthorizedUsbDevices(){if(!this.hasWebUsbSupport())return[];try{return(await navigator.usb.getDevices()).map((r,i)=>this.createDeviceFromUSB(r,`usb-authorized-${i}`))}catch(e){return console.error("Error getting authorized USB devices:",e),[]}}async discoverAll(){this.isDiscovering.set(!0);let e=[];try{let[r,i,n]=await Promise.all([this.getAuthorizedSerialPorts(),this.getAuthorizedUsbDevices(),this.fetchBackendDevices()]);e.push(...r,...i);for(let t of n)e.some(a=>a.serialNumber===t.serialNumber||a.vendorId===t.vendorId&&a.productId===t.productId)||e.push(t);this.discoveredDevices.set(e)}catch(r){console.error("Error during device discovery:",r)}finally{this.isDiscovering.set(!1)}return e}async fetchBackendDevices(){try{let e=await m(this.apiWrapper.wrap(p.discoverHardwareApiV1HardwareDiscoverGet()));return e?.devices?e.devices.map(r=>{let i=r.plr_backend?y.find(t=>t.fqn===r.plr_backend):void 0,n=r.plr_backend?D.find(t=>t.fqn===r.plr_backend):void 0;return{id:r.id,name:r.name,connectionType:r.connection_type,status:r.status,manufacturer:r.manufacturer??void 0,productName:r.model??void 0,serialNumber:r.serial_number??void 0,plrBackend:r.plr_backend??void 0,plrBackendDefinition:i,plrMachineDefinition:n,frontendDefinitionAccessionId:i?.frontend_definition_accession_id,backendDefinitionAccessionId:i?.accession_id}}):[]}catch(e){return console.warn("Could not fetch devices from backend:",e),[]}}updateDeviceConfiguration(e,r){this.discoveredDevices.update(i=>i.map(n=>n.id!==e?n:d(c({},n),{configuration:r,status:"available"})))}async registerAsMachine(e,r){if(!e.plrBackend)return console.error("Cannot register device without PLR backend"),null;if(e.requiresConfiguration&&!e.configuration)return console.error("Device requires configuration before registration"),null;try{return await m(this.apiWrapper.wrap(p.registerMachineApiV1HardwareRegisterPost({device_id:e.id,name:r||e.name,plr_backend:e.plrBackend,connection_type:e.connectionType,configuration:e.configuration})))}catch(i){return console.error("Error registering device as machine:",i),null}}async openSerialConnection(e,r={baudRate:9600}){if(!e.port)return console.error("No serial port available for device"),!1;try{return await e.port.open(r),this.discoveredDevices.update(i=>i.map(n=>n.id===e.id?d(c({},n),{status:"connected"}):n)),!0}catch(i){return console.error("Error opening serial connection:",i),this.discoveredDevices.update(n=>n.map(t=>t.id===e.id?d(c({},t),{status:"error"}):t)),!1}}async closeSerialConnection(e){if(!e.port)return!1;try{return await e.port.close(),this.discoveredDevices.update(r=>r.map(i=>i.id===e.id?d(c({},i),{status:"available"}):i)),!0}catch(r){return console.error("Error closing serial connection:",r),!1}}removeDevice(e){this.discoveredDevices.update(r=>r.filter(i=>i.id!==e))}clearDeviceError(e){this.discoveredDevices.update(r=>r.map(i=>i.id===e?d(c({},i),{status:"available",errorMessage:void 0}):i))}setDeviceError(e,r){this.discoveredDevices.update(i=>i.map(n=>n.id===e?d(c({},n),{status:"error",errorMessage:r}):n))}isPlrSupported(e){return!!(e.plrBackend&&e.plrBackend.length>0)}async connectViaBackend(e){try{return(await m(this.apiWrapper.wrap(p.connectDeviceApiV1HardwareConnectPost({device_id:e.id,backend_class:e.plrBackend||"",config:c({port:e.port?"webserial":void 0,ip_address:e.ipAddress},e.configuration)})))).status==="connected"?(this.discoveredDevices.update(i=>i.map(n=>n.id===e.id?d(c({},n),{status:"connected",errorMessage:void 0}):n)),!0):!1}catch(r){return console.error("Backend connection failed:",r),this.setDeviceError(e.id,r.message||"Connection failed"),!1}}async disconnectViaBackend(e){try{return await m(this.apiWrapper.wrap(p.disconnectDeviceApiV1HardwareDisconnectPost({device_id:e.id}))),this.discoveredDevices.update(r=>r.map(i=>i.id===e.id?d(c({},i),{status:"available"}):i)),!0}catch(r){return console.error("Backend disconnection failed:",r),!1}}async fetchBackendConnections(){try{let e=await m(this.apiWrapper.wrap(p.listConnectionsApiV1HardwareConnectionsGet()));this.discoveredDevices.update(r=>r.map(i=>{let n=e.find(t=>t.device_id===i.id);return n?d(c({},i),{status:n.status,errorMessage:n.error_message||void 0}):i}))}catch(e){console.debug("Could not fetch backend connections:",e)}}async sendHeartbeat(e){try{return!!(await m(this.apiWrapper.wrap(p.sendHeartbeatApiV1HardwareHeartbeatPost({device_id:e})))).success}catch(r){return console.debug("Heartbeat failed:",r),!1}}openPorts=new Map;async openPort(e,r={}){let i=this.discoveredDevices().find(a=>a.id===e);if(!i?.port)throw new Error(`Port ${e} not found in discovered devices`);if(this.openPorts.has(e)){console.warn(`Port ${e} is already open`);return}let n=r.baudRate||9600;await i.port.open({baudRate:n});let t=i.port.readable?.getReader(),o=i.port.writable?.getWriter();if(!t||!o)throw new Error(`Failed to get reader/writer for port ${e}`);this.openPorts.set(e,{port:i.port,reader:t,writer:o}),this.discoveredDevices.update(a=>a.map(s=>s.id===e?d(c({},s),{status:"connected"}):s)),console.log(`[HardwareDiscovery] Opened port ${e} at ${n} baud`)}async closePort(e){let r=this.openPorts.get(e);if(!r){console.warn(`Port ${e} is not open`);return}try{r.reader.releaseLock(),r.writer.releaseLock(),await r.port.close()}finally{this.openPorts.delete(e),this.discoveredDevices.update(i=>i.map(n=>n.id===e?d(c({},n),{status:"available"}):n))}console.log(`[HardwareDiscovery] Closed port ${e}`)}async writeToPort(e,r){let i=this.openPorts.get(e);if(!i)throw new Error(`Port ${e} is not open`);await i.writer.write(r)}async readFromPort(e,r){let i=this.openPorts.get(e);if(!i)throw new Error(`Port ${e} is not open`);let n=[],t=0;for(;t<r;){let{value:s,done:h}=await i.reader.read();if(h||!s)break;n.push(s),t+=s.length}let o=new Uint8Array(t),a=0;for(let s of n)o.set(s,a),a+=s.length;return o.slice(0,r)}async readLineFromPort(e){let r=this.openPorts.get(e);if(!r)throw new Error(`Port ${e} is not open`);let i=[],n=10;for(;;){let{value:t,done:o}=await r.reader.read();if(o||!t)break;for(let a=0;a<t.length;a++)if(i.push(t[a]),t[a]===n)return new Uint8Array(i)}return new Uint8Array(i)}isPortOpen(e){return this.openPorts.has(e)}static \u0275fac=function(r){return new(r||v)};static \u0275prov=S({token:v,factory:v.\u0275fac,providedIn:"root"})};export{R as a};
