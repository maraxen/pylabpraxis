import inspect
from typing import Any
from unittest.mock import ANY, MagicMock, patch

import pytest  # type: ignore

# Classes to test
from praxis.backend.core.asset_manager import AssetAcquisitionError, AssetManager

# Enums
from praxis.backend.models.enums.asset import AssetType
from praxis.backend.models.enums.machine import MachineStatusEnum
from praxis.backend.models.enums.resource import ResourceCategoryEnum, ResourceStatusEnum
from praxis.backend.models.orm import (
    DeckDefinitionOrm,
    DeckPositionDefinitionOrm,
    MachineOrm,
    ResourceDefinitionOrm,
    ResourceOrm,
)
# Dependent ORM-like Mocks
ManagedDeviceOrmMock = MagicMock
ResourceOrmMock = MagicMock
ResourceDefinitionOrmMock = MagicMock
AssetRequirementModelMock = MagicMock


# --- Mock PyLabRobot Base Classes for sync_pylabrobot_definitions tests ---
class MockResource:
  resource_type: str | None = None

  def __init__(self, name: str, **kwargs: Any) -> None:
    self.name = name
    self.model: str | None = kwargs.get("model")
    self.category_str: str | None = kwargs.get("category_str")
    self.size_x: float | None = kwargs.get("size_x")
    self.size_y: float | None = kwargs.get("size_y")
    self.size_z: float | None = kwargs.get("size_z")
    self.capacity: float | None = kwargs.get("capacity")
    self._dimensions: Any | None = kwargs.get("dimensions_obj")
    self._wells_data: list[Any] = kwargs.get("wells_data", [])
    self.__class__.__module__ = "pylabrobot.resources.mocked"

  def serialize(self) -> dict[str, Any]:
    return {
      "name": self.name,
      "model": self.model,
      "category": self.category_str or "mock_resource_category",
    }

  def get_size_x(self) -> float | None:
    return self.size_x

  def get_size_y(self) -> float | None:
    return self.size_y

  def get_size_z(self) -> float | None:
    return self.size_z

  @property
  def dimensions(self) -> Any | None:
    return self._dimensions

  def get_well(self, index: int) -> Any:
    if not self._wells_data or index >= len(self._wells_data):
      mock_well = MagicMock(spec=MockPlrWell)
      mock_well.max_volume = (
        (self.capacity / len(self._wells_data)) if self._wells_data and self.capacity else 0
      )
      return mock_well
    return self._wells_data[index]

  @property
  def wells(self) -> list[Any]:
    return self._wells_data


class MockPlrContainer(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.container"


class MockPlrPlate(MockPlrContainer):
  resource_type = "plate_type_class_level"

  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.plate"


class MockPlrTipRack(MockResource):
  resource_type = "tip_rack_type_class_level"

  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.tip_rack"


class MockPlrWell(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.well"


class MockDeck(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.deck"


class MockPlrLid(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.lid"


class MockPlrReservoir(MockPlrContainer):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.reservoir"


class MockPlrTubeRack(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.tube_rack"


class MockPlrTube(MockPlrContainer):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.tube"


class MockPlrPetriDish(MockPlrContainer):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.petri_dish"


class MockTrash(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.trash"


class MockCarrier(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.carrier"


class MockPlateCarrier(MockCarrier):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.plate_carrier"


class MockTipCarrier(MockCarrier):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.tip_carrier"


class MockPlateAdapter(MockCarrier):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.plate_adapter"


class MockItemizedResource(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.itemized_resource"


class MockPlrTip(MockResource):
  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.__class__.__module__ = "pylabrobot.resources.tip"


class MockCoordinate(MagicMock):
  pass


# --- New/Simpler Mock PyLabRobot Base Classes for specific sync tests ---
class SomeNonSimpleType:  # For complex constructor testing
  pass


class MockBaseResource:  # Simplified base for these tests
  # Class attributes to be potentially used if instantiation fails or is skipped
  model: str | None = "BaseClassModel"
  resource_type: str | None = "base_class_resource"
  # For _get_category_from_class_name
  __name__ = "MockBaseResource"

  def __init__(self, name: str, **kwargs: Any) -> None:
    self.name = name
    #  attributes override class attributes if instance is created
    self.model = kwargs.get("model", self.model)
    self.resource_type = kwargs.get("resource_type", self.resource_type)
    self.__class__.__module__ = kwargs.get("module_name", "pylabrobot.resources.mock_sync_tests")
    # Ensure __name__ is set on the instance's class for inspect.getdoc
    self.__class__.__name__ = self.__class__.__name__

  def serialize(self) -> dict[str, Any]:
    # Basic serialization, subclasses should extend
    return {"name": self.name, "model": self.model, "resource_type": self.resource_type}


class MockBaseItemizedResource(MockBaseResource):
  # Class attributes
  __name__ = "MockBaseItemizedResource"

  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.items: list[Any] = kwargs.get("items", [])
    self.wells: list[Any] = kwargs.get("wells", [])
    # Ensure __name__ is set on the instance's class
    self.__class__.__name__ = self.__class__.__name__


# Test-specific mock classes
class MockResourceSimple(MockBaseResource):
  # Override class attributes if needed, or rely on MockBaseResource
  model = "SimpleModel"  # Class attribute
  resource_type = "simple_resource"  # Class attribute
  __name__ = "MockResourceSimple"

  def __init__(self, name: str, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    #  attributes
    self.size_x: float = 10.0
    self.size_y: float = 20.0
    self.size_z: float = 30.0
    self.capacity: float = 100.0
    self.__class__.__module__ = "pylabrobot.resources.mock_simple"
    self.__class__.__name__ = "MockResourceSimple"

  def serialize(self) -> dict[str, Any]:
    data = super().serialize()
    data.update(
      {
        "size_x": self.size_x,
        "size_y": self.size_y,
        "size_z": self.size_z,
        "capacity": self.capacity,
      },
    )
    return data


class MockResourceItemized(MockBaseItemizedResource):
  model = "ItemizedModel"
  resource_type = "itemized_resource"
  __name__ = "MockResourceItemized"

  def __init__(self, name: str, num_items_init: int = 5, **kwargs: Any) -> None:
    super().__init__(name, **kwargs)
    self.num_items = num_items_init  # Direct attribute for num_items extraction
    self.wells = [MagicMock(name=f"W{i + 1}") for i in range(num_items_init)]
    self.__class__.__module__ = "pylabrobot.resources.mock_itemized"
    self.__class__.__name__ = "MockResourceItemized"

  def serialize(self) -> dict[str, Any]:
    data = super().serialize()
    data.update(
      {
        "num_items": self.num_items,
        "wells_data": [{"name": w.name} for w in self.wells],  # Simulate serialized well data
      },
    )
    return data


class MockResourceComplexConstructor(MockBaseResource):
  model = "ComplexModel"  # Class attribute
  resource_type = "complex_resource"  # Class attribute
  class_volume = 50.0  # Class attribute for testing fallback
  __name__ = "MockResourceComplexConstructor"

  def __init__(
    self, name: str, required_object: SomeNonSimpleType, optional_int: int = 0, **kwargs: Any,
  ) -> None:
    super().__init__(name, **kwargs)
    self.required_object = required_object
    self.optional_int = optional_int
    self.__class__.__module__ = "pylabrobot.resources.mock_complex"
    self.__class__.__name__ = "MockResourceComplexConstructor"
    # No serialize method, as it shouldn't be called if instantiation is skipped.


class MockResourceInstantiationFails(MockBaseResource):
  model = "FailModel"  # Class attribute
  resource_type = "fail_resource"  # Class attribute
  class_size_x = 5.0  # Class attribute for testing fallback
  __name__ = "MockResourceInstantiationFails"

  def __init__(self, name: str, **kwargs: Any) -> None:
    # super().__init__(name, **kwargs) # Don't call super if init itself fails
    self.__class__.__module__ = "pylabrobot.resources.mock_fails"
    self.__class__.__name__ = "MockResourceInstantiationFails"
    msg = "Cannot instantiate this"
    raise ValueError(msg)

  # No serialize method as it won't be instantiated.


# --- End New/Simpler Mock PyLabRobot Base Classes ---
# --- End Mock PyLabRobot Base Classes ---


# Helper function for mocking module discovery
def setup_mock_modules(
  mock_walk_packages_target,
  mock_import_module_target,
  mock_getmembers_target,
  resource_classes_to_discover,
) -> None:
  """Configures mocks for pkgutil.walk_packages, importlib.import_module, and inspect.getmembers
  to simulate the discovery of specified resource_classes.
  """
  discovered_modules_info = {}  # Stores {module_name: (mock_module_obj, list_of_members)}

  for r_class in resource_classes_to_discover:
    module_name = r_class.__module__
    class_name = r_class.__name__

    if module_name not in discovered_modules_info:
      mock_module = MagicMock()
      mock_module.__name__ = module_name
      # Attach the class to the mock module object directly
      setattr(mock_module, class_name, r_class)
      discovered_modules_info[module_name] = (mock_module, [])

    # Ensure the class is also in the list of members for getmembers
    # and re-set it on the module object in case the module was already created
    current_module_obj, members_list = discovered_modules_info[module_name]
    if not hasattr(
      current_module_obj, class_name,
    ):  # Avoid duplicate setattr if module processed multiple times
      setattr(current_module_obj, class_name, r_class)

    # Avoid adding duplicate (name, class) tuples to members_list
    if not any(m[0] == class_name for m in members_list):
      members_list.append((class_name, r_class))

  mock_walk_packages_target.return_value = [(None, name, False) for name in discovered_modules_info]

  def import_module_side_effect(name_import):
    if name_import in discovered_modules_info:
      return discovered_modules_info[name_import][0]
    # Fallback for other imports if AssetManager tries to import something else from pylabrobot.resources
    if name_import.startswith("pylabrobot.resources"):
      # print(f"DEBUG_IMPORT_HELPER: Mock importing {name_import} as new MagicMock")
      return MagicMock(__name__=name_import)  # Return a generic mock for other PLR modules
    msg = f"No mock for module {name_import} in setup_mock_modules"
    raise ImportError(msg)

  mock_import_module_target.side_effect = import_module_side_effect

  def getmembers_side_effect(module_obj, predicate=None):  # Added predicate
    # predicate is often inspect.isclass, ensure it works with our mocks
    module_name_lookup = getattr(module_obj, "__name__", None)
    if module_name_lookup in discovered_modules_info:
      # print(f"DEBUG_GETMEMBERS_HELPER: Returning members for {module_name_lookup}: "
      #       f"{discovered_modules_info[module_name_lookup][1]}")
      # Filter by predicate if provided, as inspect.getmembers does
      if predicate:
        return [
          (name, member)
          for name, member in discovered_modules_info[module_name_lookup][1]
          if predicate(member)
        ]
      return discovered_modules_info[module_name_lookup][1]
    # print(f"DEBUG_GETMEMBERS_HELPER: No members for {module_name_lookup}")
    return []

  mock_getmembers_target.side_effect = getmembers_side_effect


@pytest.fixture
def mock_db_session():
  return MagicMock()


@pytest.fixture
def mock_workcell_runtime():
  m = MagicMock()
  m.initialize_machine_backend.return_value = MagicMock(name="live_mock_machine")
  m.create_or_get_resource_plr_object.return_value = MagicMock(name="live_mock_resource")
  return m


from praxis.backend.services.deck import DeckService
from praxis.backend.services.machine import MachineService
from praxis.backend.services.resource import ResourceService
from praxis.backend.services.resource_type_definition import ResourceTypeDefinitionService
from praxis.backend.core.protocols.asset_lock_manager import IAssetLockManager

@pytest.fixture
def mock_deck_service():
    return MagicMock(spec=DeckService)

@pytest.fixture
def mock_machine_service():
    return MagicMock(spec=MachineService)

@pytest.fixture
def mock_resource_service():
    return MagicMock(spec=ResourceService)

@pytest.fixture
def mock_resource_type_definition_service():
    return MagicMock(spec=ResourceTypeDefinitionService)

@pytest.fixture
def mock_asset_lock_manager():
    return MagicMock(spec=IAssetLockManager)

@pytest.fixture
def asset_manager(
  mock_db_session: MagicMock,
  mock_workcell_runtime: MagicMock,
  mock_deck_service: MagicMock,
  mock_machine_service: MagicMock,
  mock_resource_service: MagicMock,
  mock_resource_type_definition_service: MagicMock,
  mock_asset_lock_manager: MagicMock,
):
  return AssetManager(
      db_session=mock_db_session,
      workcell_runtime=mock_workcell_runtime,
      deck_service=mock_deck_service,
      machine_service=mock_machine_service,
      resource_service=mock_resource_service,
      resource_type_definition_service=mock_resource_type_definition_service,
      asset_lock_manager=mock_asset_lock_manager,
  )


class TestAssetManagerAcquireDevice:
  @pytest.mark.asyncio
  async def test_acquire_machine_success(
    self,
    asset_manager: AssetManager,
    mock_machine_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1", fqn="SomeDeviceClass")
    mock_machine_service.get_multi.side_effect = [
      [],  # No machines in use by this run
      [mock_machine_orm],  # One available machine
    ]
    updated_mock_machine_orm = ManagedDeviceOrmMock(
      id=1,
      name="Device1",
      status=MachineStatusEnum.IN_USE,
    )
    mock_machine_service.update_machine_status.return_value = updated_mock_machine_orm

    live_machine, orm_accession_id, dev_type = await asset_manager.acquire_machine(
      protocol_run_accession_id=uuid.uuid4(),
      requested_asset_name_in_protocol="dev_in_proto",
      fqn_constraint="SomeDeviceClass",
    )

    assert mock_machine_service.get_multi.call_count == 2
    mock_workcell_runtime.initialize_machine.assert_called_once_with(mock_machine_orm)
    mock_machine_service.update_machine_status.assert_called_once_with(
      asset_manager.db,
      1,
      MachineStatusEnum.IN_USE,
      current_protocol_run_accession_id=ANY,
      status_details=ANY,
    )
    assert live_machine is mock_workcell_runtime.initialize_machine.return_value
    assert orm_accession_id == 1
    assert dev_type == "machine"

  @pytest.mark.asyncio
  async def test_acquire_machine_no_machine_found(
    self, asset_manager: AssetManager, mock_machine_service: MagicMock
  ) -> None:
    mock_machine_service.get_multi.return_value = []
    with pytest.raises(
      AssetAcquisitionError,
      match="No machine found for FQN 'SomeDeviceClass'",
    ):
      await asset_manager.acquire_machine(uuid.uuid4(), "dev", "SomeDeviceClass")

  @pytest.mark.asyncio
  async def test_acquire_machine_backend_init_fails(
    self,
    asset_manager: AssetManager,
    mock_machine_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1")
    mock_machine_service.get_multi.return_value = [mock_machine_orm]
    mock_workcell_runtime.initialize_machine.return_value = None

    with pytest.raises(
      AssetAcquisitionError, match="Failed to initialize backend for machine 'Device1'"
    ):
      await asset_manager.acquire_machine(uuid.uuid4(), "dev", "SomeDeviceClass")

  @pytest.mark.asyncio
  async def test_acquire_machine_db_status_update_fails_after_init(
    self,
    asset_manager: AssetManager,
    mock_machine_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_machine_orm = ManagedDeviceOrmMock(id=1, name="Device1")
    mock_machine_service.get_multi.return_value = [mock_machine_orm]
    mock_machine_service.update_machine_status.return_value = None

    with pytest.raises(
      AssetAcquisitionError,
      match="CRITICAL: Failed to update DB status for machine 'Device1'",
    ):
      await asset_manager.acquire_machine(uuid.uuid4(), "dev", "SomeDeviceClass")


from praxis.backend.models.pydantic_internals.asset import AcquireAsset
import uuid

class TestAssetManagerAcquireResource:
  @pytest.fixture
  def mock_resource_def(self):
    mock_def = ResourceDefinitionOrmMock()
    mock_def.fqn = "pylabrobot.resources.plate.Plate"
    return mock_def

  @pytest.mark.asyncio
  async def test_acquire_resource_success_from_storage(
    self,
    asset_manager: AssetManager,
    mock_resource_service: MagicMock,
    mock_resource_type_definition_service: MagicMock,
    mock_workcell_runtime: MagicMock,
    mock_resource_def: MagicMock,
  ) -> None:
    mock_lw_orm = ResourceOrmMock(
      accession_id=1, name="Plate1", fqn="some_plate_def_name",
    )
    mock_resource_service.get_multi.side_effect = [
        [],  # in use
        [],  # on deck
        [mock_lw_orm]  # in storage
    ]
    mock_resource_type_definition_service.get_by_name.return_value = mock_resource_def
    updated_mock_lw_orm = ResourceOrmMock(accession_id=1, name="Plate1", status=ResourceStatusEnum.IN_USE)
    mock_resource_service.update.return_value = updated_mock_lw_orm

    acquire_data = AcquireAsset(
        protocol_run_accession_id=uuid.uuid4(),
        requested_asset_name_in_protocol="lw_in_proto",
        fqn="some_plate_def_name",
    )

    live_resource, orm_accession_id, lw_type = await asset_manager.acquire_resource(
      resource_data=acquire_data
    )

    assert mock_resource_service.get_multi.call_count == 3
    mock_resource_type_definition_service.get_by_name.assert_called_once_with(
      asset_manager.db, name="some_plate_def_name"
    )
    mock_workcell_runtime.create_or_get_resource.assert_called_once_with(
      resource_orm=mock_lw_orm,
      resource_definition_fqn="pylabrobot.resources.plate.Plate",
    )
    mock_resource_service.update.assert_called_with(
      db=asset_manager.db,
      db_obj=mock_lw_orm,
      obj_in=ANY,
    )
    assert live_resource is mock_workcell_runtime.create_or_get_resource.return_value
    assert orm_accession_id == 1
    assert lw_type == "resource"

  @pytest.mark.asyncio
  async def test_acquire_resource_with_deck_assignment(
    self,
    asset_manager: AssetManager,
    mock_resource_service: MagicMock,
    mock_resource_type_definition_service: MagicMock,
    mock_workcell_runtime: MagicMock,
    mock_resource_def: MagicMock,
  ) -> None:
    mock_lw_orm = ResourceOrmMock(
      accession_id=1, name="Plate1", fqn="some_plate_def_name",
    )
    mock_deck_orm = ResourceOrmMock(accession_id=10, name="MainDeck", fqn="pylabrobot.resources.deck.Deck")

    mock_resource_service.get_multi.return_value = [mock_lw_orm]
    mock_resource_type_definition_service.get_by_name.side_effect = [
        mock_resource_def, # for the resource
        MagicMock(fqn="pylabrobot.resources.deck.Deck", plr_category="Deck") # for the deck
    ]
    mock_resource_service.get_by_name.return_value = mock_deck_orm
    mock_resource_service.update.return_value = mock_lw_orm

    location_constraints = {"deck_name": "MainDeck", "position_name": "A1"}
    acquire_data = AcquireAsset(
        protocol_run_accession_id=uuid.uuid4(),
        requested_asset_name_in_protocol="plate_on_deck",
        fqn="some_plate_def_name",
        location_constraints=location_constraints,
    )

    with patch("importlib.import_module") as mock_import:
        mock_module = MagicMock()
        mock_module.Deck = Deck
        mock_import.return_value = mock_module
        await asset_manager.acquire_resource(
          resource_data=acquire_data,
        )

    mock_resource_service.get_by_name.assert_called_once_with(
      asset_manager.db,
      name="MainDeck",
    )
    mock_workcell_runtime.assign_resource_to_deck.assert_called_once_with(
      resource_orm_accession_id=mock_lw_orm.accession_id,
      target=mock_deck_orm.accession_id,
      position_accession_id="A1",
    )
    mock_resource_service.update.assert_called_with(
      db=asset_manager.db,
      db_obj=mock_lw_orm,
      obj_in=ANY,
    )

  @pytest.mark.asyncio
  async def test_acquire_resource_fqn_not_found(
    self, asset_manager: AssetManager, mock_resource_service: MagicMock, mock_resource_type_definition_service: MagicMock
  ) -> None:
    mock_lw_orm = ResourceOrmMock(accession_id=1, fqn="unknown_def_name")
    mock_resource_service.get_multi.return_value = [mock_lw_orm]
    mock_resource_type_definition_service.get_by_name.return_value = None

    acquire_data = AcquireAsset(
        protocol_run_accession_id=uuid.uuid4(),
        requested_asset_name_in_protocol="lw_in_proto",
        fqn="unknown_def_name"
    )

    with pytest.raises(
      AssetAcquisitionError,
      match="FQN not found for resource definition 'unknown_def_name'",
    ):
      await asset_manager.acquire_resource(acquire_data)

    mock_resource_service.update.assert_called_once_with(
      db=asset_manager.db,
      db_obj=mock_lw_orm,
      obj_in=ANY,
    )

  @pytest.mark.asyncio
  async def test_acquire_resource_plr_object_creation_fails(
    self,
    asset_manager: AssetManager,
    mock_resource_service: MagicMock,
    mock_resource_type_definition_service: MagicMock,
    mock_workcell_runtime: MagicMock,
    mock_resource_def: MagicMock,
  ) -> None:
    mock_lw_orm = ResourceOrmMock(accession_id=1, name="Plate1", fqn="def")
    mock_resource_service.get_multi.return_value = [mock_lw_orm]
    mock_resource_type_definition_service.get_by_name.return_value = mock_resource_def
    mock_workcell_runtime.create_or_get_resource.return_value = None

    acquire_data = AcquireAsset(
        protocol_run_accession_id=uuid.uuid4(),
        requested_asset_name_in_protocol="lw",
        fqn="def"
    )
    with pytest.raises(
      AssetAcquisitionError, match="Failed to create/get PLR object for 'Plate1'",
    ):
      await asset_manager.acquire_resource(acquire_data)


class TestAssetManagerRelease:
  @pytest.mark.asyncio
  async def test_release_machine(
    self,
    asset_manager: AssetManager,
    mock_machine_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_machine_orm = ManagedDeviceOrmMock(id=1, fqn="some.fqn")
    mock_machine_service.get.return_value = mock_machine_orm

    await asset_manager.release_machine(
      machine_orm_accession_id=1, final_status=MachineStatusEnum.AVAILABLE,
    )

    mock_workcell_runtime.shutdown_machine.assert_called_once_with(1)
    mock_machine_service.get.assert_called_once_with(asset_manager.db, 1)
    mock_machine_service.update_machine_status.assert_called_with(
      asset_manager.db,
      1,
      MachineStatusEnum.AVAILABLE,
      status_details="Released from run",
      current_protocol_run_accession_id=None,
    )

  @pytest.mark.asyncio
  async def test_release_resource_no_deck_clear(
    self,
    asset_manager: AssetManager,
    mock_resource_service: MagicMock,
    mock_resource_type_definition_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_resource_orm = ResourceOrmMock(accession_id=1, name="Plate1", fqn="pylabrobot.resources.plate.Plate")
    mock_resource_service.get.return_value = mock_resource_orm
    mock_resource_type_definition_service.get_by_name.return_value = MagicMock(fqn="pylabrobot.resources.plate.Plate")

    await asset_manager.release_resource(
      resource_orm_accession_id=1,
      final_status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
      status_details="Stored after run",
    )
    mock_workcell_runtime.clear_deck_position.assert_not_called()
    mock_workcell_runtime.clear_resource.assert_called_once_with(1)
    mock_resource_service.update.assert_called_once_with(
      db=asset_manager.db,
      db_obj=mock_resource_orm,
      obj_in=ANY,
    )

  @pytest.mark.asyncio
  async def test_release_resource_with_deck_clear(
    self,
    asset_manager: AssetManager,
    mock_resource_service: MagicMock,
    mock_resource_type_definition_service: MagicMock,
    mock_workcell_runtime: MagicMock,
  ) -> None:
    mock_resource_orm = ResourceOrmMock(accession_id=1, name="Plate1", fqn="pylabrobot.resources.plate.Plate")
    mock_resource_service.get.return_value = mock_resource_orm
    mock_resource_type_definition_service.get_by_name.return_value = MagicMock(fqn="pylabrobot.resources.plate.Plate")

    await asset_manager.release_resource(
      resource_orm_accession_id=1,
      final_status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
      clear_from_accession_id=10,
      clear_from_position_name="A1",
      status_details="Cleared from deck and stored",
    )
    mock_workcell_runtime.clear_deck_position.assert_called_once_with(
      deck_orm_accession_id=10,
      position_name="A1",
      resource_orm_accession_id=1,
    )
    mock_resource_service.update.assert_called_once_with(
      db=asset_manager.db,
      db_obj=mock_resource_orm,
      obj_in=ANY,
    )


class TestAssetManagerSyncPylabrobotDefinitions:
  @pytest.fixture(autouse=True)
  def patch_dependencies(self, mock_ads_service: MagicMock, monkeypatch: pytest.MonkeyPatch) -> None:
    self.mock_ads_service = mock_ads_service

    self.mock_walk_packages = MagicMock()
    self.mock_import_module = MagicMock()
    self.mock_getmembers = MagicMock()
    self.mock_isabstract_inspect = MagicMock()
    self.mock_isclass_inspect = MagicMock()
    self.mock_issubclass_inspect = MagicMock()
    self.mock_get_constructor_params = MagicMock()  # Mock for get_resource_constructor_params

    # Patch targets for the helper function
    self.mock_walk_packages_target = MagicMock(name="walk_packages_target_in_fixture")
    self.mock_import_module_target = MagicMock(name="import_module_target_in_fixture")
    self.mock_getmembers_target = MagicMock(name="getmembers_target_in_fixture")

    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.pkgutil.walk_packages", self.mock_walk_packages_target,
    )
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.importlib.import_module", self.mock_import_module_target,
    )
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.inspect.getmembers",
      self.mock_getmembers_target,
    )  # Patched here

    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.inspect.isabstract", self.mock_isabstract_inspect,
    )
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.inspect.isclass", self.mock_isclass_inspect,
    )
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.issubclass", self.mock_issubclass_inspect,
    )
    # Patch for the constructor param utility
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.get_resource_constructor_params",
      self.mock_get_constructor_params,
    )

    # Keep existing PLR base class mocks as they might be used by other tests
    # The new simple mocks are additive for the new tests.
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.Resource", MockResource,
    )  # Original detailed mock
    monkeypatch.setattr(
      "praxis.backend.core.asset_manager.Container", MockPlrContainer,
    )  # Original detailed mock
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrPlate", MockPlrPlate)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrTipRack", MockPlrTipRack)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Well", MockPlrWell)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Deck", MockDeck)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Lid", MockPlrLid)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrReservoir", MockPlrReservoir)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrTubeRack", MockPlrTubeRack)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrTube", MockPlrTube)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrPetriDish", MockPlrPetriDish)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Trash", MockTrash)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlateCarrier", MockPlateCarrier)
    monkeypatch.setattr("praxis.backend.core.asset_manager.TipCarrier", MockTipCarrier)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlateAdapter", MockPlateAdapter)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Carrier", MockCarrier)
    monkeypatch.setattr("praxis.backend.core.asset_manager.ItemizedResource", MockItemizedResource)
    monkeypatch.setattr("praxis.backend.core.asset_manager.PlrTip", MockPlrTip)
    monkeypatch.setattr("praxis.backend.core.asset_manager.Coordinate", MockCoordinate)

    self.mock_isclass_inspect.side_effect = lambda obj: isinstance(obj, type)

    def _mock_issubclass(obj, base):
      if not isinstance(obj, type):
        return False
      if not inspect.isclass(base):
        return False
      return issubclass(obj, base)

    self.mock_issubclass_inspect.side_effect = _mock_issubclass

  def test_sync_simple_instantiable_resource(self, asset_manager: AssetManager, caplog) -> None:
    class MockSimplePlateDef(MockPlrPlate):
      resource_type = "simple_plate_type_inst"

      def __init__(
        self,
        name: str,
        model: str | None = "TestModel123",
        size_x: float | None = 120.0,
        capacity: float | None = 100.0,
      ) -> None:
        super().__init__(name, model=model, size_x=size_x, capacity=capacity)
        self.model = model
        self.size_x = size_x
        self.capacity = capacity
        self.__class__.__module__ = "mock_pylabrobot_module.plates"

      def serialize(self) -> dict[str, Any]:
        return {
          "custom_field": "value",
          "name": self.name,
          "model": self.model,
          "category_str": "plate",
        }

    mock_module = MagicMock()
    mock_module.MockSimplePlateToSync = MockSimplePlateDef

    self.mock_walk_packages.return_value = [(None, "mock_pylabrobot_module.plates", False)]
    self.mock_import_module.return_value = mock_module
    self.mock_getmembers.return_value = [("MockSimplePlateToSync", MockSimplePlateDef)]
    self.mock_isabstract_inspect.return_value = False
    self.mock_get_constructor_params.return_value = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
      "model": {"type": "Optional[str]", "required": False, "default": "TestModel123"},
      "size_x": {"type": "Optional[float]", "required": False, "default": 120.0},
      "capacity": {"type": "Optional[float]", "required": False, "default": 100.0},
    }
    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions(
      plr_resources_package=MagicMock(__path__=["dummy"], __name__="mock_plr_pkg"),
    )

    assert added == 1
    assert updated == 0
    self.mock_ads_service.add_or_update_resource_definition.assert_called_once()
    call_args = self.mock_ads_service.add_or_update_resource_definition.call_args[1]

    assert call_args["fqn"] == "mock_pylabrobot_module.plates.MockSimplePlateToSync"
    assert call_args["name"] == "simple_plate_type_inst"
    assert call_args["resource_type"] == "TestModel123"
    assert call_args["category"] == ResourceCategoryEnum.PLATE
    assert call_args["model"] == "TestModel123"
    assert call_args["size_x_mm"] == 120.0
    assert call_args["nominal_volume_ul"] == 100.0
    assert call_args["plr_definition_details_json"] == {
      "custom_field": "value",
      "name": ANY,
      "model": "TestModel123",
      "category_str": "plate",
    }
    assert call_args["is_consumable"] is True
    assert "MockSimplePlateToSync" in call_args["description"]

  def test_sync_complex_constructor_fallback_to_class_data(
    self, asset_manager: AssetManager, caplog,
  ) -> None:
    class MockComplexResource(MockResource):

      """Description for complex resource."""

      resource_type = "complex_static_type"
      model = "ClassLevelModel"

      def __init__(self, name: str, backend: Any, another_required: int) -> None:
        super().__init__(name)
        self.backend = backend
        self.another_required = another_required
        self.__class__.__module__ = "mock_module.complex"

    mock_module = MagicMock()
    mock_module.MockComplexResource = MockComplexResource

    self.mock_walk_packages.return_value = [(None, "mock_module.complex", False)]
    self.mock_import_module.return_value = mock_module
    self.mock_getmembers.return_value = [("MockComplexResource", MockComplexResource)]
    self.mock_isabstract_inspect.return_value = False
    self.mock_get_constructor_params.return_value = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
      "backend": {"type": "SomeBackendClass", "required": True, "default": inspect.Parameter.empty},
      "another_required": {"type": "int", "required": True, "default": inspect.Parameter.empty},
    }
    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions(
      plr_resources_package=MagicMock(__path__=["dummy"], __name__="mock_plr_pkg"),
    )

    assert added == 1
    assert updated == 0
    self.mock_ads_service.add_or_update_resource_definition.assert_called_once()
    call_args = self.mock_ads_service.add_or_update_resource_definition.call_args[1]

    assert call_args["fqn"] == "mock_module.complex.MockComplexResource"
    assert call_args["name"] == "complex_static_type"
    assert call_args["description"] == "Description for complex resource"
    assert call_args["category"] == ResourceCategoryEnum.OTHER
    assert call_args["model"] is None
    assert call_args["size_x_mm"] is None
    assert call_args["nominal_volume_ul"] is None
    assert call_args["plr_definition_details_json"] is None
    assert (
      "Skipping instantiation for mock_module.complex.MockComplexResource due to complex required parameter "
      "'backend'"
    ) in caplog.text

  def test_sync_instantiation_failure_fallback_to_class_data(
    self, asset_manager: AssetManager, caplog,
  ) -> None:
    class MockFailingResource(MockResource):

      """Description for failing resource."""

      resource_type = "failing_static_type"
      model = "FailingClassModel"

      def __init__(self, name: str) -> None:
        super().__init__(name)
        self.__class__.__module__ = "mock_module.failing"
        msg = "Test instantiation failure"
        raise TypeError(msg)

    mock_module = MagicMock()
    mock_module.MockFailingResource = MockFailingResource

    self.mock_walk_packages.return_value = [(None, "mock_module.failing", False)]
    self.mock_import_module.return_value = mock_module
    self.mock_getmembers.return_value = [("MockFailingResource", MockFailingResource)]
    self.mock_isabstract_inspect.return_value = False
    self.mock_get_constructor_params.return_value = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
    }
    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions(
      plr_resources_package=MagicMock(__path__=["dummy"], __name__="mock_plr_pkg"),
    )

    assert added == 1
    assert updated == 0
    self.mock_ads_service.add_or_update_resource_definition.assert_called_once()
    call_args = self.mock_ads_service.add_or_update_resource_definition.call_args[1]

    assert call_args["fqn"] == "mock_module.failing.MockFailingResource"
    assert call_args["name"] == "failing_static_type"
    assert call_args["description"] == "Description for failing resource"
    assert call_args["category"] == ResourceCategoryEnum.OTHER
    assert call_args["model"] is None
    assert call_args["size_x_mm"] is None
    assert call_args["nominal_volume_ul"] is None
    assert call_args["plr_definition_details_json"] is None
    assert (
      "WARNING: Instantiation of mock_module.failing.MockFailingResource failed even with smart defaults: "
      "Test instantiation failure"
    ) in caplog.text

  def test_sync_filters_excluded_classes(self, asset_manager: AssetManager, monkeypatch) -> None:
    class MockExcludedByName(MockResource):
      resource_type = "excluded_by_name_type"
      __module__ = "mock_module.excluded"

    class MockExcludedByBase(MockDeck):
      resource_type = "excluded_by_base_type"
      __module__ = "mock_module.excluded"

    class MockAbstractResource(MockPlrPlate):
      resource_type = "abstract_type"
      __module__ = "mock_module.excluded"

    class NonResource:
      __module__ = "mock_module.excluded"

    class KeptResource(MockPlrPlate):
      resource_type = "kept_resource_type"
      model = "KeptModel"
      __module__ = "mock_module.kept"

      def __init__(self, name, model="KeptModel") -> None:
        super().__init__(name, model=model)

    original_excluded_names = asset_manager.EXCLUDED_CLASS_NAMES.copy()
    monkeypatch.setattr(
      asset_manager, "EXCLUDED_CLASS_NAMES", original_excluded_names | {"MockExcludedByName"},
    )

    mock_module_excluded = MagicMock()
    mock_module_excluded.MockExcludedByName = MockExcludedByName
    mock_module_excluded.MockExcludedByBase = MockExcludedByBase
    mock_module_excluded.MockAbstractResource = MockAbstractResource
    mock_module_excluded.NonResource = NonResource

    mock_module_kept = MagicMock()
    mock_module_kept.KeptResource = KeptResource

    self.mock_walk_packages.return_value = [
      (None, "mock_module.excluded", False),
      (None, "mock_module.kept", False),
    ]

    def import_module_side_effect(name):
      if name == "mock_module.excluded":
        return mock_module_excluded
      if name == "mock_module.kept":
        return mock_module_kept
      raise ImportError

    self.mock_import_module.side_effect = import_module_side_effect

    def getmembers_side_effect(module_obj, pred):
      # Make sure the predicate is also called with the mock objects
      # This is essential for issubclass and isclass to work correctly with our mocks
      if module_obj == mock_module_excluded:
        return [
          ("MockExcludedByName", MockExcludedByName),
          ("MockExcludedByBase", MockExcludedByBase),
          ("MockAbstractResource", MockAbstractResource),
          ("NonResource", NonResource),
        ]
      if module_obj == mock_module_kept:
        return [("KeptResource", KeptResource)]
      return []

    self.mock_getmembers.side_effect = getmembers_side_effect
    self.mock_isabstract_inspect.side_effect = lambda cls: cls == MockAbstractResource

    self.mock_get_constructor_params.side_effect = (
      lambda cls: {
        "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
      }
      if cls == KeptResource
      else {}
    )

    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions(
      plr_resources_package=MagicMock(__path__=["dummy"], __name__="mock_plr_pkg"),
    )

    asset_manager.EXCLUDED_CLASS_NAMES = original_excluded_names

    assert added == 1
    assert updated == 0
    self.mock_ads_service.add_or_update_resource_definition.assert_called_once()
    call_args = self.mock_ads_service.add_or_update_resource_definition.call_args[1]
    assert call_args["fqn"] == "mock_module.kept.KeptResource"
    assert call_args["name"] == "kept_resource_type"

  # This test replaces the old test_sync_property_extraction_from_details_json
  # and incorporates checks for the new fields praxis_extracted_num_items and praxis_extracted_ordering
  def test_sync_extracts_basic_properties_and_new_fields(self, asset_manager: AssetManager, caplog) -> None:
    # Use the setup_mock_modules helper
    setup_mock_modules(
      self.mock_walk_packages_target,
      self.mock_import_module_target,
      self.mock_getmembers_target,
      [MockResourceSimple, MockResourceItemized],
    )

    # Mock get_resource_constructor_params for each class
    # For MockResourceSimple
    simple_params = {"name": {"type": "str", "required": True, "default": inspect.Parameter.empty}}
    # For MockResourceItemized
    itemized_params = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
      "num_items_init": {"type": "int", "required": False, "default": 5},
    }

    def get_constructor_params_side_effect(cls):
      if cls == MockResourceSimple:
        return simple_params
      if cls == MockResourceItemized:
        return itemized_params
      return {}

    self.mock_get_constructor_params.side_effect = get_constructor_params_side_effect

    self.mock_ads_service.get_resource_definition.return_value = None  # New definitions

    added, updated = asset_manager.sync_pylabrobot_definitions()

    assert added == 2
    assert updated == 0
    assert self.mock_ads_service.add_or_update_resource_definition.call_count == 2

    calls_args_list = self.mock_ads_service.add_or_update_resource_definition.call_args_list

    # Call 1: MockResourceSimple
    args_simple = calls_args_list[0][1]
    assert args_simple["fqn"] == "pylabrobot.resources.mock_simple.MockResourceSimple"
    assert args_simple["name"] == "simple_resource"  # From class attribute
    assert args_simple["resource_type"] == "SimpleModel"  # From class attribute, instance uses it
    assert (
      args_simple["category"] == ResourceCategoryEnum.OTHER
    )  # Default from MockBaseResource via _get_category_from_plr_object
    assert args_simple["model"] == "SimpleModel"
    assert args_simple["size_x_mm"] == 10.0
    assert args_simple["size_y_mm"] == 20.0
    assert args_simple["size_z_mm"] == 30.0
    assert args_simple["nominal_volume_ul"] == 100.0
    details_simple = args_simple["plr_definition_details_json"]
    assert "praxis_extracted_num_items" not in details_simple  # Or assert it's None
    assert "praxis_extracted_ordering" not in details_simple  # Or assert it's None

    # Call 2: MockResourceItemized
    args_itemized = calls_args_list[1][1]
    assert args_itemized["fqn"] == "pylabrobot.resources.mock_itemized.MockResourceItemized"
    assert args_itemized["name"] == "itemized_resource"
    assert args_itemized["resource_type"] == "ItemizedModel"
    assert args_itemized["category"] == ResourceCategoryEnum.OTHER  # Default
    assert args_itemized["model"] == "ItemizedModel"
    details_itemized = args_itemized["plr_definition_details_json"]
    assert details_itemized.get("praxis_extracted_num_items") == 5
    assert details_itemized.get("praxis_extracted_ordering") == "W1,W2,W3,W4,W5"

  def test_sync_handles_complex_constructor_gracefully(self, asset_manager: AssetManager, caplog) -> None:
    setup_mock_modules(
      self.mock_walk_packages_target,
      self.mock_import_module_target,
      self.mock_getmembers_target,
      [MockResourceComplexConstructor],
    )

    self.mock_get_constructor_params.return_value = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
      "required_object": {
        "type": "SomeNonSimpleType",
        "required": True,
        "default": inspect.Parameter.empty,
      },
      "optional_int": {"type": "int", "required": False, "default": 0},
    }
    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions()

    assert added == 1
    assert self.mock_ads_service.add_or_update_resource_definition.call_count == 1
    args_complex = self.mock_ads_service.add_or_update_resource_definition.call_args[1]

    assert args_complex["fqn"] == "pylabrobot.resources.mock_complex.MockResourceComplexConstructor"
    assert args_complex["name"] == "complex_resource"  # From class
    assert args_complex["resource_type"] == "ComplexModel"  # From class
    assert args_complex["model"] == "ComplexModel"  # From class attribute, as instance not created
    assert (
      args_complex["nominal_volume_ul"] is None
    )  # class_volume not automatically picked up by _extract_volume from class
    # Ensure details_json does not contain instance-specific data if temp_instance was None
    details_complex = args_complex["plr_definition_details_json"]
    # If temp_instance is None, details_json will be {} (after initialization) or None if not touched.
    # If it's {}, then these praxis_extracted keys won't be there.
    assert "praxis_extracted_num_items" not in details_complex
    assert "praxis_extracted_ordering" not in details_complex

    assert (
      "INFO: AM_SYNC: Skipping instantiation for pylabrobot.resources.mock_complex.MockResourceComplexConstructor due to complex required parameter 'required_object' of type 'SomeNonSimpleType'"
      in caplog.text
    )
    assert (
      "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_complex.MockResourceComplexConstructor without a temporary instance"
      in caplog.text
    )

  def test_sync_handles_instantiation_failure_gracefully(self, asset_manager: AssetManager, caplog) -> None:
    setup_mock_modules(
      self.mock_walk_packages_target,
      self.mock_import_module_target,
      self.mock_getmembers_target,
      [MockResourceInstantiationFails],
    )

    self.mock_get_constructor_params.return_value = {
      "name": {"type": "str", "required": True, "default": inspect.Parameter.empty},
    }
    self.mock_ads_service.get_resource_definition.return_value = None

    added, updated = asset_manager.sync_pylabrobot_definitions()

    assert added == 1
    assert self.mock_ads_service.add_or_update_resource_definition.call_count == 1
    args_fail = self.mock_ads_service.add_or_update_resource_definition.call_args[1]

    assert args_fail["fqn"] == "pylabrobot.resources.mock_fails.MockResourceInstantiationFails"
    assert args_fail["name"] == "fail_resource"  # From class
    assert args_fail["resource_type"] == "FailModel"  # From class
    assert args_fail["model"] == "FailModel"  # From class attribute
    # class_size_x is not automatically picked up by _extract_dimensions from class.
    assert args_fail["size_x_mm"] is None

    assert (
      "WARNING: AM_SYNC: Instantiation of pylabrobot.resources.mock_fails.MockResourceInstantiationFails failed even with smart defaults: ValueError('Cannot instantiate this')"
      in caplog.text
    )
    assert (
      "INFO: AM_SYNC: Proceeding to extract data for pylabrobot.resources.mock_fails.MockResourceInstantiationFails without a temporary instance"
      in caplog.text
    )




# --- Tests for AssetManager Logging (New Class) ---
class TestAssetManagerLogging:
  def test_acquire_resource_logs_property_constraints(
    self,
    asset_manager: AssetManager,
    mock_ads_service: MagicMock,
    mock_workcell_runtime: MagicMock,
    caplog,
  ) -> None:
    # Setup for a successful resource acquisition to reach the logging point
    mock_lw_orm = ResourceOrmMock(
      id=1, name="PlateLogTest", resource_definition_name="log_plate_def",
    )
    mock_resource_def = ResourceDefinitionOrmMock()
    mock_resource_def.fqn = "pylabrobot.resources.plate.Plate"  # Valid FQN

    mock_ads_service.read_resources.return_value = [mock_lw_orm]
    mock_ads_service.get_resource_definition.return_value = mock_resource_def
    mock_ads_service.update_resource_location_and_status.return_value = mock_lw_orm
    mock_workcell_runtime.create_or_get_resource_plr_object.return_value = MagicMock(
      name="live_logging_plate",
    )

    property_constraints_payload = {"min_volume_ul": 10, "is_sterile": True}

    # This is the AssetRequirementModel that Orchestrator would build and pass
    asset_req = AssetRequirementModelMock()
    asset_req.name = "test_plate_for_log"
    asset_req.actual_type_str = "log_plate_def"  # Matches name_constraint
    asset_req.constraints_json = property_constraints_payload  # This is what we want to log

    # Call acquire_asset, which dispatches to acquire_resource
    try:
      asset_manager.acquire_asset(
        protocol_run_accession_id="log_run_123",
        asset_requirement=asset_req,
      )
    except AssetAcquisitionError:  # Catch if something else fails, to still check logs
      pass

    assert (
      f"INFO: AM_ACQUIRE: Resource acquisition for 'test_plate_for_log' includes property_constraints: {property_constraints_payload}"
      in caplog.text
    )

  def test_release_resource_logs_properties_update(
    self,
    asset_manager: AssetManager,
    mock_ads_service: MagicMock,
    caplog,
  ) -> None:
    # Setup for release_resource
    final_props_update = {"content_state": "empty", "cleaned": True}

    # Mock the get_resource call that might happen if workcell_runtime is None or other logic paths
    # For this test, we are primarily interested in the log message generated by release_resource itself.
    # The actual update logic is tested elsewhere.
    mock_ads_service.update_resource_location_and_status.return_value = MagicMock(spec=ResourceOrm)

    asset_manager.release_resource(
      resource_orm_accession_id=555,
      final_status=ResourceStatusEnum.AVAILABLE_IN_STORAGE,
      final_properties_json_update=final_props_update,
      status_details="Logging properties update on release",
    )

    assert (
      f"INFO: AM_RELEASE: Resource release for instance ID 555 includes final_properties_json_update: "
      f"{final_props_update}"
    ) in caplog.text
