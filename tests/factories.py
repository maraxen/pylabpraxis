"""Factories for creating test data."""
import random
import time
import uuid

import factory
from factory.alchemy import SQLAlchemyModelFactory

from praxis.backend.models.domain.machine import Machine
from praxis.backend.models.domain.resource import Resource, ResourceDefinition
from praxis.backend.models.domain.workcell import Workcell
from praxis.backend.models.enums import AssetType
from praxis.backend.models.domain.deck import Deck, DeckDefinition
from praxis.backend.models.domain.outputs import FunctionDataOutput, WellDataOutput
from praxis.backend.models.domain.protocol import (
    FunctionCallLog,
    FunctionProtocolDefinition,
    ProtocolRun,
)
from praxis.backend.models.domain.workcell import Workcell

_last_v7_timestamp = None


def uuid7():
    """The UUIDv7 format is designed to encode a Unix timestamp with
    arbitrary sub-second precision. The key property provided by UUIDv7
    is that timestamp values generated by one system and parsed by
    another are guaranteed to have sub-second precision of either the
    generator or the parser, whichever is less. Additionally, the system
    parsing the UUIDv7 value does not need to know which precision was
    used during encoding in order to function correctly.
    """
    global _last_v7_timestamp
    nanoseconds = time.time_ns()
    if _last_v7_timestamp is not None and nanoseconds <= _last_v7_timestamp:
        nanoseconds = _last_v7_timestamp + 1
    _last_v7_timestamp = nanoseconds
    timestamp_ms, _timestamp_ns_frac = divmod(nanoseconds, 10**6)
    rand_a = random.getrandbits(12)
    rand_b = random.getrandbits(62)
    uuid_int = (timestamp_ms & 0xFFFFFFFFFFFF) << 80
    uuid_int |= (7 & 0xF) << 76
    uuid_int |= (rand_a & 0xFFF) << 64
    uuid_int |= (2 & 0x3) << 62
    uuid_int |= (rand_b & 0x3FFFFFFFFFFFFFFF)
    return uuid.UUID(int=uuid_int)


class WorkcellFactory(SQLAlchemyModelFactory):

    """Factory for Workcell."""

    class Meta:

        """Meta class for WorkcellFactory."""

        model = Workcell

    name = factory.Faker("word")


class MachineFactory(SQLAlchemyModelFactory):

    """Factory for Machine."""

    class Meta:

        """Meta class for MachineFactory."""

        model = Machine

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        """Override _create to handle init=False fields."""
        workcell = kwargs.pop("workcell", None)
        workcell_accession_id = kwargs.pop("workcell_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        if workcell:
            obj.workcell = workcell
            # Also ensure the ID is synced if possible/needed
            if hasattr(workcell, "accession_id"):
                 obj.workcell_accession_id = workcell.accession_id
        
        if workcell_accession_id:
            obj.workcell_accession_id = workcell_accession_id
            
        return obj

    name = factory.Faker("word")
    fqn = factory.Faker("word")
    asset_type = AssetType.MACHINE
    # Workcell is excluded from init by Meta.exclude, but generated by SubFactory
    # We capture it in _create via kwargs (excluded fields are passed to _create?)
    # Wait, factory_boy documentation says excluded fields are NOT passed to _create/constructor?
    # Actually, they are passed to _create if one overrides it? No.
    # Exclude means "don't pass to model constructor".
    # But they are available in 'kwargs' passed to _create? 
    # Yes, usually.
    
    workcell = factory.SubFactory(WorkcellFactory)
    workcell_accession_id = factory.SelfAttribute("workcell.accession_id")


class ResourceDefinitionFactory(SQLAlchemyModelFactory):

    """Factory for ResourceDefinition."""

    class Meta:

        """Meta class for ResourceDefinitionFactory."""

        model = ResourceDefinition

    name = factory.Faker("word")
    fqn = factory.Faker("word")
    plr_definition_details_json = {"num_items_x": 12, "num_items_y": 8}


class DeckDefinitionFactory(SQLAlchemyModelFactory):

    """Factory for DeckDefinition."""

    class Meta:

        """Meta class for DeckDefinitionFactory."""

        model = DeckDefinition

    name = factory.Faker("word")
    fqn = factory.Faker("word")
    resource_definition = factory.SubFactory(
        "tests.factories.ResourceDefinitionFactory",
    )

    resource_definition = factory.SubFactory(
        "tests.factories.ResourceDefinitionFactory",
    )


class DeckFactory(SQLAlchemyModelFactory):

    """Factory for Deck."""

    class Meta:

        """Meta class for DeckFactory."""

        model = Deck

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        """Override _create to handle init=False fields."""
        # Pop Params
        kwargs.pop("deck_type_def", None)
        kwargs.pop("machine_def", None)
        
        # Pop Relationship IDs/objects if init=False
        deck_type_id = kwargs.pop("deck_type_id", None)
        parent_machine_accession_id = kwargs.pop("parent_machine_accession_id", None)
        resource_definition_accession_id = kwargs.pop("resource_definition_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        # Manually set fields
        if deck_type_id:
            obj.deck_type_id = deck_type_id
        if parent_machine_accession_id:
            obj.parent_machine_accession_id = parent_machine_accession_id
        if resource_definition_accession_id:
            obj.resource_definition_accession_id = resource_definition_accession_id
            
        return obj

    class Params:
        # Transient parameters to build dependencies without passing them to the model's __init__
        deck_type_def = factory.SubFactory(DeckDefinitionFactory)
        machine_def = factory.SubFactory(MachineFactory)

    name = factory.Faker("word")
    asset_type = AssetType.DECK

    # Use the transient parameters to correctly populate the model's foreign key fields.
    deck_type_id = factory.LazyAttribute(lambda o: o.deck_type_def.accession_id)
    parent_machine_accession_id = factory.LazyAttribute(lambda o: o.machine_def.accession_id)
    resource_definition_accession_id = factory.LazyAttribute(
        lambda o: o.deck_type_def.resource_definition.accession_id,
    )


class ResourceFactory(SQLAlchemyModelFactory):
    """Factory for Resource."""

    class Meta:
        """Meta class for ResourceFactory."""

        model = Resource

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        """Override _create to handle init=False fields."""
        res_def = kwargs.pop("res_def", None)
        resource_definition_accession_id = kwargs.pop("resource_definition_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        if res_def:
             # Relationship name in Resource? likely resource_definition
             # But let's check Resource definition if logical.
             # Assuming standard name.
             pass 
        
        if resource_definition_accession_id:
            obj.resource_definition_accession_id = resource_definition_accession_id
            
        return obj

    class Params:

        res_def = factory.SubFactory(ResourceDefinitionFactory)

    name = factory.Faker("word")
    asset_type = AssetType.RESOURCE
    resource_definition_accession_id = factory.LazyAttribute(
        lambda o: o.res_def.accession_id
    )


class FunctionProtocolDefinitionFactory(SQLAlchemyModelFactory):
    """Factory for FunctionProtocolDefinition."""

    class Meta:
        """Meta class for FunctionProtocolDefinitionFactory."""

        model = FunctionProtocolDefinition

    name = "test_protocol"
    fqn = "test_protocol"


class ProtocolRunFactory(SQLAlchemyModelFactory):
    """Factory for ProtocolRun."""

    class Meta:
        """Meta class for ProtocolRunFactory."""

        model = ProtocolRun

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        kwargs.pop("top_level_def", None)
        top_level_protocol_definition_accession_id = kwargs.pop("top_level_protocol_definition_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        if top_level_protocol_definition_accession_id:
            obj.top_level_protocol_definition_accession_id = top_level_protocol_definition_accession_id
            
        return obj

    class Params:
        top_level_def = factory.SubFactory(FunctionProtocolDefinitionFactory)

    name = factory.Faker("word")
    accession_id = factory.LazyFunction(uuid7)
    top_level_protocol_definition_accession_id = factory.LazyAttribute(
        lambda o: o.top_level_def.accession_id
    )


class FunctionCallLogFactory(SQLAlchemyModelFactory):
    """Factory for FunctionCallLog."""

    class Meta:
        """Meta class for FunctionCallLogFactory."""

        model = FunctionCallLog

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        kwargs.pop("protocol_run_obj", None)
        kwargs.pop("executed_function_def", None)
        
        protocol_run_accession_id = kwargs.pop("protocol_run_accession_id", None)
        function_protocol_definition_accession_id = kwargs.pop("function_protocol_definition_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        if protocol_run_accession_id:
            obj.protocol_run_accession_id = protocol_run_accession_id
        if function_protocol_definition_accession_id:
            obj.function_protocol_definition_accession_id = function_protocol_definition_accession_id
            
        return obj

    class Params:
        protocol_run_obj = factory.SubFactory(ProtocolRunFactory)
        executed_function_def = factory.SubFactory(FunctionProtocolDefinitionFactory)

    name = factory.Faker("word")
    accession_id = factory.LazyFunction(uuid7)
    protocol_run_accession_id = factory.LazyAttribute(
        lambda o: o.protocol_run_obj.accession_id
    )
    sequence_in_run = 0
    function_protocol_definition_accession_id = factory.LazyAttribute(
        lambda o: o.executed_function_def.accession_id
    )


class FunctionDataOutputFactory(SQLAlchemyModelFactory):
    """Factory for FunctionDataOutput."""

    class Meta:
        """Meta class for FunctionDataOutputFactory."""

        model = FunctionDataOutput

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        _function_call_log = kwargs.pop("_function_call_log", None)
        function_call_log_accession_id = kwargs.pop("function_call_log_accession_id", None)
        protocol_run_accession_id = kwargs.pop("protocol_run_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        # Note: FunctionDataOutput might not have a relationship for _function_call_log 
        # or it might be named differently.
        # But if it was working before via SubFactory + exclude, then it was just used for ID generation
        # and not assigned.
        # But now we popped it.
        
        if function_call_log_accession_id:
            obj.function_call_log_accession_id = function_call_log_accession_id
        if protocol_run_accession_id:
            obj.protocol_run_accession_id = protocol_run_accession_id
            
        return obj

    class Params:
        pass

    name = factory.Faker("word")
    accession_id = factory.LazyFunction(uuid7)
    
    _function_call_log = factory.SubFactory(FunctionCallLogFactory)
    
    function_call_log_accession_id = factory.SelfAttribute("_function_call_log.accession_id")
    protocol_run_accession_id = factory.SelfAttribute("_function_call_log.protocol_run_accession_id")


class WellDataOutputFactory(SQLAlchemyModelFactory):
    """Factory for WellDataOutput."""

    class Meta:
        """Meta class for WellDataOutputFactory."""

        model = WellDataOutput

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        _function_data_output = kwargs.pop("_function_data_output", None)
        _plate_resource = kwargs.pop("_plate_resource", None)
        
        function_data_output_accession_id = kwargs.pop("function_data_output_accession_id", None)
        plate_resource_accession_id = kwargs.pop("plate_resource_accession_id", None)
        
        obj = super()._create(model_class, *args, **kwargs)
        
        if function_data_output_accession_id:
            obj.function_data_output_accession_id = function_data_output_accession_id
        if plate_resource_accession_id:
            obj.plate_resource_accession_id = plate_resource_accession_id
            
        return obj

    class Params:
        pass

    name = factory.Faker("word")
    
    _function_data_output = factory.SubFactory(FunctionDataOutputFactory)
    _plate_resource = factory.SubFactory(ResourceFactory)
    
    function_data_output_accession_id = factory.SelfAttribute("_function_data_output.accession_id")
    plate_resource_accession_id = factory.SelfAttribute("_plate_resource.accession_id")
    
    well_name = "A1"
    well_row = 0
    well_column = 0
    well_index = 0
    data_value = factory.Faker("pyfloat")
