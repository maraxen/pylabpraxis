diff --git a/praxis/backend/services/deck.py b/praxis/backend/services/deck.py
index 7b507d0..7ec1cc9 100644
--- a/praxis/backend/services/deck.py
+++ b/praxis/backend/services/deck.py
@@ -27,6 +27,7 @@ from praxis.backend.services.utils.query_builder import (
   apply_specific_id_filters,
 )
 from praxis.backend.utils.db_decorator import handle_db_transaction
+from praxis.backend.services.deck_configuration import deck_configuration_service
 from praxis.backend.utils.logging import get_logger
 
 logger = get_logger(__name__)
@@ -307,5 +308,21 @@ class DeckService(CRUDBase[DeckOrm, DeckCreate, DeckUpdate]):
     result = await db.execute(stmt)
     return result.scalar_one_or_none()
 
+  async def get_slot_coordinates(
+      self,
+      db: AsyncSession,
+      deck_id: uuid.UUID,
+      slot: str,
+  ) -> dict[str, float] | None:
+      """Get the coordinates of a specific slot on a deck."""
+      deck = await self.get(db, deck_id)
+      if not deck or not deck.deck_type.positioning_config_json:
+          return None
+
+      return deck_configuration_service.get_slot_coordinates(
+          deck.deck_type.positioning_config_json,
+          slot,
+      )
+
 
 deck_service = DeckService(DeckOrm)
diff --git a/praxis/backend/services/deck_configuration.py b/praxis/backend/services/deck_configuration.py
new file mode 100644
index 0000000..48b949e
--- /dev/null
+++ b/praxis/backend/services/deck_configuration.py
@@ -0,0 +1,71 @@
+# pylint: disable=broad-except
+"""Service layer for Deck Configuration Management.
+
+This service layer interacts with deck-related data in the database, providing
+functions to calculate deck positions based on the positioning configuration.
+"""
+
+from typing import Any, Dict
+
+class DeckConfigurationService:
+    """Service for deck configuration-related operations."""
+
+    def get_slot_coordinates(self, positioning_config: Dict[str, Any], slot: str) -> Dict[str, float]:
+        """
+        Calculate the coordinates of a given slot based on the positioning configuration.
+
+        Args:
+            positioning_config: The positioning configuration from the DeckDefinitionOrm.
+            slot: The slot to calculate the coordinates for.
+
+        Returns:
+            A dictionary with the x, y, and z coordinates of the slot.
+        """
+        positioning_type = positioning_config.get("type")
+
+        if positioning_type == "cartesian":
+            return self._get_cartesian_coordinates(positioning_config, slot)
+        elif positioning_type == "rails":
+            return self._get_rails_coordinates(positioning_config, slot)
+        else:
+            raise ValueError(f"Unsupported positioning type: {positioning_type}")
+
+    def _get_cartesian_coordinates(self, positioning_config: Dict[str, Any], slot: str) -> Dict[str, float]:
+        """Calculate coordinates for a cartesian system."""
+        slots = positioning_config.get("slots", {})
+        slot_coords = slots.get(slot)
+
+        if not slot_coords:
+            raise ValueError(f"Slot {slot} not found in positioning configuration.")
+
+        return {
+            "x": slot_coords.get("x", 0.0),
+            "y": slot_coords.get("y", 0.0),
+            "z": slot_coords.get("z", 0.0),
+        }
+
+    def _get_rails_coordinates(self, positioning_config: Dict[str, Any], slot: str) -> Dict[str, float]:
+        """Calculate coordinates for a rail-based system."""
+        try:
+            slot_number = int(slot)
+        except ValueError:
+            raise ValueError(f"Invalid slot number: {slot}")
+
+        rail_length = positioning_config.get("rail_length", 1000.0)
+        slot_width = positioning_config.get("slot_width", 100.0)
+        slot_gap = positioning_config.get("slot_gap", 10.0)
+        y_offset = positioning_config.get("y_offset", 50.0)
+        z_offset = positioning_config.get("z_offset", 100.0)
+
+        x_coord = (slot_number - 1) * (slot_width + slot_gap)
+
+        if x_coord > rail_length:
+            raise ValueError(f"Slot {slot} is outside the rail length.")
+
+        return {
+            "x": x_coord,
+            "y": y_offset,
+            "z": z_offset,
+        }
+
+deck_configuration_service = DeckConfigurationService()
diff --git a/praxis/backend/services/discovery_service.py b/praxis/backend/services/discovery_service.py
index 42c1a63..a757eda 100644
--- a/praxis/backend/services/discovery_service.py
+++ b/praxis/backend/services/discovery_service.py
@@ -18,10 +18,15 @@ from typing import Any
 
 from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
 
+from praxis.backend.models.pydantic_internals.deck import (
+    DeckTypeDefinitionCreate,
+    DeckTypeDefinitionUpdate,
+)
 from praxis.backend.models.pydantic_internals.protocol import (
   FunctionProtocolDefinitionCreate,
   FunctionProtocolDefinitionUpdate,
 )
+from praxis.backend.services.deck_type_definition import DeckTypeDefinitionService
 from praxis.backend.services.machine_type_definition import MachineTypeDefinitionService
 from praxis.backend.services.protocol_definition import ProtocolDefinitionCRUDService
 from praxis.backend.services.resource_type_definition import (
@@ -80,6 +85,43 @@ class ProtocolVisitor(ast.NodeVisitor):
     self.definitions.append(inferred_model)
 
 
+class DeckVisitor(ast.NodeVisitor):
+    """AST visitor to find deck definitions."""
+
+    def __init__(self, module_name: str, file_path: str):
+        self.module_name = module_name
+        self.file_path = file_path
+        self.definitions = []
+
+    def visit_ClassDef(self, node: ast.ClassDef):
+        """Visit a class definition."""
+        for base in node.bases:
+            if isinstance(base, ast.Name) and base.id == "Deck":
+                self._extract_deck_definition(node)
+
+    def _extract_deck_definition(self, node: ast.ClassDef):
+        """Extract information from a deck definition."""
+        deck_info = {
+            "name": node.name,
+            "fqn": f"{self.module_name}.{node.name}",
+            "source_file_path": self.file_path,
+            "module_name": self.module_name,
+            "class_name": node.name,
+            "positioning_config_json": None,
+        }
+
+        for item in node.body:
+            if isinstance(item, ast.Assign):
+                for target in item.targets:
+                    if isinstance(target, ast.Name) and target.id == "positioning":
+                        try:
+                            deck_info["positioning_config_json"] = ast.literal_eval(item.value)
+                        except ValueError:
+                            # Handle cases where the value is not a literal
+                            pass
+        self.definitions.append(deck_info)
+
+
 class DiscoveryService:
 
   """Service for discovering and managing protocol functions and PLR type definitions."""
@@ -89,12 +131,14 @@ class DiscoveryService:
     db_session_factory: async_sessionmaker[AsyncSession] | None = None,
     resource_type_definition_service: ResourceTypeDefinitionService | None = None,
     machine_type_definition_service: MachineTypeDefinitionService | None = None,
+    deck_type_definition_service: DeckTypeDefinitionService | None = None,
     protocol_definition_service: ProtocolDefinitionCRUDService | None = None,
   ) -> None:
     """Initialize the DiscoveryService."""
     self.db_session_factory = db_session_factory
     self.resource_type_definition_service = resource_type_definition_service
     self.machine_type_definition_service = machine_type_definition_service
+    self.deck_type_definition_service = deck_type_definition_service
     self.protocol_definition_service = protocol_definition_service
 
   async def discover_and_sync_all_definitions(
@@ -117,6 +161,32 @@ class DiscoveryService:
       await self.machine_type_definition_service.discover_and_synchronize_type_definitions()
       logger.info("Machine type definitions synchronized.")
 
+    if self.deck_type_definition_service:
+        logger.info("Synchronizing deck type definitions...")
+        deck_definitions = self._extract_deck_definitions_from_paths(protocol_search_paths)
+        async with self.db_session_factory() as session:
+            for deck_data in deck_definitions:
+                deck_pydantic_model = DeckTypeDefinitionCreate(**deck_data)
+                existing_def = await self.deck_type_definition_service.get_by_fqn(
+                    db=session,
+                    fqn=deck_pydantic_model.fqn,
+                )
+                if existing_def:
+                    update_data = DeckTypeDefinitionUpdate(
+                        **deck_pydantic_model.model_dump()
+                    )
+                    await self.deck_type_definition_service.update(
+                        db=session,
+                        db_obj=existing_def,
+                        obj_in=update_data,
+                    )
+                else:
+                    await self.deck_type_definition_service.create(
+                        db=session,
+                        obj_in=deck_pydantic_model,
+                    )
+        logger.info("Deck type definitions synchronized.")
+
     logger.info("Discovering and upserting protocols...")
     await self.discover_and_upsert_protocols(
       search_paths=protocol_search_paths,
@@ -126,6 +196,41 @@ class DiscoveryService:
     )
     logger.info("All definitions synchronized.")
 
+  def _extract_deck_definitions_from_paths(
+    self,
+    search_paths: Sequence[str | Path],
+  ) -> list[dict[str, Any]]:
+    """Extract deck definitions from Python files in the given paths."""
+    extracted_definitions = []
+    for path_item in search_paths:
+      abs_path_item = Path(path_item).resolve()
+      if not abs_path_item.is_dir():
+        continue
+
+      for root, _, files in os.walk(str(abs_path_item)):
+        for file in files:
+          if file.endswith(".py") and not file.startswith("_"):
+            module_file_path = Path(root) / file
+            module_name = ".".join(
+              module_file_path.relative_to(abs_path_item.parent).with_suffix("").parts,
+            )
+
+            with open(module_file_path, encoding="utf-8") as f:
+              source = f.read()
+              try:
+                tree = ast.parse(source, filename=str(module_file_path))
+                visitor = DeckVisitor(
+                  module_name,
+                  str(module_file_path),
+                )
+                visitor.visit(tree)
+                extracted_definitions.extend(visitor.definitions)
+              except SyntaxError as e:
+                logger.warning(
+                  f"Could not parse {module_file_path}: {e}",
+                )
+    return extracted_definitions
+
   def _extract_protocol_definitions_from_paths(
     self,
     search_paths: Sequence[str | Path],

