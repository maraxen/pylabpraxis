diff --git a/artifacts/research_browser_simulation.md b/artifacts/research_browser_simulation.md
new file mode 100644
index 0000000..0be31f7
--- /dev/null
+++ b/artifacts/research_browser_simulation.md
@@ -0,0 +1,183 @@
+# Research Report: Browser-Mode Simulation Spec
+
+This document outlines a proposal for a robust "Simulation Spec" for browser-native protocol execution.
+
+## 1. Simulation Protocol Interface
+
+This section defines a contract for specifying simulation behavior directly within a protocol. The goal is to create a declarative, co-located, and easily parsable mechanism for defining how a protocol should behave in a simulated environment.
+
+### Proposed Solution: `@simulate_output` Decorator
+
+We propose a Python decorator, `@simulate_output`, to be applied to protocol functions that generate data (e.g., from a plate reader). This decorator will provide metadata to the simulation engine about the expected output.
+
+#### Decorator Signature
+```python
+def simulate_output(
+  shape: tuple[int, int],
+  range: tuple[float, float],
+  strategy: str = "uniform"
+):
+  # ... decorator logic ...
+```
+
+- **`shape`**: A tuple defining the dimensions of the generated data (e.g., `(8, 12)` for a 96-well plate).
+- **`range`**: A tuple specifying the minimum and maximum values for the generated data.
+- **`strategy`**: The data generation strategy to use. Defaults to `"uniform"`, but could be extended to include `"normal"`, `"lognormal"`, etc.
+
+#### Example Usage
+
+```python
+from praxis.backend.core.decorators import protocol, simulate_output
+
+@protocol(
+  name="Plate Reader Measurement",
+  description="A protocol to measure absorbance from a plate."
+)
+@simulate_output(shape=(8, 12), range=(0.1, 3.0))
+def measure_absorbance(plate: Plate) -> list[list[float]]:
+  """Measures the absorbance of each well in a plate."""
+  # In a real run, this would interact with hardware.
+  # In a simulation, the decorator provides the necessary metadata.
+  pass
+```
+
+### Rationale
+
+- **Co-location**: The simulation behavior is defined directly with the protocol function, making it easy to find and understand.
+- **Declarative**: The decorator declares the *what* (the shape and range of the data) and leaves the *how* (the data generation) to the simulation engine.
+- **Inspectable**: The simulation engine can easily inspect the protocol function for the presence of this decorator and its arguments at runtime.
+
+## 2. Mocking PLR Classes in Pyodide
+
+## 2. Mocking PLR Classes in Pyodide
+
+This section details the strategy for substituting real PyLabRobot (PLR) hardware classes with simulated versions in a Pyodide environment. The key is to leverage the existing dynamic instantiation mechanism within the `WorkcellRuntime`.
+
+### Core Strategy: FQN Substitution
+
+The `WorkcellRuntime`'s `MachineManagerMixin` instantiates hardware drivers by dynamically importing a class from a Fully Qualified Name (FQN) stored in the database. This provides a clean seam for simulation.
+
+To run a protocol in simulation mode, we will:
+1.  **Define Simulator Classes**: Create a suite of simulator classes (e.g., `PlateReaderSimulator`) that mirror the public API of their real PLR counterparts.
+2.  **Use Simulator FQNs**: When a protocol is run in "simulation" mode, the backend will provide the FQN of the simulator class (e.g., `praxis.simulators.PlateReaderSimulator`) to the `WorkcellRuntime` instead of the real hardware FQN (e.g., `pylabrobot.plate_reading.plate_reader.PlateReader`).
+
+This approach requires no changes to the core orchestration or protocol execution logic.
+
+### Example: `PlateReaderSimulator`
+
+Here is a conceptual implementation of a `PlateReaderSimulator`:
+
+```python
+# In a new file: praxis/simulators/plate_reader.py
+
+import numpy as np
+from pylabrobot.resources import Plate
+
+class PlateReaderSimulator:
+    """A simulated plate reader that generates data based on protocol metadata."""
+
+    def __init__(self, name: str):
+        self.name = name
+
+    async def read_luminescence(self, plate: Plate, **kwargs) -> list[list[float]]:
+        # The simulator would need access to the protocol's simulation metadata.
+        # This could be passed in via the RunContext.
+        sim_meta = kwargs.get("__praxis_simulation_meta__", {})
+        
+        shape = sim_meta.get("shape", (8, 12))
+        data_range = sim_meta.get("range", (1000, 5000))
+        
+        data = np.random.uniform(low=data_range[0], high=data_range[1], size=shape)
+        return data.tolist()
+
+    async def setup(self):
+        print(f"Simulator '{self.name}' is ready.")
+
+    async def stop(self):
+        print(f"Simulator '{self.name}' is stopped.")
+```
+
+### Integration with `WorkcellRuntime`
+
+When the orchestrator prepares for a simulation run, it will fetch the appropriate simulator FQN for each required machine. The `initialize_machine` function in `MachineManagerMixin` will then instantiate the simulator class, and the protocol will execute with the mock object instead of the real hardware.
+
+## 3. Simulation State Manager
+
+## 3. Simulation State Manager
+
+To enable realistic simulation of processes like liquid handling, we need a mechanism to track the state of the virtual workcell. The `PraxisRunContext`, which already manages the application's canonical state, is the ideal place to house this simulation state.
+
+### Extending `PraxisRunContext`
+
+We will extend the `PraxisRunContext` to include a `simulation_state` attribute. This attribute will hold a dictionary representing the state of all resources in the simulation.
+
+```python
+class PraxisRunContext:
+    # ... existing attributes ...
+    
+    def __init__(self, ..., is_simulation: bool = False):
+        # ... existing initialization ...
+        self.is_simulation = is_simulation
+        self.simulation_state = {} if is_simulation else None
+
+    def get_simulation_state(self, resource_name: str) -> dict:
+        """Gets the state for a given resource."""
+        if not self.is_simulation:
+            return {}
+        return self.simulation_state.setdefault(resource_name, {})
+
+    def update_simulation_state(self, resource_name: str, new_state: dict):
+        """Updates the state for a given resource."""
+        if self.is_simulation:
+            self.simulation_state[resource_name] = new_state
+```
+
+### Simulator Interaction with State
+
+The simulator classes (like a `LiquidHandlerSimulator`) will interact with the `simulation_state` via the `PraxisRunContext`, which is already passed to every protocol function.
+
+#### Example: `LiquidHandlerSimulator`
+
+```python
+# In a new file: praxis/simulators/liquid_handler.py
+
+from pylabrobot.resources import Plate, Well
+
+class LiquidHandlerSimulator:
+    """A simulated liquid handler that tracks liquid volumes."""
+
+    def __init__(self, name: str, run_context: "PraxisRunContext"):
+        self.name = name
+        self.run_context = run_context
+
+    async def aspirate(self, well: Well, volume: float):
+        """Simulates aspirating liquid from a well."""
+        well_state = self.run_context.get_simulation_state(well.name)
+        current_volume = well_state.get("volume", 0)
+
+        if current_volume < volume:
+            raise RuntimeError(f"Not enough liquid in {well.name} to aspirate {volume}uL.")
+
+        well_state["volume"] = current_volume - volume
+        self.run_context.update_simulation_state(well.name, well_state)
+        print(f"Aspirated {volume}uL from {well.name}. New volume: {well_state['volume']}uL.")
+
+    async def dispense(self, well: Well, volume: float):
+        """Simulates dispensing liquid into a well."""
+        well_state = self.run_context.get_simulation_state(well.name)
+        current_volume = well_state.get("volume", 0)
+
+        well_state["volume"] = current_volume + volume
+        self.run_context.update_simulation_state(well.name, well_state)
+        print(f"Dispensed {volume}uL to {well.name}. New volume: {well_state['volume']}uL.")
+
+    async def setup(self):
+        print(f"Simulator '{self.name}' is ready.")
+
+    async def stop(self):
+        print(f"Simulator '{self.name}' is stopped.")
+```
+
+### Initial State
+
+The `initial_state_data` parameter in the `execute_protocol` method of the `Orchestrator` can be used to seed the `simulation_state` with the starting liquid volumes and other resource states for a protocol run. This allows for flexible and realistic simulation scenarios.

