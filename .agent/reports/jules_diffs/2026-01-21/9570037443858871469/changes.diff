diff --git a/praxis/backend/models/pydantic_internals/filters.py b/praxis/backend/models/pydantic_internals/filters.py
index c2e2ccb..630ba7d 100644
--- a/praxis/backend/models/pydantic_internals/filters.py
+++ b/praxis/backend/models/pydantic_internals/filters.py
@@ -13,6 +13,7 @@ class SearchFilters(BaseModel):
   limit: int = Field(default=100, ge=1, le=1000, description="Maximum number of results to return.")
   offset: int = Field(default=0, ge=0, description="Number of results to skip before returning.")
   sort_by: str | None = Field(default=None, description="Field to sort by.")
+  plr_category: str | None = Field(default=None, description="Filter by PyLabRobot category.")
   search_filters: dict[str, Any] | None = Field(
     default=None,
     description="Generic key-value filters for searching.",
diff --git a/praxis/backend/services/utils/crud_base.py b/praxis/backend/services/utils/crud_base.py
index 8bfce53..d8f9ce9 100644
--- a/praxis/backend/services/utils/crud_base.py
+++ b/praxis/backend/services/utils/crud_base.py
@@ -63,19 +63,7 @@ class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
   ) -> list[ModelType]:
     """Get multiple objects with filtering, sorting, and pagination."""
     statement = select(self.model)
-    if filters.search_filters:
-      statement = apply_search_filters(statement, self.model, filters)
-      statement = apply_date_range_filters(
-        statement,
-        filters,
-        self.model.created_at,
-      )
-      if self.model.properties_json:
-        statement = apply_property_filters(
-          statement,
-          filters,
-          self.model.properties_json,
-        )
+    statement = apply_search_filters(statement, self.model, filters)
     if filters.sort_by:
       statement = apply_sorting(statement, self.model, filters.sort_by)
     statement = apply_specific_id_filters(statement, filters, self.model)
diff --git a/praxis/backend/services/utils/query_builder.py b/praxis/backend/services/utils/query_builder.py
index 7b4f283..b6eba82 100644
--- a/praxis/backend/services/utils/query_builder.py
+++ b/praxis/backend/services/utils/query_builder.py
@@ -144,6 +144,26 @@ def apply_specific_id_filters(
   return query
 
 
+def apply_plr_category_filter(
+  query: Select,
+  filters: SearchFilters,
+  orm_model: type[BaseModel],
+) -> Select:
+  """Apply a filter for the plr_category to a SQLAlchemy query.
+
+  Args:
+      query: The SQLAlchemy Select statement.
+      filters: The SearchFilters object containing the plr_category.
+      orm_model: The ORM model class to which the query applies.
+
+  Returns:
+      The modified Select statement with the plr_category filter applied.
+  """
+  if filters.plr_category and hasattr(orm_model, "plr_category"):
+    query = query.filter(orm_model.plr_category == filters.plr_category)
+  return query
+
+
 def apply_search_filters(
   query: Select,
   orm_model: type[BaseModel],
@@ -171,6 +191,7 @@ def apply_search_filters(
   timestamp_col = getattr(orm_model, timestamp_field, None)
 
   q = apply_specific_id_filters(query, filters, orm_model)
+  q = apply_plr_category_filter(q, filters, orm_model)
   if properties_col is not None:
     q = apply_property_filters(q, filters, properties_col)
   if timestamp_col is not None:
diff --git a/praxis/backend/tests/api/test_resource_filtering.py b/praxis/backend/tests/api/test_resource_filtering.py
new file mode 100644
index 0000000..e3be059
--- /dev/null
+++ b/praxis/backend/tests/api/test_resource_filtering.py
@@ -0,0 +1,45 @@
+
+import pytest
+from httpx import AsyncClient
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from praxis.backend.models.orm.resource import ResourceDefinitionOrm
+
+@pytest.mark.asyncio
+async def test_filter_resource_definitions_by_plr_category(
+    client: AsyncClient, db: AsyncSession
+) -> None:
+    """Test that we can filter resource definitions by plr_category."""
+    # Create some test data
+    plate_def = ResourceDefinitionOrm(
+        name="Test Plate",
+        fqn="pylabrobot.resources.Plate",
+        plr_category="plate",
+    )
+    tip_rack_def = ResourceDefinitionOrm(
+        name="Test Tip Rack",
+        fqn="pylabrobot.resources.TipRack",
+        plr_category="tip_rack",
+    )
+    db.add_all([plate_def, tip_rack_def])
+    await db.commit()
+
+    # Test filtering by plate
+    response = await client.get("/api/v1/resources/definitions?plr_category=plate")
+    assert response.status_code == 200
+    data = response.json()
+    assert len(data) == 1
+    assert data[0]["name"] == "Test Plate"
+
+    # Test filtering by tip_rack
+    response = await client.get("/api/v1/resources/definitions?plr_category=tip_rack")
+    assert response.status_code == 200
+    data = response.json()
+    assert len(data) == 1
+    assert data[0]["name"] == "Test Tip Rack"
+
+    # Test with no filter
+    response = await client.get("/api/v1/resources/definitions")
+    assert response.status_code == 200
+    data = response.json()
+    assert len(data) >= 2
diff --git a/praxis/web-client/src/app/features/assets/components/resource-dialog.component.ts b/praxis/web-client/src/app/features/assets/components/resource-dialog.component.ts
index b4efd32..4558f7e 100644
--- a/praxis/web-client/src/app/features/assets/components/resource-dialog.component.ts
+++ b/praxis/web-client/src/app/features/assets/components/resource-dialog.component.ts
@@ -41,6 +41,15 @@ import { Observable } from 'rxjs';
             </mat-select>
         </mat-form-field>
 
+        <mat-form-field appearance="outline">
+          <mat-label>Category</mat-label>
+          <mat-select (selectionChange)="onCategoryChange($event)">
+            <mat-option value="plate">Plate</mat-option>
+            <mat-option value="tip_rack">Tip Rack</mat-option>
+            <mat-option value="container">Container</mat-option>
+          </mat-select>
+        </mat-form-field>
+
         <mat-form-field appearance="outline">
           <mat-label>Resource Definition</mat-label>
           <mat-select formControlName="resource_definition_accession_id">
@@ -79,9 +88,15 @@ export class ResourceDialogComponent implements OnInit {
   });
 
   ngOnInit() {
-      // definitions endpoint might fail if not implemented on backend,
-      // but we'll try to fetch it as per plan.
-      this.definitions$ = this.assetService.getResourceDefinitions();
+    this.loadDefinitions();
+  }
+
+  loadDefinitions(category?: string) {
+    this.definitions$ = this.assetService.getResourceDefinitions(category);
+  }
+
+  onCategoryChange(event: any) {
+    this.loadDefinitions(event.value);
   }
 
   save() {
diff --git a/praxis/web-client/src/app/features/assets/services/asset.service.ts b/praxis/web-client/src/app/features/assets/services/asset.service.ts
index 07c8204..fba1db0 100644
--- a/praxis/web-client/src/app/features/assets/services/asset.service.ts
+++ b/praxis/web-client/src/app/features/assets/services/asset.service.ts
@@ -1,6 +1,6 @@
 
 import { Injectable, inject } from '@angular/core';
-import { HttpClient } from '@angular/common/http';
+import { HttpClient, HttpParams } from '@angular/common/http';
 import { Observable } from 'rxjs';
 import { Machine, MachineCreate, Resource, ResourceCreate, MachineDefinition, ResourceDefinition } from '../models/asset.models';
 
@@ -42,7 +42,11 @@ export class AssetService {
       return this.http.get<MachineDefinition[]>(`${this.API_URL}/discovery/machines`);
   }
 
-  getResourceDefinitions(): Observable<ResourceDefinition[]> {
-      return this.http.get<ResourceDefinition[]>(`${this.API_URL}/discovery/resources`);
+  getResourceDefinitions(plrCategory?: string): Observable<ResourceDefinition[]> {
+    let params = new HttpParams();
+    if (plrCategory) {
+      params = params.set('plr_category', plrCategory);
+    }
+    return this.http.get<ResourceDefinition[]>(`${this.API_URL}/discovery/resources`, { params });
   }
 }

