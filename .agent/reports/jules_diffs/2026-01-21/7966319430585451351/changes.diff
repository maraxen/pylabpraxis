diff --git a/praxis/web-client/src/app/features/run-protocol/components/live-dashboard.component.ts b/praxis/web-client/src/app/features/run-protocol/components/live-dashboard.component.ts
index 199c09c..2621293 100644
--- a/praxis/web-client/src/app/features/run-protocol/components/live-dashboard.component.ts
+++ b/praxis/web-client/src/app/features/run-protocol/components/live-dashboard.component.ts
@@ -114,7 +114,7 @@ export class LiveDashboardComponent implements OnDestroy {
   ExecutionStatus = ExecutionStatus;
 
   stopRun() {
-    this.executionService.stopRun().subscribe();
+    this.executionService.stopRun();
   }
 
   ngOnDestroy() {
diff --git a/praxis/web-client/src/app/features/run-protocol/models/execution.models.ts b/praxis/web-client/src/app/features/run-protocol/models/execution.models.ts
index fac1334..c0c72c1 100644
--- a/praxis/web-client/src/app/features/run-protocol/models/execution.models.ts
+++ b/praxis/web-client/src/app/features/run-protocol/models/execution.models.ts
@@ -1,6 +1,7 @@
 
 export enum ExecutionStatus {
   PENDING = 'pending',
+  PREPARING = 'preparing',
   RUNNING = 'running',
   COMPLETED = 'completed',
   FAILED = 'failed',
diff --git a/praxis/web-client/src/app/features/run-protocol/services/execution.service.spec.ts b/praxis/web-client/src/app/features/run-protocol/services/execution.service.spec.ts
new file mode 100644
index 0000000..d3a5697
--- /dev/null
+++ b/praxis/web-client/src/app/features/run-protocol/services/execution.service.spec.ts
@@ -0,0 +1,46 @@
+
+import { TestBed } from '@angular/core/testing';
+import { HttpClientTestingModule } from '@angular/common/http/testing';
+import { ExecutionService } from './execution.service';
+import { PythonRuntimeService } from './python-runtime.service';
+import { of } from 'rxjs';
+import { vi } from 'vitest';
+
+describe('ExecutionService', () => {
+  let service: ExecutionService;
+  let pythonRuntimeService: PythonRuntimeService;
+
+  beforeEach(() => {
+    TestBed.configureTestingModule({
+      imports: [HttpClientTestingModule],
+      providers: [
+        ExecutionService,
+        {
+          provide: PythonRuntimeService,
+          useValue: {
+            runCode: vi.fn(),
+            interrupt: vi.fn(),
+            messages$: of(),
+          },
+        },
+      ],
+    });
+    service = TestBed.inject(ExecutionService);
+    pythonRuntimeService = TestBed.inject(PythonRuntimeService);
+  });
+
+  it('should be created', () => {
+    expect(service).toBeTruthy();
+  });
+
+  it('should call pythonRuntimeService.runCode on startBrowserRun', () => {
+    service.startBrowserRun('test-protocol', 'test-run', 'print("hello")');
+    expect(pythonRuntimeService.runCode).toHaveBeenCalledWith('print("hello")');
+  });
+
+  it('should call pythonRuntimeService.interrupt on stopRun for browser run', () => {
+    service.startBrowserRun('test-protocol', 'test-run', 'print("hello")');
+    service.stopRun();
+    expect(pythonRuntimeService.interrupt).toHaveBeenCalled();
+  });
+});
diff --git a/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts b/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
index a5d2af4..1fc551b 100644
--- a/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
+++ b/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
@@ -2,20 +2,25 @@
 import { Injectable, inject, signal, computed } from '@angular/core';
 import { HttpClient } from '@angular/common/http';
 import { webSocket, WebSocketSubject } from 'rxjs/webSocket';
-import { Observable, Subject, BehaviorSubject, of } from 'rxjs';
-import { catchError, tap, retry, delay } from 'rxjs/operators';
+import { Observable, Subject, of } from 'rxjs';
+import { catchError, tap, retry } from 'rxjs/operators';
 import { ExecutionState, ExecutionMessage, ExecutionStatus } from '../models/execution.models';
+import { PythonRuntimeService, PythonWorkerMessage } from './python-runtime.service';
+import { takeUntil } from 'rxjs/operators';
 
 @Injectable({
   providedIn: 'root'
 })
 export class ExecutionService {
   private http = inject(HttpClient);
+  private pythonRuntimeService = inject(PythonRuntimeService);
+  
   private readonly WS_URL = 'ws://localhost:8000/api/v1/ws/execution';
   private readonly API_URL = '/api/v1';
 
   private socket$: WebSocketSubject<ExecutionMessage> | null = null;
   private messagesSubject = new Subject<ExecutionMessage>();
+  private ngUnsubscribe = new Subject<void>();
 
   // Use signals for reactive state
   private _currentRun = signal<ExecutionState | null>(null);
@@ -28,6 +33,26 @@ export class ExecutionService {
 
   messages$ = this.messagesSubject.asObservable();
 
+  constructor() {
+    this.pythonRuntimeService.messages$
+      .pipe(takeUntil(this.ngUnsubscribe))
+      .subscribe(message => this.handlePythonWorkerMessage(message));
+  }
+  
+  /**
+   * Start a new protocol run in browser mode
+   */
+  startBrowserRun(protocolId: string, runName: string, code: string, parameters?: Record<string, any>) {
+    this._currentRun.set({
+      runId: `browser-${Date.now()}`,
+      protocolName: runName,
+      status: ExecutionStatus.PENDING,
+      progress: 0,
+      logs: []
+    });
+    this.pythonRuntimeService.runCode(code);
+  }
+
   /**
    * Start a new protocol run
    */
@@ -139,26 +164,65 @@ export class ExecutionService {
         break;
     }
   }
+  
+  private handlePythonWorkerMessage(message: PythonWorkerMessage) {
+    const currentState = this._currentRun();
+    if (!currentState) return;
+
+    switch (message.type) {
+      case 'status':
+        this._currentRun.set({ ...currentState, status: this.mapPythonStatus(message.message ?? '') });
+        break;
+      case 'result':
+        // Handle result if necessary
+        break;
+      case 'error':
+        this._currentRun.set({ ...currentState, status: ExecutionStatus.FAILED, logs: [...currentState.logs, `ERROR: ${message.payload}`] });
+        break;
+    }
+  }
+
+  private mapPythonStatus(pythonStatus: string): ExecutionStatus {
+    switch (pythonStatus) {
+      case 'loading-pyodide':
+        return ExecutionStatus.PREPARING;
+      case 'pyodide-ready':
+        return ExecutionStatus.PENDING;
+      case 'executing-python':
+        return ExecutionStatus.RUNNING;
+      case 'python-execution-complete':
+        return ExecutionStatus.COMPLETED;
+      case 'python-execution-interrupted':
+        return ExecutionStatus.CANCELLED;
+      default:
+        return this._currentRun()?.status ?? ExecutionStatus.PENDING;
+    }
+  }
+
 
   /**
    * Stop the current run
    */
-  stopRun(): Observable<void> {
+  stopRun(): void {
     const runId = this._currentRun()?.runId;
-    if (!runId) return of(void 0);
+    if (!runId) return;
 
-    return this.http.post<void>(`${this.API_URL}/runs/${runId}/stop`, {}).pipe(
-      tap(() => {
-        const current = this._currentRun();
-        if (current) {
-          this._currentRun.set({
-            ...current,
-            status: ExecutionStatus.CANCELLED
-          });
-        }
-        this.disconnect();
-      })
-    );
+    if (runId.startsWith('browser-')) {
+      this.pythonRuntimeService.interrupt();
+    } else {
+      this.http.post<void>(`${this.API_URL}/runs/${runId}/stop`, {}).pipe(
+        tap(() => {
+          const current = this._currentRun();
+          if (current) {
+            this._currentRun.set({
+              ...current,
+              status: ExecutionStatus.CANCELLED
+            });
+          }
+          this.disconnect();
+        })
+      ).subscribe();
+    }
   }
 
   /**
@@ -178,5 +242,7 @@ export class ExecutionService {
   clearRun() {
     this._currentRun.set(null);
     this.disconnect();
+    this.ngUnsubscribe.next();
+    this.ngUnsubscribe.complete();
   }
 }
diff --git a/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.spec.ts b/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.spec.ts
new file mode 100644
index 0000000..89e2dc6
--- /dev/null
+++ b/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.spec.ts
@@ -0,0 +1,39 @@
+
+import { TestBed } from '@angular/core/testing';
+import { PythonRuntimeService } from './python-runtime.service';
+import { vi } from 'vitest';
+
+describe('PythonRuntimeService', () => {
+  let service: PythonRuntimeService;
+
+  beforeEach(() => {
+    // @ts-ignore
+    global.Worker = vi.fn(() => ({
+      postMessage: vi.fn(),
+      onmessage: vi.fn(),
+      onerror: vi.fn(),
+      terminate: vi.fn(),
+    }));
+
+    TestBed.configureTestingModule({
+      providers: [PythonRuntimeService],
+    });
+    service = TestBed.inject(PythonRuntimeService);
+  });
+
+  it('should be created', () => {
+    expect(service).toBeTruthy();
+  });
+
+  it('should send code to the worker on runCode', () => {
+    const postMessageSpy = vi.spyOn(service['worker'] as Worker, 'postMessage');
+    service.runCode('print("hello")');
+    expect(postMessageSpy).toHaveBeenCalledWith({ type: 'run', payload: { code: 'print("hello")' } });
+  });
+
+  it('should send an interrupt message to the worker on interrupt', () => {
+    const postMessageSpy = vi.spyOn(service['worker'] as Worker, 'postMessage');
+    service.interrupt();
+    expect(postMessageSpy).toHaveBeenCalledWith({ type: 'interrupt' });
+  });
+});
diff --git a/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.ts b/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.ts
new file mode 100644
index 0000000..2926018
--- /dev/null
+++ b/praxis/web-client/src/app/features/run-protocol/services/python-runtime.service.ts
@@ -0,0 +1,72 @@
+
+import { Injectable } from '@angular/core';
+import { Subject, Observable } from 'rxjs';
+
+/**
+ * Defines the structure for messages exchanged with the Python Web Worker.
+ */
+export interface PythonWorkerMessage {
+  type: 'status' | 'result' | 'error' | 'interrupt-acknowledged';
+  message?: string;
+  payload?: any;
+}
+
+@Injectable({
+  providedIn: 'root'
+})
+export class PythonRuntimeService {
+  private worker: Worker | undefined;
+  private messageSubject = new Subject<PythonWorkerMessage>();
+
+  /**
+   * Observable stream of messages from the Python worker.
+   */
+  public messages$: Observable<PythonWorkerMessage> = this.messageSubject.asObservable();
+
+  constructor() {
+    if (typeof Worker !== 'undefined') {
+      this.worker = new Worker(new URL('./python.worker.ts', import.meta.url), { type: 'module' });
+
+      this.worker.onmessage = ({ data }: MessageEvent<PythonWorkerMessage>) => {
+        this.messageSubject.next(data);
+      };
+
+      this.worker.onerror = (error) => {
+        console.error('An error occurred in the Python worker:', error);
+        this.messageSubject.next({
+          type: 'error',
+          message: 'worker-error',
+          payload: error.message,
+        });
+      };
+    } else {
+      console.error('Web Workers are not supported in this browser.');
+      this.messageSubject.next({ type: 'error', message: 'worker-unsupported' });
+    }
+  }
+
+  /**
+   * Executes Python code in the Web Worker.
+   * @param code The Python code to execute.
+   */
+  runCode(code: string): void {
+    this.worker?.postMessage({ type: 'run', payload: { code } });
+  }
+
+  /**
+   * Sends an interrupt signal to the Web Worker to stop Python execution.
+   */
+  interrupt(): void {
+    console.log('Attempting to interrupt Python execution...');
+    this.worker?.postMessage({ type: 'interrupt' });
+  }
+
+  /**
+   * Terminates the Web Worker.
+   */
+  terminate(): void {
+    this.worker?.terminate();
+    this.worker = undefined;
+    console.log('Python worker terminated.');
+  }
+}
diff --git a/praxis/web-client/src/app/features/run-protocol/services/python.worker.ts b/praxis/web-client/src/app/features/run-protocol/services/python.worker.ts
new file mode 100644
index 0000000..4b0681e
--- /dev/null
+++ b/praxis/web-client/src/app/features/run-protocol/services/python.worker.ts
@@ -0,0 +1,104 @@
+
+/// <reference lib="webworker" />
+
+import { loadPyodide, PyodideInterface } from 'pyodide';
+
+// Define a shared buffer for interruption
+const interruptBuffer = new Uint8Array(new SharedArrayBuffer(1));
+
+let pyodide: PyodideInterface | null = null;
+
+/**
+ * Initializes the Pyodide runtime and sets up the interrupt buffer.
+ */
+async function initializePyodide(): Promise<PyodideInterface | null> {
+  if (pyodide) {
+    return pyodide;
+  }
+
+  self.postMessage({ type: 'status', message: 'loading-pyodide' });
+
+  try {
+    const loadedPyodide = await loadPyodide({
+      indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/',
+    });
+
+    // Pass the interrupt buffer to Pyodide
+    loadedPyodide.setInterruptBuffer(interruptBuffer);
+    pyodide = loadedPyodide;
+
+    self.postMessage({ type: 'status', message: 'pyodide-ready' });
+    return pyodide;
+  } catch (error) {
+    const errorMessage = (error instanceof Error) ? error.message : String(error);
+    self.postMessage({
+      type: 'error',
+      message: 'pyodide-failed-to-load',
+      payload: errorMessage,
+    });
+    return null;
+  }
+}
+
+/**
+ * Handles incoming messages from the main thread.
+ */
+self.onmessage = async (event: MessageEvent) => {
+  const { type, payload } = event.data;
+
+  // Ensure Pyodide is initialized before handling messages
+  if (!pyodide) {
+    await initializePyodide();
+  }
+
+  if (!pyodide) {
+    console.error("Pyodide is not available.");
+    return;
+  }
+
+  switch (type) {
+    case 'run':
+      await runPythonCode(pyodide, payload.code);
+      break;
+
+    case 'interrupt':
+      // Interrupt the running Python code
+      interruptBuffer[0] = 2;
+      self.postMessage({ type: 'interrupt-acknowledged' });
+      break;
+  }
+};
+
+/**
+ * Executes Python code and handles the results.
+ * @param pyodideInstance The initialized Pyodide instance.
+ * @param code The Python code to execute.
+ */
+async function runPythonCode(pyodideInstance: PyodideInterface, code: string) {
+  // Reset the interrupt buffer before execution
+  interruptBuffer[0] = 0;
+  self.postMessage({ type: 'status', message: 'executing-python' });
+
+  try {
+    const result = await pyodideInstance.runPythonAsync(code);
+    self.postMessage({ type: 'result', payload: result });
+    self.postMessage({ type: 'status', message: 'python-execution-complete' });
+  } catch (error) {
+    const errorMessage = (error instanceof Error) ? error.message : String(error);
+    if (errorMessage.includes('KeyboardInterrupt')) {
+      self.postMessage({ type: 'status', message: 'python-execution-interrupted' });
+    } else {
+      self.postMessage({
+        type: 'error',
+        message: 'python-execution-error',
+        payload: errorMessage,
+      });
+    }
+  } finally {
+    // Ensure the interrupt buffer is cleared after execution
+    interruptBuffer[0] = 0;
+  }
+}
+
+// Initialize Pyodide as soon as the worker is created
+initializePyodide();

