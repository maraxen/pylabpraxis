diff --git a/artifacts/research_linked_indices.md b/artifacts/research_linked_indices.md
new file mode 100644
index 0000000..6aca0c1
--- /dev/null
+++ b/artifacts/research_linked_indices.md
@@ -0,0 +1,21 @@
+# Standardized Tracers for Linked Indices
+
+## Objective
+
+Validate linked indices (source and destination well alignment) in protocols.
+
+## Tracer Implementation
+
+A new `LinkedIndicesTracer` class has been created in `praxis/backend/tracers.py`. This class is responsible for tracking and validating linked indices. It has a `validate` method that takes source and destination well sets and returns `True` if they are valid, `False` otherwise.
+
+## Integration Points
+
+The `_execute_protocol_main_logic` method in `praxis/backend/core/orchestrator/execution.py` has been modified to use the `LinkedIndicesTracer`. Before executing the protocol, this method checks if the `requires_linked_indices` flag is set on the protocol definition. If it is, it uses the `LinkedIndicesTracer` to validate the source and destination well sets.
+
+## Error Handling
+
+A new `InvalidWellSetsError` exception has been added to `praxis/backend/utils/errors.py`. This exception is raised by the `LinkedIndicesTracer` if the well sets are invalid. The `_handle_protocol_execution_error` method in `praxis/backend/core/orchestrator/error_handling.py` has been modified to handle the `InvalidWellSetsError` exception. This method catches the exception and returns a user-friendly error message.
+
+## UI Feedback
+
+When an `InvalidWellSetsError` is caught, the protocol run is marked as `FAILED` and an error message is returned to the user. The error message includes the reason for the failure, e.g., "Source and destination well sets have different lengths."
diff --git a/praxis/backend/core/orchestrator/error_handling.py b/praxis/backend/core/orchestrator/error_handling.py
index 938f18d..de8967e 100644
--- a/praxis/backend/core/orchestrator/error_handling.py
+++ b/praxis/backend/core/orchestrator/error_handling.py
@@ -18,7 +18,11 @@ from praxis.backend.models import (
 )
 from praxis.backend.services.protocols import ProtocolRunService
 from praxis.backend.services.state import PraxisState
-from praxis.backend.utils.errors import PyLabRobotGenericError, PyLabRobotVolumeError
+from praxis.backend.utils.errors import (
+    InvalidWellSetsError,
+    PyLabRobotGenericError,
+    PyLabRobotVolumeError,
+)
 from praxis.backend.utils.logging import get_logger
 
 logger = get_logger(__name__)
@@ -112,6 +116,20 @@ class ErrorHandlingMixin:
           "traceback": traceback.format_exc(),
         },
       )
+    elif isinstance(e, InvalidWellSetsError):
+        logger.info(
+            "Invalid well sets error detected for run %s. Setting status to FAILED.",
+            run_accession_id,
+        )
+        final_run_status = ProtocolRunStatusEnum.FAILED
+        status_details = json.dumps(
+            {
+                "error_type": type(e).__name__,
+                "error_message": str(e),
+                "details": "Invalid well sets provided.",
+                "traceback": traceback.format_exc(),
+            },
+        )
 
     await self.protocol_run_service.update_run_status(
       db_session,
diff --git a/praxis/backend/core/orchestrator/execution.py b/praxis/backend/core/orchestrator/execution.py
index b2c694d..1e25f5e 100644
--- a/praxis/backend/core/orchestrator/execution.py
+++ b/praxis/backend/core/orchestrator/execution.py
@@ -124,6 +124,13 @@ class ExecutionMixin:
       protocol_def_orm,
     )
 
+    if protocol_pydantic_def.requires_linked_indices:
+        from praxis.backend.tracers import LinkedIndicesTracer
+        tracer = LinkedIndicesTracer()
+        source_wells = input_parameters.get("source_wells", [])
+        destination_wells = input_parameters.get("destination_wells", [])
+        tracer.validate(source_wells, destination_wells)
+
     main_workcell_container = self.workcell_runtime.get_main_workcell()
     if not main_workcell_container:
       error_msg = "Main Workcell container not available from WorkcellRuntime."
diff --git a/praxis/backend/models/pydantic_internals/protocol.py b/praxis/backend/models/pydantic_internals/protocol.py
index 5510fd0..a83ef5d 100644
--- a/praxis/backend/models/pydantic_internals/protocol.py
+++ b/praxis/backend/models/pydantic_internals/protocol.py
@@ -231,6 +231,7 @@ class FunctionProtocolDefinitionBase(BaseModel):
   deck_param_name: str | None = None
   deck_construction_function_fqn: str | None = None  # New field for deck construction callable
   state_param_name: str | None = "state"
+  requires_linked_indices: bool = False
 
   category: str | None = None
   tags: Any = Field(default_factory=list)
@@ -271,6 +272,7 @@ class FunctionProtocolDefinitionUpdate(BaseModel):
   deck_param_name: str | None = None
   deck_construction_function_fqn: str | None = None
   state_param_name: str | None = None
+  requires_linked_indices: bool | None = None
   category: str | None = None
   tags: list[str] | None = None
   deprecated: bool | None = None
diff --git a/praxis/backend/tracers.py b/praxis/backend/tracers.py
new file mode 100644
index 0000000..8e8daf9
--- /dev/null
+++ b/praxis/backend/tracers.py
@@ -0,0 +1,22 @@
+# pylint: disable=too-few-public-methods
+"""Tracers for protocol execution."""
+from typing import List
+
+from praxis.backend.utils.errors import InvalidWellSetsError
+
+
+class LinkedIndicesTracer:
+    """Tracer for validating linked indices."""
+
+    def validate(self, source_wells: List, destination_wells: List) -> bool:
+        """Validate that the source and destination wells are linked by index."""
+        if len(source_wells) != len(destination_wells):
+            raise InvalidWellSetsError("Source and destination well sets have different lengths.")
+
+        for i, source_well in enumerate(source_wells):
+            if source_well.index != destination_wells[i].index:
+                raise InvalidWellSetsError(
+                    f"Source well at index {i} has index {source_well.index}, but destination well has index {destination_wells[i].index}."
+                )
+
+        return True
diff --git a/praxis/backend/utils/errors.py b/praxis/backend/utils/errors.py
index a4f240e..f971402 100644
--- a/praxis/backend/utils/errors.py
+++ b/praxis/backend/utils/errors.py
@@ -1,7 +1,16 @@
 """Custom exceptions and logging utility for Praxis backend."""
 
 
+class InvalidWellSetsError(PraxisError):
+  """Raised when source and destination well sets are not linked by index."""
+
+
 class PraxisError(Exception):
+    """Base exception for all custom Praxis backend errors."""
+
+
+class InvalidWellSetsError(PraxisError):
+  """Raised when source and destination well sets are not linked by index."""
 
   """Base exception for all custom Praxis backend errors.
 
@@ -25,6 +34,10 @@ class PraxisError(Exception):
     return f"{self.message}"
 
 
+class InvalidWellSetsError(PraxisError):
+  """Raised when source and destination well sets are not linked by index."""
+
+
 class OrchestratorError(Exception):
 
   """Exception raised for errors in the orchestrator service.
diff --git a/tests/backend/test_tracers.py b/tests/backend/test_tracers.py
new file mode 100644
index 0000000..0939de2
--- /dev/null
+++ b/tests/backend/test_tracers.py
@@ -0,0 +1,34 @@
+"""Tests for tracers."""
+from unittest.mock import Mock
+
+import pytest
+
+from praxis.backend.tracers import LinkedIndicesTracer
+from praxis.backend.utils.errors import InvalidWellSetsError
+
+
+class TestLinkedIndicesTracer:
+    """Tests for LinkedIndicesTracer."""
+
+    def test_validate_linked_indices_success(self) -> None:
+        """Test that validate_linked_indices returns True for valid well sets."""
+        tracer = LinkedIndicesTracer()
+        source_wells = [Mock(index=0), Mock(index=1), Mock(index=2)]
+        destination_wells = [Mock(index=0), Mock(index=1), Mock(index=2)]
+        assert tracer.validate(source_wells, destination_wells)
+
+    def test_validate_linked_indices_different_lengths(self) -> None:
+        """Test that validate_linked_indices raises InvalidWellSetsError for different lengths."""
+        tracer = LinkedIndicesTracer()
+        source_wells = [Mock(index=0), Mock(index=1), Mock(index=2)]
+        destination_wells = [Mock(index=0), Mock(index=1)]
+        with pytest.raises(InvalidWellSetsError, match="Source and destination well sets have different lengths."):
+            tracer.validate(source_wells, destination_wells)
+
+    def test_validate_linked_indices_different_indices(self) -> None:
+        """Test that validate_linked_indices raises InvalidWellSetsError for different indices."""
+        tracer = LinkedIndicesTracer()
+        source_wells = [Mock(index=0), Mock(index=1), Mock(index=2)]
+        destination_wells = [Mock(index=0), Mock(index=1), Mock(index=3)]
+        with pytest.raises(InvalidWellSetsError, match="Source well at index 2 has index 2, but destination well has index 3."):
+            tracer.validate(source_wells, destination_wells)
diff --git a/tests/core/test_orchestrator.py b/tests/core/test_orchestrator.py
index 6478c93..9bcc2c9 100644
--- a/tests/core/test_orchestrator.py
+++ b/tests/core/test_orchestrator.py
@@ -6,7 +6,11 @@ import pytest
 
 from praxis.backend.core.orchestrator import Orchestrator
 from praxis.backend.services.state import PraxisState
-from praxis.backend.utils.errors import AssetAcquisitionError, ProtocolCancelledError
+from praxis.backend.utils.errors import (
+    AssetAcquisitionError,
+    InvalidWellSetsError,
+    ProtocolCancelledError,
+)
 from praxis.backend.utils.uuid import uuid7
 from praxis.backend.models import ProtocolRunStatusEnum
 
@@ -701,3 +705,89 @@ class TestOrchestratorExecutionFlow:
 
                         # Verify DB commit was called
                         assert mock_db_session.commit.called
+
+
+class TestLinkedIndicesValidation:
+    """Tests for linked indices validation."""
+
+    @pytest.mark.asyncio
+    async def test_linked_indices_validation_fails(self) -> None:
+        """Test that protocol execution fails when linked indices validation fails."""
+        # 1. Setup Mocks
+        mock_db_session = AsyncMock()
+        mock_db_session.commit = AsyncMock()
+        mock_db_session.rollback = AsyncMock()
+
+        mock_db_session_factory = Mock()
+        mock_db_session_factory.return_value.__aenter__ = AsyncMock(return_value=mock_db_session)
+        mock_db_session_factory.return_value.__aexit__ = AsyncMock(return_value=None)
+
+        mock_asset_manager = Mock()
+        mock_workcell_runtime = Mock()
+        mock_workcell_runtime.get_main_workcell.return_value = Mock()
+        mock_protocol_code_manager = Mock()
+
+        orchestrator = Orchestrator(
+            db_session_factory=mock_db_session_factory,
+            asset_manager=mock_asset_manager,
+            workcell_runtime=mock_workcell_runtime,
+            protocol_code_manager=mock_protocol_code_manager,
+        )
+
+        # 2. Mock Protocol Definition
+        async def dummy_protocol(**kwargs):
+            return {"result": "success"}
+
+        # Protocol Def ORM
+        mock_protocol_def_orm = Mock()
+        mock_protocol_def_orm.name = "test_protocol"
+        mock_protocol_def_orm.accession_id = uuid7()
+        mock_protocol_def_orm.version = "1.0.0"
+
+        # Protocol Pydantic Def
+        mock_pydantic_def = Mock()
+        mock_pydantic_def.name = "test_protocol"
+        mock_pydantic_def.parameters = []
+        mock_pydantic_def.assets = []
+        mock_pydantic_def.state_param_name = None
+        mock_pydantic_def.preconfigure_deck = False
+        mock_pydantic_def.deck_construction_function_fqn = None
+        mock_pydantic_def.deck_param_name = None
+        mock_pydantic_def.requires_linked_indices = True
+
+        # Mock Protocol Code Manager
+        mock_protocol_code_manager.prepare_protocol_code = AsyncMock(
+            return_value=(dummy_protocol, mock_pydantic_def)
+        )
+
+        # Mock Service calls
+        mock_run_orm = Mock()
+        mock_run_orm.accession_id = uuid7()
+        mock_run_orm.status = ProtocolRunStatusEnum.PREPARING
+
+        with patch("praxis.backend.core.orchestrator.execution.svc") as mock_svc_exec:
+            with patch("praxis.backend.core.orchestrator.protocol_preparation.svc") as mock_svc_prep:
+                with patch("praxis.backend.core.orchestrator.execution.get_control_command", AsyncMock(return_value=None)):
+                    with patch("praxis.backend.core.orchestrator.protocol_preparation.PraxisState") as mock_praxis_state_cls:
+                        # Setup PraxisState mock instance
+                        mock_state_instance = mock_praxis_state_cls.return_value
+                        mock_state_instance.set = AsyncMock()
+                        mock_state_instance.update = Mock()
+
+                        # Setup returns
+                        mock_svc_prep.read_protocol_definition_by_name = AsyncMock(return_value=mock_protocol_def_orm)
+                        mock_svc_exec.create_protocol_run = AsyncMock(return_value=mock_run_orm)
+
+                        # 3. Execute Protocol and Assert Exception
+                        with patch("praxis.backend.core.orchestrator.execution.LinkedIndicesTracer") as mock_tracer:
+                            mock_tracer.return_value.validate.side_effect = InvalidWellSetsError(
+                                "Well sets are not linked."
+                            )
+                            with pytest.raises(InvalidWellSetsError, match="Well sets are not linked."):
+                                await orchestrator.execute_protocol(
+                                    protocol_name="test_protocol",
+                                    input_parameters={
+                                        "source_wells": [Mock(index=0)],
+                                        "destination_wells": [Mock(index=1)],
+                                    },
+                                )

