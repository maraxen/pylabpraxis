# Lite Mode & Offline SQLite Strategy Research

> Generated by @deep-researcher agent - 2026-01-20

## 1. Executive Summary

Praxis currently supports two "offline-capable" modes: **Browser Mode** (using `sql.js` with IndexedDB persistence) and **Lite Mode** (using a local Python server with SQLite). While functional, the current Browser Mode persistence strategy—exporting and re-importing the entire database on every write—presents significant performance bottlenecks and scalability issues as user data grows.

This research recommends a transition to **SQLite Wasm with Origin Private File System (OPFS)** for the Browser Mode, while maintaining the **Lite Mode** for users requiring a local server environment.

---

## 2. Options Evaluation

| Option | Technology | Persistence Mechanism | Performance (Large DB) | Use Case |
| :--- | :--- | :--- | :--- | :--- |
| **A) Browser-only (Current)** | `sql.js` + IndexedDB | Full binary dump to IDB on every write. | **Poor**. O(N) write cost; blocks main thread for large exports. | Quick demos, education. |
| **B) absurd-sql** | `sql.js` + block-level IDB | Treating IDB as block storage. | **Good**. Near-native for small random writes. | (Deprecated/Unmaintained). |
| **C) SQLite Wasm + OPFS** | **Official SQLite Wasm** | **Native OPFS** (Direct filesystem access). | **Excellent**. Near-native performance; handles GB-scale DBs. | **Recommended for Standalone.** |
| **D) Lite Mode (Python)** | `aiosqlite` + Native File | Local `.db` file on host disk. | **Excellent**. Full SQLite power. | Air-gapped labs, local dev. |

### Technical Analysis

#### A) Current Implementation (`sql.js` + IndexedDB)

- **Mechanism**: The `SqliteService` loads the DB into WASM memory. Every change requires `db.export()` (binary serialization) and a `put` to IndexedDB.
- **Constraint**: Browser memory limits (usually 2GB for WASM) and serialization overhead. As the DB hits >50MB, UI stutters become noticeable during saves.

#### B) absurd-sql

- **Status**: Effectively unmaintained.
- **Issues**: Relies on `SharedArrayBuffer` hacks and complex Web Worker orchestration that has been superseded by official SQLite efforts.

#### C) SQLite Wasm + OPFS (Recommended)

- **Mechanism**: Uses the modern `Origin Private File System` (OPFS) which provides a performant, private filesystem for web apps.
- **Benefits**:
  - **Random Access**: Only changed pages are written to disk.
  - **Official Support**: Maintained by the SQLite team.
  - **Scalability**: Supports databases much larger than available RAM.
- **Complexity**: Requires `SharedArrayBuffer` for the best VFS (Virtual File System) performance, which mandates COOP/COEP headers. However, the `opfs-sahpool` VFS offers a high-performance alternative with fewer header requirements.

---

## 3. Use Case Analysis

1. **Education/Demo Mode**: Current "Browser Mode" is sufficient for 90% of cases, but "SQLite Wasm + OPFS" would make it feel more "professional" and robust.
2. **Air-Gapped Lab Environments**: These users usually prefer the **Lite Mode (Python)** because they often need to interface with physical hardware via local drivers that require a full Python environment (pylabrobot).
3. **Offline-First Operation**: For users designing protocols on planes/trains, the Browser Mode with OPFS provides the most reliable experience.

---

## 4. Recommendation

**Transition Browser Mode to SQLite Wasm + OPFS.**

**Rationale:**

1. **User Experience**: Eliminates the "save lag" experienced in the current implementation.
2. **Future Proofing**: Aligns with official SQLite recommendations for the web.
3. **Simplified Logic**: Moves away from manual IDB management (dumping/loading) to a more standard filesystem-like API.

---

## 5. Implementation Outline

### Phase 1: Infrastructure (Low Effort)

1. Replace `sql.js` dependency with `@sqlite.org/sqlite-wasm`.
2. Set up the SQLite Web Worker to handle OPFS operations (mandatory for synchronous file access).

### Phase 2: Service Migration (Medium Effort)

1. Refactor `SqliteService` to communicate with the SQLite Worker instead of holding a local `sql.js` instance.
2. Implement a migration path: On first load with the new engine, detect the `praxis_db` in IndexedDB, export it once, and move it into the OPFS file.

### Phase 3: Enhanced Lite Mode (Optional/Future)

1. Evaluate **Pyodide + OPFS** integration. This would allow the "Lite Mode" (Python execution) to run entirely in the browser while sharing the same persistent SQLite database as the UI.

---

## 6. Effort Estimate

- **Total Effort**: ~3-5 development days.
- **Complexity**: Medium (requires familiarity with Web Workers and COOP/COEP browser security headers).

---

## 7. Success Criteria

- Database writes do not block the UI thread.
- Page refreshes instantly restore the database state from OPFS without a full "loading" progress bar for large DBs.
- Export/Import functionality is preserved using OPFS file copying.
