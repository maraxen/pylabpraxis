# Debugging Notes for Test Suite Failures

This document summarizes the investigation and fixes applied to the test suite, and details the remaining blocking issues.

## Summary of Progress

The initial goal was to get the test suite running and fix the various errors. A cascading series of failures was identified, starting with a Pydantic validation error and leading to deeper infrastructure issues.

### 1. `PydanticUserError` (Fixed)

*   **Problem**: The tests were failing with `pydantic.errors.PydanticUserError: Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly`.
*   **Root Cause**: The generic `create_crud_router` in `praxis/backend/api/utils/crud_router_factory.py` was using FastAPI's dependency injection with a `TypeVar` (`CreateSchemaType`). This caused FastAPI to inject a generic `pydantic.BaseModel` instance instead of the specific Pydantic schema required by the endpoint.
*   **Solution**: The `create` endpoint in the router factory was modified to accept a raw `Request` object. The request body is now manually parsed using `await request.json()` and then validated against the correct schema (`create_schema.model_validate(obj_in_data)`). This bypasses the dependency injection issue and ensures the correct Pydantic model is created.

### 2. `ValidationError` in Test Payload (Fixed)

*   **Problem**: The `test_create_deck` test was failing with a `pydantic_core.ValidationError`.
*   **Root Cause**:
    1.  The test payload was missing the required `asset_type` field.
    2.  The `machine_id` was being generated by `factory-boy` as a version 4 UUID, but the Pydantic schema (`DeckCreate`) expected a version 7 UUID.
*   **Solution**:
    1.  The `asset_type` was added to the JSON payload in `tests/api/test_decks.py` with the correct uppercase value (`"DECK"`).
    2.  A `uuid7` generator function was implemented in `tests/factories.py` and used for all `accession_id` fields in the factories to ensure the correct UUID version was generated.

### 3. Cascading `TypeError`s (Partially Fixed)

*   **Problem**: Once the `PydanticUserError` was resolved, a series of `TypeError: __init__() got an unexpected keyword argument '...'` errors appeared in the service layer.
*   **Root Cause**: The Pydantic schemas contain fields that the SQLAlchemy ORM models do not expect in their constructors (e.g., `accession_id`, `created_at`, `children`, `parent`, `machine_id`, etc.). These fields are either handled automatically by the database (like timestamps) or are relationship-based.
*   **Solution**: A "whack-a-mole" approach was taken to exclude these unexpected fields from the dictionary passed to the ORM model's constructor within each service's `create` method. This involved using `.model_dump(exclude={...})` or `.pop()` on the data dictionary. While effective, this is a brittle solution. A more centralized fix in a `CRUDBase` class was attempted but proved ineffective as services were overriding the base `create` method.

---

## Remaining Blockers

Despite the fixes above, two fundamental infrastructure errors remain that prevent the test suite from passing. These appear to be related to the `asyncio` event loop and database transaction management within the `pytest` environment.

### 1. `sqlalchemy.exc.InterfaceError: another operation is in progress`

*   **Description**: This error occurs during the database flush operation when `factory-boy` creates model instances within a test. It indicates a conflict in transaction management.
*   **Hypothesis**: The `db` fixture in `tests/conftest.py` creates a transaction that is rolled back at the end of each test. However, the `factories_session` fixture was instructing `factory-boy` to `commit` the session, which conflicts with the outer, ongoing transaction.
*   **Attempts to Fix**:
    1.  Changed `sqlalchemy_session_persistence` from `"commit"` to `"flush"` in `tests/conftest.py`. This is the correct approach, but it did not resolve the issue, suggesting the problem might be more subtle.
    2.  Consolidated the factory session setup into the `db` fixture to ensure a single point of session management. This also did not resolve the error.

### 2. `RuntimeError: Task attached to a different loop`

*   **Description**: This error indicates a conflict between different `asyncio` event loops. The components involved (the test runner, the database driver, and the FastAPI application) are not sharing the same event loop.
*   **Hypothesis**: This is a classic issue when using `pytest-asyncio`. It is often caused by manually creating or setting an event loop in a way that conflicts with the loop provided and managed by `pytest-asyncio` itself.
*   **Attempts to Fix**:
    1.  Removed the manually defined `event_loop` fixture from `tests/conftest.py`.
    2.  Attempted various ways of getting and setting the event loop within the `event_loop` and `db` fixtures.

These two errors are the primary blockers. Resolving them is critical to creating a stable test environment.
