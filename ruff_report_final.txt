warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/deck_manager.py:68. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/deck_manager.py:344. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/machine_manager.py:36. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/machine_manager.py:373. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/machine_manager.py:412. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/resource_manager.py:36. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
warning: Unexpected `# ruff: noqa` directive at praxis/backend/core/workcell_runtime/state_sync.py:64. File-level suppression comments must appear on their own line. For line-level suppression, omit the `ruff:` prefix.
BLE001 Do not catch blind exception: `Exception`
  --> praxis/backend/api/discovery.py:35:10
   |
33 |       content={"message": "Discovery and synchronization initiated successfully."},
34 |     )
35 |   except Exception as e:
   |          ^^^^^^^^^
36 |     return JSONResponse(
37 |       status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
   |

FAST001 FastAPI route with redundant `response_model` argument
  --> praxis/backend/api/machines.py:67:3
   |
65 | @router.patch(
66 |   "/{accession}/status",
67 |   response_model=MachineResponse,
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |   tags=["Machines"],
69 | )
   |
help: Remove argument

INP001 File `praxis/backend/api/utils/crud_router_factory.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/api/utils/crud_router_factory.py:1:1

FAST002 FastAPI dependency without `Annotated`
  --> praxis/backend/api/utils/crud_router_factory.py:44:5
   |
42 |   async def create(
43 |     request: Request,
44 |     db: AsyncSession = Depends(get_db),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |   ) -> ModelType:
46 |     obj_in_data = await request.json()
   |
help: Replace with `typing.Annotated`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
  --> praxis/backend/api/utils/crud_router_factory.py:44:24
   |
42 |   async def create(
43 |     request: Request,
44 |     db: AsyncSession = Depends(get_db),
   |                        ^^^^^^^^^^^^^^^
45 |   ) -> ModelType:
46 |     obj_in_data = await request.json()
   |

D100 Missing docstring in public module
--> praxis/backend/celery_app.py:1:1

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/configure.py:177:5
    |
175 |     """Return the protocol output directory path."""
176 |     path = self._output_directories_section.get("protocol_output", "./protocol_output")
177 |     os.makedirs(path, exist_ok=True)  # Ensure the directory exists
    |     ^^^^^^^^^^^
178 |     return path
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> praxis/backend/configure.py:201:20
    |
199 |     Ensures the directory exists.
200 |     """
201 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                    ^^^^^^^^^^^^
202 |     path = self._protocol_directories_section.get("default_directory", default_path)
203 |     os.makedirs(
    |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> praxis/backend/configure.py:201:33
    |
199 |     Ensures the directory exists.
200 |     """
201 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
    |                                 ^^^^^^^^^^^^^^^
202 |     path = self._protocol_directories_section.get("default_directory", default_path)
203 |     os.makedirs(
    |
help: Replace with `Path(...).parent`

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/configure.py:203:5
    |
201 |     default_path = os.path.join(os.path.dirname(__file__), "protocol", "protocols")
202 |     path = self._protocol_directories_section.get("default_directory", default_path)
203 |     os.makedirs(
    |     ^^^^^^^^^^^
204 |       path,
205 |       exist_ok=True,
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:236:19
    |
235 |     # Add default protocol directory
236 |     all_paths.add(os.path.abspath(self.default_protocol_dir))
    |                   ^^^^^^^^^^^^^^^
237 |
238 |     # Add additional directories
    |
help: Replace with `Path(...).resolve()`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:240:21
    |
238 |     # Add additional directories
239 |     for d in self.additional_directories:
240 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^
241 |
242 |     # Add protocol discovery directories
    |
help: Replace with `Path(...).resolve()`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> praxis/backend/configure.py:244:21
    |
242 |     # Add protocol discovery directories
243 |     for d in self.protocol_discovery_dirs:
244 |       all_paths.add(os.path.abspath(d))
    |                     ^^^^^^^^^^^^^^^
245 |
246 |     return sorted(all_paths)
    |
help: Replace with `Path(...).resolve()`

PTH123 `open()` should be replaced by `Path.open()`
   --> praxis/backend/configure.py:287:10
    |
285 |     self._config_parser.set("keycloak", "client_secret", client_secret)
286 |
287 |     with open(self._config_file_path, "w") as f:
    |          ^^^^
288 |       self._config_parser.write(f)
    |
help: Replace with `Path.open()`

ARG002 Unused method argument: `redis_url`
  --> praxis/backend/core/asset_lock_manager.py:14:22
   |
12 |   """A simple in-memory asset lock manager."""
13 |
14 |   def __init__(self, redis_url: str | None = None) -> None:
   |                      ^^^^^^^^^
15 |     """Initialize the AssetLockManager."""
16 |     self._locks: dict[str, AcquireAssetLock] = {}
   |

ARG002 Unused method argument: `reservation_id`
  --> praxis/backend/core/asset_lock_manager.py:35:5
   |
33 |     asset_type: str,
34 |     asset_name: str,
35 |     reservation_id: uuid.UUID,
   |     ^^^^^^^^^^^^^^
36 |     protocol_run_id: uuid.UUID | None = None,
37 |   ) -> bool:
   |

ARG002 Unused method argument: `protocol_run_id`
  --> praxis/backend/core/asset_lock_manager.py:36:5
   |
34 |     asset_name: str,
35 |     reservation_id: uuid.UUID,
36 |     protocol_run_id: uuid.UUID | None = None,
   |     ^^^^^^^^^^^^^^^
37 |   ) -> bool:
38 |     """Release a lock on an asset."""
   |

SLF001 Private member accessed: `_handle_location_constraints`
   --> praxis/backend/core/asset_manager/resource_manager.py:229:15
    |
227 |       target_position_name,
228 |       final_status_details,
229 |     ) = await cast("LocationHandlerMixin", self)._handle_location_constraints(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
230 |       is_acquiring_a_deck_resource,
231 |       resource_data.location_constraints,
    |

D100 Missing docstring in public module
--> praxis/backend/core/celery_base.py:1:1

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:13:3
   |
11 |   class PraxisTask(Task):
12 |
13 | /   """A custom Celery Task class for Praxis that integrates with the dependency injection container.
14 | |   """
   | |_____^
15 |
16 |     @property
   |
help: Reformat to one line

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:18:5
   |
16 |     @property
17 |     def container(self) -> Container:
18 | /     """Returns the dependency injection container.
19 | |     """
   | |_______^
20 |       # The container is attached to the app instance.
21 |       return self.app.container
   |
help: Reformat to one line

ANN204 Missing return type annotation for special method `__call__`
  --> praxis/backend/core/celery_base.py:23:7
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |       ^^^^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/celery_base.py:23:22
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |                      ^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/celery_base.py:23:29
   |
21 |     return self.app.container
22 |
23 |   def __call__(self, *args, **kwargs):
   |                             ^^^^^^^^
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 |     """
   |

D200 One-line docstring should fit on one line
  --> praxis/backend/core/celery_base.py:24:5
   |
23 |     def __call__(self, *args, **kwargs):
24 | /     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 | |     """
   | |_______^
26 |       with self.container.db_session.override(self.container.db_session_factory()):
27 |         return super().__call__(*args, **kwargs)
   |
help: Reformat to one line

D401 First line of docstring should be in imperative mood: "Overrides the default `__call__` method to provide a DI container scope for each task execution."
  --> praxis/backend/core/celery_base.py:24:5
   |
23 |     def __call__(self, *args, **kwargs):
24 | /     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
25 | |     """
   | |_______^
26 |       with self.container.db_session.override(self.container.db_session_factory()):
27 |         return super().__call__(*args, **kwargs)
   |

E501 Line too long (103 > 100)
  --> praxis/backend/core/celery_base.py:24:101
   |
23 |   def __call__(self, *args, **kwargs):
24 |     """Overrides the default `__call__` method to provide a DI container scope for each task execution.
   |                                                                                                     ^^^
25 |     """
26 |     with self.container.db_session.override(self.container.db_session_factory()):
   |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/celery_tasks.py:120:9
    |
118 |       if not protocol_run_orm:
119 |         msg = f"Protocol run {protocol_run_id} not found."
120 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^
121 |
122 |       await protocol_run_service.update_run_status(
    |

TID252 Prefer absolute imports over relative imports from parent modules
  --> praxis/backend/core/container.py:26:1
   |
24 | from praxis.backend.services.workcell import WorkcellService
25 |
26 | from ..utils.filesystem import RealFileSystem
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 | from .asset_lock_manager import AssetLockManager
28 | from .asset_manager import AssetManager
   |
help: Replace relative imports from parent modules with absolute imports

ERA001 Found commented-out code
   --> praxis/backend/core/container.py:122:3
    |
121 |   # Singleton provider: one instance for the entire app lifecycle.
122 |   # discovery_service = providers.Singleton(DiscoveryService)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |
124 |   # Factory provider: a new instance is created on each injection.
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/core/container.py:126:3
    |
124 |   # Factory provider: a new instance is created on each injection.
125 |   # e.g. for a service that holds request-specific state.
126 |   # transient_service = providers.Factory(MyTransientService)
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |   # --- Database ---
    |
help: Remove commented-out code

PIE794 Class field `asset_manager` is defined multiple times
   --> praxis/backend/core/container.py:215:3
    |
213 |     )
214 |
215 | /   asset_manager: providers.Factory[IAssetManager] = providers.Factory(
216 | |     AssetManager,
217 | |     db_session=db_session,
218 | |     workcell_runtime=workcell_runtime,
219 | |     deck_service=deck_service,
220 | |     machine_service=machine_service,
221 | |     resource_service=resource_service,
222 | |     resource_type_definition_service=resource_type_definition_service,
223 | |     asset_lock_manager=asset_lock_manager,
224 | |   )
    | |___^
225 |
226 |     orchestrator: providers.Factory[IOrchestrator] = providers.Factory(
    |
help: Remove duplicate field definition for `asset_manager`

D104 Missing docstring in public package
--> praxis/backend/core/decorators/__init__.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/definition_builder.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/models.py:1:1

TC003 Move standard library import `uuid` into a type-checking block
 --> praxis/backend/core/decorators/models.py:2:8
  |
1 | import contextvars
2 | import uuid
  |        ^^^^
3 | from collections.abc import Callable
4 | from dataclasses import dataclass
  |
help: Move into type-checking block

D101 Missing docstring in public class
  --> praxis/backend/core/decorators/models.py:25:7
   |
24 | @dataclass
25 | class CreateProtocolDefinitionData:
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |   func: Callable
27 |   name: str | None
   |

D100 Missing docstring in public module
--> praxis/backend/core/decorators/parameter_processor.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/decorators/protocol_decorator.py:1:1

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/core/decorators/protocol_decorator.py:96:5
   |
94 |       parent_function_call_log_accession_id=parent_log_id,
95 |     )
96 |     return call_log_entry_orm.accession_id
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |   except Exception:  # pylint: disable=broad-except
98 |     logger.exception(
   |

C901 `protocol_function` is too complex (17 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

PLR0913 Too many arguments in function definition (13 > 8)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

PLR0915 Too many statements (65 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:153:5
    |
153 | def protocol_function(
    |     ^^^^^^^^^^^^^^^^^
154 |   name: str | None = None,
155 |   version: str = "0.1.0",
    |

C901 `decorator` is too complex (16 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:197:7
    |
195 |   actual_tags = tags or []
196 |
197 |   def decorator(func: Callable) -> Callable:
    |       ^^^^^^^^^
198 |     protocol_definition, found_state_param_details = _create_protocol_definition(
199 |       CreateProtocolDefinitionData(
    |

PLR0915 Too many statements (61 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:197:7
    |
195 |   actual_tags = tags or []
196 |
197 |   def decorator(func: Callable) -> Callable:
    |       ^^^^^^^^^
198 |     protocol_definition, found_state_param_details = _create_protocol_definition(
199 |       CreateProtocolDefinitionData(
    |

SLF001 Private member accessed: `_protocol_definition`
   --> praxis/backend/core/decorators/protocol_decorator.py:216:5
    |
214 |       ),
215 |     )
216 |     cast("Any", func)._protocol_definition = protocol_definition
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:218:7
    |
216 |     cast("Any", func)._protocol_definition = protocol_definition
217 |
218 |     # TODO: The protocol registration should be handled by a discovery service.
    |       ^^^^
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |

ERA001 Found commented-out code
   --> praxis/backend/core/decorators/protocol_decorator.py:219:5
    |
218 |     # TODO: The protocol registration should be handled by a discovery service.
219 |     # _register_protocol(protocol_definition, func, found_state_param_details)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |
221 |     # Create the runtime info object and attach it to the function.
    |
help: Remove commented-out code

SLF001 Private member accessed: `_protocol_runtime_info`
   --> praxis/backend/core/decorators/protocol_decorator.py:228:5
    |
226 |       found_state_param_details=found_state_param_details,
227 |     )
228 |     cast("Any", func)._protocol_runtime_info = protocol_runtime_info
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |
230 |     @functools.wraps(func)
    |

C901 `wrapper` is too complex (15 > 10)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

PLR0912 Too many branches (17 > 12)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

PLR0915 Too many statements (56 > 50)
   --> praxis/backend/core/decorators/protocol_decorator.py:231:15
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |               ^^^^^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:30
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                              ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:45
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                             ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
   --> praxis/backend/core/decorators/protocol_decorator.py:231:53
    |
230 |     @functools.wraps(func)
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                                     ^^^
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |

SLF001 Private member accessed: `_protocol_runtime_info`
   --> praxis/backend/core/decorators/protocol_decorator.py:233:22
    |
231 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
232 |       # Get the runtime metadata from the function itself, not a global registry.
233 |       current_meta = func._protocol_runtime_info
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
234 |       protocol_unique_key = (
235 |         f"{current_meta.pydantic_definition.name}_v{current_meta.pydantic_definition.version}"
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:380:9
    |
378 |       )
379 |       await db_session.commit()
380 |       # TODO: Dispatch to intervention handler
    |         ^^^^
381 |
382 |     elif command == "PAUSE":
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/core/decorators/protocol_decorator.py:499:9
    |
497 |       )
498 |       await db_session.commit()
499 |       # TODO: dispatch to intervention handler
    |         ^^^^
    |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/core/filesystem.py:20:5
   |
18 |     errors: str | None = None,
19 |     newline: str | None = None,
20 |     closefd: bool = True,
   |     ^^^^^^^
21 |     opener: Any | None = None,
22 |   ) -> IO[Any]: ...
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/core/filesystem.py:20:5
   |
18 |     errors: str | None = None,
19 |     newline: str | None = None,
20 |     closefd: bool = True,
   |     ^^^^^^^
21 |     opener: Any | None = None,
22 |   ) -> IO[Any]: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `opener`
  --> praxis/backend/core/filesystem.py:21:13
   |
19 |     newline: str | None = None,
20 |     closefd: bool = True,
21 |     opener: Any | None = None,
   |             ^^^^^^^^^^
22 |   ) -> IO[Any]: ...
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> praxis/backend/core/filesystem.py:26:12
   |
24 |   def open(self, *args: Any, **kwargs: Any) -> IO[Any]:
25 |     """Open a file and return a file object."""
26 |     return open(*args, **kwargs)
   |            ^^^^
27 |
28 |   def exists(self, path: str | bytes | int) -> bool:
   |
help: Replace with `Path.open()`

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/core/filesystem.py:46:66
   |
44 |     Path(path).mkdir(mode=mode)
45 |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
   |                                                                  ^^^^^^^^
47 |     """Create a directory named path with numeric mode mode."""
48 |     Path(path).mkdir(mode=mode, parents=True, exist_ok=exist_ok)
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/core/filesystem.py:46:66
   |
44 |     Path(path).mkdir(mode=mode)
45 |
46 |   def makedirs(self, path: str | bytes | int, mode: int = 0o777, exist_ok: bool = False) -> None:
   |                                                                  ^^^^^^^^
47 |     """Create a directory named path with numeric mode mode."""
48 |     Path(path).mkdir(mode=mode, parents=True, exist_ok=exist_ok)
   |

PERF203 `try`-`except` within a loop incurs performance overhead
  --> praxis/backend/core/orchestrator/asset_acquisition.py:64:7
   |
62 |             live_obj,
63 |           )
64 | /       except AssetAcquisitionError as e:
65 | |         if asset_req_model.optional:
66 | |           logger.warning(
67 | |             "ORCH-ACQUIRE: Optional asset '%s' could not be acquired: %s. Proceeding as it's optional.",
68 | |             asset_req_model.name,
69 | |             e,
70 | |           )
71 | |           final_args[asset_req_model.name] = None
72 | |         else:
73 | |           error_msg = (
74 | |             f"Failed to acquire mandatory asset '{asset_req_model.name}' for "
75 | |             f"protocol '{protocol_pydantic_def.name}': {e}"
76 | |           )
77 | |           logger.exception(error_msg)
78 | |           raise ValueError(error_msg) from e
   | |____________________________________________^
79 |         except Exception as e_general:
80 |           error_msg = (
   |

E501 Line too long (104 > 100)
  --> praxis/backend/core/orchestrator/asset_acquisition.py:67:101
   |
65 |         if asset_req_model.optional:
66 |           logger.warning(
67 |             "ORCH-ACQUIRE: Optional asset '%s' could not be acquired: %s. Proceeding as it's optional.",
   |                                                                                                     ^^^^
68 |             asset_req_model.name,
69 |             e,
   |

E501 Line too long (103 > 100)
   --> praxis/backend/core/orchestrator/asset_acquisition.py:154:101
    |
152 |       elif deck_param_name in final_args:
153 |         logger.warning(
154 |           "Deck parameter '%s' was already processed (e.g., as an asset). Review protocol definition.",
    |                                                                                                     ^^^
155 |           deck_param_name,
156 |         )
    |

TRY003 Avoid specifying long messages outside the exception class
  --> praxis/backend/core/orchestrator/error_handling.py:38:13
   |
36 |     """Validate the PraxisState object."""
37 |     if praxis_state is None:
38 |       raise ValueError("PraxisState is None")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |
40 |   async def _handle_protocol_execution_error(
   |

EM101 Exception must not use a string literal, assign to variable first
  --> praxis/backend/core/orchestrator/error_handling.py:38:24
   |
36 |     """Validate the PraxisState object."""
37 |     if praxis_state is None:
38 |       raise ValueError("PraxisState is None")
   |                        ^^^^^^^^^^^^^^^^^^^^^
39 |
40 |   async def _handle_protocol_execution_error(
   |
help: Assign to variable; remove string literal

LOG014 `exc_info=` outside exception handlers
  --> praxis/backend/core/orchestrator/error_handling.py:54:7
   |
52 |       protocol_def_name,
53 |       e,
54 |       exc_info=True,
   |       ^^^^^^^^^^^^^
55 |     )
56 |     error_info = {
   |
help: Remove `exc_info=`

E501 Line too long (112 > 100)
  --> praxis/backend/core/orchestrator/error_handling.py:89:101
   |
87 |     if isinstance(e, PyLabRobotVolumeError):
88 |       logger.info(
89 |         "Specific PyLabRobot error 'VolumeError' detected for run %s. Setting status to REQUIRES_INTERVENTION.",
   |                                                                                                     ^^^^^^^^^^^^
90 |         run_accession_id,
91 |       )
   |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/orchestrator/error_handling.py:174:9
    |
172 |               asset_orm_accession_id,
173 |             )
174 | /         except Exception as release_err:  # pylint: disable=broad-except
175 | |           logger.error(
176 | |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
177 | |             asset_info.get("name_in_protocol", "UnknownAsset"),
178 | |             asset_info.get("orm_accession_id"),
179 | |             release_err,
180 | |             exc_info=True,
181 | |           )
    | |___________^
182 |
183 |       await db_session.merge(protocol_run_orm)
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/error_handling.py:175:18
    |
173 |           )
174 |         except Exception as release_err:  # pylint: disable=broad-except
175 |           logger.error(
    |                  ^^^^^
176 |             "ORCH-RELEASE: Failed to release asset '%s' (ORM ID: %s): %s",
177 |             asset_info.get("name_in_protocol", "UnknownAsset"),
    |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:40:56
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                        ^^^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:40:63
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                               ^^^^^^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_get_protocol_definition_orm_from_db`
  --> praxis/backend/core/orchestrator/execution.py:40:76
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
   |                                                                            ^^^
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:41:42
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                          ^^^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:41:49
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                                 ^^^^^^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_prepare_protocol_code`
  --> praxis/backend/core/orchestrator/execution.py:41:62
   |
39 |   # Type hints for methods from other mixins
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
   |                                                              ^^^
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:42:43
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                           ^^^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:42:50
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                                  ^^^^^^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_initialize_run_context`
  --> praxis/backend/core/orchestrator/execution.py:42:63
   |
40 |   async def _get_protocol_definition_orm_from_db(self, *args, **kwargs) -> Any: ...
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
   |                                                               ^^^
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:43:38
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                      ^^^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:43:45
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                             ^^^^^^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_prepare_arguments`
  --> praxis/backend/core/orchestrator/execution.py:43:58
   |
41 |   async def _prepare_protocol_code(self, *args, **kwargs) -> Any: ...
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
   |                                                          ^^^
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:44:42
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                          ^^^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:44:49
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                                 ^^^^^^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_finalize_protocol_run`
  --> praxis/backend/core/orchestrator/execution.py:44:62
   |
42 |   async def _initialize_run_context(self, *args, **kwargs) -> Any: ...
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
   |                                                              ^^^
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |

ANN002 Missing type annotation for `*args`
  --> praxis/backend/core/orchestrator/execution.py:45:52
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                    ^^^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/core/orchestrator/execution.py:45:59
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                           ^^^^^^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_handle_protocol_execution_error`
  --> praxis/backend/core/orchestrator/execution.py:45:72
   |
43 |   async def _prepare_arguments(self, *args, **kwargs) -> Any: ...
44 |   async def _finalize_protocol_run(self, *args, **kwargs) -> Any: ...
45 |   async def _handle_protocol_execution_error(self, *args, **kwargs) -> Any: ...
   |                                                                        ^^^
46 |
47 |   async def _handle_pre_execution_checks(
   |

SLF001 Private member accessed: `_load_callable_from_fqn`
   --> praxis/backend/core/orchestrator/execution.py:143:32
    |
141 |     deck_construction_func = None
142 |     if protocol_pydantic_def.deck_construction_function_fqn:
143 |       deck_construction_func = self.protocol_code_manager._load_callable_from_fqn(
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
144 |         protocol_pydantic_def.deck_construction_function_fqn,
145 |       )
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/execution.py:293:18
    |
291 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
292 |         except Exception as db_final_err:  # pylint: disable=broad-except
293 |           logger.error(
    |                  ^^^^^
294 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
295 |             run_accession_id,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/orchestrator/execution.py:424:18
    |
422 |           logger.info("ORCH: Final DB commit for run %s successful.", run_accession_id)
423 |         except Exception as db_final_err:
424 |           logger.error(
    |                  ^^^^^
425 |             "ORCH: CRITICAL - Failed to commit final updates for run %s: %s",
426 |             run_accession_id,
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/orchestrator/protocol_preparation.py:190:36
    |
188 |     # Expects _acquire_assets and _handle_deck_preconfiguration from AssetAcquisitionMixin
189 |     if hasattr(self, "_acquire_assets"):
190 |       await self._acquire_assets(  # type: ignore
    |                                    ^^^^^^^^^^^^^^
191 |         protocol_pydantic_def,
192 |         protocol_run_accession_id,
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/orchestrator/protocol_preparation.py:198:50
    |
197 |     if hasattr(self, "_handle_deck_preconfiguration"):
198 |       await self._handle_deck_preconfiguration(  # type: ignore
    |                                                  ^^^^^^^^^^^^^^
199 |         db_session,
200 |         protocol_pydantic_def,
    |

ANN201 Missing return type annotation for public function `temporary_sys_path`
  --> praxis/backend/core/protocol_code_manager.py:32:5
   |
31 | @contextlib.contextmanager
32 | def temporary_sys_path(path_to_add: str | None):
   |     ^^^^^^^^^^^^^^^^^^
33 |   """Add a path to sys.path temporarily.
   |
help: Add return type annotation

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/core/protocol_code_manager.py:101:5
    |
 99 |     command: list[str],
100 |     cwd: str,
101 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^
102 |     timeout: int = 300,
103 |   ) -> str:
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/core/protocol_code_manager.py:101:5
    |
 99 |     command: list[str],
100 |     cwd: str,
101 |     suppress_output: bool = False,
    |     ^^^^^^^^^^^^^^^
102 |     timeout: int = 300,
103 |   ) -> str:
    |

UP031 Use format specifiers instead of percent format
   --> praxis/backend/core/protocol_code_manager.py:147:9
    |
145 |     except subprocess.TimeoutExpired as e:
146 |       error_message = (
147 |         "CODE-GIT: Command '%s' timed out after %d seconds in %s.\nStderr: %s\nStdout: %s"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |       ) % (
149 |         " ".join(e.cmd),
    |
help: Replace with format specifiers

UP031 Use format specifiers instead of percent format
   --> praxis/backend/core/protocol_code_manager.py:173:9
    |
171 |       )
172 |       error_message = (
173 |         "CODE-GIT: Command '%s' failed with exit code %d in %s.\nStderr: %s\nStdout: %s"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |       ) % (
175 |         " ".join(e.cmd),
    |
help: Replace with format specifiers

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> praxis/backend/core/protocol_code_manager.py:209:8
    |
207 |     """
208 |     is_git_repo = False
209 |     if os.path.exists(checkout_path):
    |        ^^^^^^^^^^^^^^
210 |       try:
211 |         result = await self._run_git_command(
    |
help: Replace with `Path(...).exists()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> praxis/backend/core/protocol_code_manager.py:263:10
    |
261 |       )
262 |     else:
263 |       if os.path.exists(checkout_path):
    |          ^^^^^^^^^^^^^^
264 |         if os.listdir(checkout_path):
265 |           msg = (
    |
help: Replace with `Path(...).exists()`

PTH208 Use `pathlib.Path.iterdir()` instead.
   --> praxis/backend/core/protocol_code_manager.py:264:12
    |
262 |     else:
263 |       if os.path.exists(checkout_path):
264 |         if os.listdir(checkout_path):
    |            ^^^^^^^^^^
265 |           msg = (
266 |             f"Path '{checkout_path}' for repo '{repo_name_for_logging}' exists, "
    |

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> praxis/backend/core/protocol_code_manager.py:284:11
    |
282 |         )
283 |         try:
284 |           os.makedirs(checkout_path, exist_ok=True)
    |           ^^^^^^^^^^^
285 |         except OSError as e:
286 |           msg = f"Failed to create directory '{checkout_path}': {e}"
    |
help: Replace with `Path(...).mkdir(parents=True)`

PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
   --> praxis/backend/core/protocol_code_manager.py:481:14
    |
479 |     elif protocol_def_orm.file_system_source_accession_id and protocol_def_orm.file_system_source:
480 |       fs_source = protocol_def_orm.file_system_source
481 |       if not os.path.isdir(fs_source.base_path):
    |              ^^^^^^^^^^^^^
482 |         msg = f"Invalid base path '{fs_source.base_path}' for FS source '{fs_source.name}'."
483 |         raise ValueError(
    |
help: Replace with `Path(...).is_dir()`

TRY300 Consider moving this statement to an `else` block
   --> praxis/backend/core/protocol_code_manager.py:513:7
    |
511 |         )
512 |
513 |       return func_wrapper, pydantic_def
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
514 |
515 |     except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> praxis/backend/core/protocol_code_manager.py:516:14
    |
515 |     except Exception as e:
516 |       logger.error(
    |              ^^^^^
517 |         "Failed to load protocol function '%s' from module '%s': %s",
518 |         protocol_def_orm.function_name,
    |

INP001 File `praxis/backend/core/protocols/asset_lock_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/asset_lock_manager.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/protocols/asset_lock_manager.py:1:1

INP001 File `praxis/backend/core/protocols/asset_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/asset_manager.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:19:13
   |
17 |   """A protocol for an asset manager."""
18 |
19 |   async def apply_deck(
   |             ^^^^^^^^^^
20 |     self,
21 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:25:13
   |
23 |   ) -> Deck: ...
24 |
25 |   async def acquire_machine(
   |             ^^^^^^^^^^^^^^^
26 |     self,
27 |     protocol_run_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:32:13
   |
30 |   ) -> tuple[Any, uuid.UUID, str]: ...
31 |
32 |   async def acquire_resource(
   |             ^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_data: AcquireAsset,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:37:13
   |
35 |   ) -> tuple[Any, uuid.UUID, str]: ...
36 |
37 |   async def acquire_asset(
   |             ^^^^^^^^^^^^^
38 |     self,
39 |     protocol_run_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:43:13
   |
41 |   ) -> tuple[Any, uuid.UUID, str]: ...
42 |
43 |   async def release_machine(
   |             ^^^^^^^^^^^^^^^
44 |     self,
45 |     machine_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:50:13
   |
48 |   ) -> None: ...
49 |
50 |   async def release_resource(
   |             ^^^^^^^^^^^^^^^^
51 |     self,
52 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:60:13
   |
58 |   ) -> None: ...
59 |
60 |   async def lock_asset(
   |             ^^^^^^^^^^
61 |     self,
62 |     asset_type: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/asset_manager.py:68:13
   |
66 |   ) -> bool: ...
67 |
68 |   async def unlock_asset(
   |             ^^^^^^^^^^^^
69 |     self,
70 |     asset_type: str,
   |

INP001 File `praxis/backend/core/protocols/filesystem.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/filesystem.py:1:1

D100 Missing docstring in public module
--> praxis/backend/core/protocols/filesystem.py:1:1

INP001 File `praxis/backend/core/protocols/orchestrator.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/orchestrator.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/orchestrator.py:13:13
   |
11 |   """A protocol for an orchestrator."""
12 |
13 |   async def execute_protocol(
   |             ^^^^^^^^^^^^^^^^
14 |     self,
15 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/orchestrator.py:23:13
   |
21 |   ) -> ProtocolRunOrm: ...
22 |
23 |   async def execute_existing_protocol_run(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 |     self,
25 |     protocol_run_orm: ProtocolRunOrm,
   |

INP001 File `praxis/backend/core/protocols/protocol_code_manager.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/protocol_code_manager.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_code_manager.py:17:13
   |
15 |   """A protocol for a protocol code manager."""
16 |
17 |   async def prepare_protocol_code(
   |             ^^^^^^^^^^^^^^^^^^^^^
18 |     self,
19 |     protocol_def_orm: FunctionProtocolDefinitionOrm,
   |

INP001 File `praxis/backend/core/protocols/protocol_execution_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/protocol_execution_service.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:14:13
   |
12 |   """A protocol for a protocol execution service."""
13 |
14 |   async def execute_protocol_immediately(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |     self,
16 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:24:13
   |
22 |   ) -> ProtocolRunOrm: ...
23 |
24 |   async def schedule_protocol_execution(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     self,
26 |     protocol_name: str,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:34:13
   |
32 |   ) -> ProtocolRunOrm: ...
33 |
34 |   async def get_protocol_run_status(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
35 |     self,
36 |     protocol_run_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/protocol_execution_service.py:39:13
   |
37 |   ) -> dict[str, Any] | None: ...
38 |
39 |   async def cancel_protocol_run(self, protocol_run_id: uuid.UUID) -> bool: ...
   |             ^^^^^^^^^^^^^^^^^^^
   |

INP001 File `praxis/backend/core/protocols/scheduler.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/scheduler.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:14:13
   |
12 |   """A protocol for a protocol scheduler."""
13 |
14 |   async def schedule_protocol_execution(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |     self,
16 |     protocol_run_orm: ProtocolRunOrm,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:21:13
   |
19 |   ) -> bool: ...
20 |
21 |   async def cancel_scheduled_run(self, protocol_run_id: uuid.UUID) -> bool: ...
   |             ^^^^^^^^^^^^^^^^^^^^
22 |
23 |   async def get_schedule_status(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:23:13
   |
21 |   async def cancel_scheduled_run(self, protocol_run_id: uuid.UUID) -> bool: ...
22 |
23 |   async def get_schedule_status(
   |             ^^^^^^^^^^^^^^^^^^^
24 |     self,
25 |     protocol_run_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/scheduler.py:28:13
   |
26 |   ) -> dict[str, Any] | None: ...
27 |
28 |   async def list_active_schedules(self) -> list[dict[str, Any]]: ...
   |             ^^^^^^^^^^^^^^^^^^^^^
   |

INP001 File `praxis/backend/core/protocols/workcell.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/workcell.py:1:1

INP001 File `praxis/backend/core/protocols/workcell_runtime.py` is part of an implicit namespace package. Add an `__init__.py`.
--> praxis/backend/core/protocols/workcell_runtime.py:1:1

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:19:13
   |
17 |   """A protocol for a workcell runtime."""
18 |
19 |   async def start_workcell_state_sync(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |
21 |   async def stop_workcell_state_sync(self) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:21:13
   |
19 |   async def start_workcell_state_sync(self) -> None: ...
20 |
21 |   async def stop_workcell_state_sync(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 |   def get_main_workcell(self) -> IWorkcell: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:23:7
   |
21 |   async def stop_workcell_state_sync(self) -> None: ...
22 |
23 |   def get_main_workcell(self) -> IWorkcell: ...
   |       ^^^^^^^^^^^^^^^^^
24 |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:25:7
   |
23 |   def get_main_workcell(self) -> IWorkcell: ...
24 |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
   |       ^^^^^^^^^^^^^^^^^^
26 |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:27:7
   |
25 |   def get_state_snapshot(self) -> dict[str, Any]: ...
26 |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
   |       ^^^^^^^^^^^^^^^^^^^^
28 |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:29:13
   |
27 |   def apply_state_snapshot(self, snapshot_json: dict[str, Any]) -> None: ...
28 |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
   |             ^^^^^^^^^^^^^^^^^^
30 |
31 |   async def create_or_get_resource(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:31:13
   |
29 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine: ...
30 |
31 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
32 |     self,
33 |     resource_orm: ResourceOrm,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:37:7
   |
35 |   ) -> Resource: ...
36 |
37 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine: ...
   |       ^^^^^^^^^^^^^^^^^^
38 |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:39:7
   |
37 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine: ...
38 |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:41:7
   |
39 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID: ...
40 |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |
43 |   def get_active_resource(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:43:7
   |
41 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID: ...
42 |
43 |   def get_active_resource(
   |       ^^^^^^^^^^^^^^^^^^^
44 |     self,
45 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:48:7
   |
46 |   ) -> Resource: ...
47 |
48 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID: ...
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:50:7
   |
48 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID: ...
49 |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
   |       ^^^^^^^^^^^^^^^
51 |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:52:13
   |
50 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck: ...
51 |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
   |             ^^^^^^^^^^^^^^^^
53 |
54 |   async def assign_resource_to_deck(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:54:13
   |
52 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None: ...
53 |
54 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
55 |     self,
56 |     resource_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:62:13
   |
60 |   ) -> None: ...
61 |
62 |   async def clear_deck_position(
   |             ^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:69:13
   |
67 |   ) -> None: ...
68 |
69 |   async def execute_machine_action(
   |             ^^^^^^^^^^^^^^^^^^^^^^
70 |     self,
71 |     machine_orm_accession_id: uuid.UUID,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_machine_action`
  --> praxis/backend/core/protocols/workcell_runtime.py:74:8
   |
72 |     action_name: str,
73 |     params: dict[str, Any] | None = None,
74 |   ) -> Any: ...
   |        ^^^
75 |
76 |   async def shutdown_all_machines(self) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:76:13
   |
74 |   ) -> Any: ...
75 |
76 |   async def shutdown_all_machines(self) -> None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^
77 |
78 |   async def get_deck_state_representation(
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:78:13
   |
76 |   async def shutdown_all_machines(self) -> None: ...
77 |
78 |   async def get_deck_state_representation(
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
79 |     self,
80 |     deck_orm_accession_id: uuid.UUID,
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:83:13
   |
81 |   ) -> dict[str, Any]: ...
82 |
83 |   async def get_last_initialized_deck_object(self) -> Deck | None: ...
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |
85 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None: ...
   |

D102 Missing docstring in public method
  --> praxis/backend/core/protocols/workcell_runtime.py:85:13
   |
83 |   async def get_last_initialized_deck_object(self) -> Deck | None: ...
84 |
85 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None: ...
   |             ^^^^^^^^^^^^^^
   |

D104 Missing docstring in public package
--> praxis/backend/core/workcell_runtime/__init__.py:1:1

TC003 Move standard library import `asyncio` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:3:8
  |
1 | """Core WorkcellRuntime class definition."""
2 |
3 | import asyncio
  |        ^^^^^^^
4 | import uuid
5 | from typing import TYPE_CHECKING
  |
help: Move into type-checking block

TC003 Move standard library import `uuid` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:4:8
  |
3 | import asyncio
4 | import uuid
  |        ^^^^
5 | from typing import TYPE_CHECKING
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.machines.Machine` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:7:33
  |
5 | from typing import TYPE_CHECKING
6 |
7 | from pylabrobot.machines import Machine
  |                                 ^^^^^^^
8 | from pylabrobot.resources import Deck, Resource
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.resources.Deck` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:8:34
  |
7 | from pylabrobot.machines import Machine
8 | from pylabrobot.resources import Deck, Resource
  |                                  ^^^^
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

TC002 Move third-party import `pylabrobot.resources.Resource` into a type-checking block
 --> praxis/backend/core/workcell_runtime/core.py:8:40
  |
7 | from pylabrobot.machines import Machine
8 | from pylabrobot.resources import Deck, Resource
  |                                        ^^^^^^^^
9 | from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
  |
help: Move into type-checking block

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:34:5
   |
32 |   def get_active_deck_accession_id(self, deck: Deck) -> uuid.UUID:
33 |     """Retrieve the ORM ID of an active PyLabRobot Deck instance."""
34 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
35 |     for orm_accession_id, active_deck in self._active_decks.items():
36 |       if active_deck is deck:
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:43:5
   |
41 |   def get_active_deck(self, deck_orm_accession_id: uuid.UUID) -> Deck:
42 |     """Retrieve an active PyLabRobot Deck instance by its ORM ID."""
43 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
44 |     deck = self._active_decks.get(deck_orm_accession_id)
45 |     if deck is None:
   |
help: Consider using a different variable name

C901 `assign_resource_to_deck` is too complex (14 > 10)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLR0912 Too many branches (17 > 12)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLR0915 Too many statements (60 > 50)
  --> praxis/backend/core/workcell_runtime/deck_manager.py:62:13
   |
60 |     suffix=" - Ensure the resource and deck are valid and connected.",
61 |   )
62 |   async def assign_resource_to_deck(
   |             ^^^^^^^^^^^^^^^^^^^^^^^
63 |     self,
64 |     resource_orm_accession_id: uuid.UUID,
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/deck_manager.py:70:5
   |
68 |   ) -> None:  # ruff: noqa: C901, PLR0912, PLR0915
69 |     """Assign a live Resource to a specific location or position on a deck."""
70 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
71 |     if location is None and position_accession_id is None:
72 |       msg = (
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:191:5
    |
189 |   ) -> None:
190 |     """Clear a resource from a specific position on a live deck."""
191 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
192 |     deck = self.get_active_deck(deck_orm_accession_id)
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:240:5
    |
238 |   ) -> dict[str, Any]:
239 |     """Construct a dictionary representing the state of a specific deck."""
240 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
241 |     async with self.db_session_factory() as db_session:
242 |       deck_orm = await self.deck_svc.get(db=db_session, accession_id=deck_orm_accession_id)
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:329:5
    |
327 |   async def get_last_initialized_deck_object(self) -> Deck | None:
328 |     """Return the Deck most recently initialized by this runtime instance."""
329 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
330 |     if self._last_initialized_deck_object:
331 |       return self._last_initialized_deck_object
    |
help: Consider using a different variable name

C901 `_get_calculated_location` is too complex (12 > 10)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:338:13
    |
336 |     suffix=" - Ensure the deck type definition exists in the database.",
337 |   )
338 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
339 |     self,
340 |     target_deck: Deck,
    |

PLR0912 Too many branches (15 > 12)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:338:13
    |
336 |     suffix=" - Ensure the deck type definition exists in the database.",
337 |   )
338 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
339 |     self,
340 |     target_deck: Deck,
    |

PLR0915 Too many statements (55 > 50)
   --> praxis/backend/core/workcell_runtime/deck_manager.py:338:13
    |
336 |     suffix=" - Ensure the deck type definition exists in the database.",
337 |   )
338 |   async def _get_calculated_location(
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
339 |     self,
340 |     target_deck: Deck,
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/deck_manager.py:346:5
    |
344 |   ) -> Coordinate:  # ruff: noqa: C901, PLR0912, PLR0915
345 |     """Calculate the PyLabRobot Coordinate for a given position_accession_id."""
346 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
347 |     if positioning_config is None:
348 |       logger.info(
    |
help: Consider using a different variable name

TRY003 Avoid specifying long messages outside the exception class
   --> praxis/backend/core/workcell_runtime/deck_manager.py:359:19
    |
357 |           )
358 |           if not deck_type_definition:
359 |             raise WorkcellRuntimeError(f"Deck type definition with ID {deck_type_id} not found.")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
360 |           all_deck_position_definitions = deck_type_definition.positions
361 |           found_position_def = next(
    |

EM102 Exception must not use an f-string literal, assign to variable first
   --> praxis/backend/core/workcell_runtime/deck_manager.py:359:40
    |
357 |           )
358 |           if not deck_type_definition:
359 |             raise WorkcellRuntimeError(f"Deck type definition with ID {deck_type_id} not found.")
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
360 |           all_deck_position_definitions = deck_type_definition.positions
361 |           found_position_def = next(
    |
help: Assign to variable; remove f-string literal

C901 `initialize_machine` is too complex (21 > 10)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLR0912 Too many branches (24 > 12)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLR0915 Too many statements (87 > 50)
  --> praxis/backend/core/workcell_runtime/machine_manager.py:36:13
   |
34 |     suffix=" - Ensure the machine ORM is valid, the class, and machine is connected.",
35 |   )
36 |   async def initialize_machine(self, machine_orm: MachineOrm) -> Machine:  # ruff: noqa: C901, PLR0912, PLR0915
   |             ^^^^^^^^^^^^^^^^^^
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/machine_manager.py:39:5
   |
37 |     """Initialize and connects to a machine's PyLabRobot machine/resource."""
38 |     # We assume self is WorkcellRuntime
39 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
40 |
41 |     if not hasattr(machine_orm, "id") or machine_orm.accession_id is None:
   |
help: Consider using a different variable name

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:137:11
    |
135 |             f"instance. Type is {type(machine_instance).__name__}."
136 |           )
137 |           raise TypeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^
138 |
139 |         if (
    |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:160:11
    |
158 |             "and awaitable."
159 |           )
160 |           raise WorkcellRuntimeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |       except Exception as e:  # pylint: disable=broad-except
162 |         error_message = f"Failed to instantiate or setup machine \
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/core/workcell_runtime/machine_manager.py:213:74
    |
212 |     if hasattr(machine_instance, "deck") and isinstance(machine_instance.deck, Deck):
213 |       machine_deck: Deck = cast("LiquidHandler", machine_instance).deck  # type: ignore
    |                                                                          ^^^^^^^^^^^^^^
214 |       if not isinstance(machine_deck, Deck):
215 |         msg = (
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:263:5
    |
261 |   def get_active_machine(self, machine_orm_accession_id: uuid.UUID) -> Machine:
262 |     """Retrieve an active PyLabRobot machine instance by its ORM ID."""
263 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
264 |     machine = self._active_machines.get(machine_orm_accession_id)
265 |     if machine is None:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:280:5
    |
278 |   def get_active_machine_accession_id(self, machine: Machine) -> uuid.UUID:
279 |     """Retrieve the ORM ID of an active PyLabRobot machine instance."""
280 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
281 |     for orm_accession_id, active_machine in self._active_machines.items():
282 |       if active_machine is machine:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:295:5
    |
293 |   async def shutdown_machine(self, machine_orm_accession_id: uuid.UUID) -> None:
294 |     """Shut down and removes a live PyLabRobot machine instance."""
295 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
296 |     machine_instance = self._active_machines.pop(machine_orm_accession_id, None)
297 |     try:
    |
help: Consider using a different variable name

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:318:11
    |
316 |             f"{machine_orm_accession_id} that is callable and awaitable."
317 |           )
318 |           raise WorkcellRuntimeError(msg)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
319 |         async with self.db_session_factory() as db_session:
320 |           await self.machine_svc.update_machine_status(
    |

TRY301 Abstract `raise` to an inner function
   --> praxis/backend/core/workcell_runtime/machine_manager.py:341:9
    |
339 |           "unexpectedly offline."
340 |         )
341 |         raise WorkcellRuntimeError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
342 |
343 |     except Exception as e:  # pylint: disable=broad-except
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_machine_action`
   --> praxis/backend/core/workcell_runtime/machine_manager.py:373:8
    |
371 |     action_name: str,
372 |     params: dict[str, Any] | None = None,
373 |   ) -> Any:  # ruff: noqa: ANN401
    |        ^^^
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |

ERA001 Found commented-out code
   --> praxis/backend/core/workcell_runtime/machine_manager.py:375:5
    |
373 |   ) -> Any:  # ruff: noqa: ANN401
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
376 |     machine = self.get_active_machine(machine_orm_accession_id)
377 |     logger.info(
    |
help: Remove commented-out code

E501 Line too long (124 > 100)
   --> praxis/backend/core/workcell_runtime/machine_manager.py:375:101
    |
373 |   ) -> Any:  # ruff: noqa: ANN401
374 |     """Execute a method/action on a live PyLabRobot machine instance."""
375 |     # self = cast("WorkcellRuntime", self) # Not needed for this method strictly speaking if get_active_machine is available
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
376 |     machine = self.get_active_machine(machine_orm_accession_id)
377 |     logger.info(
    |

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/machine_manager.py:410:5
    |
408 |   async def shutdown_all_machines(self) -> None:
409 |     """Shut down all currently active PyLabRobot machine instances."""
410 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
411 |     logger.info("WorkcellRuntime: Shutting down all active machines...")
412 |     for machine_accession_id in list(self._active_machines.keys()):  # ruff: noqa: PERF203
    |
help: Consider using a different variable name

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/workcell_runtime/machine_manager.py:419:7
    |
417 |           )
418 |           await self.shutdown_machine(machine_accession_id)
419 | /       except WorkcellRuntimeError:
420 | |         logger.exception(
421 | |           "WorkcellRuntime: Error shutting down machine ID %s",
422 | |           machine_accession_id,
423 | |         )
424 | |         continue
    | |________________^
425 |       logger.info("WorkcellRuntime: All active machines processed for shutdown.")
    |

C901 `create_or_get_resource` is too complex (12 > 10)
  --> praxis/backend/core/workcell_runtime/resource_manager.py:32:13
   |
30 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
31 |   )
32 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_orm: ResourceOrm,
   |

PLR0912 Too many branches (13 > 12)
  --> praxis/backend/core/workcell_runtime/resource_manager.py:32:13
   |
30 |     suffix=" - Ensure the resource instance ORM and definition FQN are valid.",
31 |   )
32 |   async def create_or_get_resource(
   |             ^^^^^^^^^^^^^^^^^^^^^^
33 |     self,
34 |     resource_orm: ResourceOrm,
   |

PLW0642 Reassigned `self` variable in instance method
  --> praxis/backend/core/workcell_runtime/resource_manager.py:38:5
   |
36 |   ) -> Resource:  # ruff: noqa: C901, PLR0912
37 |     """Create or retrieve a live PyLabRobot resource object."""
38 |     self = cast("WorkcellRuntime", self)
   |     ^^^^
39 |     if not hasattr(resource_orm, "id") or resource_orm.accession_id is None:
40 |       msg = "Invalid resource_orm object passed to create_or_get_resource (no id)."
   |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:163:5
    |
161 |   ) -> Resource:
162 |     """Retrieve an active PyLabRobot resource object by its ORM ID."""
163 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
164 |     resource = self._active_resources.get(resource_orm_accession_id)
165 |     if resource is None:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:181:5
    |
179 |   def get_active_resource_accession_id(self, resource: Resource) -> uuid.UUID:
180 |     """Retrieve the ORM ID of an active PyLabRobot resource object."""
181 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
182 |     for orm_accession_id, active_resource in self._active_resources.items():
183 |       if active_resource is resource:
    |
help: Consider using a different variable name

PLW0642 Reassigned `self` variable in instance method
   --> praxis/backend/core/workcell_runtime/resource_manager.py:194:5
    |
192 |   async def clear_resource(self, resource_orm_accession_id: uuid.UUID) -> None:
193 |     """Clear a resource from the workcell runtime."""
194 |     self = cast("WorkcellRuntime", self)
    |     ^^^^
195 |     if resource_orm_accession_id in self._active_resources:
196 |       del self._active_resources[resource_orm_accession_id]
    |
help: Consider using a different variable name

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/core/workcell_runtime/state_sync.py:97:7
    |
 95 |             )
 96 |
 97 | /       except asyncio.CancelledError:
 98 | |         logger.info("Workcell state sync loop cancelled.")
 99 | |         break
    | |_____________^
100 |         except Exception:  # pylint: disable=broad-except
101 |           logger.exception(
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> praxis/backend/models/orm/deck.py:77:20
   |
76 |   __tablename__ = "decks"
77 |   __table_args__ = {"extend_existing": True}
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
78 |   __mapper_args__: ClassVar[dict] = {
79 |     "polymorphic_identity": "DECK",  # Uppercase to match AssetType.DECK
   |

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:125:3
    |
123 |   # resource_child_list: Mapped[list["ResourceOrm"]] = relationship(
124 |   #   "ResourceOrm",
125 |   #   back_populates="resource_definition",
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |   #   cascade="all, delete-orphan",
127 |   #   default_factory=list,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:126:3
    |
124 |   #   "ResourceOrm",
125 |   #   back_populates="resource_definition",
126 |   #   cascade="all, delete-orphan",
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |   #   default_factory=list,
128 |   # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:127:3
    |
125 |   #   back_populates="resource_definition",
126 |   #   cascade="all, delete-orphan",
127 |   #   default_factory=list,
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^
128 |   # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> praxis/backend/models/orm/machine.py:128:3
    |
126 |   #   cascade="all, delete-orphan",
127 |   #   default_factory=list,
128 |   # )
    |   ^^^
129 |
130 |   resource_definition_accession_id: Mapped[uuid.UUID | None] = mapped_column(
    |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> praxis/backend/models/orm/protocol.py:65:20
   |
64 |   __tablename__ = "protocol_source_repositories"
65 |   __table_args__ = {"extend_existing": True}
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
66 |
67 |   name: Mapped[str] = mapped_column(
   |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/orm/protocol.py:398:22
    |
396 |     comment="JSONB representation of any constraints on the parameter, such as allowed values or \
397 |       ranges.",
398 |     default=None,  # TODO(mar): consider using a more structured type for constraints # noqa: TD003
    |                      ^^^^
399 |   )
400 |   ui_hint_json: Mapped[dict | None] = mapped_column(
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/orm/protocol.py:495:22
    |
493 |     comment="JSONB representation of any constraints on the asset requirement, such as allowed \
494 |       values or ranges.",
495 |     default=None,  # TODO(mar): consider using a more structured type for constraints # noqa: TD003
    |                      ^^^^
496 |   )
497 |   location_constraints_json: Mapped[dict | None] = mapped_column(
    |

E501 Line too long (101 > 100)
   --> praxis/backend/models/orm/schedule.py:444:101
    |
442 |     nullable=False,
443 |     default=ScheduleHistoryEventTriggerEnum.SYSTEM,
444 |     comment="Identifier for the entity that triggered this event, e.g., 'user', 'system', 'celery'.",
    |                                                                                                     ^
445 |     kw_only=True,
446 |   )
    |

ERA001 Found commented-out code
   --> praxis/backend/models/orm/schedule.py:496:1
    |
494 |   CreateMaterializedView("scheduler_metrics_mv", metrics_query),
495 | )
496 | # event.listen(Base.metadata, "before_drop", DropMaterializedView("scheduler_metrics_mv"))
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> praxis/backend/models/orm/schedule.py:515:20
    |
513 |   avg_execution_time_ms: Mapped[float] = mapped_column(Float, init=False)
514 |
515 |   __table_args__ = {"extend_existing": True}
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
    |

E501 Line too long (106 > 100)
  --> praxis/backend/models/pydantic_internals/filters.py:38:101
   |
36 |     description="Filter by associated protocol run ID.",
37 |   )
38 |   machine_accession_id: UUID7 | None = Field(default=None, description="Filter by associated machine ID.")
   |                                                                                                     ^^^^^^
39 |   resource_accession_id: UUID7 | None = Field(default=None, description="Filter by associated resource ID.")
40 |   parent_accession_id: UUID7 | None = Field(default=None, description="Filter by parent asset ID.")
   |

E501 Line too long (108 > 100)
  --> praxis/backend/models/pydantic_internals/filters.py:39:101
   |
37 |   )
38 |   machine_accession_id: UUID7 | None = Field(default=None, description="Filter by associated machine ID.")
39 |   resource_accession_id: UUID7 | None = Field(default=None, description="Filter by associated resource ID.")
   |                                                                                                     ^^^^^^^^
40 |   parent_accession_id: UUID7 | None = Field(default=None, description="Filter by parent asset ID.")
   |

D101 Missing docstring in public class
  --> praxis/backend/models/pydantic_internals/outputs.py:73:7
   |
73 | class FunctionDataOutputCreate(FunctionDataOutputBase):
   |       ^^^^^^^^^^^^^^^^^^^^^^^^
74 |   name: str = "default_name"
75 |   """Model for creating function data outputs."""
   |

ANN206 Missing return type annotation for classmethod `validate_data_content`
   --> praxis/backend/models/pydantic_internals/outputs.py:131:7
    |
129 |   )
130 |   @classmethod
131 |   def validate_data_content(cls, v, values):
    |       ^^^^^^^^^^^^^^^^^^^^^
132 |     """Ensure at least one data field is provided."""
133 |     data_fields = [
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `v`
   --> praxis/backend/models/pydantic_internals/outputs.py:131:34
    |
129 |   )
130 |   @classmethod
131 |   def validate_data_content(cls, v, values):
    |                                  ^
132 |     """Ensure at least one data field is provided."""
133 |     data_fields = [
    |

ANN001 Missing type annotation for function argument `values`
   --> praxis/backend/models/pydantic_internals/outputs.py:131:37
    |
129 |   )
130 |   @classmethod
131 |   def validate_data_content(cls, v, values):
    |                                     ^^^^^^
132 |     """Ensure at least one data field is provided."""
133 |     data_fields = [
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/models/pydantic_internals/outputs.py:290:8
    |
288 |     None,
289 |     description="Updated metadata",
290 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/models/pydantic_internals/outputs.py:290:8
    |
288 |     None,
289 |     description="Updated metadata",
290 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/models/pydantic_internals/outputs.py:290:8
    |
288 |     None,
289 |     description="Updated metadata",
290 |   )  # TODO: figure out how to integrate this
    |        ^^^^
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:377:34
    |
375 |   export_format: str = Field(..., description="Export format (csv, json, xlsx, etc.)")
376 |
377 |   include_metadata: bool = Field(True, description="Whether to include metadata")
    |                                  ^^^^
378 |
379 |   include_spatial_info: bool = Field(
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:380:5
    |
379 |   include_spatial_info: bool = Field(
380 |     True,
    |     ^^^^
381 |     description="Whether to include spatial information",
382 |   )
    |

FBT003 Boolean positional value in function call
   --> praxis/backend/models/pydantic_internals/outputs.py:385:5
    |
384 |   flatten_structure: bool = Field(
385 |     False,
    |     ^^^^^
386 |     description="Whether to flatten hierarchical data",
387 |   )
    |

PYI063 Use PEP 570 syntax for positional-only parameters
  --> praxis/backend/models/pydantic_internals/pydantic_base.py:44:29
   |
42 |   )
43 |
44 |   def model_post_init(self, __context: Any) -> None:  # noqa: ANN401
   |                             ^^^^^^^^^
45 |     """Set the updated_at field to the current time after model initialization."""
46 |     self.updated_at = datetime.datetime.now(tz=datetime.timezone.utc)
   |
help: Add `/` to function signature

RUF022 `__all__` is not sorted
  --> praxis/backend/services/__init__.py:30:11
   |
28 |   from praxis.backend.services.workcell import workcell_service
29 |
30 |   __all__ = [
   |  ___________^
31 | |   # Deck
32 | |   "deck_service",
33 | |   # Deck Type Definition
34 | |   "DeckTypeDefinitionService",
35 | |   "DiscoveryService",
36 | |   # Function Output Data
37 | |   "FunctionDataOutputCRUDService",
38 | |   # Machine
39 | |   "machine_service",
40 | |   # Plate Viz
41 | |   "read_plate_data_visualization",
42 | |   # Praxis ORM Service
43 | |   "PraxisDBService",
44 | |   # Protocol Output Data
45 | |   "read_protocol_run_data_summary",
46 | |   # Protocols
47 | |   "protocol_run_service",
48 | |   # Resource
49 | |   "resource_service",
50 | |   # Resource Definition
51 | |   "ResourceTypeDefinitionService",
52 | |   # Workcell
53 | |   "workcell_service",
54 | | ]
   | |_^
   |
help: Apply an isort-style sorting to `__all__`

C901 `create` is too complex (12 > 10)
  --> praxis/backend/services/deck.py:39:13
   |
38 |   @handle_db_transaction
39 |   async def create(self, db: AsyncSession, *, obj_in: DeckCreate) -> DeckOrm:
   |             ^^^^^^
40 |     """Create a new deck."""
41 |     logger.info(
   |

PLR0912 Too many branches (13 > 12)
  --> praxis/backend/services/deck.py:39:13
   |
38 |   @handle_db_transaction
39 |   async def create(self, db: AsyncSession, *, obj_in: DeckCreate) -> DeckOrm:
   |             ^^^^^^
40 |     """Create a new deck."""
41 |     logger.info(
   |

E501 Line too long (106 > 100)
  --> praxis/backend/services/deck.py:61:101
   |
59 |     )
60 |
61 |     # Remap the Pydantic `machine_id` or `parent_accession_id` to the ORM's `parent_machine_accession_id`.
   |                                                                                                     ^^^^^^
62 |     # Don't keep parent_accession_id as it has FK constraint to resources table (machines are in machines table)
63 |     machine_id_to_use = deck_data.pop("machine_id", None) or deck_data.pop(
   |

E501 Line too long (112 > 100)
  --> praxis/backend/services/deck.py:62:101
   |
61 |     # Remap the Pydantic `machine_id` or `parent_accession_id` to the ORM's `parent_machine_accession_id`.
62 |     # Don't keep parent_accession_id as it has FK constraint to resources table (machines are in machines table)
   |                                                                                                     ^^^^^^^^^^^^
63 |     machine_id_to_use = deck_data.pop("machine_id", None) or deck_data.pop(
64 |       "parent_accession_id", None,
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/deck.py:68:7
   |
67 |     if machine_id_to_use:
68 |       from praxis.backend.models import MachineOrm
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |
70 |       machine = await db.get(MachineOrm, machine_id_to_use)
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/deck.py:79:5
   |
78 |     # Filter to only valid constructor parameters
79 |     import enum
   |     ^^^^^^^^^^^
80 |     import inspect as py_inspect
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/deck.py:80:5
   |
78 |     # Filter to only valid constructor parameters
79 |     import enum
80 |     import inspect as py_inspect
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
81 |
82 |     from sqlalchemy import inspect as sa_inspect
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/deck.py:82:5
   |
80 |     import inspect as py_inspect
81 |
82 |     from sqlalchemy import inspect as sa_inspect
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |
84 |     init_signature = py_inspect.signature(self.model.__init__)
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/deck.py:104:7
    |
102 |     # Workaround for FKs not sticking in MappedAsDataclass hierarchy or joined inheritance
103 |     if "resource_definition_accession_id" in filtered_data:
104 |       from praxis.backend.models import ResourceDefinitionOrm
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |
106 |       res_def = await db.get(
    |

TD003 Missing issue link for this TODO
  --> praxis/backend/services/discovery_service.py:49:3
   |
49 | # TODO(mar): Make this much safer, accessing sys.path directly can lead to issues.
   |   ^^^^
50 | class DiscoveryService:
   |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/services/discovery_service.py:49:3
   |
49 | # TODO(mar): Make this much safer, accessing sys.path directly can lead to issues.
   |   ^^^^
50 | class DiscoveryService:
   |

C901 `_extract_protocol_definitions_from_paths` is too complex (18 > 10)
   --> praxis/backend/services/discovery_service.py:134:7
    |
132 |     return directory_paths
133 |
134 |   def _extract_protocol_definitions_from_paths(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |     self,
136 |     search_paths: Sequence[str | Path],
    |

PLR0912 Too many branches (20 > 12)
   --> praxis/backend/services/discovery_service.py:134:7
    |
132 |     return directory_paths
133 |
134 |   def _extract_protocol_definitions_from_paths(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |     self,
136 |     search_paths: Sequence[str | Path],
    |

PLR0915 Too many statements (59 > 50)
   --> praxis/backend/services/discovery_service.py:134:7
    |
132 |     return directory_paths
133 |
134 |   def _extract_protocol_definitions_from_paths(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 |     self,
136 |     search_paths: Sequence[str | Path],
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> praxis/backend/services/discovery_service.py:267:73
    |
265 |                       )
266 |
267 |                   inferred_model = FunctionProtocolDefinitionCreate(  # TODO: ensure that if a reinspection happens it is assigned th
    |                                                                         ^^^^
268 |                     name=func_obj.__name__,
269 |                     version="0.0.0-inferred",
    |

TD003 Missing issue link for this TODO
   --> praxis/backend/services/discovery_service.py:267:73
    |
265 |                       )
266 |
267 |                   inferred_model = FunctionProtocolDefinitionCreate(  # TODO: ensure that if a reinspection happens it is assigned th
    |                                                                         ^^^^
268 |                     name=func_obj.__name__,
269 |                     version="0.0.0-inferred",
    |

FIX002 Line contains TODO, consider resolving the issue
   --> praxis/backend/services/discovery_service.py:267:73
    |
265 |                       )
266 |
267 |                   inferred_model = FunctionProtocolDefinitionCreate(  # TODO: ensure that if a reinspection happens it is assigned th
    |                                                                         ^^^^
268 |                     name=func_obj.__name__,
269 |                     version="0.0.0-inferred",
    |

E501 Line too long (151 > 100)
   --> praxis/backend/services/discovery_service.py:267:101
    |
265 | 
266 | 
267 | nCreate(  # TODO: ensure that if a reinspection happens it is assigned the already existing
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
268 | 
269 | 
    |

ARG002 Unused method argument: `source_repository_accession_id`
   --> praxis/backend/services/discovery_service.py:294:5
    |
292 |     self,
293 |     search_paths: str | list[str],
294 |     source_repository_accession_id: uuid.UUID | None = None,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
295 |     commit_hash: str | None = None,
296 |     file_system_source_accession_id: uuid.UUID | None = None,
    |

ARG002 Unused method argument: `commit_hash`
   --> praxis/backend/services/discovery_service.py:295:5
    |
293 |     search_paths: str | list[str],
294 |     source_repository_accession_id: uuid.UUID | None = None,
295 |     commit_hash: str | None = None,
    |     ^^^^^^^^^^^
296 |     file_system_source_accession_id: uuid.UUID | None = None,
297 |   ) -> list[Any]:
    |

ARG002 Unused method argument: `file_system_source_accession_id`
   --> praxis/backend/services/discovery_service.py:296:5
    |
294 |     source_repository_accession_id: uuid.UUID | None = None,
295 |     commit_hash: str | None = None,
296 |     file_system_source_accession_id: uuid.UUID | None = None,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
297 |   ) -> list[Any]:
298 |     """Discover protocol functions in the given paths and upsert them to the DB.
    |

F841 Local variable `protocol_unique_key` is assigned to but never used
   --> praxis/backend/services/discovery_service.py:374:11
    |
372 |           upserted_definitions_orm.append(def_orm)
373 |
374 |           protocol_unique_key = f"{protocol_pydantic_model.name}_v{protocol_pydantic_model.version}"
    |           ^^^^^^^^^^^^^^^^^^^
375 |
376 |         except (ValueError, RuntimeError):
    |
help: Remove assignment to unused variable `protocol_unique_key`

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/entity_linking.py:46:3
   |
44 | ) -> "ResourceDefinitionOrm":
45 |   """Retrieve a resource definition."""
46 |   from praxis.backend.models import ResourceDefinitionOrm
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |
48 |   result = await db.execute(
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/entity_linking.py:73:3
   |
71 |   ) -> Optional["ResourceOrm"]:
72 |     """Create or link ResourceOrm counterpart for a MachineOrm."""
73 | /   from praxis.backend.models import (
74 | |     ResourceOrm,
75 | |     ResourceStatusEnum,
76 | |   )  # Runtime import
   | |___^
77 |
78 |     log_prefix = f"Machine (ID: {machine_orm.accession_id}, Name: '{machine_orm.name}'):"
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/entity_linking.py:195:3
    |
193 | ) -> Optional["MachineOrm"]:
194 |   """Create or link a MachineOrm counterpart for a ResourceOrm."""
195 |   from praxis.backend.models import MachineOrm, MachineStatusEnum
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 |
197 |   log_prefix = f"Resource (ID: {resource_orm.accession_id}, Name: '{resource_orm.name}'):"
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:322:1
    |
322 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:349:1
    |
349 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/services/entity_linking.py:376:1
    |
376 | # type: ignore
    | ^^^^^^^^^^^^^^
    |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/outputs.py:61:5
   |
59 |   ) -> FunctionDataOutputOrm:
60 |     """Create a new function data output record."""
61 |     from praxis.backend.models.enums.outputs import DataOutputTypeEnum
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 |
63 |     data_type_enum = DataOutputTypeEnum(obj_in.data_type)
   |

C901 `read_plate_dimensions` is too complex (15 > 10)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PLR0911 Too many return statements (10 > 6)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PLR0912 Too many branches (14 > 12)
  --> praxis/backend/services/plate_parsing.py:16:11
   |
16 | async def read_plate_dimensions(
   |           ^^^^^^^^^^^^^^^^^^^^^
17 |   db: AsyncSession,
18 |   plate_resource_accession_id: UUID,
   |

PERF203 `try`-`except` within a loop incurs performance overhead
  --> praxis/backend/services/plate_parsing.py:65:11
   |
63 |               max_row = max(max_row, row_idx)
64 |               max_col = max(max_col, col_idx)
65 | /           except ValueError:
66 | |             continue
   | |____________________^
67 |
68 |           if max_row > 0 or max_col > 0:
   |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> praxis/backend/services/plate_parsing.py:103:40
    |
102 |   """
103 |   if not well_name or len(well_name) < 2:
    |                                        ^
104 |     msg = f"Invalid well name: {well_name}"
105 |     raise ValueError(msg)
    |

PYI059 `Generic[]` should always be the last base class
  --> praxis/backend/services/plr_type_base.py:17:34
   |
17 |   class DiscoverableTypeServiceBase(
   |  __________________________________^
18 | |   Generic[ModelType, CreateSchemaType, UpdateSchemaType],
19 | |   ABC,
20 | | ):
   | |_^
21 |
22 |     """An abstract base class for services that handle discoverable pylabrobot type definitions."""
   |
help: Move `Generic[]` to the end

C901 `initialize` is too complex (11 > 10)
  --> praxis/backend/services/praxis_orm_service.py:67:13
   |
66 |   @classmethod
67 |   async def initialize(
   |             ^^^^^^^^^^
68 |     cls,
69 |     keycloak_dsn: str | None = None,
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:297:7
    |
295 |     logger.info("Executing raw SQL statement.")
296 |     async with self.get_praxis_session() as session:
297 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
298 |
299 |       await session.execute(text(sql_statement), params)
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:321:7
    |
319 |     logger.info("Fetching all rows from raw SQL query.")
320 |     async with self.get_praxis_session() as session:
321 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
322 |
323 |       result = await session.execute(text(sql_query), params)
    |

SLF001 Private member accessed: `_mapping`
   --> praxis/backend/services/praxis_orm_service.py:324:20
    |
323 |       result = await session.execute(text(sql_query), params)
324 |       rows = [dict(row._mapping) for row in result]
    |                    ^^^^^^^^^^^^
325 |       logger.debug("Fetched %d rows.", len(rows))
326 |       return rows
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:347:7
    |
345 |     logger.info("Fetching one row from raw SQL query.")
346 |     async with self.get_praxis_session() as session:
347 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
348 |
349 |       result = await session.execute(text(sql_query), params)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `fetch_val_sql`
   --> praxis/backend/services/praxis_orm_service.py:357:80
    |
355 |       return None
356 |
357 |   async def fetch_val_sql(self, sql_query: str, params: dict | None = None) -> Any:
    |                                                                                ^^^
358 |     """Fetch a single scalar value from a raw SQL query on the Praxis database.
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/praxis_orm_service.py:372:7
    |
370 |     logger.info("Fetching scalar value from raw SQL query.")
371 |     async with self.get_praxis_session() as session:
372 |       from sqlalchemy.sql import text
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
373 |
374 |       result = await session.execute(text(sql_query), params)
    |

N806 Variable `PROJECT_ROOT` in function should be lowercase
   --> praxis/backend/services/praxis_orm_service.py:410:3
    |
408 |   """
409 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
410 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
    |   ^^^^^^^^^^^^
411 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |

N806 Variable `CONFIG_FILE_PATH` in function should be lowercase
   --> praxis/backend/services/praxis_orm_service.py:411:3
    |
409 |   logger.info("Attempting to retrieve Keycloak DSN from configuration.")
410 |   PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
411 |   CONFIG_FILE_PATH = PROJECT_ROOT / "praxis.ini"
    |   ^^^^^^^^^^^^^^^^
412 |
413 |   if not CONFIG_FILE_PATH.exists():
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/services/praxis_orm_service.py:436:74
    |
434 |       logger.info("Successfully retrieved Keycloak DSN from config.")
435 |     except Exception as e:
436 |       logger.exception("Error reading Keycloak DSN from praxis.ini: %s", e)
    |                                                                          ^
437 |       return None
438 |     else:
    |

ANN001 Missing type annotation for function argument `filters`
   --> praxis/backend/services/protocol_definition.py:152:32
    |
151 |   async def get_multi(
152 |     self, db: AsyncSession, *, filters=None,
    |                                ^^^^^^^
153 |   ) -> list[FunctionProtocolDefinitionOrm]:
154 |     """Get multiple protocol definitions with eager loaded relationships."""
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/protocol_definition.py:155:5
    |
153 |   ) -> list[FunctionProtocolDefinitionOrm]:
154 |     """Get multiple protocol definitions with eager loaded relationships."""
155 |     from praxis.backend.models.pydantic_internals.filters import SearchFilters
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 |
157 |     # Get results from parent class (which handles filters)
    |

ARG002 Unused method argument: `source_name`
   --> praxis/backend/services/protocol_definition.py:209:5
    |
207 |     name: str,
208 |     version: str | None = None,
209 |     source_name: str | None = None,
    |     ^^^^^^^^^^^
210 |     commit_hash: str | None = None,
211 |   ) -> FunctionProtocolDefinitionOrm | None:
    |

ERA001 Found commented-out code
   --> praxis/backend/services/protocol_definition.py:217:5
    |
215 |       stmt = stmt.filter(self.model.version == version)
216 |     # if source_name:
217 |     #   stmt = stmt.filter(self.model.source_name == source_name)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |     if commit_hash:
219 |       stmt = stmt.filter(self.model.commit_hash == commit_hash)
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/protocols.py:68:5
   |
67 |     # Filter to only valid constructor parameters
68 |     import enum
   |     ^^^^^^^^^^^
69 |     import inspect as py_inspect
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/protocols.py:69:5
   |
67 |     # Filter to only valid constructor parameters
68 |     import enum
69 |     import inspect as py_inspect
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |
71 |     from sqlalchemy import inspect as sa_inspect
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/protocols.py:71:5
   |
69 |     import inspect as py_inspect
70 |
71 |     from sqlalchemy import inspect as sa_inspect
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |
73 |     init_signature = py_inspect.signature(self.model.__init__)
   |

C901 `update` is too complex (11 > 10)
   --> praxis/backend/services/resource.py:152:13
    |
151 |   @handle_db_transaction
152 |   async def update(  # type: ignore[override]
    |             ^^^^^^
153 |     self,
154 |     db: AsyncSession,
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/resource.py:171:5
    |
170 |     # Convert enum string values back to enum members for SQLAlchemy
171 |     import enum
    |     ^^^^^^^^^^^
172 |
173 |     from sqlalchemy import inspect as sa_inspect
    |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/resource.py:173:5
    |
171 |     import enum
172 |
173 |     from sqlalchemy import inspect as sa_inspect
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 |
175 |     for attr_name, column in sa_inspect(self.model).columns.items():
    |

TC002 Move third-party import `sqlalchemy.orm.attributes.InstrumentedAttribute` into a type-checking block
  --> praxis/backend/services/scheduler.py:20:39
   |
18 | from sqlalchemy.ext.asyncio import AsyncSession
19 | from sqlalchemy.orm import selectinload
20 | from sqlalchemy.orm.attributes import InstrumentedAttribute
   |                                       ^^^^^^^^^^^^^^^^^^^^^
21 |
22 | from praxis.backend.models.enums import (
   |
help: Move into type-checking block

F811 Redefinition of unused `ScheduleStatusEnum` from line 26
  --> praxis/backend/services/scheduler.py:33:3
   |
31 |   ScheduleEntryOrm,
32 |   ScheduleHistoryOrm,
33 |   ScheduleStatusEnum,
   |   ^^^^^^^^^^^^^^^^^^ `ScheduleStatusEnum` redefined here
34 | )
35 | from praxis.backend.models.pydantic_internals.filters import SearchFilters
   |
  ::: praxis/backend/services/scheduler.py:26:3
   |
24 |   ScheduleHistoryEventEnum,
25 |   ScheduleHistoryEventTriggerEnum,
26 |   ScheduleStatusEnum,
   |   ------------------ previous definition of `ScheduleStatusEnum` here
27 | )
28 | from praxis.backend.models.orm.schedule import (
   |
help: Remove definition: `ScheduleStatusEnum`

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/scheduler.py:82:5
   |
81 |     # Fetch the protocol run
82 |     from praxis.backend.models.orm.protocol import ProtocolRunOrm
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |
84 |     protocol_run_result = await db.execute(
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/scheduler.py:111:5
    |
110 |     # Create a new ScheduleEntryOrm
111 |     from datetime import datetime, timezone
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |
113 |     schedule_entry = self.model(
    |

PLR0913 Too many arguments in function definition (11 > 8)
   --> praxis/backend/services/scheduler.py:284:11
    |
283 | @handle_db_transaction
284 | async def create_asset_reservation(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^
285 |   db: AsyncSession,
286 |   schedule_entry_accession_id: uuid.UUID,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/services/scheduler.py:352:3
    |
350 |   asset_name: str | None = None,
351 |   status_filter: list[AssetReservationStatusEnum] | None = None,
352 |   active_only: bool = False,
    |   ^^^^^^^^^^^
353 | ) -> list[AssetReservationOrm]:
354 |   """List asset reservations with optional filters."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/services/scheduler.py:352:3
    |
350 |   asset_name: str | None = None,
351 |   status_filter: list[AssetReservationStatusEnum] | None = None,
352 |   active_only: bool = False,
    |   ^^^^^^^^^^^
353 | ) -> list[AssetReservationOrm]:
354 |   """List asset reservations with optional filters."""
    |

PLR0913 Too many arguments in function definition (12 > 8)
   --> praxis/backend/services/scheduler.py:462:11
    |
461 | @handle_db_transaction
462 | async def log_schedule_event(
    |           ^^^^^^^^^^^^^^^^^^
463 |   db: AsyncSession,
464 |   schedule_entry_accession_id: uuid.UUID,
    |

A004 Import `ConnectionError` is shadowing a Python builtin
  --> praxis/backend/services/state.py:9:30
   |
 8 | import redis
 9 | from redis.exceptions import ConnectionError
   |                              ^^^^^^^^^^^^^^^
10 |
11 | from praxis.backend.configure import PraxisConfiguration
   |

PLC0415 `import` should be at the top-level of a file
  --> praxis/backend/services/user.py:86:5
   |
85 |     # Filter to only valid constructor parameters
86 |     import inspect as py_inspect
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |
88 |     init_signature = py_inspect.signature(UserOrm.__init__)
   |

PLC0415 `import` should be at the top-level of a file
   --> praxis/backend/services/utils/crud_base.py:98:5
    |
 96 |     # Convert enum string values back to enum members for SQLAlchemy
 97 |     # This is necessary because jsonable_encoder converts enums to strings
 98 |     import enum
    |     ^^^^^^^^^^^
 99 |
100 |     for attr_name, column in inspect(self.model).columns.items():
    |

F403 `from .db import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:1:1
  |
1 | from .db import *
  | ^^^^^^^^^^^^^^^^^
2 | from .errors import *
3 | from .logging import *
  |

D104 Missing docstring in public package
--> praxis/backend/utils/__init__.py:1:1

F403 `from .errors import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:2:1
  |
1 | from .db import *
2 | from .errors import *
  | ^^^^^^^^^^^^^^^^^^^^^
3 | from .logging import *
4 | from .notify import *
  |

F403 `from .logging import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:3:1
  |
1 | from .db import *
2 | from .errors import *
3 | from .logging import *
  | ^^^^^^^^^^^^^^^^^^^^^^
4 | from .notify import *
5 | from .redis_lock import *
  |

F403 `from .notify import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:4:1
  |
2 | from .errors import *
3 | from .logging import *
4 | from .notify import *
  | ^^^^^^^^^^^^^^^^^^^^^
5 | from .redis_lock import *
6 | from .sanitation import *
  |

F403 `from .redis_lock import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:5:1
  |
3 | from .logging import *
4 | from .notify import *
5 | from .redis_lock import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
6 | from .sanitation import *
7 | from .uuid import uuid4, uuid7
  |

F403 `from .sanitation import *` used; unable to detect undefined names
 --> praxis/backend/utils/__init__.py:6:1
  |
4 | from .notify import *
5 | from .redis_lock import *
6 | from .sanitation import *
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
7 | from .uuid import uuid4, uuid7
  |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/db.py:52:12
   |
50 |         "password",
51 |         fallback="password",
52 |       )  # TODO(mar): Use a secure method for production # noqa: TD003
   |            ^^^^
53 |       praxis_db_host = config_parser.get("database", "host", fallback="localhost")
54 |       praxis_db_port = config_parser.get("database", "port", fallback="5432")
   |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/db.py:61:12
   |
59 |         "POSTGRES_PASSWORD",
60 |         praxis_db_password,
61 |       )  # TODO(mar): Use a secure method for production # noqa: TD003
   |            ^^^^
62 |       praxis_db_host = os.getenv("POSTGRES_HOST", praxis_db_host)
63 |       praxis_db_port = os.getenv("POSTGRES_PORT", praxis_db_port)
   |

ANN001 Missing type annotation for function argument `engine`
   --> praxis/backend/utils/db.py:201:33
    |
201 | async def init_praxis_db_schema(engine=None) -> None:
    |                                 ^^^^^^
202 |   """Initialize the Praxis database schema.
    |

D401 First line of docstring should be in imperative mood: "Decorator to manage database transactions in service layer methods."
  --> praxis/backend/utils/db_decorator.py:13:3
   |
12 |   def handle_db_transaction(func: F) -> F:
13 | /   """Decorator to manage database transactions in service layer methods.
14 | |
15 | |   This decorator wraps an async function that takes a SQLAlchemy `AsyncSession`
16 | |   as its first argument. It ensures that the session is properly committed
17 | |   on success and rolled back on any exception.
18 | |
19 | |   Args:
20 | |       func (Callable): The async function to be decorated.
21 | |
22 | |   Returns:
23 | |       Callable: The wrapped async function with transaction management logic.
24 | |
25 | |   Raises:
26 | |       Exception: Re-raises any exception that occurs within the decorated function
27 | |       after rolling back the transaction.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
  --> praxis/backend/utils/db_decorator.py:32:28
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                            ^^^
33 |     """Wrap the function with transaction handling.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> praxis/backend/utils/db_decorator.py:32:43
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                           ^^^
33 |     """Wrap the function with transaction handling.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
  --> praxis/backend/utils/db_decorator.py:32:51
   |
31 |   @wraps(func)
32 |   async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                                   ^^^
33 |     """Wrap the function with transaction handling.
   |

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/db_decorator.py:62:7
   |
60 |       result = await func(*args, **kwargs)
61 |       await db.commit()
62 |       return result
   |       ^^^^^^^^^^^^^
63 |     except Exception:
64 |       await db.rollback()
   |

ANN001 Missing type annotation for function argument `message`
   --> praxis/backend/utils/errors.py:220:5
    |
218 |   def __init__(
219 |     self,
220 |     message="Too little liquid for transfer.",
    |     ^^^^^^^
221 |     details=None,
222 |     original_plr_exception: Exception | None = None,
    |

ANN001 Missing type annotation for function argument `details`
   --> praxis/backend/utils/errors.py:221:5
    |
219 |     self,
220 |     message="Too little liquid for transfer.",
221 |     details=None,
    |     ^^^^^^^
222 |     original_plr_exception: Exception | None = None,
223 |   ) -> None:
    |

ANN001 Missing type annotation for function argument `message`
   --> praxis/backend/utils/errors.py:243:5
    |
241 |   def __init__(
242 |     self,
243 |     message="A PyLabRobot operation failed.",
    |     ^^^^^^^
244 |     original_plr_exception: Exception | None = None,
245 |   ) -> None:
    |

D100 Missing docstring in public module
--> praxis/backend/utils/filesystem.py:1:1

PTH123 `open()` should be replaced by `Path.open()`
  --> praxis/backend/utils/filesystem.py:10:12
   |
 8 |   def open(self, file: str, mode: str = "r", encoding: str | None = None) -> IO[Any]:
 9 |     """Open a file and return a file object."""
10 |     return open(file, mode, encoding=encoding)
   |            ^^^^
   |
help: Replace with `Path.open()`

ANN201 Missing return type annotation for public function `get_logger`
  --> praxis/backend/utils/logging.py:10:5
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |     ^^^^^^^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `name`
  --> praxis/backend/utils/logging.py:10:16
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

TD003 Missing issue link for this TODO
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

FIX002 Line contains TODO, consider resolving the issue
  --> praxis/backend/utils/logging.py:10:26
   |
10 | def get_logger(name):  # TODO: change to use built-in logging.getLogger and config
   |                          ^^^^
11 |   """Create and return a configured logger with stream handler."""
12 |   logger = logging.getLogger(name)
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/logging.py:25:3
   |
23 |   exception: Exception,
24 |   exception_type: type[Exception],
25 |   raises: bool,
   |   ^^^^^^
26 |   raises_exception: type[Exception],
27 |   prefix: str,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
  --> praxis/backend/utils/logging.py:29:12
   |
27 |   prefix: str,
28 |   suffix: str,
29 |   return_: Any,
   |            ^^^
30 | ) -> Any:
31 |   """Process the exception to generate a custom error message."""
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_process_exception`
  --> praxis/backend/utils/logging.py:30:6
   |
28 |   suffix: str,
29 |   return_: Any,
30 | ) -> Any:
   |      ^^^
31 |   """Process the exception to generate a custom error message."""
32 |   error_message = f"{prefix}{exception.__class__.__name__}: \
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/logging.py:54:3
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/logging.py:54:3
   |
52 |   logger_instance: logging.Logger,
53 |   exception_type: type[Exception] = Exception,
54 |   raises: bool = True,
   |   ^^^^^^
55 |   raises_exception: type[Exception] = Exception,
56 |   prefix: str = "",
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
  --> praxis/backend/utils/logging.py:58:12
   |
56 |   prefix: str = "",
57 |   suffix: str = "",
58 |   return_: Any = None,
   |            ^^^
59 | ) -> Callable:
60 |   """Log specified exceptions in a function and optionally re-raise them.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
  --> praxis/backend/utils/logging.py:94:30
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                              ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> praxis/backend/utils/logging.py:94:45
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                             ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
  --> praxis/backend/utils/logging.py:94:53
   |
92 |   def decorator(func: Callable) -> Callable:
93 |     @wraps(func)
94 |     async def wrapper(*args: Any, **kwargs: Any) -> Any:
   |                                                     ^^^
95 |       try:
96 |         return await func(*args, **kwargs)
   |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/logging.py:117:3
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/logging.py:117:3
    |
115 |   logger_instance: logging.Logger,
116 |   exception_type: type[Exception] = Exception,
117 |   raises: bool = True,
    |   ^^^^^^
118 |   raises_exception: type[Exception] = Exception,
119 |   prefix: str = "",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `return_`
   --> praxis/backend/utils/logging.py:121:12
    |
119 |   prefix: str = "",
120 |   suffix: str = "",
121 |   return_: Any = None,
    |            ^^^
122 | ) -> Callable:
123 |   """Log specified exceptions in a function and optionally re-raise them.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> praxis/backend/utils/logging.py:157:24
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                        ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> praxis/backend/utils/logging.py:157:39
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                       ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `wrapper`
   --> praxis/backend/utils/logging.py:157:47
    |
155 |   def decorator(func: Callable) -> Callable:
156 |     @wraps(func)
157 |     def wrapper(*args: Any, **kwargs: Any) -> Any:
    |                                               ^^^
158 |       try:
159 |         return func(*args, **kwargs)
    |

ANN001 Missing type annotation for function argument `smtp_server`
  --> praxis/backend/utils/notify.py:41:22
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                      ^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_port`
  --> praxis/backend/utils/notify.py:41:35
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                   ^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_username`
  --> praxis/backend/utils/notify.py:41:46
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                              ^^^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

ANN001 Missing type annotation for function argument `smtp_password`
  --> praxis/backend/utils/notify.py:41:61
   |
39 |   """A utility class for sending email and SMS notifications."""
40 |
41 |   def __init__(self, smtp_server, smtp_port, smtp_username, smtp_password) -> None:
   |                                                             ^^^^^^^^^^^^^
42 |     """Initialize the Notifier with SMTP server details."""
43 |     self.smtp_server = smtp_server
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> praxis/backend/utils/notify.py:74:5
   |
72 |           server.login(self.smtp_username, self.smtp_password)
73 |           server.send_message(message)
74 | /     except Exception:  # noqa: BLE001
75 | |       pass
   | |__________^
76 |
77 |     def send_text(
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `module`
  --> praxis/backend/utils/plr_inspection.py:38:11
   |
37 | def get_module_classes(
38 |   module: Any,
   |           ^^^
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:40:3
   |
38 |   module: Any,
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |   ^^^^^^^^^^^^^
41 | ) -> dict[str, type[Any]]:
42 |   """Get all classes from a module that are subclasses of parent_class.
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:40:3
   |
38 |   module: Any,
39 |   parent_class: type[Any] | None = None,
40 |   concrete_only: bool = False,
   |   ^^^^^^^^^^^^^
41 | ) -> dict[str, type[Any]]:
42 |   """Get all classes from a module that are subclasses of parent_class.
   |

FBT001 Boolean-typed positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:82:3
   |
80 | def get_constructor_params_with_defaults(
81 |   klass: type[Any],
82 |   required_only: bool = False,
   |   ^^^^^^^^^^^^^
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

FBT002 Boolean default positional argument in function definition
  --> praxis/backend/utils/plr_inspection.py:82:3
   |
80 | def get_constructor_params_with_defaults(
81 |   klass: type[Any],
82 |   required_only: bool = False,
   |   ^^^^^^^^^^^^^
83 | ) -> dict[str, Any]:
84 |   """Get the constructor parameters and their default values for a class.
   |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:105:87
    |
103 |       params[name] = param.default
104 |   except Exception as e:
105 |     logger.exception("Error inspecting constructor for %s: %s", get_class_fqn(klass), e)
    |                                                                                       ^
106 |   return params
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:142:3
    |
140 |   module_name: str,
141 |   parent_class: type[Any] | None,
142 |   concrete_only: bool,
    |   ^^^^^^^^^^^^^
143 |   visited_modules: set[str],
144 | ) -> dict[str, type[Any]]:
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:188:69
    |
186 |     logger.warning("Could not import module %s: %s", module_name, e)
187 |   except Exception as e:
188 |     logger.exception("Error processing module %s: %s", module_name, e)
    |                                                                     ^
189 |   return found_classes
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:195:3
    |
193 |   base_module_names: str | list[str] = "pylabrobot",
194 |   parent_class: type[Any] | None = None,
195 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
196 | ) -> dict[str, type[Any]]:
197 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:195:3
    |
193 |   base_module_names: str | list[str] = "pylabrobot",
194 |   parent_class: type[Any] | None = None,
195 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
196 | ) -> dict[str, type[Any]]:
197 |   """Get all PyLabRobot classes from base module(s) and their submodules.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:224:3
    |
223 | def get_resource_classes(
224 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:224:3
    |
223 | def get_resource_classes(
224 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:227:28
    |
225 | ) -> dict[str, type[Resource]]:
226 |   """Return all resource classes from PyLabRobot modules."""
227 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
228 |     base_module_names=[
229 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:238:3
    |
237 | def get_machine_classes(
238 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:238:3
    |
237 | def get_machine_classes(
238 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:241:28
    |
239 | ) -> dict[str, type[Machine]]:
240 |   """Return all machine classes from PyLabRobot modules."""
241 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
242 |     base_module_names="pylabrobot.machines",
243 |     parent_class=Machine,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:248:22
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:248:22
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
    |                      ^^^^^^^^^^^^^
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:250:33
    |
248 | def get_deck_classes(concrete_only: bool = True) -> dict[str, type[Deck]]:
249 |   """Return all deck classes from PyLabRobot modules."""
250 |   all_decks = get_all_classes(  # type: ignore
    |                                 ^^^^^^^^^^^^^^
251 |     base_module_names=[
252 |       "pylabrobot.resources",
    |

PERF403 Use a dictionary comprehension instead of a for-loop
   --> praxis/backend/utils/plr_inspection.py:281:11
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |
help: Replace for loop with dict comprehension

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:281:54
    |
279 |       for fqn, deck_class in deck_classes_in_pkg.items():
280 |         if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |           discovered_deck_classes[fqn] = deck_class  # type: ignore
    |                                                      ^^^^^^^^^^^^^^
282 |     except ImportError:
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
    |

PERF203 `try`-`except` within a loop incurs performance overhead
   --> praxis/backend/utils/plr_inspection.py:282:5
    |
280 |           if issubclass(deck_class, Deck) and deck_class is not Deck:
281 |             discovered_deck_classes[fqn] = deck_class  # type: ignore
282 | /     except ImportError:
283 | |       logger.warning("Package %s not found during deck discovery.", package_name)
    | |_________________________________________________________________________________^
284 |       except Exception as e:
285 |         logger.exception("Error discovering deck classes in package %s: %s", package_name, e)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> praxis/backend/utils/plr_inspection.py:285:90
    |
283 |       logger.warning("Package %s not found during deck discovery.", package_name)
284 |     except Exception as e:
285 |       logger.exception("Error discovering deck classes in package %s: %s", package_name, e)
    |                                                                                          ^
286 |   return discovered_deck_classes
    |

C901 `_get_accepted_categories_for_resource_holder` is too complex (11 > 10)
   --> praxis/backend/utils/plr_inspection.py:289:5
    |
289 | def _get_accepted_categories_for_resource_holder(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
290 |   holder: ResourceHolder,
291 |   parent_carrier: Carrier | None = None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:327:3
    |
326 | def get_resource_holder_classes(
327 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
328 | ) -> dict[str, type[ResourceHolder]]:
329 |   """Return all resource holder and specific carrier classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:327:3
    |
326 | def get_resource_holder_classes(
327 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
328 | ) -> dict[str, type[ResourceHolder]]:
329 |   """Return all resource holder and specific carrier classes.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:333:28
    |
331 |   Includes holders and specific carriers from PyLabRobot modules.
332 |   """
333 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
334 |     base_module_names=[
335 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:344:3
    |
343 | def get_carrier_classes(
344 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
345 | ) -> dict[str, type[Carrier]]:
346 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:344:3
    |
343 | def get_carrier_classes(
344 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
345 | ) -> dict[str, type[Carrier]]:
346 |   """Return all carrier classes (including plate, tip, and trough carriers).
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:350:28
    |
348 |   Includes all carrier types from PyLabRobot modules.
349 |   """
350 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
351 |     base_module_names=[
352 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:361:3
    |
360 | def get_plate_carrier_classes(
361 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:361:3
    |
360 | def get_plate_carrier_classes(
361 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:364:28
    |
362 | ) -> dict[str, type[PlateCarrier]]:
363 |   """Return all plate carrier classes from PyLabRobot modules."""
364 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
365 |     base_module_names=[
366 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:375:3
    |
374 | def get_tip_carrier_classes(
375 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:375:3
    |
374 | def get_tip_carrier_classes(
375 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:378:28
    |
376 | ) -> dict[str, type[TipCarrier]]:
377 |   """Return all tip carrier classes from PyLabRobot modules."""
378 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
379 |     base_module_names=[
380 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:389:3
    |
388 | def get_trough_carrier_classes(
389 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:389:3
    |
388 | def get_trough_carrier_classes(
389 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:392:28
    |
390 | ) -> dict[str, type[TroughCarrier]]:
391 |   """Return all trough carrier classes from PyLabRobot modules."""
392 |   return get_all_classes(  # type: ignore
    |                            ^^^^^^^^^^^^^^
393 |     base_module_names=[
394 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:403:3
    |
402 | def get_all_carrier_classes(
403 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
404 | ) -> dict[str, type[Carrier]]:
405 |   """Return all carrier classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:403:3
    |
402 | def get_all_carrier_classes(
403 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
404 | ) -> dict[str, type[Carrier]]:
405 |   """Return all carrier classes.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> praxis/backend/utils/plr_inspection.py:417:36
    |
416 |   """
417 |   all_carriers = get_all_classes(  # type: ignore
    |                                    ^^^^^^^^^^^^^^
418 |     base_module_names=[
419 |       "pylabrobot.resources",
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:433:3
    |
432 | def get_all_deck_and_carrier_classes(
433 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
434 | ) -> dict[str, type[Deck | Carrier]]:
435 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:433:3
    |
432 | def get_all_deck_and_carrier_classes(
433 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
434 | ) -> dict[str, type[Deck | Carrier]]:
435 |   """Return all deck and carrier classes from PyLabRobot modules."""
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:442:3
    |
441 | def get_all_resource_classes(
442 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:442:3
    |
441 | def get_all_resource_classes(
442 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |

E501 Line too long (102 > 100)
   --> praxis/backend/utils/plr_inspection.py:444:101
    |
442 |   concrete_only: bool = True,
443 | ) -> dict[str, type[Resource]]:
444 |   """Return all resource classes (including holders and specific carriers) from PyLabRobot modules."""
    |                                                                                                     ^^
445 |   all_resources = get_resource_classes(concrete_only=concrete_only)
446 |   all_holders = get_resource_holder_classes(concrete_only=concrete_only)
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:451:3
    |
450 | def get_all_machine_and_deck_classes(
451 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
452 | ) -> dict[str, type[Machine | Deck]]:
453 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:451:3
    |
450 | def get_all_machine_and_deck_classes(
451 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
452 | ) -> dict[str, type[Machine | Deck]]:
453 |   """Return all machine and deck classes from PyLabRobot modules."""
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:462:3
    |
460 |   base_module_names: str | list[str] = "pylabrobot",
461 |   parent_class: type[Any] | None = None,
462 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
463 | ) -> dict[str, type[Any]]:
464 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:462:3
    |
460 |   base_module_names: str | list[str] = "pylabrobot",
461 |   parent_class: type[Any] | None = None,
462 |   concrete_only: bool = False,
    |   ^^^^^^^^^^^^^
463 | ) -> dict[str, type[Any]]:
464 |   """Get all classes with enhanced inspection from base module(s) and their submodules.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:505:3
    |
504 | def get_all_resource_and_machine_classes(
505 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
506 | ) -> dict[str, type[Any]]:
507 |   """Return all resources and machine classes.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:505:3
    |
504 | def get_all_resource_and_machine_classes(
505 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
506 | ) -> dict[str, type[Any]]:
507 |   """Return all resources and machine classes.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:517:3
    |
516 | def get_deck_and_carrier_classes(
517 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
518 | ) -> dict[str, type[Any]]:
519 |   """Return all deck and carrier classes with enhanced inspection.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:517:3
    |
516 | def get_deck_and_carrier_classes(
517 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
518 | ) -> dict[str, type[Any]]:
519 |   """Return all deck and carrier classes with enhanced inspection.
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:539:3
    |
538 | def get_all_resource_and_machine_classes_enhanced(
539 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
540 | ) -> dict[str, type[Any]]:
541 |   """Return all resources and machine classes with enhanced inspection.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/plr_inspection.py:539:3
    |
538 | def get_all_resource_and_machine_classes_enhanced(
539 |   concrete_only: bool = True,
    |   ^^^^^^^^^^^^^
540 | ) -> dict[str, type[Any]]:
541 |   """Return all resources and machine classes with enhanced inspection.
    |

D100 Missing docstring in public module
--> praxis/backend/utils/redis_lock.py:1:1

ANN201 Missing return type annotation for public function `acquire_lock`
  --> praxis/backend/utils/redis_lock.py:8:5
   |
 7 | @contextlib.contextmanager
 8 | def acquire_lock(
   |     ^^^^^^^^^^^^
 9 |   redis_client: redis.Redis,
10 |   resource_name: str,
   |
help: Add return type annotation

TRY203 Remove exception handler; error is immediately re-raised
  --> praxis/backend/utils/redis_lock.py:44:3
   |
42 |       # Timeout
43 |       yield False
44 | /   except Exception:
45 | |     raise
   | |_________^
46 |     finally:
47 |       # Only release the lock if it was acquired and the identifier matches
   |

TRY203 Remove exception handler; error is immediately re-raised
  --> praxis/backend/utils/redis_lock.py:51:7
   |
49 |         try:
50 |           redis_client.delete(lock_name)
51 | /       except Exception:
52 | |         raise
   | |_____________^
   |

ERA001 Found commented-out code
  --> praxis/backend/utils/run_control.py:19:3
   |
17 |   # Assuming settings.redis_host and settings.redis_port are available
18 |   # If settings.redis_url is directly available, that would be preferred:
19 |   # redis_url = settings.redis_url
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 |   redis_url = f"redis://{SETTINGS.redis_host}:{SETTINGS.redis_port}/0"
21 |   return redis.Redis.from_url(redis_url, decode_responses=True)
   |
help: Remove commented-out code

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/run_control.py:51:5
   |
49 |     key = _get_command_key(run_accession_id)
50 |     await r.set(key, command, ex=ttl_seconds)
51 |     return True
   |     ^^^^^^^^^^^
52 |   except RedisError:
53 |     # In a real application, use a proper logger
   |

TRY300 Consider moving this statement to an `else` block
  --> praxis/backend/utils/run_control.py:89:5
   |
87 |     key = _get_command_key(run_accession_id)
88 |     deleted_count = await r.delete(key)
89 |     return deleted_count > 0
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
90 |   except RedisError:
91 |     return False
   |

D100 Missing docstring in public module
--> praxis/backend/utils/sanitation.py:1:1

D103 Missing docstring in public function
  --> praxis/backend/utils/sanitation.py:10:11
   |
10 | async def well_to_int(well: Well, plate: Plate) -> int:
   |           ^^^^^^^^^^^
11 |   column, row = await parse_well_name(well)
12 |   return int((column * plate.num_items_y) + row)
   |

ANN201 Missing return type annotation for public function `liquid_handler_setup_check`
  --> praxis/backend/utils/sanitation.py:15:5
   |
15 | def liquid_handler_setup_check(func):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
  --> praxis/backend/utils/sanitation.py:15:32
   |
15 | def liquid_handler_setup_check(func):
   |                                ^^^^
16 |   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 |   function.
   |

D205 1 blank line required between summary line and description
  --> praxis/backend/utils/sanitation.py:16:3
   |
15 |   def liquid_handler_setup_check(func):
16 | /   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 | |   function.
18 | |
19 | |   Args:
20 | |     func: The function to be decorated.
21 | |
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | |
26 | |   Returns:
27 | |     The decorated function.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "A decorator function that checks if a liquid handler is set up before executing the decorated"
  --> praxis/backend/utils/sanitation.py:16:3
   |
15 |   def liquid_handler_setup_check(func):
16 | /   """A decorator function that checks if a liquid handler is set up before executing the decorated
17 | |   function.
18 | |
19 | |   Args:
20 | |     func: The function to be decorated.
21 | |
22 | |   Raises:
23 | |     ValueError: If no liquid handler is provided.
24 | |     RuntimeError: If the liquid handler is not set up.
25 | |
26 | |   Returns:
27 | |     The decorated function.
28 | |
29 | |   """
   | |_____^
30 |
31 |     @wraps(func)
   |

ANN202 Missing return type annotation for private function `wrapper`
  --> praxis/backend/utils/sanitation.py:32:13
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |             ^^^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> praxis/backend/utils/sanitation.py:32:21
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                     ^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |

ANN003 Missing type annotation for `**kwargs`
  --> praxis/backend/utils/sanitation.py:32:28
   |
31 |   @wraps(func)
32 |   async def wrapper(*args, **kwargs):
   |                            ^^^^^^^^
33 |     if len(args) == 0 and "liquid_handler" not in kwargs:
34 |       msg = "No liquid handler provided"
   |

D417 Missing argument description in the docstring for `coerce_to_list`: `target_length`
  --> praxis/backend/utils/sanitation.py:45:11
   |
45 | async def coerce_to_list(items: list | tuple, target_length: int | None) -> list:
   |           ^^^^^^^^^^^^^^
46 |   """Coerces the given items into a list.
   |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/sanitation.py:109:48
    |
109 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^
110 |   """Check the types of items in a list against a given list of types.
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/sanitation.py:109:48
    |
109 | async def type_check(items: list, types: list, in_list: bool = False) -> None:
    |                                                ^^^^^^^
110 |   """Check the types of items in a list against a given list of types.
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:129:7
    |
127 |     if not isinstance(item, item_type):
128 |       msg = f"Expected {item_type} but got {type(item)}"
129 |       raise ValueError(msg)
    |       ^^^^^^^^^^^^^^^^^^^^^
    |

D417 Missing argument descriptions in the docstring for `check_list_length`: `coerce_length`, `target_length`
   --> praxis/backend/utils/sanitation.py:132:11
    |
132 | async def check_list_length(
    |           ^^^^^^^^^^^^^^^^^
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |

FBT001 Boolean-typed positional argument in function definition
   --> praxis/backend/utils/sanitation.py:134:3
    |
132 | async def check_list_length(
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^
135 |   target_length: int | None = None,
136 | ) -> list[list[Any]]:
    |

FBT002 Boolean default positional argument in function definition
   --> praxis/backend/utils/sanitation.py:134:3
    |
132 | async def check_list_length(
133 |   items: list[Any] | list[list[Any]],
134 |   coerce_length: bool = False,
    |   ^^^^^^^^^^^^^
135 |   target_length: int | None = None,
136 | ) -> list[list[Any]]:
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:155:7
    |
153 |   if not isinstance(items[0], list) and len(items) != target_length:
154 |     if len(items) == 1 and coerce_length:
155 |       assert target_length is not None, "Expected target length to be provided"
    |       ^^^^^^
156 |       return items * target_length
157 |     msg = f"Expected list of length {length} but got list of length {len(items)}"
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:165:7
    |
163 |     if not isinstance(item, list):
164 |       msg = f"Expected list but got {type(item)}"
165 |       raise ValueError(msg)
    |       ^^^^^^^^^^^^^^^^^^^^^
166 |     if len(item) != target_length:
167 |       if len(item) == 1 and coerce_length:
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:168:9
    |
166 |     if len(item) != target_length:
167 |       if len(item) == 1 and coerce_length:
168 |         assert target_length is not None, "Expected target length to be provided"  # mypy assert
    |         ^^^^^^
169 |         new_items.append(item * target_length)
170 |       else:
    |

D417 Missing argument description in the docstring for `parse_well_name`: `well`
   --> praxis/backend/utils/sanitation.py:180:11
    |
180 | async def parse_well_name(well: Well) -> tuple:
    |           ^^^^^^^^^^^^^^^
181 |   """Parse the name of a well into a tuple of the row and column.
    |

D417 Missing argument descriptions in the docstring for `parse_well_str_accession_id`: `plate`, `well`
   --> praxis/backend/utils/sanitation.py:196:11
    |
196 | async def parse_well_str_accession_id(well: str, plate: Plate) -> list[Well]:
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 |   """Parse the name of a well into a tuple of the row and column.
    |

C901 `tip_mapping` is too complex (12 > 10)
   --> praxis/backend/utils/sanitation.py:209:11
    |
209 | async def tip_mapping(
    |           ^^^^^^^^^^^
210 |   tips: TipRack | list[TipSpot],
211 |   sources: list[Well],
    |

D417 Missing argument descriptions in the docstring for `tip_mapping`: `map_tips`, `source_plate`, `target_plate`
   --> praxis/backend/utils/sanitation.py:209:11
    |
209 | async def tip_mapping(
    |           ^^^^^^^^^^^
210 |   tips: TipRack | list[TipSpot],
211 |   sources: list[Well],
    |

ARG001 Unused function argument: `target_plate`
   --> praxis/backend/utils/sanitation.py:213:3
    |
211 |   sources: list[Well],
212 |   source_plate: Plate,
213 |   target_plate: Plate | None = None,
    |   ^^^^^^^^^^^^
214 |   targets: list[Well] | None = None,
215 |   map_tips: Literal["source", "target"] | None = None,
    |

D205 1 blank line required between summary line and description
   --> praxis/backend/utils/sanitation.py:217:3
    |
215 |     map_tips: Literal["source", "target"] | None = None,
216 |   ) -> list[TipSpot]:
217 | /   """Check if tips can be mapped between either source or destination containers based on if they
218 | |   are wells, and that the number of tips is sufficient for the number of sources and targets.
219 | |
220 | |   Args:
221 | |     tips (TipRack | list[TipSpot]): The list of tips to be mapped.
222 | |     sources (list[Well]): The list of source containers.
223 | |     targets (list[Well]): The list of destination containers.
224 | |
225 | |   Raises:
226 | |     ValueError: If the tips cannot be mapped between either the source and target containers.
227 | |     NotImplementedError: If multiple tip racks are used to map between source or target containers.
228 | |     ValueError: If the tip rack does not have a tip at the specified location.
229 | |     ValueError: If the type of the tip is not a list of Tip objects or a single TipRack.
230 | |     ValueError: If the value of map_tips is not "source" or "target".
231 | |     ValueError: If the number of tips is insufficient for the number of sources or targets.
232 | |
233 | |   Returns:
234 | |     tips: The list of tips, either from the input or from mapping between source, target, and
235 | |     tip rack.
236 | |
237 | |   """
    | |_____^
238 |     if isinstance(tips, list):
239 |       if all(isinstance(tip, TipSpot) for tip in tips):
    |
help: Insert single blank line

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:258:3
    |
256 |     targets = sources
257 |   map_onto = sources if map_tips == "source" else targets
258 |   assert map_onto is not None, "Expected map_onto to be provided"  # mypy assert
    |   ^^^^^^
259 |   if isinstance(tips, TipRack):
260 |     tip_number = tips.num_items
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> praxis/backend/utils/sanitation.py:263:5
    |
261 |     else:
262 |       msg = "Invalid type for tip. Must be a list of TipSpot objects or single TipRack."
263 | /     raise ValueError(
264 | |       msg,
265 | |     )
    | |_____^
266 |     if tip_number < len(map_onto):
267 |       msg = "Insufficient number of tips for the number of sources or targets."
    |

S101 Use of `assert` detected
   --> praxis/backend/utils/sanitation.py:280:7
    |
278 |       )
279 |     for well in map_onto:
280 |       assert isinstance(well, Well), "Expected Well object"  # mypy compatible assert
    |       ^^^^^^
281 |       well_number = await well_to_int(well, source_plate)
282 |       if not tips[well_number][0].has_tip():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `key`
   --> praxis/backend/utils/sanitation.py:289:43
    |
289 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                           ^^^
290 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 |     the key matches the given key and the value matches the given value.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> praxis/backend/utils/sanitation.py:289:55
    |
289 | def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
    |                                                       ^^^
290 |   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 |     the key matches the given key and the value matches the given value.
    |

D205 1 blank line required between summary line and description
   --> praxis/backend/utils/sanitation.py:290:3
    |
289 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
290 | /   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 | |     the key matches the given key and the value matches the given value.
292 | |
293 | |   Args:
294 | |     nested_dict (dict): The nested dictionary to be sliced.
295 | |     key (Any): The key to be matched.
296 | |     value (Any): The value to be matched.
297 | |
298 | |   Returns:
299 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
300 | |
301 | |   """
    | |_____^
302 |     new_dict = {}
303 |     for k, v in nested_dict.items():
    |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "Returns a new dictionary containing only the key-value pairs from the nested dictionary where \"
   --> praxis/backend/utils/sanitation.py:290:3
    |
289 |   def boolean_slice(nested_dict: dict, key: Any, value: Any) -> dict:
290 | /   """Returns a new dictionary containing only the key-value pairs from the nested dictionary where \
291 | |     the key matches the given key and the value matches the given value.
292 | |
293 | |   Args:
294 | |     nested_dict (dict): The nested dictionary to be sliced.
295 | |     key (Any): The key to be matched.
296 | |     value (Any): The value to be matched.
297 | |
298 | |   Returns:
299 | |     dict: The new dictionary containing only the key-value pairs that match the given key and value.
300 | |
301 | |   """
    | |_____^
302 |     new_dict = {}
303 |     for k, v in nested_dict.items():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `obj_type`
  --> praxis/backend/utils/type_inspection.py:10:38
   |
10 | def is_pylabrobot_resource(obj_type: Any) -> bool:
   |                                      ^^^
11 |   """Check if the given type is a Pylabrobot Resource or Union of Resources."""
12 |   if obj_type is inspect.Parameter.empty:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
  --> praxis/backend/utils/type_inspection.py:26:30
   |
26 | def fqn_from_hint(type_hint: Any) -> str:
   |                              ^^^
27 |   """Get the fully qualified name of a type hint.
   |

SIM108 Use ternary operator `actual_type = resource_types[0] if resource_types else non_none_args[0]` instead of `if`-`else`-block
  --> praxis/backend/utils/type_inspection.py:48:7
   |
46 |         # This is a heuristic. A more robust solution might require more context.
47 |         resource_types = [t for t in non_none_args if is_pylabrobot_resource(t)]
48 | /       if resource_types:
49 | |         actual_type = resource_types[0]
50 | |       else:
51 | |         actual_type = non_none_args[0]  # Fallback to the first type
   | |______________________________________^
52 |       else:  # Only NoneType in Union
53 |         return "None"
   |
help: Replace `if`-`else`-block with `actual_type = resource_types[0] if resource_types else non_none_args[0]`

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `type_hint`
  --> praxis/backend/utils/type_inspection.py:69:36
   |
69 | def serialize_type_hint(type_hint: Any) -> str:
   |                                    ^^^
70 |   """Serialize a type hint to a string representation."""
71 |   if type_hint == inspect.Parameter.empty:
   |

Found 452 errors (5 fixed, 447 remaining).
No fixes available (20 hidden fixes can be enabled with the `--unsafe-fixes` option).
