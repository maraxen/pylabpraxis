# WebSocket API

Praxis uses WebSockets for real-time monitoring of protocol execution. This allows the frontend to receive status changes, progress updates, logs, and telemetry without polling.

## Endpoint

Connect to the execution-specific WebSocket endpoint:

```
ws://<host>:<port>/api/v1/ws/execution/{run_id}
```

**Parameters:**

* `run_id`: The UUID of the protocol run to monitor.

## Connection Lifecycle

1. **Connect**: Client establishes WebSocket connection to the URL.
2. **Streaming**: Server immediately begins pushing updates (polling internally if necessary).
3. **Termination**:
    * Server closes connection when run reaches a terminal state (`COMPLETED`, `FAILED`, `CANCELLED`).
    * Client can disconect at any time.

## Message Format

All messages sent by the server follow this structure:

```json
{
  "type": "string",       // Message type (status, progress, log, telemetry, etc.)
  "payload": { ... },     // Data specific to the message type
  "timestamp": "string"   // Server timestamp
}
```

## Message Types

### 1. Status Update

Sent when the run status changes (e.g., from `PENDING` to `RUNNING`).

```json
{
  "type": "status",
  "payload": {
    "status": "RUNNING",
    "step": "Initializing"
  }
}
```

### 2. Progress Update

Sent periodically to indicate the percentage of completion.

```json
{
  "type": "progress",
  "payload": {
    "progress": 45.5  // Percentage (0-100)
  }
}
```

### 3. Log Entry

Sent when new log lines are generated by the execution runtime.

```json
{
  "type": "log",
  "payload": {
    "message": "Aspirating 100uL from Source Plate A1",
    "level": "INFO"
  }
}
```

### 4. Telemetry Data

Sent when new sensor or telemetry data is available (e.g., from `MockTelemetryService`).

```json
{
  "type": "telemetry",
  "payload": {
    "metric": "temperature",
    "value": 37.0,
    "unit": "C"
  }
}
```

### 5. Completion

Sent when the run finishes successfully. The server will close the connection shortly after.

```json
{
  "type": "complete"
}
```

### 6. Error

Sent if the run fails or encounters a critical error.

```json
{
  "type": "error",
  "payload": {
    "error": "Protocol execution failed"
  }
}
```

## Example (JavaScript)

```javascript
const runId = "123e4567-e89b-12d3-a456-426614174000";
const ws = new WebSocket(`ws://localhost:8000/api/v1/ws/execution/${runId}`);

ws.onopen = () => {
    console.log("Connected to execution stream");
};

ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    
    switch (msg.type) {
        case 'status':
            console.log("Status changed:", msg.payload.status);
            break;
        case 'progress':
            updateProgressBar(msg.payload.progress);
            break;
        case 'log':
            console.log(`[${msg.payload.level}] ${msg.payload.message}`);
            break;
        case 'telemetry':
            updateChart(msg.payload);
            break;
        case 'complete':
            console.log("Run finished!");
            break;
    }
};

ws.onclose = () => {
    console.log("Connection closed");
};
```
