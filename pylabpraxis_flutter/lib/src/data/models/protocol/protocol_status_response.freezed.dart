// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'protocol_status_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ProtocolStatusResponse {

// Unique identifier for the protocol run.
 String get runId;// Current status of the protocol execution.
 RunStatus get status;// Optional: A message providing more details about the current status or any errors.
 String? get message;// Optional: Timestamp of when this status was recorded or updated.
 DateTime? get timestamp;// Optional: Progress of the protocol execution (e.g., percentage, current step).
// This could be a simple number or a more complex object.
 dynamic get progress;// e.g., { "current_step": "step_3", "total_steps": 10, "percentage": 30 }
// Optional: Any results or data generated by the protocol up to this point.
 Map<String, dynamic>? get results;// Optional: Estimated time remaining.
@JsonKey(name: 'estimated_time_remaining') String? get estimatedTimeRemaining;// e.g., "PT10M"
// Optional: Link to detailed logs or further information about the run.
 String? get logsUrl;
/// Create a copy of ProtocolStatusResponse
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ProtocolStatusResponseCopyWith<ProtocolStatusResponse> get copyWith => _$ProtocolStatusResponseCopyWithImpl<ProtocolStatusResponse>(this as ProtocolStatusResponse, _$identity);

  /// Serializes this ProtocolStatusResponse to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ProtocolStatusResponse&&(identical(other.runId, runId) || other.runId == runId)&&(identical(other.status, status) || other.status == status)&&(identical(other.message, message) || other.message == message)&&(identical(other.timestamp, timestamp) || other.timestamp == timestamp)&&const DeepCollectionEquality().equals(other.progress, progress)&&const DeepCollectionEquality().equals(other.results, results)&&(identical(other.estimatedTimeRemaining, estimatedTimeRemaining) || other.estimatedTimeRemaining == estimatedTimeRemaining)&&(identical(other.logsUrl, logsUrl) || other.logsUrl == logsUrl));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,runId,status,message,timestamp,const DeepCollectionEquality().hash(progress),const DeepCollectionEquality().hash(results),estimatedTimeRemaining,logsUrl);

@override
String toString() {
  return 'ProtocolStatusResponse(runId: $runId, status: $status, message: $message, timestamp: $timestamp, progress: $progress, results: $results, estimatedTimeRemaining: $estimatedTimeRemaining, logsUrl: $logsUrl)';
}


}

/// @nodoc
abstract mixin class $ProtocolStatusResponseCopyWith<$Res>  {
  factory $ProtocolStatusResponseCopyWith(ProtocolStatusResponse value, $Res Function(ProtocolStatusResponse) _then) = _$ProtocolStatusResponseCopyWithImpl;
@useResult
$Res call({
 String runId, RunStatus status, String? message, DateTime? timestamp, dynamic progress, Map<String, dynamic>? results,@JsonKey(name: 'estimated_time_remaining') String? estimatedTimeRemaining, String? logsUrl
});




}
/// @nodoc
class _$ProtocolStatusResponseCopyWithImpl<$Res>
    implements $ProtocolStatusResponseCopyWith<$Res> {
  _$ProtocolStatusResponseCopyWithImpl(this._self, this._then);

  final ProtocolStatusResponse _self;
  final $Res Function(ProtocolStatusResponse) _then;

/// Create a copy of ProtocolStatusResponse
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? runId = null,Object? status = null,Object? message = freezed,Object? timestamp = freezed,Object? progress = freezed,Object? results = freezed,Object? estimatedTimeRemaining = freezed,Object? logsUrl = freezed,}) {
  return _then(_self.copyWith(
runId: null == runId ? _self.runId : runId // ignore: cast_nullable_to_non_nullable
as String,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as RunStatus,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,timestamp: freezed == timestamp ? _self.timestamp : timestamp // ignore: cast_nullable_to_non_nullable
as DateTime?,progress: freezed == progress ? _self.progress : progress // ignore: cast_nullable_to_non_nullable
as dynamic,results: freezed == results ? _self.results : results // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,estimatedTimeRemaining: freezed == estimatedTimeRemaining ? _self.estimatedTimeRemaining : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
as String?,logsUrl: freezed == logsUrl ? _self.logsUrl : logsUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _ProtocolStatusResponse implements ProtocolStatusResponse {
  const _ProtocolStatusResponse({required this.runId, required this.status, this.message, this.timestamp, this.progress, final  Map<String, dynamic>? results, @JsonKey(name: 'estimated_time_remaining') this.estimatedTimeRemaining, this.logsUrl}): _results = results;
  factory _ProtocolStatusResponse.fromJson(Map<String, dynamic> json) => _$ProtocolStatusResponseFromJson(json);

// Unique identifier for the protocol run.
@override final  String runId;
// Current status of the protocol execution.
@override final  RunStatus status;
// Optional: A message providing more details about the current status or any errors.
@override final  String? message;
// Optional: Timestamp of when this status was recorded or updated.
@override final  DateTime? timestamp;
// Optional: Progress of the protocol execution (e.g., percentage, current step).
// This could be a simple number or a more complex object.
@override final  dynamic progress;
// e.g., { "current_step": "step_3", "total_steps": 10, "percentage": 30 }
// Optional: Any results or data generated by the protocol up to this point.
 final  Map<String, dynamic>? _results;
// e.g., { "current_step": "step_3", "total_steps": 10, "percentage": 30 }
// Optional: Any results or data generated by the protocol up to this point.
@override Map<String, dynamic>? get results {
  final value = _results;
  if (value == null) return null;
  if (_results is EqualUnmodifiableMapView) return _results;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

// Optional: Estimated time remaining.
@override@JsonKey(name: 'estimated_time_remaining') final  String? estimatedTimeRemaining;
// e.g., "PT10M"
// Optional: Link to detailed logs or further information about the run.
@override final  String? logsUrl;

/// Create a copy of ProtocolStatusResponse
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ProtocolStatusResponseCopyWith<_ProtocolStatusResponse> get copyWith => __$ProtocolStatusResponseCopyWithImpl<_ProtocolStatusResponse>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ProtocolStatusResponseToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ProtocolStatusResponse&&(identical(other.runId, runId) || other.runId == runId)&&(identical(other.status, status) || other.status == status)&&(identical(other.message, message) || other.message == message)&&(identical(other.timestamp, timestamp) || other.timestamp == timestamp)&&const DeepCollectionEquality().equals(other.progress, progress)&&const DeepCollectionEquality().equals(other._results, _results)&&(identical(other.estimatedTimeRemaining, estimatedTimeRemaining) || other.estimatedTimeRemaining == estimatedTimeRemaining)&&(identical(other.logsUrl, logsUrl) || other.logsUrl == logsUrl));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,runId,status,message,timestamp,const DeepCollectionEquality().hash(progress),const DeepCollectionEquality().hash(_results),estimatedTimeRemaining,logsUrl);

@override
String toString() {
  return 'ProtocolStatusResponse(runId: $runId, status: $status, message: $message, timestamp: $timestamp, progress: $progress, results: $results, estimatedTimeRemaining: $estimatedTimeRemaining, logsUrl: $logsUrl)';
}


}

/// @nodoc
abstract mixin class _$ProtocolStatusResponseCopyWith<$Res> implements $ProtocolStatusResponseCopyWith<$Res> {
  factory _$ProtocolStatusResponseCopyWith(_ProtocolStatusResponse value, $Res Function(_ProtocolStatusResponse) _then) = __$ProtocolStatusResponseCopyWithImpl;
@override @useResult
$Res call({
 String runId, RunStatus status, String? message, DateTime? timestamp, dynamic progress, Map<String, dynamic>? results,@JsonKey(name: 'estimated_time_remaining') String? estimatedTimeRemaining, String? logsUrl
});




}
/// @nodoc
class __$ProtocolStatusResponseCopyWithImpl<$Res>
    implements _$ProtocolStatusResponseCopyWith<$Res> {
  __$ProtocolStatusResponseCopyWithImpl(this._self, this._then);

  final _ProtocolStatusResponse _self;
  final $Res Function(_ProtocolStatusResponse) _then;

/// Create a copy of ProtocolStatusResponse
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? runId = null,Object? status = null,Object? message = freezed,Object? timestamp = freezed,Object? progress = freezed,Object? results = freezed,Object? estimatedTimeRemaining = freezed,Object? logsUrl = freezed,}) {
  return _then(_ProtocolStatusResponse(
runId: null == runId ? _self.runId : runId // ignore: cast_nullable_to_non_nullable
as String,status: null == status ? _self.status : status // ignore: cast_nullable_to_non_nullable
as RunStatus,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,timestamp: freezed == timestamp ? _self.timestamp : timestamp // ignore: cast_nullable_to_non_nullable
as DateTime?,progress: freezed == progress ? _self.progress : progress // ignore: cast_nullable_to_non_nullable
as dynamic,results: freezed == results ? _self._results : results // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,estimatedTimeRemaining: freezed == estimatedTimeRemaining ? _self.estimatedTimeRemaining : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
as String?,logsUrl: freezed == logsUrl ? _self.logsUrl : logsUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on
